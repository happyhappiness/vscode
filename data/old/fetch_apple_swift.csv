commit_sha,commit_message,file_name,change_type,log_statement,log_loc,store_name
6814fdbc8120e7072996eac8da36a17d4dd29753,Merge pull request #8037 from swiftix/master,lib/SILOptimizer/Utils/Generics.cpp,+,if (FnTy->hasErrorResult()) {,128,download/apple_swift1.cpp
6814fdbc8120e7072996eac8da36a17d4dd29753,Merge pull request #8037 from swiftix/master,lib/SILOptimizer/Utils/Generics.cpp,+,getTypeDepthAndWidth(FnTy->getErrorResult().getType());,133,download/apple_swift1.cpp
2b5585410bd674eebc1bf0cb8df0552230d29948,"[sil-generic-specializer] Don't specialize types which are too wide or too deep

This improves the existing logic which is used to stop specialization for types that are too big to handle. It catches some pathological cases which hang the compiler.

Fixes rdar://30938882

Re-applying this commit, which was speculatively reverted. It turned out that that performance tests issues were unrelated.",lib/SILOptimizer/Utils/Generics.cpp,+,if (FnTy->hasErrorResult()) {,128,download/apple_swift2.cpp
2b5585410bd674eebc1bf0cb8df0552230d29948,"[sil-generic-specializer] Don't specialize types which are too wide or too deep

This improves the existing logic which is used to stop specialization for types that are too big to handle. It catches some pathological cases which hang the compiler.

Fixes rdar://30938882

Re-applying this commit, which was speculatively reverted. It turned out that that performance tests issues were unrelated.",lib/SILOptimizer/Utils/Generics.cpp,+,getTypeDepthAndWidth(FnTy->getErrorResult().getType());,133,download/apple_swift2.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/ArgumentSource.cpp,-,"return gen.emitExprInto(e, dest);",153,download/apple_swift3.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/ArgumentSource.cpp,+,"return SGF.emitExprInto(e, dest);",153,download/apple_swift3.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/ArgumentSource.cpp,-,"gen.emitExprInto(expr, temp.get());",167,download/apple_swift3.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/ArgumentSource.cpp,+,"SGF.emitExprInto(expr, temp.get());",168,download/apple_swift3.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/Condition.cpp,-,"assert(!gen.B.hasValidInsertionPoint() && ""already in a branch"");",165,download/apple_swift4.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/Condition.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""already in a branch"");",166,download/apple_swift4.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/Condition.cpp,-,"assert(!gen.B.hasValidInsertionPoint() && ""still in a branch"");",209,download/apple_swift4.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/Condition.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""still in a branch"");",209,download/apple_swift4.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/FormalEvaluation.cpp,-,wasInWritebackScope(gen.InWritebackScope) {,58,download/apple_swift5.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/FormalEvaluation.cpp,+,wasInWritebackScope(SGF.InWritebackScope) {,61,download/apple_swift5.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/ManagedValue.cpp,-,"assert(gen.InWritebackScope && ""Can only perform a formal access copy in a """,50,download/apple_swift6.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/ManagedValue.cpp,+,"assert(SGF.InWritebackScope && ""Can only perform a formal access copy in a """,50,download/apple_swift6.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,100,download/apple_swift7.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());,101,download/apple_swift7.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,assert(gen.silConv.useLoweredAddresses() ==,650,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,assert(SGF.silConv.useLoweredAddresses() ==,652,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,"printSILLocationDescription(out, loc, gen.getASTContext());",1702,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,"printSILLocationDescription(out, loc, SGF.getASTContext());",1702,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,"gen.getTryApplyErrorDest(loc, substFnType->getErrorResult(),",1730,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,"SGF.getTryApplyErrorDest(loc, substFnType->getErrorResult(),",1730,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,"emitForeignErrorArgument(SILGenFunction &gen,",1761,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,"emitForeignErrorArgument(SILGenFunction &SGF,",1761,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,"InitialWritebackScope(std::move(writebackScope)),",4083,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,"initialWritebackScope(std::move(writebackScope)),",4084,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,"InitialWritebackScope(std::move(e.InitialWritebackScope)),",4171,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,"initialWritebackScope(std::move(e.initialWritebackScope)),",4171,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,assert(!AssumedPlusZeroSelf);,4314,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,assert(!assumedPlusZeroSelf);,4314,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,FormalEvaluationScope writebackScope(gen);,4620,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,FormalEvaluationScope writebackScope(SGF);,4620,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,FormalEvaluationScope writebacks(gen);,4665,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,FormalEvaluationScope writebacks(SGF);,4665,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,assert(gen.MagicFunctionName,4735,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,assert(SGF.MagicFunctionName,4736,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,-,gen.MagicFunctionName.printPretty(os);,4740,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenApply.cpp,+,SGF.MagicFunctionName.printPretty(os);,4742,download/apple_swift8.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,474,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,474,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()) {,481,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,"return gen.emitNativeToBridgedError(loc, v, loweredBridgedTy);",481,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {,481,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);",482,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(v.getType().isTrivial(gen.SGM.M) || v.hasCleanup());,510,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());,510,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,748,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,748,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()),755,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,"return gen.emitBridgedToNativeError(loc, v);",755,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()),755,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitBridgedToNativeError(loc, v);",756,download/apple_swift9.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"lvalue.performWriteback(gen, /*isFinal*/ false);",52,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"lvalue.performWriteback(SGF, /*isFinal*/ false);",52,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"static void pushWriteback(SILGenFunction &gen,",65,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"static void pushWriteback(SILGenFunction &SGF,",65,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope);,70,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope);,70,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,187,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,187,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(clonedComponent), base,",220,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(clonedComponent), base,",220,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"void LogicalPathComponent::writeback(SILGenFunction &gen, SILLocation loc,",225,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"void LogicalPathComponent::writeback(SILGenFunction &SGF, SILLocation loc,",225,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope,260,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope,260,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(!gen.InInOutConversionScope,262,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(!SGF.InInOutConversionScope,262,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"assert(gen.InInOutConversionScope && ""already exited conversion scope?!"");",269,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"assert(SGF.InInOutConversionScope && ""already exited conversion scope?!"");",270,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,771,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,771,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(clonedComponent), base, materialized);",837,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);",837,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"void writeback(SILGenFunction &gen, SILLocation loc,",842,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"void writeback(SILGenFunction &SGF, SILLocation loc,",842,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"LogicalPathComponent::writeback(gen, loc,",848,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"LogicalPathComponent::writeback(SGF, loc,",848,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"void writeback(SILGenFunction &gen, SILLocation loc,",1102,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"void writeback(SILGenFunction &SGF, SILLocation loc,",1102,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,1146,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,1146,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(component), result.second,",1177,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(component), result.second,",1177,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);",1579,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);",1579,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"assert(gen.OpaqueValues.count(e) && ""Didn't bind OpaqueValueExpr"");",1659,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"assert(SGF.OpaqueValues.count(e) && ""Didn't bind OpaqueValueExpr"");",1659,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);",1750,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);",1750,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(addr != gen.VarLocs.end() && addr->second.value);,1788,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(addr != SGF.VarLocs.end() && addr->second.value);,1789,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);",1846,download/apple_swift10.cpp
f23ec8855d8f633d3bfb1b7c79ed0a0bf42dd57d,Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);",1846,download/apple_swift10.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/ArgumentSource.cpp,-,"return gen.emitExprInto(e, dest);",153,download/apple_swift11.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/ArgumentSource.cpp,+,"return SGF.emitExprInto(e, dest);",153,download/apple_swift11.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/ArgumentSource.cpp,-,"gen.emitExprInto(expr, temp.get());",167,download/apple_swift11.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/ArgumentSource.cpp,+,"SGF.emitExprInto(expr, temp.get());",168,download/apple_swift11.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/Condition.cpp,-,"assert(!gen.B.hasValidInsertionPoint() && ""already in a branch"");",165,download/apple_swift12.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/Condition.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""already in a branch"");",166,download/apple_swift12.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/Condition.cpp,-,"assert(!gen.B.hasValidInsertionPoint() && ""still in a branch"");",209,download/apple_swift12.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/Condition.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""still in a branch"");",209,download/apple_swift12.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/FormalEvaluation.cpp,-,wasInWritebackScope(gen.InWritebackScope) {,58,download/apple_swift13.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/FormalEvaluation.cpp,+,wasInWritebackScope(SGF.InWritebackScope) {,61,download/apple_swift13.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/ManagedValue.cpp,-,"assert(gen.InWritebackScope && ""Can only perform a formal access copy in a """,50,download/apple_swift14.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/ManagedValue.cpp,+,"assert(SGF.InWritebackScope && ""Can only perform a formal access copy in a """,50,download/apple_swift14.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,100,download/apple_swift15.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());,101,download/apple_swift15.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,-,assert(gen.silConv.useLoweredAddresses() ==,650,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,+,assert(SGF.silConv.useLoweredAddresses() ==,652,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,-,"printSILLocationDescription(out, loc, gen.getASTContext());",1702,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,+,"printSILLocationDescription(out, loc, SGF.getASTContext());",1702,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,-,"gen.getTryApplyErrorDest(loc, substFnType->getErrorResult(),",1730,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,+,"SGF.getTryApplyErrorDest(loc, substFnType->getErrorResult(),",1730,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,-,"emitForeignErrorArgument(SILGenFunction &gen,",1761,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,+,"emitForeignErrorArgument(SILGenFunction &SGF,",1761,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,-,FormalEvaluationScope writebackScope(gen);,4620,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,+,FormalEvaluationScope writebackScope(SGF);,4620,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,-,FormalEvaluationScope writebacks(gen);,4665,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,+,FormalEvaluationScope writebacks(SGF);,4665,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,-,assert(gen.MagicFunctionName,4735,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,+,assert(SGF.MagicFunctionName,4736,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,-,gen.MagicFunctionName.printPretty(os);,4740,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenApply.cpp,+,SGF.MagicFunctionName.printPretty(os);,4742,download/apple_swift16.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,474,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,474,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()) {,481,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,"return gen.emitNativeToBridgedError(loc, v, loweredBridgedTy);",481,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {,481,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);",482,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(v.getType().isTrivial(gen.SGM.M) || v.hasCleanup());,510,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());,510,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,748,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,748,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()),755,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,"return gen.emitBridgedToNativeError(loc, v);",755,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()),755,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitBridgedToNativeError(loc, v);",756,download/apple_swift17.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"lvalue.performWriteback(gen, /*isFinal*/ false);",52,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"lvalue.performWriteback(SGF, /*isFinal*/ false);",52,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"static void pushWriteback(SILGenFunction &gen,",65,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"static void pushWriteback(SILGenFunction &SGF,",65,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope);,70,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope);,70,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,187,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,187,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(clonedComponent), base,",220,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(clonedComponent), base,",220,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"void LogicalPathComponent::writeback(SILGenFunction &gen, SILLocation loc,",225,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"void LogicalPathComponent::writeback(SILGenFunction &SGF, SILLocation loc,",225,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope,260,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope,260,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(!gen.InInOutConversionScope,262,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(!SGF.InInOutConversionScope,262,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"assert(gen.InInOutConversionScope && ""already exited conversion scope?!"");",269,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"assert(SGF.InInOutConversionScope && ""already exited conversion scope?!"");",270,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,771,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,771,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(clonedComponent), base, materialized);",837,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);",837,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"void writeback(SILGenFunction &gen, SILLocation loc,",842,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"void writeback(SILGenFunction &SGF, SILLocation loc,",842,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"LogicalPathComponent::writeback(gen, loc,",848,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"LogicalPathComponent::writeback(SGF, loc,",848,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"void writeback(SILGenFunction &gen, SILLocation loc,",1102,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"void writeback(SILGenFunction &SGF, SILLocation loc,",1102,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,1146,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,1146,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(component), result.second,",1177,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(component), result.second,",1177,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);",1579,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);",1579,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"assert(gen.OpaqueValues.count(e) && ""Didn't bind OpaqueValueExpr"");",1659,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"assert(SGF.OpaqueValues.count(e) && ""Didn't bind OpaqueValueExpr"");",1659,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);",1750,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);",1750,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(addr != gen.VarLocs.end() && addr->second.value);,1788,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(addr != SGF.VarLocs.end() && addr->second.value);,1789,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);",1846,download/apple_swift18.cpp
68c581f7298a7dc46906d6afa73f0e255e954f40,"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);",1846,download/apple_swift18.cpp
f064e26f314ec3c59d5087df95aa40a40e0bcc71,[gardening] Normalize field capitalization.,lib/SILGen/SILGenApply.cpp,-,"InitialWritebackScope(std::move(writebackScope)),",4081,download/apple_swift19.cpp
f064e26f314ec3c59d5087df95aa40a40e0bcc71,[gardening] Normalize field capitalization.,lib/SILGen/SILGenApply.cpp,+,"initialWritebackScope(std::move(writebackScope)),",4081,download/apple_swift19.cpp
f064e26f314ec3c59d5087df95aa40a40e0bcc71,[gardening] Normalize field capitalization.,lib/SILGen/SILGenApply.cpp,-,"InitialWritebackScope(std::move(e.InitialWritebackScope)),",4170,download/apple_swift19.cpp
f064e26f314ec3c59d5087df95aa40a40e0bcc71,[gardening] Normalize field capitalization.,lib/SILGen/SILGenApply.cpp,+,"initialWritebackScope(std::move(e.initialWritebackScope)),",4170,download/apple_swift19.cpp
f064e26f314ec3c59d5087df95aa40a40e0bcc71,[gardening] Normalize field capitalization.,lib/SILGen/SILGenApply.cpp,-,assert(!AssumedPlusZeroSelf);,4314,download/apple_swift19.cpp
f064e26f314ec3c59d5087df95aa40a40e0bcc71,[gardening] Normalize field capitalization.,lib/SILGen/SILGenApply.cpp,+,assert(!assumedPlusZeroSelf);,4314,download/apple_swift19.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(!AssumedPlusZeroSelf);,4180,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedSites.size() == 1);,4220,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(!formalApplyType->getExtInfo().throws());,4221,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedSites.size() == 2);,4252,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedSites.size() == 1);,4257,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(substFnType->getNumResults() == 1);,4261,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,"~CallEmission() { assert(applied && ""never applied!""); }",4266,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(!foreignError ||,4280,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,"InitialWritebackScope(std::move(e.InitialWritebackScope)),",4304,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedLoc);,4334,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(formalApplyType);,4334,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedArgs.size() == 1 &&,4420,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(specializedEmitter->isNamedBuiltin());,4481,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,FormalEvaluationScope writebackScope(gen);,4513,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(!AssumedPlusZeroSelf);,4581,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,assert(substFnType->hasErrorResult() ||,4585,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedSites.size() == 2);,4649,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedSites.size() == 1);,4655,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(substFnType->getNumResults() == 1);,4658,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,"~CallEmission() { assert(applied && ""never applied!""); }",4694,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,"assert(uncurriedArgs.size() == 1 && ""Can only partially apply the """,4704,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,-,"InitialWritebackScope(std::move(e.InitialWritebackScope)),",4743,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedSites.size() == 1);,4791,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(!formalApplyType->getExtInfo().throws());,4793,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(specializedEmitter.isNamedBuiltin());,4827,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(!foreignError || uncurriedSites.size() == 1 ||,4855,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedLoc);,4895,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(formalApplyType);,4896,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,FormalEvaluationScope writebackScope(gen);,4924,download/apple_swift20.cpp
126edf7339752ecc5b1b58c1b33d4677224b5679,Merge pull request #8034 from gottesmm/refactor_callemission_apply,lib/SILGen/SILGenApply.cpp,+,assert(substFnType->hasErrorResult() ||,4937,download/apple_swift20.cpp
22e0fdafacd0260e19880804aab0cbc75d8cd1d9,[silgenapply][callemission] Change access of new helper methods to be private.,lib/SILGen/SILGenApply.cpp,+,"~CallEmission() { assert(applied && ""never applied!""); }",4164,download/apple_swift21.cpp
22e0fdafacd0260e19880804aab0cbc75d8cd1d9,[silgenapply][callemission] Change access of new helper methods to be private.,lib/SILGen/SILGenApply.cpp,+,"InitialWritebackScope(std::move(e.InitialWritebackScope)),",4170,download/apple_swift21.cpp
22e0fdafacd0260e19880804aab0cbc75d8cd1d9,[silgenapply][callemission] Change access of new helper methods to be private.,lib/SILGen/SILGenApply.cpp,-,"~CallEmission() { assert(applied && ""never applied!""); }",4231,download/apple_swift21.cpp
22e0fdafacd0260e19880804aab0cbc75d8cd1d9,[silgenapply][callemission] Change access of new helper methods to be private.,lib/SILGen/SILGenApply.cpp,-,"InitialWritebackScope(std::move(e.InitialWritebackScope)),",4236,download/apple_swift21.cpp
4391dbafad3e21d6992587964043913c84c06c8c,[silgenapply][callemission] Refactor out enum element constructor emission.,lib/SILGen/SILGenApply.cpp,-,assert(!AssumedPlusZeroSelf);,4187,download/apple_swift22.cpp
4391dbafad3e21d6992587964043913c84c06c8c,[silgenapply][callemission] Refactor out enum element constructor emission.,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedSites.size() == 2);,4217,download/apple_swift22.cpp
4391dbafad3e21d6992587964043913c84c06c8c,[silgenapply][callemission] Refactor out enum element constructor emission.,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedSites.size() == 1);,4222,download/apple_swift22.cpp
4391dbafad3e21d6992587964043913c84c06c8c,[silgenapply][callemission] Refactor out enum element constructor emission.,lib/SILGen/SILGenApply.cpp,-,assert(substFnType->getNumResults() == 1);,4224,download/apple_swift22.cpp
4391dbafad3e21d6992587964043913c84c06c8c,[silgenapply][callemission] Refactor out enum element constructor emission.,lib/SILGen/SILGenApply.cpp,+,assert(!AssumedPlusZeroSelf);,4284,download/apple_swift22.cpp
4391dbafad3e21d6992587964043913c84c06c8c,[silgenapply][callemission] Refactor out enum element constructor emission.,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedSites.size() == 2);,4329,download/apple_swift22.cpp
4391dbafad3e21d6992587964043913c84c06c8c,[silgenapply][callemission] Refactor out enum element constructor emission.,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedSites.size() == 1);,4335,download/apple_swift22.cpp
4391dbafad3e21d6992587964043913c84c06c8c,[silgenapply][callemission] Refactor out enum element constructor emission.,lib/SILGen/SILGenApply.cpp,+,assert(substFnType->getNumResults() == 1);,4338,download/apple_swift22.cpp
1a3ab56dfdc6e6e78f319a3efae230b6a84d84a3,[silgenapply][callemission] Refactor first level call partial applied super method into a helper method called applyPartiallyAppliedSuperMethod.,lib/SILGen/SILGenApply.cpp,-,"assert(uncurriedArgs.size() == 1 && ""Can only partially apply the """,4254,download/apple_swift23.cpp
1a3ab56dfdc6e6e78f319a3efae230b6a84d84a3,[silgenapply][callemission] Refactor first level call partial applied super method into a helper method called applyPartiallyAppliedSuperMethod.,lib/SILGen/SILGenApply.cpp,+,"assert(uncurriedArgs.size() == 1 && ""Can only partially apply the """,4356,download/apple_swift23.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,-,assert(!AssumedPlusZeroSelf);,4184,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,+,assert(!AssumedPlusZeroSelf);,4226,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedSites.size() == 1);,4262,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,-,assert(!formalApplyType->getExtInfo().throws());,4263,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedSites.size() == 2);,4294,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedSites.size() == 1);,4311,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedSites.size() == 2);,4317,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedSites.size() == 1);,4323,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,-,assert(substFnType->getNumResults() == 1);,4326,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,+,assert(substFnType->getNumResults() == 1);,4331,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedArgs.size() == 1 &&,4351,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,-,assert(specializedEmitter->isNamedBuiltin());,4414,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,+,"assert(uncurriedArgs.size() == 1 && ""Can only partially apply the """,4430,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedSites.size() == 1);,4390,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,+,assert(!formalApplyType->getExtInfo().throws());,4392,download/apple_swift24.cpp
46260379cc512cbc4a94ad31752aef25331cdda7,[silgenapply][callemission] Refactor out code for applying a first level specialized emitter.,lib/SILGen/SILGenApply.cpp,+,assert(specializedEmitter.isNamedBuiltin());,4426,download/apple_swift24.cpp
dad7a55506f3562a81dd906e012cc691b45a722b,[silgenapply][callemission] Refactor out argument emission for non-early specialized emitter and non-enum constructor calls.,lib/SILGen/SILGenApply.cpp,-,assert(!foreignError ||,4275,download/apple_swift25.cpp
dad7a55506f3562a81dd906e012cc691b45a722b,[silgenapply][callemission] Refactor out argument emission for non-early specialized emitter and non-enum constructor calls.,lib/SILGen/SILGenApply.cpp,-,assert(uncurriedLoc);,4321,download/apple_swift25.cpp
dad7a55506f3562a81dd906e012cc691b45a722b,[silgenapply][callemission] Refactor out argument emission for non-early specialized emitter and non-enum constructor calls.,lib/SILGen/SILGenApply.cpp,-,assert(formalApplyType);,4321,download/apple_swift25.cpp
dad7a55506f3562a81dd906e012cc691b45a722b,[silgenapply][callemission] Refactor out argument emission for non-early specialized emitter and non-enum constructor calls.,lib/SILGen/SILGenApply.cpp,+,assert(!foreignError || uncurriedSites.size() == 1 ||,4410,download/apple_swift25.cpp
dad7a55506f3562a81dd906e012cc691b45a722b,[silgenapply][callemission] Refactor out argument emission for non-early specialized emitter and non-enum constructor calls.,lib/SILGen/SILGenApply.cpp,+,assert(uncurriedLoc);,4450,download/apple_swift25.cpp
dad7a55506f3562a81dd906e012cc691b45a722b,[silgenapply][callemission] Refactor out argument emission for non-early specialized emitter and non-enum constructor calls.,lib/SILGen/SILGenApply.cpp,+,assert(formalApplyType);,4451,download/apple_swift25.cpp
230259cffd2da5dff8a6e99474c2c06e876d8483,"[silgen][callemission] Refactor out the handling of the remaining call sites after the first call site into its own method.

This is in preperation for eliminating the spaghetti code in
CallEmission::apply.",lib/SILGen/SILGenApply.cpp,-,FormalEvaluationScope writebackScope(gen);,4432,download/apple_swift26.cpp
230259cffd2da5dff8a6e99474c2c06e876d8483,"[silgen][callemission] Refactor out the handling of the remaining call sites after the first call site into its own method.

This is in preperation for eliminating the spaghetti code in
CallEmission::apply.",lib/SILGen/SILGenApply.cpp,-,assert(substFnType->hasErrorResult() ||,4444,download/apple_swift26.cpp
230259cffd2da5dff8a6e99474c2c06e876d8483,"[silgen][callemission] Refactor out the handling of the remaining call sites after the first call site into its own method.

This is in preperation for eliminating the spaghetti code in
CallEmission::apply.",lib/SILGen/SILGenApply.cpp,-,"InitialWritebackScope(std::move(e.InitialWritebackScope)),",4489,download/apple_swift26.cpp
230259cffd2da5dff8a6e99474c2c06e876d8483,"[silgen][callemission] Refactor out the handling of the remaining call sites after the first call site into its own method.

This is in preperation for eliminating the spaghetti code in
CallEmission::apply.",lib/SILGen/SILGenApply.cpp,+,"InitialWritebackScope(std::move(e.InitialWritebackScope)),",4493,download/apple_swift26.cpp
230259cffd2da5dff8a6e99474c2c06e876d8483,"[silgen][callemission] Refactor out the handling of the remaining call sites after the first call site into its own method.

This is in preperation for eliminating the spaghetti code in
CallEmission::apply.",lib/SILGen/SILGenApply.cpp,+,FormalEvaluationScope writebackScope(gen);,4468,download/apple_swift26.cpp
230259cffd2da5dff8a6e99474c2c06e876d8483,"[silgen][callemission] Refactor out the handling of the remaining call sites after the first call site into its own method.

This is in preperation for eliminating the spaghetti code in
CallEmission::apply.",lib/SILGen/SILGenApply.cpp,+,assert(substFnType->hasErrorResult() ||,4481,download/apple_swift26.cpp
ba3db59d0d404e1b18ba081d4180a1ce57314e5d,"Merge pull request #8032 from swiftix/master

Speculatively revert ""[sil-generic-specializer] Don't specialize types which are too wide or too deep""",lib/SILOptimizer/Utils/Generics.cpp,-,if (FnTy->hasErrorResult()) {,127,download/apple_swift27.cpp
ba3db59d0d404e1b18ba081d4180a1ce57314e5d,"Merge pull request #8032 from swiftix/master

Speculatively revert ""[sil-generic-specializer] Don't specialize types which are too wide or too deep""",lib/SILOptimizer/Utils/Generics.cpp,-,getTypeDepthAndWidth(FnTy->getErrorResult().getType());,131,download/apple_swift27.cpp
5f4cc96267716739f0a0d996cf8659d9f3bdce05,"Revert ""[sil-generic-specializer] Don't specialize types which are too wide or too deep""

This speculatively reverts commit f07743b1178b6bfa37ecf9ca86399a38153cd887, because it seems to have caused compiler hangs on performance bots.",lib/SILOptimizer/Utils/Generics.cpp,-,if (FnTy->hasErrorResult()) {,127,download/apple_swift28.cpp
5f4cc96267716739f0a0d996cf8659d9f3bdce05,"Revert ""[sil-generic-specializer] Don't specialize types which are too wide or too deep""

This speculatively reverts commit f07743b1178b6bfa37ecf9ca86399a38153cd887, because it seems to have caused compiler hangs on performance bots.",lib/SILOptimizer/Utils/Generics.cpp,-,getTypeDepthAndWidth(FnTy->getErrorResult().getType());,131,download/apple_swift28.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTDumper.cpp,-,P->getInherited()[0].getType().print(OS);,171,download/apple_swift29.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTDumper.cpp,+,P->getInherited()[0].getType().print(OS);,178,download/apple_swift29.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTDumper.cpp,-,Super.getType().print(OS);,584,download/apple_swift29.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTDumper.cpp,+,"interleave(Inherited, [&](TypeLoc Super) { Super.getType().print(OS); },",585,download/apple_swift29.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,-,printType(argTy);,1313,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,-,printType(param);,1314,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,-,"Printer.callPrintStructurePre(PrintStructureKind::GenericParameter, GP);",1315,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,-,"Printer.printName(GP->getName(), PrintNameContext::GenericParameter);",1315,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,-,"Printer.printStructurePost(PrintStructureKind::GenericParameter, GP);",1315,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,-,printType(param);,1316,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,+,printType(argTy);,1322,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,+,printType(param);,1324,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,+,Printer.callPrintStructurePre(,1326,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,+,"Printer.printName(GP->getName(),",1328,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,+,Printer.printStructurePost(,1330,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ASTPrinter.cpp,+,printType(param);,1333,download/apple_swift30.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ConcreteDeclRef.cpp,-,c.getConcrete()->printName(os);,94,download/apple_swift31.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/ConcreteDeclRef.cpp,+,c.getConcrete()->printName(os);,106,download/apple_swift31.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/GenericSignatureBuilder.cpp,-,"ProtoAndSource.second->print(Out, SrcMgr);",1667,download/apple_swift32.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/GenericSignatureBuilder.cpp,+,"ProtoAndSource.second->print(Out, SrcMgr);",1676,download/apple_swift32.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/TypeRepr.cpp,-,"printTypeRepr(Arg, Printer, Opts);",338,download/apple_swift33.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/TypeRepr.cpp,+,"interleave(Args, [&](TypeRepr *Arg) { printTypeRepr(Arg, Printer, Opts); },",339,download/apple_swift33.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/TypeRepr.cpp,-,"printTypeRepr(T, Printer, Opts);",555,download/apple_swift33.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/AST/TypeRepr.cpp,+,"interleave(Types, [&](TypeRepr *T) { printTypeRepr(T, Printer, Opts); },",556,download/apple_swift33.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/Sema/Constraint.cpp,-,"constraint->print(Out, sm);",225,download/apple_swift34.cpp
2ba4f03d8a18e993141df6591cf6d19a06033706,Merge pull request #8023 from huonw/tweak,lib/Sema/Constraint.cpp,+,"[&](Constraint *constraint) { constraint->print(Out, sm); },",228,download/apple_swift34.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTDumper.cpp,-,P->getInherited()[0].getType().print(OS);,171,download/apple_swift35.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTDumper.cpp,+,P->getInherited()[0].getType().print(OS);,178,download/apple_swift35.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTDumper.cpp,-,Super.getType().print(OS);,584,download/apple_swift35.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTDumper.cpp,+,"interleave(Inherited, [&](TypeLoc Super) { Super.getType().print(OS); },",585,download/apple_swift35.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,-,printType(argTy);,1313,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,-,printType(param);,1314,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,-,"Printer.callPrintStructurePre(PrintStructureKind::GenericParameter, GP);",1315,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,-,"Printer.printName(GP->getName(), PrintNameContext::GenericParameter);",1315,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,-,"Printer.printStructurePost(PrintStructureKind::GenericParameter, GP);",1315,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,-,printType(param);,1316,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,+,printType(argTy);,1322,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,+,printType(param);,1324,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,+,Printer.callPrintStructurePre(,1326,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,+,"Printer.printName(GP->getName(),",1328,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,+,Printer.printStructurePost(,1330,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTPrinter.cpp,+,printType(param);,1333,download/apple_swift36.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ConcreteDeclRef.cpp,-,c.getConcrete()->printName(os);,94,download/apple_swift37.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ConcreteDeclRef.cpp,+,c.getConcrete()->printName(os);,106,download/apple_swift37.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/GenericSignatureBuilder.cpp,-,"ProtoAndSource.second->print(Out, SrcMgr);",1667,download/apple_swift38.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/GenericSignatureBuilder.cpp,+,"ProtoAndSource.second->print(Out, SrcMgr);",1676,download/apple_swift38.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/TypeRepr.cpp,-,"printTypeRepr(Arg, Printer, Opts);",338,download/apple_swift39.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/TypeRepr.cpp,+,"interleave(Args, [&](TypeRepr *Arg) { printTypeRepr(Arg, Printer, Opts); },",339,download/apple_swift39.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/TypeRepr.cpp,-,"printTypeRepr(T, Printer, Opts);",555,download/apple_swift39.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/TypeRepr.cpp,+,"interleave(Types, [&](TypeRepr *T) { printTypeRepr(T, Printer, Opts); },",556,download/apple_swift39.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/Sema/Constraint.cpp,-,"constraint->print(Out, sm);",223,download/apple_swift40.cpp
a9299802bb990a07c84483ab75d114b511517984,"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/Sema/Constraint.cpp,+,"[&](Constraint *constraint) { constraint->print(Out, sm); },",226,download/apple_swift40.cpp
7401d0f33691c28e133664c279c6b38cff3d5d7d,"Merge pull request #8018 from eeckstein/lazy-irgen

IRGen: emit type metadata and (value) witness tables lazily.",lib/IRGen/GenDecl.cpp,+,assert(eligibleLazyMetadata.count(Nominal) == 0);,110,download/apple_swift41.cpp
7401d0f33691c28e133664c279c6b38cff3d5d7d,"Merge pull request #8018 from eeckstein/lazy-irgen

IRGen: emit type metadata and (value) witness tables lazily.",lib/IRGen/GenDecl.cpp,-,assert(decl);,891,download/apple_swift41.cpp
7401d0f33691c28e133664c279c6b38cff3d5d7d,"Merge pull request #8018 from eeckstein/lazy-irgen

IRGen: emit type metadata and (value) witness tables lazily.",lib/IRGen/GenDecl.cpp,-,assert(isTypeMetadataEmittedLazily(type));,926,download/apple_swift41.cpp
7401d0f33691c28e133664c279c6b38cff3d5d7d,"Merge pull request #8018 from eeckstein/lazy-irgen

IRGen: emit type metadata and (value) witness tables lazily.",lib/IRGen/GenDecl.cpp,+,assert(scheduledLazyMetadata.count(Nominal) == 1);,931,download/apple_swift41.cpp
a16daf13129d07c19d71de35ba6e6a88f367e969,"Merge pull request #8020 from jckarter/open-existential-helper

Sema: Add a stdlib-internal _openExistential helper.",lib/Sema/CSApply.cpp,+,"assert(arg->getNumElements() == 2 && ""should have two arguments"");",6382,download/apple_swift42.cpp
a16daf13129d07c19d71de35ba6e6a88f367e969,"Merge pull request #8020 from jckarter/open-existential-helper

Sema: Add a stdlib-internal _openExistential helper.",lib/Sema/CSApply.cpp,+,"assert(body && ""can't make nonescaping?!"");",6395,download/apple_swift42.cpp
a16daf13129d07c19d71de35ba6e6a88f367e969,"Merge pull request #8020 from jckarter/open-existential-helper

Sema: Add a stdlib-internal _openExistential helper.",lib/Sema/CSApply.cpp,+,assert(openedArchetype->getOpenedExistentialType(),6406,download/apple_swift42.cpp
a16daf13129d07c19d71de35ba6e6a88f367e969,"Merge pull request #8020 from jckarter/open-existential-helper

Sema: Add a stdlib-internal _openExistential helper.",lib/Sema/CSSimplify.cpp,+,assert(instanceTy->isExistentialType());,3653,download/apple_swift43.cpp
eb40d4303bc0d77480144aef23426b339d6ffdb2,"Sema: Add a stdlib-internal _openExistential helper.

Leverage the ""special type-checking semantics"" hack to pass an opened existential down to an arbitrary subexpression. Please don't use this.",lib/Sema/CSApply.cpp,+,"assert(arg->getNumElements() == 2 && ""should have two arguments"");",6382,download/apple_swift44.cpp
eb40d4303bc0d77480144aef23426b339d6ffdb2,"Sema: Add a stdlib-internal _openExistential helper.

Leverage the ""special type-checking semantics"" hack to pass an opened existential down to an arbitrary subexpression. Please don't use this.",lib/Sema/CSApply.cpp,+,"assert(body && ""can't make nonescaping?!"");",6395,download/apple_swift44.cpp
eb40d4303bc0d77480144aef23426b339d6ffdb2,"Sema: Add a stdlib-internal _openExistential helper.

Leverage the ""special type-checking semantics"" hack to pass an opened existential down to an arbitrary subexpression. Please don't use this.",lib/Sema/CSApply.cpp,+,assert(openedArchetype->getOpenedExistentialType(),6406,download/apple_swift44.cpp
eb40d4303bc0d77480144aef23426b339d6ffdb2,"Sema: Add a stdlib-internal _openExistential helper.

Leverage the ""special type-checking semantics"" hack to pass an opened existential down to an arbitrary subexpression. Please don't use this.",lib/Sema/CSSimplify.cpp,+,assert(instanceTy->isExistentialType());,3653,download/apple_swift45.cpp
41c17a5b0c0ce3937be523c7756ac04a8b9100df,"IRGen: emit type metadata and (value) witness tables lazily.

This gives big code size wins for unused types and also for types, which are never used in a generic context.
Also it reduces the amount of symbols in the symbol table.
The size wins heavily depend on the project. I have seen binary size reductions from 0 to 20% on real world projects.

rdar://problem/30119960",lib/IRGen/GenDecl.cpp,+,assert(eligibleLazyMetadata.count(Nominal) == 0);,110,download/apple_swift46.cpp
41c17a5b0c0ce3937be523c7756ac04a8b9100df,"IRGen: emit type metadata and (value) witness tables lazily.

This gives big code size wins for unused types and also for types, which are never used in a generic context.
Also it reduces the amount of symbols in the symbol table.
The size wins heavily depend on the project. I have seen binary size reductions from 0 to 20% on real world projects.

rdar://problem/30119960",lib/IRGen/GenDecl.cpp,-,assert(decl);,891,download/apple_swift46.cpp
41c17a5b0c0ce3937be523c7756ac04a8b9100df,"IRGen: emit type metadata and (value) witness tables lazily.

This gives big code size wins for unused types and also for types, which are never used in a generic context.
Also it reduces the amount of symbols in the symbol table.
The size wins heavily depend on the project. I have seen binary size reductions from 0 to 20% on real world projects.

rdar://problem/30119960",lib/IRGen/GenDecl.cpp,-,assert(isTypeMetadataEmittedLazily(type));,926,download/apple_swift46.cpp
41c17a5b0c0ce3937be523c7756ac04a8b9100df,"IRGen: emit type metadata and (value) witness tables lazily.

This gives big code size wins for unused types and also for types, which are never used in a generic context.
Also it reduces the amount of symbols in the symbol table.
The size wins heavily depend on the project. I have seen binary size reductions from 0 to 20% on real world projects.

rdar://problem/30119960",lib/IRGen/GenDecl.cpp,+,assert(scheduledLazyMetadata.count(Nominal) == 1);,931,download/apple_swift46.cpp
dc16a94d899186b711d19e10fde0a782bf313f0d,"Merge pull request #8005 from aschwaighofer/cow_existential_wip_04

Support for copy-on-write existentials - IRGen Support",lib/IRGen/GenExistential.cpp,+,assert(existentialTy.isExistentialType());,2498,download/apple_swift47.cpp
dc16a94d899186b711d19e10fde0a782bf313f0d,"Merge pull request #8005 from aschwaighofer/cow_existential_wip_04

Support for copy-on-write existentials - IRGen Support",lib/IRGen/IRGenSIL.cpp,+,assert(!getSILModule().getOptions().UseCOWExistentials &&,4741,download/apple_swift48.cpp
dc16a94d899186b711d19e10fde0a782bf313f0d,"Merge pull request #8005 from aschwaighofer/cow_existential_wip_04

Support for copy-on-write existentials - IRGen Support",lib/SIL/SILVerifier.cpp,+,"assert(apply && ""Not an apply instruction kind"");",2197,download/apple_swift49.cpp
dc16a94d899186b711d19e10fde0a782bf313f0d,"Merge pull request #8005 from aschwaighofer/cow_existential_wip_04

Support for copy-on-write existentials - IRGen Support",lib/SIL/SILVerifier.cpp,+,"assert(conv.isIndirectConvention() && ""Expect an indirect convention"");",2213,download/apple_swift49.cpp
dc16a94d899186b711d19e10fde0a782bf313f0d,"Merge pull request #8005 from aschwaighofer/cow_existential_wip_04

Support for copy-on-write existentials - IRGen Support",lib/SIL/SILVerifier.cpp,+,"assert(false && ""Unhandled unexpected instruction"");",2262,download/apple_swift49.cpp
a73f58e38c9cb7a53ebd1c2aaf42eab9e1b39397,Merge pull request #8014 from DougGregor/conformance-access-path-fixes,lib/AST/GenericSignature.cpp,-,"assert(hasConformanceInSignature(sig, subjectType, conformingProto) &&",889,download/apple_swift50.cpp
a73f58e38c9cb7a53ebd1c2aaf42eab9e1b39397,Merge pull request #8014 from DougGregor/conformance-access-path-fixes,lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(sig, rootType, conformingProto) &&",889,download/apple_swift50.cpp
a73f58e38c9cb7a53ebd1c2aaf42eab9e1b39397,Merge pull request #8014 from DougGregor/conformance-access-path-fixes,lib/AST/GenericSignatureBuilder.cpp,-,assert(storageKind == StorageKind::RootArchetype);,426,download/apple_swift51.cpp
a73f58e38c9cb7a53ebd1c2aaf42eab9e1b39397,Merge pull request #8014 from DougGregor/conformance-access-path-fixes,lib/AST/GenericSignatureBuilder.cpp,+,assert(root->storageKind == StorageKind::RootArchetype);,426,download/apple_swift51.cpp
a73f58e38c9cb7a53ebd1c2aaf42eab9e1b39397,Merge pull request #8014 from DougGregor/conformance-access-path-fixes,lib/Sema/TypeCheckProtocol.cpp,-,T.print(llvm::errs());,5288,download/apple_swift52.cpp
a73f58e38c9cb7a53ebd1c2aaf42eab9e1b39397,Merge pull request #8014 from DougGregor/conformance-access-path-fixes,lib/Sema/TypeCheckProtocol.cpp,-,.print(llvm::errs());,5293,download/apple_swift52.cpp
a73f58e38c9cb7a53ebd1c2aaf42eab9e1b39397,Merge pull request #8014 from DougGregor/conformance-access-path-fixes,lib/Sema/TypeCheckProtocol.cpp,+,T.print(llvm::errs());,5301,download/apple_swift52.cpp
a73f58e38c9cb7a53ebd1c2aaf42eab9e1b39397,Merge pull request #8014 from DougGregor/conformance-access-path-fixes,lib/Sema/TypeCheckProtocol.cpp,+,path.print(llvm::errs());,5303,download/apple_swift52.cpp
3738b00b6f02fb322fe69c7973fac71cd9547be9,"Merge pull request #7973 from swiftix/wip-fso-fixes

[function-signature-opt] Allow FSO on witness_methods when performing  the dead argument signature optimization for partial_apply instructions",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");",935,download/apple_swift53.cpp
3738b00b6f02fb322fe69c7973fac71cd9547be9,"Merge pull request #7973 from swiftix/wip-fso-fixes

[function-signature-opt] Allow FSO on witness_methods when performing  the dead argument signature optimization for partial_apply instructions",lib/SILOptimizer/Utils/FunctionSignatureOptUtils.cpp,+,assert(!OptForPartialApply || FuncInfo);,91,download/apple_swift54.cpp
790cf4895515af4bd59bcef64e6d6c7089327313,"[Type checker] Always build conformance access paths in debug mode.

As a sanity check, build conformance access paths for conformance
checks of (non-existential) archetypes to protocols.",lib/Sema/TypeCheckProtocol.cpp,-,T.print(llvm::errs());,5288,download/apple_swift55.cpp
790cf4895515af4bd59bcef64e6d6c7089327313,"[Type checker] Always build conformance access paths in debug mode.

As a sanity check, build conformance access paths for conformance
checks of (non-existential) archetypes to protocols.",lib/Sema/TypeCheckProtocol.cpp,-,.print(llvm::errs());,5293,download/apple_swift55.cpp
790cf4895515af4bd59bcef64e6d6c7089327313,"[Type checker] Always build conformance access paths in debug mode.

As a sanity check, build conformance access paths for conformance
checks of (non-existential) archetypes to protocols.",lib/Sema/TypeCheckProtocol.cpp,+,T.print(llvm::errs());,5301,download/apple_swift55.cpp
790cf4895515af4bd59bcef64e6d6c7089327313,"[Type checker] Always build conformance access paths in debug mode.

As a sanity check, build conformance access paths for conformance
checks of (non-existential) archetypes to protocols.",lib/Sema/TypeCheckProtocol.cpp,+,path.print(llvm::errs());,5303,download/apple_swift55.cpp
a41e44fa27c4a3d5757e2e9df3f32bccff92823e,"[AST] Don't use a protocol's requirement signature to canonicalize types.

Requirement signatures are a bit brittle, because they (intentionally)
don't carry the ""Self: Proto"" requirement. Most of the compiler never
uses requirement signatures as a signature per se, which is good,
because they canonicalize poorly.

Teach the construction of conformance access paths to use the
protocol's generic signature for canonicalization, rather than the
requirement signature.

As a future step, we should present only the *requirements* from the
requirement signature to prevent its use as a full-fledged
GenericSignature.",lib/AST/GenericSignature.cpp,-,"assert(hasConformanceInSignature(sig, subjectType, conformingProto) &&",889,download/apple_swift56.cpp
a41e44fa27c4a3d5757e2e9df3f32bccff92823e,"[AST] Don't use a protocol's requirement signature to canonicalize types.

Requirement signatures are a bit brittle, because they (intentionally)
don't carry the ""Self: Proto"" requirement. Most of the compiler never
uses requirement signatures as a signature per se, which is good,
because they canonicalize poorly.

Teach the construction of conformance access paths to use the
protocol's generic signature for canonicalization, rather than the
requirement signature.

As a future step, we should present only the *requirements* from the
requirement signature to prevent its use as a full-fledged
GenericSignature.",lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(sig, rootType, conformingProto) &&",889,download/apple_swift56.cpp
bca51d1186fe5a369f57b5b5aadda8153ee6579d,[GSB] Fix a broken assertion.,lib/AST/GenericSignatureBuilder.cpp,-,assert(storageKind == StorageKind::RootArchetype);,426,download/apple_swift57.cpp
bca51d1186fe5a369f57b5b5aadda8153ee6579d,[GSB] Fix a broken assertion.,lib/AST/GenericSignatureBuilder.cpp,+,assert(root->storageKind == StorageKind::RootArchetype);,426,download/apple_swift57.cpp
80732ead341d0fec8a3e099ebc8f7a408bbc08b1,"Non-witness implementations of init_existential_addr, deinit_existential_addr, open_existential_addr, copy_addr, destory_addr

For the boxed existential variant.",lib/IRGen/GenExistential.cpp,+,assert(existentialTy.isExistentialType());,2498,download/apple_swift58.cpp
80732ead341d0fec8a3e099ebc8f7a408bbc08b1,"Non-witness implementations of init_existential_addr, deinit_existential_addr, open_existential_addr, copy_addr, destory_addr

For the boxed existential variant.",lib/IRGen/IRGenSIL.cpp,+,assert(!getSILModule().getOptions().UseCOWExistentials &&,4741,download/apple_swift59.cpp
1c9f7f533892b7023a524a4682eca8ed136228a5,"SIL: Add verification of open_existential_addr instructions

Make sure that all uses of ""immutable_access"" instructions are not mutating the
opened value.

Only enable verification if we have COW existentials enabled.",lib/SIL/SILVerifier.cpp,+,"assert(apply && ""Not an apply instruction kind"");",2197,download/apple_swift60.cpp
1c9f7f533892b7023a524a4682eca8ed136228a5,"SIL: Add verification of open_existential_addr instructions

Make sure that all uses of ""immutable_access"" instructions are not mutating the
opened value.

Only enable verification if we have COW existentials enabled.",lib/SIL/SILVerifier.cpp,+,"assert(conv.isIndirectConvention() && ""Expect an indirect convention"");",2213,download/apple_swift60.cpp
1c9f7f533892b7023a524a4682eca8ed136228a5,"SIL: Add verification of open_existential_addr instructions

Make sure that all uses of ""immutable_access"" instructions are not mutating the
opened value.

Only enable verification if we have COW existentials enabled.",lib/SIL/SILVerifier.cpp,+,"assert(false && ""Unhandled unexpected instruction"");",2259,download/apple_swift60.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"static void printNode(llvm::raw_ostream &Out, const Node *node,",30,download/apple_swift61.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child, depth + 1);",46,download/apple_swift61.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::dump() const { print(llvm::errs()); },49,download/apple_swift61.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::print(llvm::raw_ostream &Out) const {,50,download/apple_swift61.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, Root, 0);",50,download/apple_swift61.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,void print(llvm::raw_ostream &out) const override {,64,download/apple_swift61.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(out, TheNode, 4);",69,download/apple_swift61.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/Mangler.cpp,-,demangle_wrappers::NodeDumper(OldNode).print(llvm::errs());,222,download/apple_swift62.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/Mangler.cpp,-,demangle_wrappers::NodeDumper(NewNode).print(llvm::errs());,224,download/apple_swift62.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/Context.cpp,+,"assert(MangledName.startswith(""_T""));",131,download/apple_swift63.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/Context.cpp,+,"assert(Remaining.startswith(""To"") || Remaining.startswith(""TO""));",137,download/apple_swift63.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/Demangler.cpp,-,"assert(MangledName.startswith(""_T""));",228,download/apple_swift64.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/Demangler.cpp,-,"assert(Remaining.startswith(""To"") || Remaining.startswith(""TO""));",233,download/apple_swift64.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodeDumper.cpp,+,"static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {",29,download/apple_swift65.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodeDumper.cpp,+,"printNode(Out, child, depth + 1);",47,download/apple_swift65.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodeDumper.cpp,+,"printNode(Printer, Root, 0);",53,download/apple_swift65.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,static void printer_unreachable(const char *Message) {,27,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"fprintf(stderr, ""fatal error: %s\n"", Message);",28,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"snprintf(buffer, sizeof(buffer), ""%llu"", n);",34,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"snprintf(buffer, sizeof(buffer), ""%lld"",n);",40,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad directness"");",103,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad value witness kind"");",153,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,NodePrinter(DemangleOptions options) : Options(options) {},162,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,std::string printRoot(NodePointer root) {,164,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(root);,165,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void printChildren(Node::iterator begin,",170,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(*begin);,174,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void printChildren(NodePointer pointer, const char *sep = nullptr) {",181,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printChildren(begin, end, sep);",185,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printBoundGenericNoSugar(NodePointer pointer) {,198,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,202,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printChildren(typelist, "", "");",204,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,static bool isDebuggerGeneratedModule(NodePointer node) {,213,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad node kind"");",397,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getKind() == Node::Kind::BoundGenericStructure);,434,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printBoundGeneric(NodePointer pointer) {,453,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,457,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,465,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,473,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,481,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,490,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(keyType);,498,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(valueType);,500,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void printSimplifiedEntityType(NodePointer context, NodePointer entityType);",507,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printFunctionType(NodePointer node) {,509,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);,510,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);,514,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex));,518,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex+1));,520,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printImplFunctionType(NodePointer fn) {,523,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(newState >= curState);,526,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"case Results: printer_unreachable(""no state after Results"");",531,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad state"");",533,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,541,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,546,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(curState == Attrs);,548,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,549,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printContext(NodePointer context) {,557,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,!isDebuggerGeneratedModule(context)),560,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(context, /*asContext*/ true);",562,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void print(NodePointer pointer, bool asContext = false, bool suppressType = false);",569,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"unsigned printFunctionSigSpecializationParam(NodePointer pointer,",571,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void printSpecializationPrefix(NodePointer node, StringRef Description,",574,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"unsigned NodePrinter::printFunctionSigSpecializationParam(NodePointer pointer,",585,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,593,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,598,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,613,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,615,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,620,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,622,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,624,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,630,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,632,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,639,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(,652,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,657,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void NodePrinter::printSpecializationPrefix(NodePointer node,",661,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(i));,680,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(i));,688,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""not an entity"");",747,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void NodePrinter::printSimplifiedEntityType(NodePointer context,",765,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,if (!isMethodContext(context)) return print(entityType);,768,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(type->getKind() == Node::Kind::Type);,772,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(entityType);,779,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void NodePrinter::print(NodePointer pointer, bool asContext, bool suppressType) {",782,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printContext(pointer->getChild(0));,786,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,if (hasName) print(pointer->getChild(1));,793,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,801,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printSimplifiedEntityType(pointer->getChild(0), type);",804,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,807,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext, suppressType);",818,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext, suppressType);",822,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext, suppressType);",826,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext, suppressType);",830,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert((pointer->getNumChildren() == 2 || pointer->getNumChildren() == 3),836,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), true);",841,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(1), asContext);",844,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(2), true);",846,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, """");",852,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, std::move(printName).str());",862,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printChildren(pointer);,866,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, ""(variable initialization expression)"");",873,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, std::move(strPrinter).str());",879,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext);",883,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext);",886,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,889,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, false, """");",896,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,900,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,907,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,924,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,928,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,932,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printChildren(pointer);,953,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printChildren(pointer, "", "");",961,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,970,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(id);,974,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,975,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printChildren(pointer);,986,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,991,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,995,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,999,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1003,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1021,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1024,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1027,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1030,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1033,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1039,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(i));,1045,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"unsigned Idx = printFunctionSigSpecializationParam(pointer, 0);",1053,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"Idx = printFunctionSigSpecializationParam(pointer, Idx);",1057,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""option sets should have been handled earlier"");",1125,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1149,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1151,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1155,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1157,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1161,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1165,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1169,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1173,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1177,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1179,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1190,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1201,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0)); // directness,1205,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(entity, /*asContext*/ false,",1208,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(pointer->getNumChildren() - 2));,1216,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getNumChildren() == 2 + unsigned(generics != nullptr));,1223,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(generics);,1225,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(pointer->getNumChildren() - 2));,1229,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(pointer->getNumChildren() - 1));,1231,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1236,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1240,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1244,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1248,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1252,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1256,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1260,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1264,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1266,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1270,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(2));,1272,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1274,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1278,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1284,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1288,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1292,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGeneric(pointer);,1297,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,1304,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,1309,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,1315,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(repr);,1322,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,1330,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(repr);,1344,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,1350,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1359,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printChildren(type_list, "" & "");",1369,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(decl_ctx);,1385,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".owningAddressor"");",1390,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".owningMutableAddressor"");",1393,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".nativeOwningAddressor"");",1396,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".nativeOwningMutableAddressor"");",1399,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".nativePinningAddressor"");",1402,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".nativePinningMutableAddressor"");",1405,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".unsafeAddressor"");",1408,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".unsafeMutableAddressor"");",1411,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".getter"");",1414,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".getter"");",1417,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".setter"");",1420,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".materializeForSet"");",1423,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".willset"");",1426,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".didset"");",1429,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, true,",1432,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, true, ""init"");",1437,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, ""deinit"");",1440,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false,",1443,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, ""__ivar_initializer"");",1448,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, ""__ivar_destroyer"");",1451,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child2);,1460,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child0);,1462,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child1);,1464,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child0);,1466,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child1);,1469,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child2);,1471,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printChildren(pointer);,1477,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printChildren(pointer, "" "");",1490,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printImplFunctionType(pointer);,1493,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(i));,1531,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""should be printed as a child of a """,1539,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,1544,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(reqt);,1546,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,1552,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(layout->getKind() == Node::Kind::Identifier);,1554,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(layout->getText().size() == 1);,1555,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(2));,1574,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(3));,1577,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(fst);,1587,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(snd);,1589,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(sig);,1599,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(depTy);,1601,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(base);,1606,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(assocTy);,1609,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1618,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1622,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1626,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1630,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getNumChildren() == 1 || pointer->getNumChildren() == 3);,1646,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(layout->getKind() == Node::Kind::SILBoxLayout);,1648,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(signature->getKind() == Node::Kind::DependentGenericSignature);,1652,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(genericArgs->getKind() == Node::Kind::TypeList);,1654,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(signature);,1656,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(layout);,1659,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(genericArgs->getChild(i));,1665,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(i));,1677,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getNumChildren() == 1,1686,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1688,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad node kind!"");",1691,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,return NodePrinter(options).printRoot(root);,1699,download/apple_swift66.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"snprintf(buffer, sizeof(buffer), ""%llu"", n);",43,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"snprintf(buffer, sizeof(buffer), ""%lld"",n);",48,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,NodePrinter(DemangleOptions options) : Options(options) {},2244,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,std::string printRoot(NodePointer root) {,2245,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(root);,2245,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"void printChildren(Node::iterator begin,",2249,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(*begin);,2252,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"void printChildren(NodePointer pointer, const char *sep = nullptr) {",2258,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printChildren(begin, end, sep);",2261,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,void printBoundGenericNoSugar(NodePointer pointer) {,2273,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2276,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printChildren(typelist, "", "");",2277,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,static bool isDebuggerGeneratedModule(NodePointer node) {,2285,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(pointer->getKind() == Node::Kind::BoundGenericStructure);,2505,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,void printBoundGeneric(NodePointer pointer) {,2523,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printBoundGenericNoSugar(pointer);,2526,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printBoundGenericNoSugar(pointer);,2533,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printBoundGenericNoSugar(pointer);,2540,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,2547,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,2555,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(keyType);,2562,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(valueType);,2563,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"void printSimplifiedEntityType(NodePointer context, NodePointer entityType);",2569,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,void printFunctionType(NodePointer node) {,2570,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);,2570,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);,2573,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(node->getChild(startIndex));,2576,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(node->getChild(startIndex+1));,2577,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,void printImplFunctionType(NodePointer fn) {,2579,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(newState >= curState);,2581,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child);,2595,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child);,2599,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(curState == Attrs);,2600,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child);,2600,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,void printContext(NodePointer context) {,2607,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,!isDebuggerGeneratedModule(context)),2609,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(context, /*asContext*/ true);",2610,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"void print(NodePointer pointer, bool asContext = false, bool suppressType = false);",2616,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"unsigned printFunctionSigSpecializationParam(NodePointer pointer,",2617,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"void printSpecializationPrefix(NodePointer node, StringRef Description,",2619,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"unsigned NodePrinter::printFunctionSigSpecializationParam(NodePointer pointer,",2629,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2636,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2640,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2654,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2655,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2659,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2660,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2661,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2666,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2667,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child);,2673,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(,2685,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2689,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"void NodePrinter::printSpecializationPrefix(NodePointer node,",2692,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(node->getChild(i));,2710,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(node->getChild(i));,2717,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"void NodePrinter::printSimplifiedEntityType(NodePointer context,",2793,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,if (!isMethodContext(context)) return print(entityType);,2795,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(type->getKind() == Node::Kind::Type);,2798,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(entityType);,2804,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"void NodePrinter::print(NodePointer pointer, bool asContext, bool suppressType) {",2806,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printContext(pointer->getChild(0));,2809,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,if (hasName) print(pointer->getChild(1));,2815,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,2822,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printSimplifiedEntityType(pointer->getChild(0), type);",2824,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,2826,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext, suppressType);",2836,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext, suppressType);",2839,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext, suppressType);",2842,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext, suppressType);",2845,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert((pointer->getNumChildren() == 2 || pointer->getNumChildren() == 3),2850,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), true);",2854,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(1), asContext);",2856,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(2), true);",2857,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, """");",2862,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, std::move(printName).str());",2871,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printChildren(pointer);,2874,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, ""(variable initialization expression)"");",2880,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, std::move(strPrinter).str());",2885,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext);",2888,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext);",2890,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2892,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, false, """");",2898,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,2901,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,2907,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,2923,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,2926,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,2929,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printChildren(pointer);,2949,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printChildren(pointer, "", "");",2956,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,2964,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(id);,2967,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,2967,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printChildren(pointer);,2977,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2981,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2984,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2987,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2990,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3007,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3009,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3011,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3013,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3015,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3020,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(i));,3025,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"unsigned Idx = printFunctionSigSpecializationParam(pointer, 0);",3032,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"Idx = printFunctionSigSpecializationParam(pointer, Idx);",3035,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3126,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3127,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3130,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3131,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3134,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3137,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3140,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3143,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3146,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3147,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3157,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3167,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0)); // directness,3170,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"print(entity, /*asContext*/ false,",3172,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(pointer->getNumChildren() - 2));,3179,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(pointer->getNumChildren() == 2 + unsigned(generics != nullptr));,3185,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(generics);,3186,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(pointer->getNumChildren() - 2));,3189,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(pointer->getNumChildren() - 1));,3190,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3194,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3197,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3200,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3203,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3206,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3209,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3212,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3215,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3216,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3219,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(2));,3220,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3221,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3224,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3229,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3232,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3235,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printBoundGeneric(pointer);,3239,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,3245,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,3249,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,3254,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(repr);,3260,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,3267,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(repr);,3280,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,3285,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3293,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printChildren(type_list, "" & "");",3302,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(decl_ctx);,3317,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".owningAddressor"");",3321,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".owningMutableAddressor"");",3323,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".nativeOwningAddressor"");",3325,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".nativeOwningMutableAddressor"");",3327,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".nativePinningAddressor"");",3329,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".nativePinningMutableAddressor"");",3331,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".unsafeAddressor"");",3333,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".unsafeMutableAddressor"");",3335,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".getter"");",3337,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".getter"");",3339,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".setter"");",3341,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".materializeForSet"");",3343,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".willset"");",3345,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".didset"");",3347,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, true,",3349,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, true, ""init"");",3353,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, ""deinit"");",3355,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false,",3357,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, ""__ivar_initializer"");",3361,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, ""__ivar_destroyer"");",3363,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child2);,3371,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child0);,3372,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child1);,3373,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child0);,3374,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child1);,3376,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(child2);,3377,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printChildren(pointer);,3382,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"printChildren(pointer, "" "");",3394,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,printImplFunctionType(pointer);,3396,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(i));,3433,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,3445,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(reqt);,3446,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(type);,3451,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(layout->getKind() == Node::Kind::Identifier);,3452,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(layout->getText().size() == 1);,3452,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(2));,3470,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(3));,3472,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(fst);,3481,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(snd);,3482,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(sig);,3491,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(depTy);,3492,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(base);,3496,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(assocTy);,3498,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3506,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3509,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3512,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3515,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(pointer->getNumChildren() == 1 || pointer->getNumChildren() == 3);,3530,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(layout->getKind() == Node::Kind::SILBoxLayout);,3531,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(signature->getKind() == Node::Kind::DependentGenericSignature);,3534,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(genericArgs->getKind() == Node::Kind::TypeList);,3535,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(signature);,3536,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(layout);,3538,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(genericArgs->getChild(i));,3543,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(i));,3554,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,assert(pointer->getNumChildren() == 1,3562,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3563,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,return NodePrinter(options).printRoot(root);,3573,download/apple_swift67.cpp
cc6045b45afdfdb345431929769f4ce85bbe8aef,"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",tools/swift-demangle/swift-demangle.cpp,-,swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());,92,download/apple_swift68.cpp
4f927c4d9b8bd0b814f10ebe901f503eda9f4934,Merge pull request #8008 from gottesmm/init_existential_ref_fix,lib/SILGen/SILGenConvert.cpp,-,"branchArg = emitBridgedToNativeError(loc,",563,download/apple_swift69.cpp
4f927c4d9b8bd0b814f10ebe901f503eda9f4934,Merge pull request #8008 from gottesmm/init_existential_ref_fix,lib/SILGen/SILGenConvert.cpp,+,"branchArg = emitBridgedToNativeError(loc, nsError).forward(*this);",565,download/apple_swift69.cpp
0769239daffbbb4138bb34497174f03f6e1f7088,"[silgen] Fix ownership of several uses of init_existential_ref in SILGenBuilder.

We were just passing along the previously used cleanup, rather than destroying
the old cleanup and propagating a new one along.

rdar://29791263",lib/SILGen/SILGenConvert.cpp,-,"branchArg = emitBridgedToNativeError(loc,",563,download/apple_swift70.cpp
0769239daffbbb4138bb34497174f03f6e1f7088,"[silgen] Fix ownership of several uses of init_existential_ref in SILGenBuilder.

We were just passing along the previously used cleanup, rather than destroying
the old cleanup and propagating a new one along.

rdar://29791263",lib/SILGen/SILGenConvert.cpp,+,"branchArg = emitBridgedToNativeError(loc, nsError).forward(*this);",565,download/apple_swift70.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"static void printNode(llvm::raw_ostream &Out, const Node *node,",30,download/apple_swift71.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child, depth + 1);",46,download/apple_swift71.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::dump() const { print(llvm::errs()); },49,download/apple_swift71.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::print(llvm::raw_ostream &Out) const {,50,download/apple_swift71.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, Root, 0);",50,download/apple_swift71.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,void print(llvm::raw_ostream &out) const override {,64,download/apple_swift71.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(out, TheNode, 4);",69,download/apple_swift71.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/Mangler.cpp,-,demangle_wrappers::NodeDumper(OldNode).print(llvm::errs());,222,download/apple_swift72.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/Mangler.cpp,-,demangle_wrappers::NodeDumper(NewNode).print(llvm::errs());,224,download/apple_swift72.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/Context.cpp,+,"assert(MangledName.startswith(""_T""));",131,download/apple_swift73.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/Context.cpp,+,"assert(Remaining.startswith(""To"") || Remaining.startswith(""TO""));",137,download/apple_swift73.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/Demangler.cpp,-,"assert(MangledName.startswith(""_T""));",228,download/apple_swift74.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/Demangler.cpp,-,"assert(Remaining.startswith(""To"") || Remaining.startswith(""TO""));",233,download/apple_swift74.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodeDumper.cpp,+,"static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {",29,download/apple_swift75.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodeDumper.cpp,+,"printNode(Out, child, depth + 1);",47,download/apple_swift75.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodeDumper.cpp,+,"printNode(Printer, Root, 0);",53,download/apple_swift75.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,static void printer_unreachable(const char *Message) {,27,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"fprintf(stderr, ""fatal error: %s\n"", Message);",28,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"snprintf(buffer, sizeof(buffer), ""%llu"", n);",34,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"snprintf(buffer, sizeof(buffer), ""%lld"",n);",40,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad directness"");",103,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad value witness kind"");",153,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,NodePrinter(DemangleOptions options) : Options(options) {},162,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,std::string printRoot(NodePointer root) {,164,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(root);,165,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void printChildren(Node::iterator begin,",170,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(*begin);,174,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void printChildren(NodePointer pointer, const char *sep = nullptr) {",181,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printChildren(begin, end, sep);",185,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printBoundGenericNoSugar(NodePointer pointer) {,198,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,202,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printChildren(typelist, "", "");",204,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,static bool isDebuggerGeneratedModule(NodePointer node) {,213,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad node kind"");",397,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getKind() == Node::Kind::BoundGenericStructure);,434,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printBoundGeneric(NodePointer pointer) {,453,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,457,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,465,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,473,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,481,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,490,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(keyType);,498,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(valueType);,500,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void printSimplifiedEntityType(NodePointer context, NodePointer entityType);",507,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printFunctionType(NodePointer node) {,509,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);,510,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);,514,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex));,518,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex+1));,520,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printImplFunctionType(NodePointer fn) {,523,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(newState >= curState);,526,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"case Results: printer_unreachable(""no state after Results"");",531,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad state"");",533,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,541,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,546,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(curState == Attrs);,548,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,549,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printContext(NodePointer context) {,557,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,!isDebuggerGeneratedModule(context)),560,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(context, /*asContext*/ true);",562,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void print(NodePointer pointer, bool asContext = false, bool suppressType = false);",569,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"unsigned printFunctionSigSpecializationParam(NodePointer pointer,",571,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void printSpecializationPrefix(NodePointer node, StringRef Description,",574,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"unsigned NodePrinter::printFunctionSigSpecializationParam(NodePointer pointer,",585,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,593,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,598,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,613,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,615,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,620,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,622,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,624,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,630,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,632,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,639,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(,652,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(Idx++));,657,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void NodePrinter::printSpecializationPrefix(NodePointer node,",661,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(i));,680,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(i));,688,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""not an entity"");",747,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void NodePrinter::printSimplifiedEntityType(NodePointer context,",765,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,if (!isMethodContext(context)) return print(entityType);,768,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(type->getKind() == Node::Kind::Type);,772,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(entityType);,779,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void NodePrinter::print(NodePointer pointer, bool asContext, bool suppressType) {",782,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printContext(pointer->getChild(0));,786,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,if (hasName) print(pointer->getChild(1));,793,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,801,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printSimplifiedEntityType(pointer->getChild(0), type);",804,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,807,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext, suppressType);",818,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext, suppressType);",822,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext, suppressType);",826,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext, suppressType);",830,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert((pointer->getNumChildren() == 2 || pointer->getNumChildren() == 3),836,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), true);",841,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(1), asContext);",844,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(2), true);",846,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, """");",852,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, std::move(printName).str());",862,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printChildren(pointer);,866,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, ""(variable initialization expression)"");",873,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, std::move(strPrinter).str());",879,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext);",883,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(pointer->getChild(0), asContext);",886,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,889,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, false, """");",896,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,900,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,907,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,924,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,928,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,932,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printChildren(pointer);,953,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printChildren(pointer, "", "");",961,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,970,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(id);,974,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,975,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printChildren(pointer);,986,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,991,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,995,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,999,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1003,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1021,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1024,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1027,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1030,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"return printSpecializationPrefix(pointer,",1033,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1039,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(i));,1045,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"unsigned Idx = printFunctionSigSpecializationParam(pointer, 0);",1053,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"Idx = printFunctionSigSpecializationParam(pointer, Idx);",1057,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""option sets should have been handled earlier"");",1125,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1149,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1151,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1155,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1157,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1161,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1165,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1169,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1173,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1177,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1179,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1190,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1201,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0)); // directness,1205,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(entity, /*asContext*/ false,",1208,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(pointer->getNumChildren() - 2));,1216,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getNumChildren() == 2 + unsigned(generics != nullptr));,1223,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(generics);,1225,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(pointer->getNumChildren() - 2));,1229,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(pointer->getNumChildren() - 1));,1231,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1236,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1240,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1244,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1248,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1252,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1256,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1260,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1264,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1266,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(1));,1270,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(2));,1272,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1274,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1278,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1284,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1288,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getFirstChild());,1292,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGeneric(pointer);,1297,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,1304,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printFunctionType(pointer);,1309,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,1315,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(repr);,1322,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,1330,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(repr);,1344,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,1350,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1359,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printChildren(type_list, "" & "");",1369,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(decl_ctx);,1385,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".owningAddressor"");",1390,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".owningMutableAddressor"");",1393,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".nativeOwningAddressor"");",1396,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".nativeOwningMutableAddressor"");",1399,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".nativePinningAddressor"");",1402,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".nativePinningMutableAddressor"");",1405,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".unsafeAddressor"");",1408,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".unsafeMutableAddressor"");",1411,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".getter"");",1414,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".getter"");",1417,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".setter"");",1420,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".materializeForSet"");",1423,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".willset"");",1426,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(true, true, "".didset"");",1429,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, true,",1432,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, true, ""init"");",1437,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, ""deinit"");",1440,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false,",1443,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, ""__ivar_initializer"");",1448,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printEntity(false, false, ""__ivar_destroyer"");",1451,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child2);,1460,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child0);,1462,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child1);,1464,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child0);,1466,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child1);,1469,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child2);,1471,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printChildren(pointer);,1477,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printChildren(pointer, "" "");",1490,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printImplFunctionType(pointer);,1493,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(i));,1531,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""should be printed as a child of a """,1539,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,1544,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(reqt);,1546,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,1552,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(layout->getKind() == Node::Kind::Identifier);,1554,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(layout->getText().size() == 1);,1555,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(2));,1574,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(3));,1577,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(fst);,1587,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(snd);,1589,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(sig);,1599,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(depTy);,1601,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(base);,1606,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(assocTy);,1609,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1618,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1622,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1626,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1630,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getNumChildren() == 1 || pointer->getNumChildren() == 3);,1646,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(layout->getKind() == Node::Kind::SILBoxLayout);,1648,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(signature->getKind() == Node::Kind::DependentGenericSignature);,1652,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(genericArgs->getKind() == Node::Kind::TypeList);,1654,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(signature);,1656,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(layout);,1659,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(genericArgs->getChild(i));,1665,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(i));,1677,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getNumChildren() == 1,1686,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,1688,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad node kind!"");",1691,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,return NodePrinter(options).printRoot(root);,1699,download/apple_swift76.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"snprintf(buffer, sizeof(buffer), ""%llu"", n);",43,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"snprintf(buffer, sizeof(buffer), ""%lld"",n);",48,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,NodePrinter(DemangleOptions options) : Options(options) {},2244,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,std::string printRoot(NodePointer root) {,2245,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(root);,2245,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"void printChildren(Node::iterator begin,",2249,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(*begin);,2252,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"void printChildren(NodePointer pointer, const char *sep = nullptr) {",2258,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printChildren(begin, end, sep);",2261,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,void printBoundGenericNoSugar(NodePointer pointer) {,2273,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2276,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printChildren(typelist, "", "");",2277,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,static bool isDebuggerGeneratedModule(NodePointer node) {,2285,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(pointer->getKind() == Node::Kind::BoundGenericStructure);,2505,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,void printBoundGeneric(NodePointer pointer) {,2523,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printBoundGenericNoSugar(pointer);,2526,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printBoundGenericNoSugar(pointer);,2533,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printBoundGenericNoSugar(pointer);,2540,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,2547,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,2555,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(keyType);,2562,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(valueType);,2563,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"void printSimplifiedEntityType(NodePointer context, NodePointer entityType);",2569,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,void printFunctionType(NodePointer node) {,2570,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);,2570,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);,2573,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(node->getChild(startIndex));,2576,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(node->getChild(startIndex+1));,2577,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,void printImplFunctionType(NodePointer fn) {,2579,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(newState >= curState);,2581,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child);,2595,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child);,2599,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(curState == Attrs);,2600,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child);,2600,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,void printContext(NodePointer context) {,2607,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,!isDebuggerGeneratedModule(context)),2609,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(context, /*asContext*/ true);",2610,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"void print(NodePointer pointer, bool asContext = false, bool suppressType = false);",2616,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"unsigned printFunctionSigSpecializationParam(NodePointer pointer,",2617,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"void printSpecializationPrefix(NodePointer node, StringRef Description,",2619,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"unsigned NodePrinter::printFunctionSigSpecializationParam(NodePointer pointer,",2629,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2636,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2640,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2654,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2655,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2659,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2660,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2661,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2666,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2667,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child);,2673,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(,2685,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(Idx++));,2689,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"void NodePrinter::printSpecializationPrefix(NodePointer node,",2692,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(node->getChild(i));,2710,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(node->getChild(i));,2717,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"void NodePrinter::printSimplifiedEntityType(NodePointer context,",2793,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,if (!isMethodContext(context)) return print(entityType);,2795,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(type->getKind() == Node::Kind::Type);,2798,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(entityType);,2804,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"void NodePrinter::print(NodePointer pointer, bool asContext, bool suppressType) {",2806,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printContext(pointer->getChild(0));,2809,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,if (hasName) print(pointer->getChild(1));,2815,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,2822,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printSimplifiedEntityType(pointer->getChild(0), type);",2824,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,2826,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext, suppressType);",2836,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext, suppressType);",2839,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext, suppressType);",2842,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext, suppressType);",2845,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert((pointer->getNumChildren() == 2 || pointer->getNumChildren() == 3),2850,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), true);",2854,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(1), asContext);",2856,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(2), true);",2857,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, """");",2862,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, std::move(printName).str());",2871,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printChildren(pointer);,2874,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, ""(variable initialization expression)"");",2880,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, std::move(strPrinter).str());",2885,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext);",2888,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(pointer->getChild(0), asContext);",2890,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2892,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, false, """");",2898,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,2901,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,2907,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,2923,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,2926,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,2929,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printChildren(pointer);,2949,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printChildren(pointer, "", "");",2956,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,2964,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(id);,2967,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,2967,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printChildren(pointer);,2977,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2981,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2984,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2987,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,2990,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3007,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3009,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3011,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3013,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"return printSpecializationPrefix(pointer,",3015,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3020,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(i));,3025,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"unsigned Idx = printFunctionSigSpecializationParam(pointer, 0);",3032,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"Idx = printFunctionSigSpecializationParam(pointer, Idx);",3035,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3126,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3127,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3130,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3131,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3134,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3137,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3140,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3143,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3146,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3147,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3157,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3167,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0)); // directness,3170,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"print(entity, /*asContext*/ false,",3172,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(pointer->getNumChildren() - 2));,3179,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(pointer->getNumChildren() == 2 + unsigned(generics != nullptr));,3185,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(generics);,3186,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(pointer->getNumChildren() - 2));,3189,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(pointer->getNumChildren() - 1));,3190,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3194,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3197,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3200,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3203,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3206,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3209,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3212,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3215,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3216,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(1));,3219,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(2));,3220,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3221,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3224,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3229,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3232,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getFirstChild());,3235,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printBoundGeneric(pointer);,3239,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,3245,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printFunctionType(pointer);,3249,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,3254,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(repr);,3260,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,3267,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(repr);,3280,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,3285,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3293,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printChildren(type_list, "" & "");",3302,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(decl_ctx);,3317,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".owningAddressor"");",3321,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".owningMutableAddressor"");",3323,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".nativeOwningAddressor"");",3325,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".nativeOwningMutableAddressor"");",3327,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".nativePinningAddressor"");",3329,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".nativePinningMutableAddressor"");",3331,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".unsafeAddressor"");",3333,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".unsafeMutableAddressor"");",3335,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".getter"");",3337,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".getter"");",3339,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".setter"");",3341,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".materializeForSet"");",3343,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".willset"");",3345,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(true, true, "".didset"");",3347,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, true,",3349,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, true, ""init"");",3353,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, ""deinit"");",3355,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false,",3357,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, ""__ivar_initializer"");",3361,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printEntity(false, false, ""__ivar_destroyer"");",3363,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child2);,3371,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child0);,3372,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child1);,3373,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child0);,3374,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child1);,3376,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(child2);,3377,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printChildren(pointer);,3382,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"printChildren(pointer, "" "");",3394,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,printImplFunctionType(pointer);,3396,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(i));,3433,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,3445,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(reqt);,3446,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(type);,3451,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(layout->getKind() == Node::Kind::Identifier);,3452,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(layout->getText().size() == 1);,3452,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(2));,3470,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(3));,3472,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(fst);,3481,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(snd);,3482,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(sig);,3491,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(depTy);,3492,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(base);,3496,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(assocTy);,3498,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3506,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3509,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3512,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3515,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(pointer->getNumChildren() == 1 || pointer->getNumChildren() == 3);,3530,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(layout->getKind() == Node::Kind::SILBoxLayout);,3531,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(signature->getKind() == Node::Kind::DependentGenericSignature);,3534,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(genericArgs->getKind() == Node::Kind::TypeList);,3535,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(signature);,3536,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(layout);,3538,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(genericArgs->getChild(i));,3543,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(i));,3554,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,assert(pointer->getNumChildren() == 1,3562,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,print(pointer->getChild(0));,3563,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,return NodePrinter(options).printRoot(root);,3573,download/apple_swift77.cpp
5e80555c9bd3559ad28816b74e0781b165599e85,"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",tools/swift-demangle/swift-demangle.cpp,-,swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());,92,download/apple_swift78.cpp
467c8affc4c64b3b2f5e937149314aef8f61866e,"Merge pull request #7994 from swiftix/generic-specialization-fixes

[sil-generic-specializer] Don't specialize types which are too wide or too deep",lib/SILOptimizer/Utils/Generics.cpp,+,if (FnTy->hasErrorResult()) {,128,download/apple_swift79.cpp
467c8affc4c64b3b2f5e937149314aef8f61866e,"Merge pull request #7994 from swiftix/generic-specialization-fixes

[sil-generic-specializer] Don't specialize types which are too wide or too deep",lib/SILOptimizer/Utils/Generics.cpp,+,getTypeDepthAndWidth(FnTy->getErrorResult().getType());,133,download/apple_swift79.cpp
f07743b1178b6bfa37ecf9ca86399a38153cd887,"[sil-generic-specializer] Don't specialize types which are too wide or too deep

This improves the existing logic which is used to stop specialization for types that are too big to handle. It catches some pathological cases which hang the compiler.

Fixes rdar://30938882",lib/SILOptimizer/Utils/Generics.cpp,+,if (FnTy->hasErrorResult()) {,128,download/apple_swift80.cpp
f07743b1178b6bfa37ecf9ca86399a38153cd887,"[sil-generic-specializer] Don't specialize types which are too wide or too deep

This improves the existing logic which is used to stop specialization for types that are too big to handle. It catches some pathological cases which hang the compiler.

Fixes rdar://30938882",lib/SILOptimizer/Utils/Generics.cpp,+,getTypeDepthAndWidth(FnTy->getErrorResult().getType());,133,download/apple_swift80.cpp
d106001cc8ca339301ecc1e988cb05524ffb19fe,Merge pull request #7987 from DougGregor/canonical-conformance-access-paths,lib/AST/GenericSignature.cpp,+,assert(path.path.back().second == inProtocol &&,798,download/apple_swift81.cpp
d106001cc8ca339301ecc1e988cb05524ffb19fe,Merge pull request #7987 from DougGregor/canonical-conformance-access-paths,lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(inProtocol->getRequirementSignature(),",817,download/apple_swift81.cpp
d106001cc8ca339301ecc1e988cb05524ffb19fe,Merge pull request #7987 from DougGregor/canonical-conformance-access-paths,lib/AST/GenericSignature.cpp,+,assert(inProtocol->isRequirementSignatureComputed() &&,832,download/apple_swift81.cpp
d106001cc8ca339301ecc1e988cb05524ffb19fe,Merge pull request #7987 from DougGregor/canonical-conformance-access-paths,lib/AST/GenericSignature.cpp,-,"assert(hasConformanceInSignature(inProtocol->getRequirementSignature(),",853,download/apple_swift81.cpp
d106001cc8ca339301ecc1e988cb05524ffb19fe,Merge pull request #7987 from DougGregor/canonical-conformance-access-paths,lib/AST/GenericSignature.cpp,+,assert(knownConforms != rep->getConformsTo().end());,864,download/apple_swift81.cpp
d106001cc8ca339301ecc1e988cb05524ffb19fe,Merge pull request #7987 from DougGregor/canonical-conformance-access-paths,lib/AST/GenericSignature.cpp,-,"assert(hasConformanceInSignature(this, subjectType, conformingProto) &&",882,download/apple_swift81.cpp
d106001cc8ca339301ecc1e988cb05524ffb19fe,Merge pull request #7987 from DougGregor/canonical-conformance-access-paths,lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(sig, subjectType, conformingProto) &&",882,download/apple_swift81.cpp
1f8b0f9b8540415ab4330804a270899ee57e22e4,"Canonicalize conformance access paths for sources pre-requirement-signature.

When a requirement source involving a ProtocolRequirement element is
built prior to the requirement signature of the protocol it
references, we can end up with a requirement source whose steps don't
reflect was is actually available via the requirement signatures. When
building a conformance access path from such requirement sources,
canonicalize on-the-fly using the requirement signatures (which have
been/can be computed by this point) to produce a correct access path.",lib/AST/GenericSignature.cpp,+,assert(path.path.back().second == inProtocol &&,798,download/apple_swift82.cpp
1f8b0f9b8540415ab4330804a270899ee57e22e4,"Canonicalize conformance access paths for sources pre-requirement-signature.

When a requirement source involving a ProtocolRequirement element is
built prior to the requirement signature of the protocol it
references, we can end up with a requirement source whose steps don't
reflect was is actually available via the requirement signatures. When
building a conformance access path from such requirement sources,
canonicalize on-the-fly using the requirement signatures (which have
been/can be computed by this point) to produce a correct access path.",lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(inProtocol->getRequirementSignature(),",817,download/apple_swift82.cpp
1f8b0f9b8540415ab4330804a270899ee57e22e4,"Canonicalize conformance access paths for sources pre-requirement-signature.

When a requirement source involving a ProtocolRequirement element is
built prior to the requirement signature of the protocol it
references, we can end up with a requirement source whose steps don't
reflect was is actually available via the requirement signatures. When
building a conformance access path from such requirement sources,
canonicalize on-the-fly using the requirement signatures (which have
been/can be computed by this point) to produce a correct access path.",lib/AST/GenericSignature.cpp,+,assert(inProtocol->isRequirementSignatureComputed() &&,832,download/apple_swift82.cpp
1f8b0f9b8540415ab4330804a270899ee57e22e4,"Canonicalize conformance access paths for sources pre-requirement-signature.

When a requirement source involving a ProtocolRequirement element is
built prior to the requirement signature of the protocol it
references, we can end up with a requirement source whose steps don't
reflect was is actually available via the requirement signatures. When
building a conformance access path from such requirement sources,
canonicalize on-the-fly using the requirement signatures (which have
been/can be computed by this point) to produce a correct access path.",lib/AST/GenericSignature.cpp,-,"assert(hasConformanceInSignature(inProtocol->getRequirementSignature(),",853,download/apple_swift82.cpp
1f8b0f9b8540415ab4330804a270899ee57e22e4,"Canonicalize conformance access paths for sources pre-requirement-signature.

When a requirement source involving a ProtocolRequirement element is
built prior to the requirement signature of the protocol it
references, we can end up with a requirement source whose steps don't
reflect was is actually available via the requirement signatures. When
building a conformance access path from such requirement sources,
canonicalize on-the-fly using the requirement signatures (which have
been/can be computed by this point) to produce a correct access path.",lib/AST/GenericSignature.cpp,+,assert(knownConforms != rep->getConformsTo().end());,864,download/apple_swift82.cpp
1f8b0f9b8540415ab4330804a270899ee57e22e4,"Canonicalize conformance access paths for sources pre-requirement-signature.

When a requirement source involving a ProtocolRequirement element is
built prior to the requirement signature of the protocol it
references, we can end up with a requirement source whose steps don't
reflect was is actually available via the requirement signatures. When
building a conformance access path from such requirement sources,
canonicalize on-the-fly using the requirement signatures (which have
been/can be computed by this point) to produce a correct access path.",lib/AST/GenericSignature.cpp,-,"assert(hasConformanceInSignature(this, subjectType, conformingProto) &&",882,download/apple_swift82.cpp
1f8b0f9b8540415ab4330804a270899ee57e22e4,"Canonicalize conformance access paths for sources pre-requirement-signature.

When a requirement source involving a ProtocolRequirement element is
built prior to the requirement signature of the protocol it
references, we can end up with a requirement source whose steps don't
reflect was is actually available via the requirement signatures. When
building a conformance access path from such requirement sources,
canonicalize on-the-fly using the requirement signatures (which have
been/can be computed by this point) to produce a correct access path.",lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(sig, subjectType, conformingProto) &&",882,download/apple_swift82.cpp
26ca022053187e5a147844cc78b7e7d8a53e953c,Merge pull request #7984 from gottesmm/tuple_init_fixes,lib/SILGen/SILGenExpr.cpp,-,assert(lowering.getLoweredType() == v->getType());,293,download/apple_swift83.cpp
26ca022053187e5a147844cc78b7e7d8a53e953c,Merge pull request #7984 from gottesmm/tuple_init_fixes,lib/SILGen/SILGenExpr.cpp,+,assert(lowering.getLoweredType().getObjectType() ==,293,download/apple_swift83.cpp
c643c7ba87897f1997761f24bc93a46ac11c56f0,"[silgen] Fix tuple initialization for semantic sil.

rdar://29791263",lib/SILGen/SILGenExpr.cpp,-,assert(lowering.getLoweredType() == v->getType());,293,download/apple_swift84.cpp
c643c7ba87897f1997761f24bc93a46ac11c56f0,"[silgen] Fix tuple initialization for semantic sil.

rdar://29791263",lib/SILGen/SILGenExpr.cpp,+,assert(lowering.getLoweredType().getObjectType() ==,293,download/apple_swift84.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/ASTContext.cpp,-,"assert(gpContext && ""No generic parameter context"");",1103,download/apple_swift85.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/ASTContext.cpp,-,assert(gpContext->getGenericEnvironmentOfContext() != nullptr &&,1103,download/apple_swift85.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/ASTContext.cpp,-,assert(BGT->getGenericArgs().size() == 1);,1104,download/apple_swift85.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/ASTContext.cpp,-,"assert(gpContext && ""Missing generic parameter context"");",1115,download/apple_swift85.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/ASTContext.cpp,-,"assert(boundGenericSubstitutions.count({type, gpContext}) == 0 &&",1137,download/apple_swift85.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/Module.cpp,-,assert(gpContext->getAsNominalTypeOrNominalTypeExtensionContext(),573,download/apple_swift86.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/Module.cpp,-,assert(result.second);,633,download/apple_swift86.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/SubstitutionMap.cpp,+,assert(how == CombineSubstitutionMaps::AtIndex);,378,download/apple_swift87.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/Type.cpp,-,assert(origSubs.size() == substSubs.size());,1711,download/apple_swift88.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/Type.cpp,-,assert(origSubs[subi].getConformances().size(),1715,download/apple_swift88.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/AST/Type.cpp,+,assert(result.second);,3121,download/apple_swift88.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SIL/SILType.cpp,-,"assert(!fnTy->isPolymorphic() && ""function type without subs must not """,344,download/apple_swift89.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SIL/SILType.cpp,-,"assert(fnTy->isPolymorphic() && ""Can only subst interface generic args on """,347,download/apple_swift89.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILGen/SILGenBridging.cpp,+,assert(!cast<FuncDecl>(witness.getDecl())->isGeneric() &&,98,download/apple_swift90.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILGen/SILGenConvert.cpp,+,"SubstitutionMap::getProtocolSubstitutions(ctx.getErrorDecl(),",525,download/apple_swift91.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILGen/SILGenDynamicCast.cpp,-,assert(fnGenericParams.size() == fromSubsts.size() + toSubsts.size() &&,621,download/apple_swift92.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILGen/SILGenExpr.cpp,-,assert(fnGenericParams.size() == fromSubsts.size() + toSubsts.size() &&,1357,download/apple_swift93.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILGen/SILGenExpr.cpp,-,"assert(conformance && ""not a _Pointer type"");",3614,download/apple_swift93.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILOptimizer/Transforms/ReleaseDevirtualizer.cpp,-,assert(!AllocSubsts.empty() == DeallocType->isPolymorphic() &&,153,download/apple_swift94.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILOptimizer/Utils/Local.cpp,-,"assert(Conf && ""_ObjectiveCBridgeable conformance should exist"");",1343,download/apple_swift95.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/Sema/TypeCheckProtocol.cpp,-,if (sub.getReplacement()->hasError()),3183,download/apple_swift96.cpp
b243ee3798cbbbdbe18ac0aaa9b54f03c97579f8,"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/Sema/TypeCheckProtocol.cpp,+,"return t.subst(subMap, SubstFlags::UseErrorType)->hasError();",3192,download/apple_swift96.cpp
2777c9b478424b9a39b6f51183bc6c45d2b959f7,AST: Remove TypeBase::gatherAllSubstitutions(),lib/AST/ASTContext.cpp,-,"assert(gpContext && ""No generic parameter context"");",1103,download/apple_swift97.cpp
2777c9b478424b9a39b6f51183bc6c45d2b959f7,AST: Remove TypeBase::gatherAllSubstitutions(),lib/AST/ASTContext.cpp,-,assert(gpContext->getGenericEnvironmentOfContext() != nullptr &&,1103,download/apple_swift97.cpp
2777c9b478424b9a39b6f51183bc6c45d2b959f7,AST: Remove TypeBase::gatherAllSubstitutions(),lib/AST/ASTContext.cpp,-,assert(BGT->getGenericArgs().size() == 1);,1104,download/apple_swift97.cpp
2777c9b478424b9a39b6f51183bc6c45d2b959f7,AST: Remove TypeBase::gatherAllSubstitutions(),lib/AST/ASTContext.cpp,-,"assert(gpContext && ""Missing generic parameter context"");",1115,download/apple_swift97.cpp
2777c9b478424b9a39b6f51183bc6c45d2b959f7,AST: Remove TypeBase::gatherAllSubstitutions(),lib/AST/ASTContext.cpp,-,"assert(boundGenericSubstitutions.count({type, gpContext}) == 0 &&",1137,download/apple_swift97.cpp
2777c9b478424b9a39b6f51183bc6c45d2b959f7,AST: Remove TypeBase::gatherAllSubstitutions(),lib/AST/Module.cpp,-,assert(gpContext->getAsNominalTypeOrNominalTypeExtensionContext(),573,download/apple_swift98.cpp
2777c9b478424b9a39b6f51183bc6c45d2b959f7,AST: Remove TypeBase::gatherAllSubstitutions(),lib/AST/Module.cpp,-,assert(result.second);,633,download/apple_swift98.cpp
46600b5f1a8d1c156b886f5aed52ecb5162535b7,Sema: Remove gatherAllSubstitutions() usage,lib/Sema/TypeCheckProtocol.cpp,-,if (sub.getReplacement()->hasError()),3183,download/apple_swift99.cpp
46600b5f1a8d1c156b886f5aed52ecb5162535b7,Sema: Remove gatherAllSubstitutions() usage,lib/Sema/TypeCheckProtocol.cpp,+,"return t.subst(subMap, SubstFlags::UseErrorType)->hasError();",3192,download/apple_swift99.cpp
848076946d3206137cb5fb42a04e32a51f82c842,AST: Remove gatherAllSubstitutions() usages,lib/AST/Type.cpp,-,assert(origSubs.size() == substSubs.size());,1711,download/apple_swift100.cpp
848076946d3206137cb5fb42a04e32a51f82c842,AST: Remove gatherAllSubstitutions() usages,lib/AST/Type.cpp,-,assert(origSubs[subi].getConformances().size(),1715,download/apple_swift100.cpp
3d4503a99c0844ade934bc6a6e4b0a0501277fc1,"AST: Add optional GenericEnvironment parameter to TypeBase::getContextSubstitutionMap()

If a generic type appears in a generic function, the old
gatherAllSubstitutions() method would map outer generic
parameters to archetypes.

However, getContextSubstitutionMap() did not map them to
anything.

I'm trying to unify these methods, so add an optional
GenericEnvironment to getContextSubstitutionMap() to support
the cases where they're needed.

Of course types in generic functions are not supported right
now, but not preserving this subtle behavioral difference
makes some crashers regress.",lib/AST/Type.cpp,+,assert(result.second);,3115,download/apple_swift101.cpp
76eb5dd66d70b6774e1e5b2660a267ff7bfba514,"SILGen: Clean up ad-hoc SubstitutionList construction when calling intrinsics

Change emitApplyOfLibraryIntrinsic() to take a SubstitutionMap,
and use the correct abstractions to build the map.

This gets rid of the last remaining uses of gatherAllSubstitutions()
in SIL.",lib/SILGen/SILGenConvert.cpp,+,"SubstitutionMap::getProtocolSubstitutions(ctx.getErrorDecl(),",525,download/apple_swift102.cpp
76eb5dd66d70b6774e1e5b2660a267ff7bfba514,"SILGen: Clean up ad-hoc SubstitutionList construction when calling intrinsics

Change emitApplyOfLibraryIntrinsic() to take a SubstitutionMap,
and use the correct abstractions to build the map.

This gets rid of the last remaining uses of gatherAllSubstitutions()
in SIL.",lib/SILGen/SILGenDynamicCast.cpp,-,assert(fnGenericParams.size() == fromSubsts.size() + toSubsts.size() &&,621,download/apple_swift103.cpp
76eb5dd66d70b6774e1e5b2660a267ff7bfba514,"SILGen: Clean up ad-hoc SubstitutionList construction when calling intrinsics

Change emitApplyOfLibraryIntrinsic() to take a SubstitutionMap,
and use the correct abstractions to build the map.

This gets rid of the last remaining uses of gatherAllSubstitutions()
in SIL.",lib/SILGen/SILGenExpr.cpp,-,assert(fnGenericParams.size() == fromSubsts.size() + toSubsts.size() &&,1357,download/apple_swift104.cpp
76eb5dd66d70b6774e1e5b2660a267ff7bfba514,"SILGen: Clean up ad-hoc SubstitutionList construction when calling intrinsics

Change emitApplyOfLibraryIntrinsic() to take a SubstitutionMap,
and use the correct abstractions to build the map.

This gets rid of the last remaining uses of gatherAllSubstitutions()
in SIL.",lib/SILGen/SILGenExpr.cpp,-,"assert(conformance && ""not a _Pointer type"");",3614,download/apple_swift104.cpp
76eb5dd66d70b6774e1e5b2660a267ff7bfba514,"SILGen: Clean up ad-hoc SubstitutionList construction when calling intrinsics

Change emitApplyOfLibraryIntrinsic() to take a SubstitutionMap,
and use the correct abstractions to build the map.

This gets rid of the last remaining uses of gatherAllSubstitutions()
in SIL.",lib/SILOptimizer/Utils/Local.cpp,-,"assert(Conf && ""_ObjectiveCBridgeable conformance should exist"");",1343,download/apple_swift105.cpp
5465c8ca8f653c5a5172494ecd9228791c7e70aa,SIL: Remove most usages of TypeBase::gatherAllSubstitutions(),lib/SIL/SILType.cpp,-,"assert(!fnTy->isPolymorphic() && ""function type without subs must not """,344,download/apple_swift106.cpp
5465c8ca8f653c5a5172494ecd9228791c7e70aa,SIL: Remove most usages of TypeBase::gatherAllSubstitutions(),lib/SIL/SILType.cpp,-,"assert(fnTy->isPolymorphic() && ""Can only subst interface generic args on """,347,download/apple_swift106.cpp
5465c8ca8f653c5a5172494ecd9228791c7e70aa,SIL: Remove most usages of TypeBase::gatherAllSubstitutions(),lib/SILGen/SILGenBridging.cpp,+,assert(!cast<FuncDecl>(witness.getDecl())->isGeneric() &&,98,download/apple_swift107.cpp
5465c8ca8f653c5a5172494ecd9228791c7e70aa,SIL: Remove most usages of TypeBase::gatherAllSubstitutions(),lib/SILOptimizer/Transforms/ReleaseDevirtualizer.cpp,-,assert(!AllocSubsts.empty() == DeallocType->isPolymorphic() &&,153,download/apple_swift108.cpp
53819211318c63205d471176158a35531b252e2a,AST: Generalize SubstitutionMap::combineSubstitutionMaps(),lib/AST/SubstitutionMap.cpp,+,assert(how == CombineSubstitutionMaps::AtIndex);,378,download/apple_swift109.cpp
8aab9f742fd47eb93a66c915aa1d682b553dfbc4,Merge pull request #7974 from gottesmm/foreach_switch_enum,lib/SILGen/SILGenStmt.cpp,+,"assert(!inputValue && ""None should not be passed an argument!"");",946,download/apple_swift110.cpp
8aab9f742fd47eb93a66c915aa1d682b553dfbc4,Merge pull request #7974 from gottesmm/foreach_switch_enum,lib/SILGen/SwitchCaseFullExpr.cpp,-,"assert(!scope.isValid() && ""Switch Case Full Expr was not popped?!"");",27,download/apple_swift111.cpp
bf8d941103023e68b7a50932df842bd380ab0061,"[silgen] Change foreach loop emission to use the new SwitchEnumBuilder.

rdar://29791263",lib/SILGen/SILGenStmt.cpp,+,"assert(!inputValue && ""None should not be passed an argument!"");",946,download/apple_swift112.cpp
bf8d941103023e68b7a50932df842bd380ab0061,"[silgen] Change foreach loop emission to use the new SwitchEnumBuilder.

rdar://29791263",lib/SILGen/SwitchCaseFullExpr.cpp,-,"assert(!scope.isValid() && ""Switch Case Full Expr was not popped?!"");",27,download/apple_swift113.cpp
be5e01af3196fc9e8f0a7cab218409330b918003,"[function-signature-opt] Allow FSO on witness_methods when performing the dead argument signature optimization for partial_apply instructions

This improves performance of some benchmarks, which pass static operators like `Int.<` as closure arguments.

Fixes rdar://23428804",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");",935,download/apple_swift114.cpp
be5e01af3196fc9e8f0a7cab218409330b918003,"[function-signature-opt] Allow FSO on witness_methods when performing the dead argument signature optimization for partial_apply instructions

This improves performance of some benchmarks, which pass static operators like `Int.<` as closure arguments.

Fixes rdar://23428804",lib/SILOptimizer/Utils/FunctionSignatureOptUtils.cpp,+,assert(!OptForPartialApply || FuncInfo);,91,download/apple_swift115.cpp
0dc16d8c1afb80d3a862e2550047d5d8864e1cd6,"Merge pull request #7969 from slavapestov/subst-cleanup

More SubstitutionList => SubstitutionMap cleanups",lib/AST/ProtocolConformance.cpp,+,assert(classDecl);,147,download/apple_swift116.cpp
0dc16d8c1afb80d3a862e2550047d5d8864e1cd6,"Merge pull request #7969 from slavapestov/subst-cleanup

More SubstitutionList => SubstitutionMap cleanups",lib/AST/Substitution.cpp,-,assert(!substReplacement->hasError() &&,58,download/apple_swift117.cpp
0dc16d8c1afb80d3a862e2550047d5d8864e1cd6,"Merge pull request #7969 from slavapestov/subst-cleanup

More SubstitutionList => SubstitutionMap cleanups",lib/AST/Substitution.cpp,-,assert(classDecl);,106,download/apple_swift117.cpp
0dc16d8c1afb80d3a862e2550047d5d8864e1cd6,"Merge pull request #7969 from slavapestov/subst-cleanup

More SubstitutionList => SubstitutionMap cleanups",lib/AST/Substitution.cpp,-,assert(conformance);,120,download/apple_swift117.cpp
0dc16d8c1afb80d3a862e2550047d5d8864e1cd6,"Merge pull request #7969 from slavapestov/subst-cleanup

More SubstitutionList => SubstitutionMap cleanups",lib/AST/Substitution.cpp,-,assert(substConformances.size() == Conformance.size());,124,download/apple_swift117.cpp
de2f5f78ac5beef3b305da628851a58574adf066,"AST: Remove Substitution::subst()

I want to get rid of Substitution entirely, and now we have
the right abstractions to do everything with SubstitutionMap.",lib/AST/Substitution.cpp,-,assert(!substReplacement->hasError() &&,56,download/apple_swift118.cpp
de2f5f78ac5beef3b305da628851a58574adf066,"AST: Remove Substitution::subst()

I want to get rid of Substitution entirely, and now we have
the right abstractions to do everything with SubstitutionMap.",lib/AST/Substitution.cpp,-,assert(substConformances.size() == Conformance.size());,75,download/apple_swift118.cpp
61b6cc823ed97ece6caea42c8c1ee1a04cd71d10,"AST: Add ProtocolConformanceRef::subst()

Extract this from Substitution::subst(), which is going away.",lib/AST/ProtocolConformance.cpp,+,assert(classDecl);,147,download/apple_swift119.cpp
61b6cc823ed97ece6caea42c8c1ee1a04cd71d10,"AST: Add ProtocolConformanceRef::subst()

Extract this from Substitution::subst(), which is going away.",lib/AST/Substitution.cpp,-,assert(classDecl);,105,download/apple_swift120.cpp
61b6cc823ed97ece6caea42c8c1ee1a04cd71d10,"AST: Add ProtocolConformanceRef::subst()

Extract this from Substitution::subst(), which is going away.",lib/AST/Substitution.cpp,-,assert(conformance);,119,download/apple_swift120.cpp
e58d02b88bc7408b5e65e0c11cc0557c2e7cdf09,"Make sure ErrorTypes containing type variables are marked as such. (#7963)

In some cases, the type checker will produce error types with the
""original type"" intact for recovery purposes. Like other types, when
the original type contains a type variable, the ErrorType instance
will be allocated in the ""temporary"" memory arena associated with the
active constraint solver, because there's no way that particular error
will come up again once the constraint system containing that type
variable has been destroyed.

However, we weren't propagating that ""contains a type variable""
information to the newly-created ErrorType, which meant that any type
/containing/ that ErrorType would be allocated in the ""permanent""
arena. In practice, this would always be a DependentMemberType; not
too many types are created without looking at their base types at all.
The arena containing the ErrorType would then be deallocated, and its
memory reused later on for a /different/ type. If we ever tried to
make a DependentMemberType whose base was this new type, we'd find the
old DependentMemberType instance in our cache and return that. The
result was that we'd have a DependentMemberType whose ""HasError"" bit
was set even though the base type was not an error type, and which was
considered canonical whether or not the base type was. This would then
either hit an assertion later on or result in nonsensical errors like
""'C.Iterator' is not the same type as 'C.Iterator'"".

Because the reused address always referred to a valid type, none of
the usual dynamic analysis tools could catch the problem. It really
comes down to using a pointer address as a key in a map---but even
without that, we were allocating types in the permanent arena that
really should be temporary, which is a waste of memory.

Likely fixes rdar://problem/30382791, a nondeterministic failure we've
been seeing for weeks on the bots and on developer machines.",lib/AST/ASTContext.cpp,-,"new (*this, AllocationArena::Permanent) ErrorType(*this, Type())),",407,download/apple_swift121.cpp
e58d02b88bc7408b5e65e0c11cc0557c2e7cdf09,"Make sure ErrorTypes containing type variables are marked as such. (#7963)

In some cases, the type checker will produce error types with the
""original type"" intact for recovery purposes. Like other types, when
the original type contains a type variable, the ErrorType instance
will be allocated in the ""temporary"" memory arena associated with the
active constraint solver, because there's no way that particular error
will come up again once the constraint system containing that type
variable has been destroyed.

However, we weren't propagating that ""contains a type variable""
information to the newly-created ErrorType, which meant that any type
/containing/ that ErrorType would be allocated in the ""permanent""
arena. In practice, this would always be a DependentMemberType; not
too many types are created without looking at their base types at all.
The arena containing the ErrorType would then be deallocated, and its
memory reused later on for a /different/ type. If we ever tried to
make a DependentMemberType whose base was this new type, we'd find the
old DependentMemberType instance in our cache and return that. The
result was that we'd have a DependentMemberType whose ""HasError"" bit
was set even though the base type was not an error type, and which was
considered canonical whether or not the base type was. This would then
either hit an assertion later on or result in nonsensical errors like
""'C.Iterator' is not the same type as 'C.Iterator'"".

Because the reused address always referred to a valid type, none of
the usual dynamic analysis tools could catch the problem. It really
comes down to using a pointer address as a key in a map---but even
without that, we were allocating types in the permanent arena that
really should be temporary, which is a waste of memory.

Likely fixes rdar://problem/30382791, a nondeterministic failure we've
been seeing for weeks on the bots and on developer machines.",lib/AST/ASTContext.cpp,+,"ErrorType(*this, Type(), RecursiveTypeProperties::HasError)),",408,download/apple_swift121.cpp
e58d02b88bc7408b5e65e0c11cc0557c2e7cdf09,"Make sure ErrorTypes containing type variables are marked as such. (#7963)

In some cases, the type checker will produce error types with the
""original type"" intact for recovery purposes. Like other types, when
the original type contains a type variable, the ErrorType instance
will be allocated in the ""temporary"" memory arena associated with the
active constraint solver, because there's no way that particular error
will come up again once the constraint system containing that type
variable has been destroyed.

However, we weren't propagating that ""contains a type variable""
information to the newly-created ErrorType, which meant that any type
/containing/ that ErrorType would be allocated in the ""permanent""
arena. In practice, this would always be a DependentMemberType; not
too many types are created without looking at their base types at all.
The arena containing the ErrorType would then be deallocated, and its
memory reused later on for a /different/ type. If we ever tried to
make a DependentMemberType whose base was this new type, we'd find the
old DependentMemberType instance in our cache and return that. The
result was that we'd have a DependentMemberType whose ""HasError"" bit
was set even though the base type was not an error type, and which was
considered canonical whether or not the base type was. This would then
either hit an assertion later on or result in nonsensical errors like
""'C.Iterator' is not the same type as 'C.Iterator'"".

Because the reused address always referred to a valid type, none of
the usual dynamic analysis tools could catch the problem. It really
comes down to using a pointer address as a key in a map---but even
without that, we were allocating types in the permanent arena that
really should be temporary, which is a waste of memory.

Likely fixes rdar://problem/30382791, a nondeterministic failure we've
been seeing for weeks on the bots and on developer machines.",lib/AST/ASTContext.cpp,-,"return entry = new (mem) ErrorType(ctx, originalType);",2439,download/apple_swift121.cpp
e58d02b88bc7408b5e65e0c11cc0557c2e7cdf09,"Make sure ErrorTypes containing type variables are marked as such. (#7963)

In some cases, the type checker will produce error types with the
""original type"" intact for recovery purposes. Like other types, when
the original type contains a type variable, the ErrorType instance
will be allocated in the ""temporary"" memory arena associated with the
active constraint solver, because there's no way that particular error
will come up again once the constraint system containing that type
variable has been destroyed.

However, we weren't propagating that ""contains a type variable""
information to the newly-created ErrorType, which meant that any type
/containing/ that ErrorType would be allocated in the ""permanent""
arena. In practice, this would always be a DependentMemberType; not
too many types are created without looking at their base types at all.
The arena containing the ErrorType would then be deallocated, and its
memory reused later on for a /different/ type. If we ever tried to
make a DependentMemberType whose base was this new type, we'd find the
old DependentMemberType instance in our cache and return that. The
result was that we'd have a DependentMemberType whose ""HasError"" bit
was set even though the base type was not an error type, and which was
considered canonical whether or not the base type was. This would then
either hit an assertion later on or result in nonsensical errors like
""'C.Iterator' is not the same type as 'C.Iterator'"".

Because the reused address always referred to a valid type, none of
the usual dynamic analysis tools could catch the problem. It really
comes down to using a pointer address as a key in a map---but even
without that, we were allocating types in the permanent arena that
really should be temporary, which is a waste of memory.

Likely fixes rdar://problem/30382791, a nondeterministic failure we've
been seeing for weeks on the bots and on developer machines.",lib/AST/ASTContext.cpp,+,"return entry = new (mem) ErrorType(ctx, originalType, properties);",2442,download/apple_swift121.cpp
e58d02b88bc7408b5e65e0c11cc0557c2e7cdf09,"Make sure ErrorTypes containing type variables are marked as such. (#7963)

In some cases, the type checker will produce error types with the
""original type"" intact for recovery purposes. Like other types, when
the original type contains a type variable, the ErrorType instance
will be allocated in the ""temporary"" memory arena associated with the
active constraint solver, because there's no way that particular error
will come up again once the constraint system containing that type
variable has been destroyed.

However, we weren't propagating that ""contains a type variable""
information to the newly-created ErrorType, which meant that any type
/containing/ that ErrorType would be allocated in the ""permanent""
arena. In practice, this would always be a DependentMemberType; not
too many types are created without looking at their base types at all.
The arena containing the ErrorType would then be deallocated, and its
memory reused later on for a /different/ type. If we ever tried to
make a DependentMemberType whose base was this new type, we'd find the
old DependentMemberType instance in our cache and return that. The
result was that we'd have a DependentMemberType whose ""HasError"" bit
was set even though the base type was not an error type, and which was
considered canonical whether or not the base type was. This would then
either hit an assertion later on or result in nonsensical errors like
""'C.Iterator' is not the same type as 'C.Iterator'"".

Because the reused address always referred to a valid type, none of
the usual dynamic analysis tools could catch the problem. It really
comes down to using a pointer address as a key in a map---but even
without that, we were allocating types in the permanent arena that
really should be temporary, which is a waste of memory.

Likely fixes rdar://problem/30382791, a nondeterministic failure we've
been seeing for weeks on the bots and on developer machines.",lib/AST/Type.cpp,-,"assert(!typeVariables.empty() && ""Did not find type variables!"");",387,download/apple_swift122.cpp
e58d02b88bc7408b5e65e0c11cc0557c2e7cdf09,"Make sure ErrorTypes containing type variables are marked as such. (#7963)

In some cases, the type checker will produce error types with the
""original type"" intact for recovery purposes. Like other types, when
the original type contains a type variable, the ErrorType instance
will be allocated in the ""temporary"" memory arena associated with the
active constraint solver, because there's no way that particular error
will come up again once the constraint system containing that type
variable has been destroyed.

However, we weren't propagating that ""contains a type variable""
information to the newly-created ErrorType, which meant that any type
/containing/ that ErrorType would be allocated in the ""permanent""
arena. In practice, this would always be a DependentMemberType; not
too many types are created without looking at their base types at all.
The arena containing the ErrorType would then be deallocated, and its
memory reused later on for a /different/ type. If we ever tried to
make a DependentMemberType whose base was this new type, we'd find the
old DependentMemberType instance in our cache and return that. The
result was that we'd have a DependentMemberType whose ""HasError"" bit
was set even though the base type was not an error type, and which was
considered canonical whether or not the base type was. This would then
either hit an assertion later on or result in nonsensical errors like
""'C.Iterator' is not the same type as 'C.Iterator'"".

Because the reused address always referred to a valid type, none of
the usual dynamic analysis tools could catch the problem. It really
comes down to using a pointer address as a key in a map---but even
without that, we were allocating types in the permanent arena that
really should be temporary, which is a waste of memory.

Likely fixes rdar://problem/30382791, a nondeterministic failure we've
been seeing for weeks on the bots and on developer machines.",lib/AST/Type.cpp,+,assert((!typeVariables.empty() || hasError()) &&,387,download/apple_swift122.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(isProjection());,149,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storageAddress);,159,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(numIndirectResults == loweredFnConv.getNumIndirectSILResults());,415,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(argIdx == pass.loweredFnConv.getNumIndirectSILResults());,497,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"assert(pass.domInfo->properlyDominates(stackInst, innerVal));",525,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(ApplySite(value).getSubstCalleeType()->getNumResults() > 1);,554,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage.isRewritten());,620,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,DEBUG(user->dump());,653,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.loweredFnConv.hasIndirectSILResults());,673,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(resultIdx < pass.loweredFnConv.getNumIndirectSILResults());,682,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)",711,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteParameters();,714,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteIndirectParameter(Operand *operand);,715,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ApplyRewriter::rewriteParameters() {,729,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteIndirectParameter(&operand);,737,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ApplyRewriter::rewriteIndirectParameter(Operand *operand) {,781,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage.isRewritten());,788,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(apply.getSubstCalleeType()->hasIndirectFormalResults());,874,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.valueStorageMap.contains(origCallInst));,904,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newResultArgIdx == loweredFnConv.getSILArgIndexOfFirstParam());,961,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newResultArgIdx == loweredCalleeConv.getSILArgIndexOfFirstParam());,962,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(loweredFnConv.isSILIndirect(resultInfo));,994,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(loweredCalleeConv.isSILIndirect(resultInfo));,995,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,ReturnRewriter(AddressLoweringState &pass) : pass(pass) {},1036,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteReturns();,1038,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteReturn(ReturnInst *returnInst);,1041,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ReturnRewriter::rewriteReturns() {,1044,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteReturn(cast<ReturnInst>(termInst));,1047,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ReturnRewriter::rewriteReturn(ReturnInst *returnInst) {,1051,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(origDirectResultValues.size() == numOrigDirectResults);,1071,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!origFnConv.isSILIndirect(resultInfo));,1085,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newResultArgIdx,1088,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage.isRewritten());,1096,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newDirectResults.size(),1114,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,explicit AddressOnlyRewriter(AddressLoweringState &pass),1156,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,void rewriteFunction() {,1158,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueDef->dump());",1161,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(if (valueStorage.storageAddress) {,1161,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,explicit AddressOnlyUseRewriter(AddressLoweringState &pass),1173,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(V->dump());,1183,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  REWRITE ""; V->dump());",1191,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""  REWRITE USE ""; V->dump());",1191,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,DEBUG(V->dump());,1199,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  CALL ""; applyInst->dump();",1205,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(applyInst, pass).rewriteIndirectParameter(currOper);",1208,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"B.createDebugValueAddr(debugInst->getLoc(), addr);",1235,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"B.createDebugValueAddr(debugInst->getLoc(), srcAddr);",1238,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == destroyInst->getOperand());,1243,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!currOper);,1254,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(currOper->get() == srcVal);,1270,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storeInst->getOwnershipQualifier(),1276,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!srcAddr);,1280,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!srcStorage.isProjection());,1284,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == returnInst->getOperand());,1301,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(origDirectResultValues.size() == numOrigDirectResults);,1329,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!origFnConv.isSILIndirect(resultInfo));,1353,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newResultArgIdx < loweredFnConv.getSILArgIndexOfFirstParam());,1354,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newDirectResults.size() == loweredFnConv.getNumDirectSILResults());,1376,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,explicit AddressOnlyDefRewriter(AddressLoweringState &pass),1406,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""REWRITE DEF ""; V->dump());",1415,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""  STORAGE ""; storage->storageAddress->dump());",1417,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,B.setCurrentDebugScope(I->getDebugScope());,1421,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == storeInst->getSrc());,1425,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(storeInst->getOwnershipQualifier() ==,1427,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,DEBUG(V->dump());,1429,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!storage->isRewritten());,1434,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter rewriter(applyInst, pass);",1438,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriter.rewriteParameters();,1439,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage->isProjection() || storage->isRewritten());,1445,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage->storageAddress);,1453,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage->storageAddress);,1470,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,1490,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(extractInst->use_empty(),1517,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(ApplySite::isa(srcVal));,1526,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(cast<SILInstruction>(srcVal), pass)",1527,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage->storageAddress);,1530,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,static void rewriteFunction(AddressLoweringState &pass) {,1535,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.valueStorageMap.getStorage(result).isRewritten());,1557,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter rewriter(applyInst, pass);",1564,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriter.rewriteParameters();,1565,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(applyInst, pass).rewriteParameters();",1570,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,ReturnRewriter(pass).rewriteReturns();,1573,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,AddressOnlyRewriter(pass).rewriteFunction();,1470,download/apple_swift123.cpp
4a25d055cf7b27bffe7c62a2de81dfd38803b4b3,Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteFunction(pass);,1470,download/apple_swift123.cpp
81ed11ccfad7f5e842411ae1be31b59afb197701,"Merge pull request #7959 from DougGregor/inferred-requirements-are-not-redundant

[GSB] Don't complain about redundant requirements with inferred sources.",lib/AST/DiagnosticEngine.cpp,+,Arg.getAsValueDecl()->getFullName().printPretty(Out);,373,download/apple_swift124.cpp
81ed11ccfad7f5e842411ae1be31b59afb197701,"Merge pull request #7959 from DougGregor/inferred-requirements-are-not-redundant

[GSB] Don't complain about redundant requirements with inferred sources.",lib/AST/GenericSignatureBuilder.cpp,-,constraint.concreteType.print(Out);,1617,download/apple_swift125.cpp
81ed11ccfad7f5e842411ae1be31b59afb197701,"Merge pull request #7959 from DougGregor/inferred-requirements-are-not-redundant

[GSB] Don't complain about redundant requirements with inferred sources.",lib/AST/GenericSignatureBuilder.cpp,+,constraint.value.print(Out);,1617,download/apple_swift125.cpp
81ed11ccfad7f5e842411ae1be31b59afb197701,"Merge pull request #7959 from DougGregor/inferred-requirements-are-not-redundant

[GSB] Don't complain about redundant requirements with inferred sources.",lib/AST/GenericSignatureBuilder.cpp,-,constraint.concreteType.print(Out);,1634,download/apple_swift125.cpp
81ed11ccfad7f5e842411ae1be31b59afb197701,"Merge pull request #7959 from DougGregor/inferred-requirements-are-not-redundant

[GSB] Don't complain about redundant requirements with inferred sources.",lib/AST/GenericSignatureBuilder.cpp,+,constraint.value.print(Out);,1634,download/apple_swift125.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(isProjection());,149,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storageAddress);,159,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(numIndirectResults == loweredFnConv.getNumIndirectSILResults());,415,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(argIdx == pass.loweredFnConv.getNumIndirectSILResults());,497,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"assert(pass.domInfo->properlyDominates(stackInst, innerVal));",525,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(ApplySite(value).getSubstCalleeType()->getNumResults() > 1);,554,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage.isRewritten());,620,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,DEBUG(user->dump());,653,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.loweredFnConv.hasIndirectSILResults());,673,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(resultIdx < pass.loweredFnConv.getNumIndirectSILResults());,682,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)",711,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteParameters();,714,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteIndirectParameter(Operand *operand);,715,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ApplyRewriter::rewriteParameters() {,729,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteIndirectParameter(&operand);,737,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ApplyRewriter::rewriteIndirectParameter(Operand *operand) {,781,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage.isRewritten());,788,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(apply.getSubstCalleeType()->hasIndirectFormalResults());,874,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.valueStorageMap.contains(origCallInst));,904,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newResultArgIdx == loweredFnConv.getSILArgIndexOfFirstParam());,961,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newResultArgIdx == loweredCalleeConv.getSILArgIndexOfFirstParam());,962,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(loweredFnConv.isSILIndirect(resultInfo));,994,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(loweredCalleeConv.isSILIndirect(resultInfo));,995,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,ReturnRewriter(AddressLoweringState &pass) : pass(pass) {},1036,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteReturns();,1038,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteReturn(ReturnInst *returnInst);,1041,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ReturnRewriter::rewriteReturns() {,1044,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteReturn(cast<ReturnInst>(termInst));,1047,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ReturnRewriter::rewriteReturn(ReturnInst *returnInst) {,1051,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(origDirectResultValues.size() == numOrigDirectResults);,1071,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!origFnConv.isSILIndirect(resultInfo));,1085,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newResultArgIdx,1088,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage.isRewritten());,1096,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newDirectResults.size(),1114,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,explicit AddressOnlyRewriter(AddressLoweringState &pass),1156,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,void rewriteFunction() {,1158,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueDef->dump());",1161,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(if (valueStorage.storageAddress) {,1161,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,explicit AddressOnlyUseRewriter(AddressLoweringState &pass),1173,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(V->dump());,1183,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  REWRITE ""; V->dump());",1191,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""  REWRITE USE ""; V->dump());",1191,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,DEBUG(V->dump());,1199,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  CALL ""; applyInst->dump();",1205,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(applyInst, pass).rewriteIndirectParameter(currOper);",1208,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"B.createDebugValueAddr(debugInst->getLoc(), addr);",1235,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"B.createDebugValueAddr(debugInst->getLoc(), srcAddr);",1238,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == destroyInst->getOperand());,1243,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!currOper);,1254,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(currOper->get() == srcVal);,1270,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storeInst->getOwnershipQualifier(),1276,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!srcAddr);,1280,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!srcStorage.isProjection());,1284,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == returnInst->getOperand());,1301,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(origDirectResultValues.size() == numOrigDirectResults);,1329,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!origFnConv.isSILIndirect(resultInfo));,1353,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newResultArgIdx < loweredFnConv.getSILArgIndexOfFirstParam());,1354,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newDirectResults.size() == loweredFnConv.getNumDirectSILResults());,1376,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,explicit AddressOnlyDefRewriter(AddressLoweringState &pass),1406,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""REWRITE DEF ""; V->dump());",1415,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""  STORAGE ""; storage->storageAddress->dump());",1417,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,B.setCurrentDebugScope(I->getDebugScope());,1421,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == storeInst->getSrc());,1425,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(storeInst->getOwnershipQualifier() ==,1427,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,DEBUG(V->dump());,1429,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!storage->isRewritten());,1434,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter rewriter(applyInst, pass);",1438,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriter.rewriteParameters();,1439,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage->isProjection() || storage->isRewritten());,1445,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage->storageAddress);,1453,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage->storageAddress);,1470,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,1490,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(extractInst->use_empty(),1517,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(ApplySite::isa(srcVal));,1526,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(cast<SILInstruction>(srcVal), pass)",1527,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storage->storageAddress);,1530,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,static void rewriteFunction(AddressLoweringState &pass) {,1535,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.valueStorageMap.getStorage(result).isRewritten());,1557,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter rewriter(applyInst, pass);",1564,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriter.rewriteParameters();,1565,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(applyInst, pass).rewriteParameters();",1570,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,ReturnRewriter(pass).rewriteReturns();,1573,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,AddressOnlyRewriter(pass).rewriteFunction();,1470,download/apple_swift126.cpp
c2b433bad630f501dc0cc740c33fe63e66f78694,"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteFunction(pass);,1470,download/apple_swift126.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignature.cpp,+,void ConformanceAccessPath::print(raw_ostream &out) const {,29,download/apple_swift127.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignature.cpp,+,entry.first.print(out);,32,download/apple_swift127.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignature.cpp,+,print(llvm::errs());,40,download/apple_swift127.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignature.cpp,+,"assert(type->isTypeParameter() && ""not a type parameter"");",743,download/apple_swift127.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignature.cpp,+,assert(conforms != rep->getConformsTo().end());,753,download/apple_swift127.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(inProtocol->getRequirementSignature(),",803,download/apple_swift127.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignature.cpp,+,assert(source->kind == RequirementSource::Explicit ||,821,download/apple_swift127.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(this, subjectType, conformingProto) &&",830,download/apple_swift127.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/AST/GenericSignatureBuilder.cpp,-,"assert(req && ""substituting Self in requirement shouldn't fail"");",1864,download/apple_swift128.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/Sema/TypeCheckProtocol.cpp,+,T.print(llvm::errs());,5263,download/apple_swift129.cpp
fa4a196fe008c9ac1c942a365d5234a6d875c7e2,Merge pull request #7956 from DougGregor/conformance-access-path,lib/Sema/TypeCheckProtocol.cpp,+,.print(llvm::errs());,5269,download/apple_swift129.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/AST/GenericSignature.cpp,+,void ConformanceAccessPath::print(raw_ostream &out) const {,29,download/apple_swift130.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/AST/GenericSignature.cpp,+,entry.first.print(out);,32,download/apple_swift130.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/AST/GenericSignature.cpp,+,print(llvm::errs());,40,download/apple_swift130.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/AST/GenericSignature.cpp,+,"assert(type->isTypeParameter() && ""not a type parameter"");",743,download/apple_swift130.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/AST/GenericSignature.cpp,+,assert(conforms != rep->getConformsTo().end());,753,download/apple_swift130.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(inProtocol->getRequirementSignature(),",803,download/apple_swift130.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/AST/GenericSignature.cpp,+,assert(source->kind == RequirementSource::Explicit ||,821,download/apple_swift130.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/AST/GenericSignature.cpp,+,"assert(hasConformanceInSignature(this, subjectType, conformingProto) &&",830,download/apple_swift130.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/Sema/TypeCheckProtocol.cpp,+,T.print(llvm::errs());,5134,download/apple_swift131.cpp
202bc7eeea239171a27594c13aba3c8659113974,"[AST] Introduce GenericSignature::getConformanceAccessPath().

Introduce an API that determines the ""conformance access path"" that
one would follow to find the conformance of a given type parameter
(e.g., T.Iterator.Element) to a given protocol (e.g., Equatable). A
conformance access path starts at one of the explicit requirements
of that generic signature and then proceeds through zero or more
protocol-supplied requirements. For example, given this function:

  func f<C: Collection>(_: C) { }

The conformance access path for ""C.Iterator: IteratorProtocol"" is

  (C, Collection) -> (Self, Sequence) -> (Self.Iterator, IteratorProtocol)

because one starts with the explicit requirement ""C: Collection"", goes
to the inherited protocol requirement (the ""Self"" in Collection
conforms to Sequence) and then a requirement on the associated type
(Self.Iterator in Sequence conforms to IteratorProtocol).

This is all scaffolding now; it's intended to be used by IRGen (to
find the witness tables it needs) and SubstitutionMap (to dig out
conformances during substitution).",lib/Sema/TypeCheckProtocol.cpp,+,.print(llvm::errs());,5140,download/apple_swift131.cpp
908123ac119eb09b274f4b99564a4ce66f10bd77,"[GSB] Fix requirement sources from protocol requirement signature.

The stored dependent types in ProtocolRequirement elements within
requirement sources were incorrect for requirements created from the
requirement signature of another protocol, because we picked up the
already-substituted subject type. Thread the optional substitution map
through addRequirement(Requirement) as well, so we maintain the
original spelling of the stored dependent type.

This is a temporary fix; we should be able to recover the stored
dependent types from the potential archetypes in the requirement
source, so that we don't need to specify them explicitly at
construction time.",lib/AST/GenericSignatureBuilder.cpp,-,"assert(req && ""substituting Self in requirement shouldn't fail"");",1864,download/apple_swift132.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/Parse/ParseSIL.cpp,+,assert(Opcode == ValueKind::CheckedCastValueBranchInst);,2531,download/apple_swift133.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,-,assert(data.InnerIndirectResultAddrs.size(),1525,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,+,assert(data.InnerIndirectResultAddrs.size() ==,1527,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,-,assert(Gen.silConv.isSILIndirect(innerResult));,1633,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,+,assert(Gen.silConv.isSILIndirect(innerResult) ||,1633,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,-,assert((!outerOrigType.isTuple() || Gen.silConv.isSILIndirect(innerResult)),1821,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,+,assert((!outerOrigType.isTuple() || innerResult.isFormalIndirect()) &&,1823,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,+,assert(!Gen.silConv.useLoweredAddresses() &&,1840,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,+,assert(!innerOrigType.isTuple());,2187,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,+,"assert(outerSubstTupleType && ""Outer type must be a tuple"");",2190,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,+,assert(innerSubstType->getNumElements() ==,2191,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILGen/SILGenPoly.cpp,+,"assert(innerTupleType && ""Only supports tuple inner types"");",2264,download/apple_swift134.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILOptimizer/Utils/CFG.cpp,+,"assert(EdgeIdx == 0 || EdgeIdx == 1 && ""Invalid edge index"");",266,download/apple_swift135.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/SILOptimizer/Utils/CFG.cpp,+,assert(OldDest == CBI->getSuccessBB() ||,434,download/apple_swift135.cpp
3376f2bcd3847aa2f3661e63366138fb5e4ac066,"Merge pull request #7947 from shajrawi/conditional_checked_cast

Add support for conditional checked cast instruction for opaque value types + SILGen support for it",lib/Serialization/DeserializeSIL.cpp,+,assert(ListOfValues.size() == 5 &&,1913,download/apple_swift136.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ASTContext.cpp,+,assert(proto->isSpecificProtocol(KPK_ObjectiveCBridgeable) &&,3621,download/apple_swift137.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/GenericEnvironment.cpp,+,assert(reqts.size() == sub.getConformances().size());,424,download/apple_swift138.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/GenericEnvironment.cpp,-,assert(contextTy->hasError());,430,download/apple_swift138.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/GenericEnvironment.cpp,+,assert(contextTy->hasError());,431,download/apple_swift138.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/GenericSignature.cpp,-,assert(getGenericParams().empty() || areAllParamsConcrete());,394,download/apple_swift139.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/GenericSignature.cpp,+,assert(reqts.size() == sub.getConformances().size());,406,download/apple_swift139.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/GenericSignatureBuilder.cpp,+,"assert(depTy->is<GenericTypeParamType>() && ""not a type parameter!"");",401,download/apple_swift140.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ProtocolConformance.cpp,+,assert(idx < conformances.size());,264,download/apple_swift141.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ProtocolConformance.cpp,+,assert(conformances[idx].getRequirement() ==,265,download/apple_swift141.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ProtocolConformance.cpp,+,"assert(idx == conformances.size() && ""Too many conformances"");",270,download/apple_swift141.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ProtocolConformance.cpp,+,assert(assocType->isTypeParameter() &&,341,download/apple_swift141.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ProtocolConformance.cpp,+,assert(type->isEqual(proto->getSelfInterfaceType()) &&,350,download/apple_swift141.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ProtocolConformance.cpp,+,assert(assocType->isTypeParameter() &&,374,download/apple_swift141.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ProtocolConformance.cpp,-,"assert((!isComplete() || isInvalid()) && ""Conformance already complete?"");",424,download/apple_swift141.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/AST/ProtocolConformance.cpp,+,assert((!isComplete() || isInvalid() ||,424,download/apple_swift141.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,+,"assert(MangledName.startswith(""_T""));",233,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,+,"assert(Remaining.startswith(""To"") || Remaining.startswith(""TO""));",239,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,+,assert(StartingAt <= NumChildren);,314,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,+,assert(NumElems <= Capacity);,377,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,+,"int Length = snprintf(Elems + NumElems, MaxIntPrintSize, ""%d"", Number);",384,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,+,assert(Length > 0 && Length < MaxIntPrintSize);,385,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,-,"std::move(DemanglerPrinter() << ""Builtin.Float"" << size).str());",889,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,-,"(DemanglerPrinter() << ""Builtin.Int"" << size).str());",900,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Demangler.cpp,-,"(DemanglerPrinter() << ""Builtin.Vec"" << elts << ""x"" <<",913,download/apple_swift142.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Mangler.cpp,-,assert(isUpperLetter(Storage[lastSubstIdx]));,373,download/apple_swift143.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Remangler.cpp,-,assert(isUpperLetter(lastChar));,322,download/apple_swift144.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Version.cpp,-,assert(currentVersion.hasValue() &&,254,download/apple_swift145.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Version.cpp,-,assert(v.hasValue());,305,download/apple_swift145.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Basic/Version.cpp,+,"static_assert(SWIFT_VERSION_MAJOR == 3,",332,download/apple_swift145.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/ClangImporter/ImportDecl.cpp,+,assert(req.getFirstType()->isEqual(proto->getSelfInterfaceType()));,6974,download/apple_swift146.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/ClangImporter/ImportDecl.cpp,+,assert(reqConformance && reqConformance->isConcrete() &&,6980,download/apple_swift146.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/ClangImporter/ImportType.cpp,-,assert(resultTy &&,1781,download/apple_swift147.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},49,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},54,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},59,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,63,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },",70,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },",79,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"static bool writeFilelistIfNecessary(const Job *job, DiagnosticEngine &diags);",107,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";",208,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,IncrementalTracer->printPath(,209,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";",233,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Blocked by: "" << LogJob(Blocking)",245,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"<< LogJobArray(BlockingCommands[Blocking]) << ""\n"";",247,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);",257,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"assert(success && ""failed to write filelist"");",258,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,assert(Cmd->getExtraEnvironment().empty() &&,261,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";",265,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,",272,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"<< "": "" << LogJob(Cmd) << ""\n"";",286,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"<< LogJobArray(AllBlocked) << ""\n"";",295,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,OS << LogJob(BeganCmd);,312,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,BeganCmd->printCommandLine(llvm::errs());,323,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,358,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,assert(DepGraph.isMarked(FinishedCmd));,395,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,assert(BlockingCommands.empty() &&,662,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,",721,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,Result = Comp.Diags.hadAnyError();,735,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,"IncrementalTracer->printPath(llvm::outs(), cmd,",836,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,"bool success = writeFilelistIfNecessary(Cmd, Diags);",855,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,"assert(success && ""failed to write filelist"");",855,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,assert(Cmd->getExtraEnvironment().empty() &&,857,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,BeganCmd->printCommandLine(llvm::errs());,1012,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,assert(FinishedCmd->getCondition() == Job::Condition::Always);,1057,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,assert(DepGraph.isMarked(FinishedCmd));,1094,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,assert(State.BlockingCommands.empty() &&,1210,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,Result = Diags.hadAnyError();,1247,download/apple_swift148.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Driver/Job.cpp,+,void Job::printSummary(raw_ostream &os) const {,112,download/apple_swift149.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenArchetype.cpp,+,assert(memberType.getBase()->isEqual(source->getSelfInterfaceType()));,122,download/apple_swift150.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenArchetype.cpp,-,assert(associate &&,416,download/apple_swift150.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,static_assert(llvm::PointerLikeTypeTraits<llvm::Function*>,979,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,static_assert(llvm::PointerLikeTypeTraits<AbstractFunctionDecl*>,982,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,"assert(method && ""null method provided"");",991,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");",994,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");",998,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(getKind() == Kind::Method);,1004,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(getKind() != Kind::Method);,1008,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(fields.getNextOffsetFromGlobal() == size);,1247,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(fields.getNextOffsetFromGlobal() == size);,1290,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,-,assert(InstanceMethodTypesExt.size() == InstanceMethods.size(),1574,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,-,assert(ClassMethodTypesExt.size() == ClassMethods.size(),1575,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,-,assert(OptInstanceMethodTypesExt.size() == OptInstanceMethods.size(),1576,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,-,assert(OptClassMethodTypesExt.size() == OptClassMethods.size(),1577,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(descriptor.getKind() == MethodDescriptor::Kind::Method &&,1609,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,fields.addInt32(alignment.log2());,1744,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,-,"llvm::ConstantInt::get(IGM.Int32Ty, alignment.log2()),",1751,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,-,"assert(getter_setter.second && ""no descriptor for setter?!"");",1829,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,-,"assert(subscript->getSetter() && ""no descriptor for setter?!"");",2018,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(startOfClassRO.isMultipleOf(IGM.getPointerSize()));,2057,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,assert(startOfMetaclassRO.isMultipleOf(IGM.getPointerSize()));,2065,download/apple_swift151.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenDecl.cpp,-,assert(definitionType == nullptr);,1851,download/apple_swift152.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenDecl.cpp,+,assert(!definition);,1851,download/apple_swift152.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenDecl.cpp,-,assert(definitionType == nullptr);,1865,download/apple_swift152.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenDecl.cpp,+,assert(!definition);,1865,download/apple_swift152.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenDecl.cpp,-,"assert(definitionType && ""not defining nominal type descriptor?"");",2777,download/apple_swift152.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenDecl.cpp,+,"assert(definition && ""not defining nominal type descriptor?"");",2778,download/apple_swift152.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenDecl.cpp,+,assert(!definition &&,2795,download/apple_swift152.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenDecl.cpp,-,assert(conformance->getProtocol() == associate->getProtocol());,3316,download/apple_swift152.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenMeta.cpp,-,assert(TemplateHeaderFieldCount == Field);,3115,download/apple_swift153.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenMeta.cpp,-,"addWord(llvm::ConstantExpr::getBitCast(IGM.getDeletedMethodErrorFn(),",3526,download/apple_swift153.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenMeta.cpp,+,"B.addBitCast(IGM.getDeletedMethodErrorFn(), IGM.FunctionPtrTy);",3527,download/apple_swift153.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(baseEntry.isBase());,765,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(piEntry.getOutOfLineBaseIndex().getValue() == Table.size(),1044,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1045,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(piEntry.getFunctionIndex().getValue() == Table.size(),1088,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1089,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(piEntry.getAssociatedTypeIndex().getValue() == Table.size(),1123,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1124,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(protos.size() == sub.getConformances().size());,1132,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(!associate->hasTypeParameter());,1151,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,1159,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Requirement == requirement,1161,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Protocol == protocol,1162,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,1165,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Requirement->isEqual(associatedType),1168,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Protocol == protocol,1170,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1175,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,+,assert(isa<GenericTypeParamType>(depAssociatedType)); // Self,1346,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/GenProto.cpp,-,assert(entry.isOutOfLineBase());,2076,download/apple_swift154.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/IRGen/Linking.cpp,+,assert(isa<GenericTypeParamType>(assocType));,88,download/apple_swift155.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Parse/ParseSIL.cpp,+,"parseSILOwnership(RHSKind) || parseSILDebugLocation(InstLoc, B)) {",2184,download/apple_swift156.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Parse/ParseSIL.cpp,+,assert(isa<GenericTypeParamType>(assocType));,4643,download/apple_swift156.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SIL/Mangle.cpp,-,"assert(idx == Subs.size() && ""subs not parallel to dependent types"");",82,download/apple_swift157.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SIL/SILPrinter.cpp,+,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {",2268,download/apple_swift158.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SIL/SILPrinter.cpp,+,"if (printAssociatedTypePath(OS, memberType.getBase()))",2270,download/apple_swift158.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SIL/SILPrinter.cpp,+,assert(isa<GenericTypeParamType>(path));,2275,download/apple_swift158.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SIL/SILPrinter.cpp,+,"(void) printAssociatedTypePath(OS, assocProtoWitness.Requirement);",2339,download/apple_swift158.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SIL/SILType.cpp,-,"assert(isObject() && ""Should only be called on object types."");",379,download/apple_swift159.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/RValue.cpp,+,assert(eltFormalType->isMaterializable());,92,download/apple_swift160.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/RValue.cpp,+,assert(eltTy.isAddress() == tuple.getType().isAddress());,95,download/apple_swift160.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,99,download/apple_swift160.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,125,download/apple_swift160.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenApply.cpp,-,"assert(!isa<LValueType>(origParamType) && ""Self can't be @lvalue"");",238,download/apple_swift161.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenApply.cpp,-,assert(tuple->getNumElements() == 1);,244,download/apple_swift161.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenApply.cpp,-,assert(isa<MetatypeType>(origParamType) == isa<MetatypeType>(selfType));,250,download/apple_swift161.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenApply.cpp,-,assert(origParamType->getRValueInstanceType()->isTypeParameter());,250,download/apple_swift161.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenApply.cpp,-,assert(selfType->getRValueInstanceType()->is<ArchetypeType>());,250,download/apple_swift161.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenApply.cpp,-,assert(!HasSubstitutions);,368,download/apple_swift161.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenApply.cpp,+,assert(Substitutions.empty());,368,download/apple_swift161.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenApply.cpp,-,"assert(fnType && ""found no call sites?"");",821,download/apple_swift161.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenBuilder.cpp,+,assert(!builder.hasValidInsertionPoint());,676,download/apple_swift162.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenBuilder.cpp,+,assert(!builder.hasValidInsertionPoint());,696,download/apple_swift162.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenConvert.cpp,+,assert(noOptResultTy);,307,download/apple_swift163.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenConvert.cpp,-,assert(resultValueTy);,335,download/apple_swift163.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenDecl.cpp,-,assert(protos.size() == witness.getConformances().size(),1739,download/apple_swift164.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenDecl.cpp,-,assert(witness.getConformances().empty(),1742,download/apple_swift164.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenDecl.cpp,-,assert(foundConformance != witness.getConformances().end());,1768,download/apple_swift164.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SILGenDestructor.cpp,+,assert(resultSelfValue.getOwnershipKind() ==,97,download/apple_swift165.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SwitchCaseFullExpr.cpp,+,"assert(!scope.isValid() && ""Switch Case Full Expr was not popped?!"");",27,download/apple_swift166.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILGen/SwitchCaseFullExpr.cpp,+,assert(SGF.B.hasValidInsertionPoint());,31,download/apple_swift166.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"assert(SubIt != SubEnd && ""Not enough substitutions."");",344,download/apple_swift167.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,assert(!Replacement->hasTypeParameter());,350,download/apple_swift167.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/IPO/EagerSpecializer.cpp,+,assert(!Replacement->hasTypeParameter());,371,download/apple_swift167.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"assert(SubIt == SubEnd && ""Too many substitutions."");",392,download/apple_swift167.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"GenericFunc->mapTypeIntoContext(t).print(dbgs()); },",705,download/apple_swift167.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"assert(hashIter != valueHashMap.end() && ""Missing SILValue"");",100,download/apple_swift168.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"assert(hashResult.second && ""SILValue already mapped"");",106,download/apple_swift168.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,-,"F->getEffectsKind(), nullptr, F->getDebugScope());",494,download/apple_swift169.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,F->getDebugScope());,498,download/apple_swift169.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()",69,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()",73,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,DEBUG(llvm::dbgs() <<,118,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,DEBUG(for (auto Sub : ParamSubs) {,119,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Partial specialization is not supported.\n"");",123,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(for (auto Sub : ParamSubs) { Sub.dump(); });,124,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(llvm::dbgs(),123,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,assert(RI.isFormalIndirect());,144,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Partial specialization is not supported if """,194,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(for (auto Sub : ParamSubs) {,196,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""\n\nPartially specialized types for function: """,229,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(CalleeFnTy->isPolymorphic());,244,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,247,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,249,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!SpecializedSubstFnTy->isPolymorphic() &&,255,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!SpecializedSubstFnTy->hasTypeParameter() &&,257,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(SpecializedSubstFnTy == SpecializedCalleeSubstFnTy &&,279,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""The new specialized type is the same as """,287,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""Specializing the call:\n"";",300,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(FnTy);,400,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,"FnTy->getOptionalErrorResult(), M.getASTContext());",406,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"FnTy->getParameters(), FnTy->getResults(), FnTy->getOptionalErrorResult(),",407,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()",531,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!Sub.getReplacement()->hasError() &&,588,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,881,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,883,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,-,"Arguments, ResultBB, TAI->getErrorBB());",917,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/Generics.cpp,+,"ResultBB, TAI->getErrorBB());",918,download/apple_swift170.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/SILOptimizer/Utils/SpecializationMangler.cpp,-,"assert(idx == Subs.size() && ""subs not parallel to dependent types"");",80,download/apple_swift171.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/CSSimplify.cpp,+,assert(TC.Context.LangOpts.EnableObjCInterop,3359,download/apple_swift172.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/Constraint.cpp,+,assert(kind != ConstraintKind::BridgingConversion,532,download/apple_swift173.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"printProtocolStubFixitString(SourceLoc TypeLoc, ProtocolConformance *Conf,",2667,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"if (!printRequirementStub(VD, Conf->getDeclContext(), Conf->getType(),",2674,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,-,"bool AddFixit = printRequirementStub(Requirement, Adopter,",2681,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"printProtocolStubFixitString(TypeLoc, Conf,",2724,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Inferring associated types from decl:\n"";",3318,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Considering whether "" << result.first->getName()",3341,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,-,if (result.second->hasError()),3346,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,if (result.second->hasError()) {,3346,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- has error type\n"");",3347,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- duplicate\n"");",3355,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""++ we can same-type to:\n"";",3413,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- tautological\n"");",3428,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""** contradicts explicit type witness, """,3446,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- doesn't fulfill requirements\n"");",3468,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""++ seems legit\n"");",3473,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Candidates for inference:\n"";",3983,download/apple_swift174.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Sema/TypeCheckStmt.cpp,+,"printPayloads(EE, OS);",311,download/apple_swift175.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Serialization/Serialization.cpp,+,"writeConformance(reqConformance, DeclTypeAbbrCodes);",1323,download/apple_swift176.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Serialization/Serialization.cpp,-,assert(sig->getAllDependentTypes().size(),3294,download/apple_swift176.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Serialization/Serialization.cpp,+,assert(sig->getSubstitutionListSize(),3294,download/apple_swift176.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::DeclModifier);,45,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 4);,46,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Kind == tok::kw_class ||,51,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, DeclModifierSyntax::Cursor::LeftParen,",59,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, DeclModifierSyntax::Cursor::Argument,",61,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, DeclModifierSyntax::Cursor::RightParen,",63,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(NewName->getTokenKind() == tok::identifier);,97,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",107,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(NewArgument->getTokenKind() == tok::identifier);,118,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",128,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 8);,473,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionParameterSyntax::Cursor::ExternalName,",474,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionParameterSyntax::Cursor::LocalName,",476,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionParameterSyntax::Cursor::Colon,",478,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionParameterSyntax::Cursor::Type)->isType());,480,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionParameterSyntax::Cursor::Ellipsis,",481,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",483,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(,486,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",488,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(NewExternalName->getTokenKind() == tok::identifier);,528,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(NewLocalName->getTokenKind() == tok::identifier);,539,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewColonToken, tok::colon, "":"");",550,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(NewEqualToken->getTokenKind() == tok::equal);,593,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewTrailingComma, tok::comma, "","");",637,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 7);,649,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",650,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionSignatureSyntax::Cursor::ParameterList)->Kind ==,654,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",657,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(cast<TokenSyntax>(ThrowsRethrows)->getTokenKind() == tok::kw_throws ||,663,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionSignatureSyntax::Cursor::Arrow,",666,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw,",668,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionSignatureSyntax::Cursor::ReturnType)->isType());,671,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",707,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",741,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewThrowsToken, tok::kw_throws, ""throws"");",756,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRethrowsToken, tok::kw_rethrows, ""rethrows"");",772,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewArrowToken, tok::arrow, ""->"");",783,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::FunctionDecl);,841,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 8);,842,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Attributes,",843,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Modifiers,",845,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionDeclSyntax::Cursor::FuncKeyword,",847,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionDeclSyntax::Cursor::Identifier,",849,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw,",851,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Signature,",854,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::GenericWhereClause,",856,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Body,",858,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewFuncKeyword, tok::kw_func, ""func"");",936,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/DeclSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,948,download/apple_swift177.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/ExprSyntax.cpp,-,assert(Child->Kind == SyntaxKind::FunctionCallArgument);,313,download/apple_swift178.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/ExprSyntax.cpp,-,assert(Index <= getRaw()->Layout.size());,352,download/apple_swift178.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/GenericSyntax.cpp,-,assert(Raw->Kind == SyntaxKind::GenericRequirementList);,235,download/apple_swift179.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(NewWhereKeyword, tok::kw_where, ""where"");",270,download/apple_swift179.cpp
ca77872ba84acd9e32aaade7136d9982c01d655c,Merge CheckedCastValueBranch with new master,lib/Syntax/StmtSyntax.cpp,-,assert(Raw->Kind == SyntaxKind::StmtList);,391,download/apple_swift180.cpp
5d2cd20051f21ca4bf04d9fa9badfde8347252df,Sema/FixCode: Introducing a wrapper for ConformanceChecker to fix missing stubs for multiple protocols in a single fixit invocation. (#7937),lib/Sema/TypeCheckProtocol.cpp,-,"printProtocolStubFixitString(TypeLoc, Conf,",2691,download/apple_swift181.cpp
5d2cd20051f21ca4bf04d9fa9badfde8347252df,Sema/FixCode: Introducing a wrapper for ConformanceChecker to fix missing stubs for multiple protocols in a single fixit invocation. (#7937),lib/Sema/TypeCheckProtocol.cpp,+,"printProtocolStubFixitString(TypeLoc, Conf,",2734,download/apple_swift181.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/Parse/ParseSIL.cpp,+,assert(Opcode == ValueKind::CheckedCastValueBranchInst);,2502,download/apple_swift182.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,-,assert(data.InnerIndirectResultAddrs.size(),1525,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,+,assert(data.InnerIndirectResultAddrs.size() ==,1527,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,-,assert(Gen.silConv.isSILIndirect(innerResult));,1633,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,+,assert(Gen.silConv.isSILIndirect(innerResult) ||,1633,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,-,assert((!outerOrigType.isTuple() || Gen.silConv.isSILIndirect(innerResult)),1821,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,+,assert((!outerOrigType.isTuple() || innerResult.isFormalIndirect()) &&,1823,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,+,assert(!Gen.silConv.useLoweredAddresses() &&,1840,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,+,assert(!innerOrigType.isTuple());,2187,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,+,"assert(outerSubstTupleType && ""Outer type must be a tuple"");",2190,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,+,assert(innerSubstType->getNumElements() ==,2191,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILGen/SILGenPoly.cpp,+,"assert(innerTupleType && ""Only supports tuple inner types"");",2264,download/apple_swift183.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILOptimizer/Utils/CFG.cpp,+,"assert(EdgeIdx == 0 || EdgeIdx == 1 && ""Invalid edge index"");",266,download/apple_swift184.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/SILOptimizer/Utils/CFG.cpp,+,assert(OldDest == CBI->getSuccessBB() ||,434,download/apple_swift184.cpp
1f626304f1f1be21c2b94e3944687b4433116fc4,Add support for conditional checked cast instruction for opaque value types + SILGen support for it,lib/Serialization/DeserializeSIL.cpp,+,assert(ListOfValues.size() == 5 &&,1903,download/apple_swift185.cpp
d5d2db5185731f242ef7ed2720afffc3a3a12b68,"[Diagnostics] Allow ValueDecl* diagnostic arguments.

Render these via their full names.",lib/AST/DiagnosticEngine.cpp,+,Arg.getAsValueDecl()->getFullName().printPretty(Out);,373,download/apple_swift186.cpp
370550f47222bb429a69ea4958d02cb8093fd610,[GSB] Abstract ConcreteConstraint to a more-general Constraint<T>.,lib/AST/GenericSignatureBuilder.cpp,-,constraint.concreteType.print(Out);,1541,download/apple_swift187.cpp
370550f47222bb429a69ea4958d02cb8093fd610,[GSB] Abstract ConcreteConstraint to a more-general Constraint<T>.,lib/AST/GenericSignatureBuilder.cpp,+,constraint.value.print(Out);,1541,download/apple_swift187.cpp
370550f47222bb429a69ea4958d02cb8093fd610,[GSB] Abstract ConcreteConstraint to a more-general Constraint<T>.,lib/AST/GenericSignatureBuilder.cpp,-,constraint.concreteType.print(Out);,1558,download/apple_swift187.cpp
370550f47222bb429a69ea4958d02cb8093fd610,[GSB] Abstract ConcreteConstraint to a more-general Constraint<T>.,lib/AST/GenericSignatureBuilder.cpp,+,constraint.value.print(Out);,1558,download/apple_swift187.cpp
e6041acd4dfc2b22749a9b60beae70ef129def7a,"Merge pull request #7941 from apple/revert-7917-sil-combiner-cleanup

Revert ""SILCombiner: Clean up the concrete -> existential peephole a bit""",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,-,assert(origTy->isEqual(OpenedArchetype));,704,download/apple_swift188.cpp
e6041acd4dfc2b22749a9b60beae70ef129def7a,"Merge pull request #7941 from apple/revert-7917-sil-combiner-cleanup

Revert ""SILCombiner: Clean up the concrete -> existential peephole a bit""",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,-,assert(FnTy->isPolymorphic());,719,download/apple_swift188.cpp
e6041acd4dfc2b22749a9b60beae70ef129def7a,"Merge pull request #7941 from apple/revert-7917-sil-combiner-cleanup

Revert ""SILCombiner: Clean up the concrete -> existential peephole a bit""",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,-,"TAI->getNormalBB(), TAI->getErrorBB());",752,download/apple_swift188.cpp
e6041acd4dfc2b22749a9b60beae70ef129def7a,"Merge pull request #7941 from apple/revert-7917-sil-combiner-cleanup

Revert ""SILCombiner: Clean up the concrete -> existential peephole a bit""",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,+,"TAI->getNormalBB(), TAI->getErrorBB());",754,download/apple_swift188.cpp
d1ea199966300d12908cc1024fa760c47a806457,Merge pull request #7943 from DougGregor/witness-table-indirect-conformances,lib/AST/GenericSignatureBuilder.cpp,+,"assert(depTy->is<GenericTypeParamType>() && ""not a type parameter!"");",361,download/apple_swift189.cpp
d1ea199966300d12908cc1024fa760c47a806457,Merge pull request #7943 from DougGregor/witness-table-indirect-conformances,lib/AST/ProtocolConformance.cpp,-,assert(type->isEqual(getProtocol()->getSelfInterfaceType()) &&,372,download/apple_swift190.cpp
d1ea199966300d12908cc1024fa760c47a806457,Merge pull request #7943 from DougGregor/witness-table-indirect-conformances,lib/AST/ProtocolConformance.cpp,+,assert(type->isEqual(proto->getSelfInterfaceType()) &&,372,download/apple_swift190.cpp
d1ea199966300d12908cc1024fa760c47a806457,Merge pull request #7943 from DougGregor/witness-table-indirect-conformances,lib/AST/ProtocolConformance.cpp,-,assert(memberType.getBase()->isEqual(getProtocol()->getSelfInterfaceType()) &&,385,download/apple_swift190.cpp
d1ea199966300d12908cc1024fa760c47a806457,Merge pull request #7943 from DougGregor/witness-table-indirect-conformances,lib/AST/ProtocolConformance.cpp,-,assert(foundInRequirements &&,389,download/apple_swift190.cpp
d1ea199966300d12908cc1024fa760c47a806457,Merge pull request #7943 from DougGregor/witness-table-indirect-conformances,lib/AST/ProtocolConformance.cpp,-,assert(type->isEqual(getProtocol()->getSelfInterfaceType()) &&,400,download/apple_swift190.cpp
d1ea199966300d12908cc1024fa760c47a806457,Merge pull request #7943 from DougGregor/witness-table-indirect-conformances,lib/AST/ProtocolConformance.cpp,-,"assert(conf && ""inherited conformances cannot be abstract"");",402,download/apple_swift190.cpp
d1ea199966300d12908cc1024fa760c47a806457,Merge pull request #7943 from DougGregor/witness-table-indirect-conformances,lib/AST/ProtocolConformance.cpp,-,assert(memberType.getBase()->isEqual(getProtocol()->getSelfInterfaceType()) &&,410,download/apple_swift190.cpp
0ef867ad4f7d3ad6756e2a97d54f3e47146cf7be,Merge pull request #7942 from gottesmm/switch_enum_changes_for_convert_optional_to_optional,lib/SILGen/SILGenBuilder.cpp,+,assert(!builder.hasValidInsertionPoint());,667,download/apple_swift191.cpp
0ef867ad4f7d3ad6756e2a97d54f3e47146cf7be,Merge pull request #7942 from gottesmm/switch_enum_changes_for_convert_optional_to_optional,lib/SILGen/SILGenBuilder.cpp,+,assert(!builder.hasValidInsertionPoint());,687,download/apple_swift191.cpp
0ef867ad4f7d3ad6756e2a97d54f3e47146cf7be,Merge pull request #7942 from gottesmm/switch_enum_changes_for_convert_optional_to_optional,lib/SILGen/SILGenConvert.cpp,+,assert(noOptResultTy);,307,download/apple_swift192.cpp
0ef867ad4f7d3ad6756e2a97d54f3e47146cf7be,Merge pull request #7942 from gottesmm/switch_enum_changes_for_convert_optional_to_optional,lib/SILGen/SILGenConvert.cpp,-,assert(resultValueTy);,335,download/apple_swift192.cpp
0ef867ad4f7d3ad6756e2a97d54f3e47146cf7be,Merge pull request #7942 from gottesmm/switch_enum_changes_for_convert_optional_to_optional,lib/SILGen/SwitchCaseFullExpr.cpp,+,"assert(!scope.isValid() && ""Switch Case Full Expr was not popped?!"");",27,download/apple_swift193.cpp
0ef867ad4f7d3ad6756e2a97d54f3e47146cf7be,Merge pull request #7942 from gottesmm/switch_enum_changes_for_convert_optional_to_optional,lib/SILGen/SwitchCaseFullExpr.cpp,+,assert(SGF.B.hasValidInsertionPoint());,31,download/apple_swift193.cpp
031e70ffee24d4bfc47b8819aa9cda642241c375,"Reimplement NormalProtocolConformance::getAssocated{Type|Conformance}.

Reimplement these methods, making use of Type::subst() for
the former and the stored protocol conformances that correspond to the
protocol's requirement signature for the latter. This is enough to
emit witness tables with indirect conformance requirements in them.",lib/AST/ProtocolConformance.cpp,-,assert(type->isEqual(getProtocol()->getSelfInterfaceType()) &&,372,download/apple_swift194.cpp
031e70ffee24d4bfc47b8819aa9cda642241c375,"Reimplement NormalProtocolConformance::getAssocated{Type|Conformance}.

Reimplement these methods, making use of Type::subst() for
the former and the stored protocol conformances that correspond to the
protocol's requirement signature for the latter. This is enough to
emit witness tables with indirect conformance requirements in them.",lib/AST/ProtocolConformance.cpp,+,assert(type->isEqual(proto->getSelfInterfaceType()) &&,372,download/apple_swift194.cpp
031e70ffee24d4bfc47b8819aa9cda642241c375,"Reimplement NormalProtocolConformance::getAssocated{Type|Conformance}.

Reimplement these methods, making use of Type::subst() for
the former and the stored protocol conformances that correspond to the
protocol's requirement signature for the latter. This is enough to
emit witness tables with indirect conformance requirements in them.",lib/AST/ProtocolConformance.cpp,-,assert(memberType.getBase()->isEqual(getProtocol()->getSelfInterfaceType()) &&,385,download/apple_swift194.cpp
031e70ffee24d4bfc47b8819aa9cda642241c375,"Reimplement NormalProtocolConformance::getAssocated{Type|Conformance}.

Reimplement these methods, making use of Type::subst() for
the former and the stored protocol conformances that correspond to the
protocol's requirement signature for the latter. This is enough to
emit witness tables with indirect conformance requirements in them.",lib/AST/ProtocolConformance.cpp,-,assert(foundInRequirements &&,389,download/apple_swift194.cpp
031e70ffee24d4bfc47b8819aa9cda642241c375,"Reimplement NormalProtocolConformance::getAssocated{Type|Conformance}.

Reimplement these methods, making use of Type::subst() for
the former and the stored protocol conformances that correspond to the
protocol's requirement signature for the latter. This is enough to
emit witness tables with indirect conformance requirements in them.",lib/AST/ProtocolConformance.cpp,-,assert(type->isEqual(getProtocol()->getSelfInterfaceType()) &&,400,download/apple_swift194.cpp
031e70ffee24d4bfc47b8819aa9cda642241c375,"Reimplement NormalProtocolConformance::getAssocated{Type|Conformance}.

Reimplement these methods, making use of Type::subst() for
the former and the stored protocol conformances that correspond to the
protocol's requirement signature for the latter. This is enough to
emit witness tables with indirect conformance requirements in them.",lib/AST/ProtocolConformance.cpp,-,"assert(conf && ""inherited conformances cannot be abstract"");",402,download/apple_swift194.cpp
031e70ffee24d4bfc47b8819aa9cda642241c375,"Reimplement NormalProtocolConformance::getAssocated{Type|Conformance}.

Reimplement these methods, making use of Type::subst() for
the former and the stored protocol conformances that correspond to the
protocol's requirement signature for the latter. This is enough to
emit witness tables with indirect conformance requirements in them.",lib/AST/ProtocolConformance.cpp,-,assert(memberType.getBase()->isEqual(getProtocol()->getSelfInterfaceType()) &&,410,download/apple_swift194.cpp
1600a446dd6f8f14cf84ab1695fc22ed9c5b58a9,"[silgen] Change emitOptionalToOptional to use the SwitchEnumBuilder API.

rdar://29791263",lib/SILGen/SILGenConvert.cpp,+,assert(noOptResultTy);,307,download/apple_swift195.cpp
1600a446dd6f8f14cf84ab1695fc22ed9c5b58a9,"[silgen] Change emitOptionalToOptional to use the SwitchEnumBuilder API.

rdar://29791263",lib/SILGen/SILGenConvert.cpp,-,assert(resultValueTy);,335,download/apple_swift195.cpp
e849900a7b95cfdab20d78ae435cf95f86ad6b70,"[silgen] Add a new API for building switches: SwitchEnumBuilder.

This is a closure based API for creating switches that obey ownership
convensions. The way you use it with objects is as follows:

   SwitchEnumBuilder S(...);

   S.addCase(Decl, Block, [](ManagedValue Arg) -> void {
     ...
   });
   S.addCase(Decl, Block, [](ManagedValue Arg) -> void {
     ...
   });
   S.addDefaultCase(Block, [](ManagedValue Arg) -> void {
     ...
   });
   std::move(S).emit();

What is important is that it sets up the switch_enum destination blocks with the
proper cleanups for code emitted into the destination block and also provides
the default error with the passed in value with the appropriate cleanups.

It does not handle exits from the switch_enum on purpose since diamond
switch_enum APIs form a subset of APIs. It also expects the closure to create
terminators if appropriate.

In the switch_enum_addr case you have to do a bit more work, but it is still a
nicer API than doing it by hand as we do today.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,assert(!builder.hasValidInsertionPoint());,667,download/apple_swift196.cpp
e849900a7b95cfdab20d78ae435cf95f86ad6b70,"[silgen] Add a new API for building switches: SwitchEnumBuilder.

This is a closure based API for creating switches that obey ownership
convensions. The way you use it with objects is as follows:

   SwitchEnumBuilder S(...);

   S.addCase(Decl, Block, [](ManagedValue Arg) -> void {
     ...
   });
   S.addCase(Decl, Block, [](ManagedValue Arg) -> void {
     ...
   });
   S.addDefaultCase(Block, [](ManagedValue Arg) -> void {
     ...
   });
   std::move(S).emit();

What is important is that it sets up the switch_enum destination blocks with the
proper cleanups for code emitted into the destination block and also provides
the default error with the passed in value with the appropriate cleanups.

It does not handle exits from the switch_enum on purpose since diamond
switch_enum APIs form a subset of APIs. It also expects the closure to create
terminators if appropriate.

In the switch_enum_addr case you have to do a bit more work, but it is still a
nicer API than doing it by hand as we do today.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,assert(!builder.hasValidInsertionPoint());,687,download/apple_swift196.cpp
e849900a7b95cfdab20d78ae435cf95f86ad6b70,"[silgen] Add a new API for building switches: SwitchEnumBuilder.

This is a closure based API for creating switches that obey ownership
convensions. The way you use it with objects is as follows:

   SwitchEnumBuilder S(...);

   S.addCase(Decl, Block, [](ManagedValue Arg) -> void {
     ...
   });
   S.addCase(Decl, Block, [](ManagedValue Arg) -> void {
     ...
   });
   S.addDefaultCase(Block, [](ManagedValue Arg) -> void {
     ...
   });
   std::move(S).emit();

What is important is that it sets up the switch_enum destination blocks with the
proper cleanups for code emitted into the destination block and also provides
the default error with the passed in value with the appropriate cleanups.

It does not handle exits from the switch_enum on purpose since diamond
switch_enum APIs form a subset of APIs. It also expects the closure to create
terminators if appropriate.

In the switch_enum_addr case you have to do a bit more work, but it is still a
nicer API than doing it by hand as we do today.

rdar://29791263",lib/SILGen/SwitchCaseFullExpr.cpp,+,"assert(!scope.isValid() && ""Switch Case Full Expr was not popped?!"");",27,download/apple_swift197.cpp
e849900a7b95cfdab20d78ae435cf95f86ad6b70,"[silgen] Add a new API for building switches: SwitchEnumBuilder.

This is a closure based API for creating switches that obey ownership
convensions. The way you use it with objects is as follows:

   SwitchEnumBuilder S(...);

   S.addCase(Decl, Block, [](ManagedValue Arg) -> void {
     ...
   });
   S.addCase(Decl, Block, [](ManagedValue Arg) -> void {
     ...
   });
   S.addDefaultCase(Block, [](ManagedValue Arg) -> void {
     ...
   });
   std::move(S).emit();

What is important is that it sets up the switch_enum destination blocks with the
proper cleanups for code emitted into the destination block and also provides
the default error with the passed in value with the appropriate cleanups.

It does not handle exits from the switch_enum on purpose since diamond
switch_enum APIs form a subset of APIs. It also expects the closure to create
terminators if appropriate.

In the switch_enum_addr case you have to do a bit more work, but it is still a
nicer API than doing it by hand as we do today.

rdar://29791263",lib/SILGen/SwitchCaseFullExpr.cpp,+,assert(SGF.B.hasValidInsertionPoint());,31,download/apple_swift197.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,static_assert(llvm::PointerLikeTypeTraits<llvm::Function*>,979,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,static_assert(llvm::PointerLikeTypeTraits<AbstractFunctionDecl*>,982,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,"assert(method && ""null method provided"");",991,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");",994,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");",998,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(getKind() == Kind::Method);,1004,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(getKind() != Kind::Method);,1008,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(fields.getNextOffsetFromGlobal() == size);,1247,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(fields.getNextOffsetFromGlobal() == size);,1290,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,-,assert(InstanceMethodTypesExt.size() == InstanceMethods.size(),1574,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,-,assert(ClassMethodTypesExt.size() == ClassMethods.size(),1575,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,-,assert(OptInstanceMethodTypesExt.size() == OptInstanceMethods.size(),1576,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,-,assert(OptClassMethodTypesExt.size() == OptClassMethods.size(),1577,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(descriptor.getKind() == MethodDescriptor::Kind::Method &&,1609,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,fields.addInt32(alignment.log2());,1744,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,-,"llvm::ConstantInt::get(IGM.Int32Ty, alignment.log2()),",1751,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,-,"assert(getter_setter.second && ""no descriptor for setter?!"");",1829,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,-,"assert(subscript->getSetter() && ""no descriptor for setter?!"");",2018,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(startOfClassRO.isMultipleOf(IGM.getPointerSize()));,2057,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenClass.cpp,+,assert(startOfMetaclassRO.isMultipleOf(IGM.getPointerSize()));,2065,download/apple_swift198.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenDecl.cpp,-,assert(definitionType == nullptr);,1851,download/apple_swift199.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenDecl.cpp,+,assert(!definition);,1851,download/apple_swift199.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenDecl.cpp,-,assert(definitionType == nullptr);,1865,download/apple_swift199.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenDecl.cpp,+,assert(!definition);,1865,download/apple_swift199.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenDecl.cpp,-,"assert(definitionType && ""not defining nominal type descriptor?"");",2777,download/apple_swift199.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenDecl.cpp,+,"assert(definition && ""not defining nominal type descriptor?"");",2778,download/apple_swift199.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenDecl.cpp,+,assert(!definition &&,2795,download/apple_swift199.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenMeta.cpp,-,assert(TemplateHeaderFieldCount == Field);,3115,download/apple_swift200.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenMeta.cpp,-,"addWord(llvm::ConstantExpr::getBitCast(IGM.getDeletedMethodErrorFn(),",3526,download/apple_swift200.cpp
aa4cffee7eada7069ecd52340fbbdd958dd16c88,"Merge pull request #7935 from rjmccall/use-constant-init-builder

Replace Swift's ConstantBuilder with Clang's ConstantInitBuilder",lib/IRGen/GenMeta.cpp,+,"B.addBitCast(IGM.getDeletedMethodErrorFn(), IGM.FunctionPtrTy);",3527,download/apple_swift200.cpp
eb45355a89ab0a37af456cdc40d4042f4c2f41da,"Revert ""SILCombiner: Clean up the concrete -> existential peephole a bit""",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,-,assert(origTy->isEqual(OpenedArchetype));,704,download/apple_swift201.cpp
eb45355a89ab0a37af456cdc40d4042f4c2f41da,"Revert ""SILCombiner: Clean up the concrete -> existential peephole a bit""",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,-,assert(FnTy->isPolymorphic());,719,download/apple_swift201.cpp
eb45355a89ab0a37af456cdc40d4042f4c2f41da,"Revert ""SILCombiner: Clean up the concrete -> existential peephole a bit""",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,-,"TAI->getNormalBB(), TAI->getErrorBB());",752,download/apple_swift201.cpp
eb45355a89ab0a37af456cdc40d4042f4c2f41da,"Revert ""SILCombiner: Clean up the concrete -> existential peephole a bit""",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,+,"TAI->getNormalBB(), TAI->getErrorBB());",754,download/apple_swift201.cpp
f203c372c1201ef72b9ed61c31e08badd4b9e228,"Change conditions under which an extension is considered empty.

- Empty extensions add no Objective-C compatible members or protocols",lib/PrintAsObjC/PrintAsObjC.cpp,-,printProtocols(protocols);,367,download/apple_swift202.cpp
f203c372c1201ef72b9ed61c31e08badd4b9e228,"Change conditions under which an extension is considered empty.

- Empty extensions add no Objective-C compatible members or protocols",lib/PrintAsObjC/PrintAsObjC.cpp,+,printProtocols(ED->getLocalProtocols(ConformanceLookupKind::OnlyExplicit));,367,download/apple_swift202.cpp
f203c372c1201ef72b9ed61c31e08badd4b9e228,"Change conditions under which an extension is considered empty.

- Empty extensions add no Objective-C compatible members or protocols",lib/PrintAsObjC/PrintAsObjC.cpp,-,printMembers(members);,369,download/apple_swift202.cpp
f203c372c1201ef72b9ed61c31e08badd4b9e228,"Change conditions under which an extension is considered empty.

- Empty extensions add no Objective-C compatible members or protocols",lib/PrintAsObjC/PrintAsObjC.cpp,+,printMembers(ED->getMembers());,369,download/apple_swift202.cpp
730ecfe6104be3fcf8ae0bfc1bfd49d57ecf203d,"[GSB] Start tracking the owning dependent type in requirement sources.

For a protocol requirement element within a requirement source, track
both the protocol in which the requirement was introduced as well as
the dependent type (relative to that protocol) on which the
requirement was introduced. This information is important when
reconstructing the path from a requirement-as-written to the location
of a desired protocol conformance.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(depTy->is<GenericTypeParamType>() && ""not a type parameter!"");",361,download/apple_swift203.cpp
c4b66e591c4ac55da9783ada05ec5f4cbc37adf6,"[ClangImporter] Don't crash when a bad override affects NSErrors. (#7907)

Most of the time the name importer does a good job deciding whether to
import a particular method as throwing or not. However, when a method
is an override, it skips all that work and assumes the decisions made
for the superclass method apply here as well---which makes sense,
since you're going to get the subclass implementation if you call the
superclass's entry point. This can really throw things off if the
types /don't/ match up, though. Handle the one case where this is
legal according to the rules of Objective-C, and make sure we don't
import methods in the other cases.

rdar://problem/30705461",lib/ClangImporter/ImportType.cpp,-,assert(resultTy &&,1781,download/apple_swift204.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,static_assert(llvm::PointerLikeTypeTraits<llvm::Function*>,979,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,static_assert(llvm::PointerLikeTypeTraits<AbstractFunctionDecl*>,982,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,"assert(method && ""null method provided"");",991,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");",994,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");",998,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(getKind() == Kind::Method);,1004,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(getKind() != Kind::Method);,1008,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(fields.getNextOffsetFromGlobal() == size);,1247,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(fields.getNextOffsetFromGlobal() == size);,1290,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,-,assert(InstanceMethodTypesExt.size() == InstanceMethods.size(),1574,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,-,assert(ClassMethodTypesExt.size() == ClassMethods.size(),1575,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,-,assert(OptInstanceMethodTypesExt.size() == OptInstanceMethods.size(),1576,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,-,assert(OptClassMethodTypesExt.size() == OptClassMethods.size(),1577,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(descriptor.getKind() == MethodDescriptor::Kind::Method &&,1609,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,fields.addInt32(alignment.log2());,1744,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,-,"llvm::ConstantInt::get(IGM.Int32Ty, alignment.log2()),",1751,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,-,"assert(getter_setter.second && ""no descriptor for setter?!"");",1829,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,-,"assert(subscript->getSetter() && ""no descriptor for setter?!"");",2018,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(startOfClassRO.isMultipleOf(IGM.getPointerSize()));,2057,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenClass.cpp,+,assert(startOfMetaclassRO.isMultipleOf(IGM.getPointerSize()));,2065,download/apple_swift205.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenDecl.cpp,-,assert(definitionType == nullptr);,1851,download/apple_swift206.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenDecl.cpp,+,assert(!definition);,1851,download/apple_swift206.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenDecl.cpp,-,assert(definitionType == nullptr);,1865,download/apple_swift206.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenDecl.cpp,+,assert(!definition);,1865,download/apple_swift206.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenDecl.cpp,-,"assert(definitionType && ""not defining nominal type descriptor?"");",2777,download/apple_swift206.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenDecl.cpp,+,"assert(definition && ""not defining nominal type descriptor?"");",2778,download/apple_swift206.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenDecl.cpp,+,assert(!definition &&,2795,download/apple_swift206.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenMeta.cpp,-,assert(TemplateHeaderFieldCount == Field);,3115,download/apple_swift207.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenMeta.cpp,-,"addWord(llvm::ConstantExpr::getBitCast(IGM.getDeletedMethodErrorFn(),",3526,download/apple_swift207.cpp
d61d966451711ce3ed1522124f992434172f905e,"Use ConstantInitBuilder in most kinds of metadata emission.

This is NFC in intent, but I had to restructure the code to emit more
of the lists ""inline"", which means I inevitably altered some IRGen
emission patterns in ways that are visible to tests:

- GenClass emits property/ivar/whatever descriptors in a somewhat
  different order.

- An ext method type list is now emitted as just an array, not a struct
  containing only that array.

- Protocol descriptors are no longer emitted as packed structs.

I was sorely tempted to stop using packed structs for all the metadata
emission, but didn't really want to update that many tests in one go.",lib/IRGen/GenMeta.cpp,+,"B.addBitCast(IGM.getDeletedMethodErrorFn(), IGM.FunctionPtrTy);",3527,download/apple_swift207.cpp
47e698e519c1eb7192019b6b595ad83e3073480e,Restore empty extensions when they add protocol conformances.,lib/PrintAsObjC/PrintAsObjC.cpp,-,printProtocols(ED->getLocalProtocols(ConformanceLookupKind::OnlyExplicit));,344,download/apple_swift208.cpp
47e698e519c1eb7192019b6b595ad83e3073480e,Restore empty extensions when they add protocol conformances.,lib/PrintAsObjC/PrintAsObjC.cpp,+,printProtocols(protocols);,344,download/apple_swift208.cpp
a4749a2f1a258f4b35a23a024529b012fb7b9fa5,Remove empty extensions from Swift compatibility headers.,lib/PrintAsObjC/PrintAsObjC.cpp,-,printMembers(ED->getMembers());,343,download/apple_swift209.cpp
a4749a2f1a258f4b35a23a024529b012fb7b9fa5,Remove empty extensions from Swift compatibility headers.,lib/PrintAsObjC/PrintAsObjC.cpp,+,printMembers(members);,343,download/apple_swift209.cpp
b661af188b98e507b108ede57c17060ec31b558c,Merge pull request #7924 from eeckstein/mangling-improvements,lib/Basic/Mangler.cpp,-,assert(isUpperLetter(Storage[lastSubstIdx]));,373,download/apple_swift210.cpp
b661af188b98e507b108ede57c17060ec31b558c,Merge pull request #7924 from eeckstein/mangling-improvements,lib/Basic/Remangler.cpp,-,assert(isUpperLetter(lastChar));,322,download/apple_swift211.cpp
a04a29af4fa472840c18403133d00eae1c805e02,"mangling: efficient mangling of repeated substitutions

Instead of appending a character for each substitution, we now prefix the substitution with the repeat count, e.g.
AbbbbB -> A5B

The same is done for known-type substitutions, e.g.
SiSiSi -> S3i

This significantly shrinks mangled names which contain large lists of the same type, like
  func foo(_ x: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int))

rdar://problem/30707433",lib/Basic/Mangler.cpp,-,assert(isUpperLetter(Storage[lastSubstIdx]));,372,download/apple_swift212.cpp
a04a29af4fa472840c18403133d00eae1c805e02,"mangling: efficient mangling of repeated substitutions

Instead of appending a character for each substitution, we now prefix the substitution with the repeat count, e.g.
AbbbbB -> A5B

The same is done for known-type substitutions, e.g.
SiSiSi -> S3i

This significantly shrinks mangled names which contain large lists of the same type, like
  func foo(_ x: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int))

rdar://problem/30707433",lib/Basic/Remangler.cpp,-,assert(isUpperLetter(lastChar));,322,download/apple_swift213.cpp
014ec70cbe363a3adbcb0fe83a22649a48aa2380,Merge pull request #7902 from gottesmm/mo_tuples_mo_problems,lib/SILGen/RValue.cpp,+,assert(eltFormalType->isMaterializable());,92,download/apple_swift214.cpp
014ec70cbe363a3adbcb0fe83a22649a48aa2380,Merge pull request #7902 from gottesmm/mo_tuples_mo_problems,lib/SILGen/RValue.cpp,+,assert(eltTy.isAddress() == tuple.getType().isAddress());,95,download/apple_swift214.cpp
014ec70cbe363a3adbcb0fe83a22649a48aa2380,Merge pull request #7902 from gottesmm/mo_tuples_mo_problems,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,99,download/apple_swift214.cpp
014ec70cbe363a3adbcb0fe83a22649a48aa2380,Merge pull request #7902 from gottesmm/mo_tuples_mo_problems,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,125,download/apple_swift214.cpp
87ca878870d12b23a91d2200df6a5d1ed01859cb,"[silgen] Fix another tuple explosion -> borrow + copy since we do not have the destructure operation yet.

rdar://29791263",lib/SILGen/RValue.cpp,+,assert(eltFormalType->isMaterializable());,92,download/apple_swift215.cpp
87ca878870d12b23a91d2200df6a5d1ed01859cb,"[silgen] Fix another tuple explosion -> borrow + copy since we do not have the destructure operation yet.

rdar://29791263",lib/SILGen/RValue.cpp,+,assert(eltTy.isAddress() == tuple.getType().isAddress());,95,download/apple_swift215.cpp
87ca878870d12b23a91d2200df6a5d1ed01859cb,"[silgen] Fix another tuple explosion -> borrow + copy since we do not have the destructure operation yet.

rdar://29791263",lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,99,download/apple_swift215.cpp
87ca878870d12b23a91d2200df6a5d1ed01859cb,"[silgen] Fix another tuple explosion -> borrow + copy since we do not have the destructure operation yet.

rdar://29791263",lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,125,download/apple_swift215.cpp
5a624ebbb6ce8c8afeef1a0c8daec32db4ba4cc3,"Merge pull request #7918 from slavapestov/silgen-apply-cleanup

SILGen: Remove SubstFormalType computation",lib/SILGen/SILGenApply.cpp,-,"assert(!isa<LValueType>(origParamType) && ""Self can't be @lvalue"");",238,download/apple_swift216.cpp
5a624ebbb6ce8c8afeef1a0c8daec32db4ba4cc3,"Merge pull request #7918 from slavapestov/silgen-apply-cleanup

SILGen: Remove SubstFormalType computation",lib/SILGen/SILGenApply.cpp,-,assert(tuple->getNumElements() == 1);,244,download/apple_swift216.cpp
5a624ebbb6ce8c8afeef1a0c8daec32db4ba4cc3,"Merge pull request #7918 from slavapestov/silgen-apply-cleanup

SILGen: Remove SubstFormalType computation",lib/SILGen/SILGenApply.cpp,-,assert(isa<MetatypeType>(origParamType) == isa<MetatypeType>(selfType));,250,download/apple_swift216.cpp
5a624ebbb6ce8c8afeef1a0c8daec32db4ba4cc3,"Merge pull request #7918 from slavapestov/silgen-apply-cleanup

SILGen: Remove SubstFormalType computation",lib/SILGen/SILGenApply.cpp,-,assert(origParamType->getRValueInstanceType()->isTypeParameter());,250,download/apple_swift216.cpp
5a624ebbb6ce8c8afeef1a0c8daec32db4ba4cc3,"Merge pull request #7918 from slavapestov/silgen-apply-cleanup

SILGen: Remove SubstFormalType computation",lib/SILGen/SILGenApply.cpp,-,assert(selfType->getRValueInstanceType()->is<ArchetypeType>());,250,download/apple_swift216.cpp
5a624ebbb6ce8c8afeef1a0c8daec32db4ba4cc3,"Merge pull request #7918 from slavapestov/silgen-apply-cleanup

SILGen: Remove SubstFormalType computation",lib/SILGen/SILGenApply.cpp,-,assert(!HasSubstitutions);,368,download/apple_swift216.cpp
5a624ebbb6ce8c8afeef1a0c8daec32db4ba4cc3,"Merge pull request #7918 from slavapestov/silgen-apply-cleanup

SILGen: Remove SubstFormalType computation",lib/SILGen/SILGenApply.cpp,+,assert(Substitutions.empty());,368,download/apple_swift216.cpp
5a624ebbb6ce8c8afeef1a0c8daec32db4ba4cc3,"Merge pull request #7918 from slavapestov/silgen-apply-cleanup

SILGen: Remove SubstFormalType computation",lib/SILGen/SILGenApply.cpp,-,"assert(fnType && ""found no call sites?"");",821,download/apple_swift216.cpp
66ff05820e5e42db72dbfe88775472c276f4a5f9,"SILGen: Remove SubstFormalType computation

There was a lot of rather elaborate code that didn't do
anything at all.",lib/SILGen/SILGenApply.cpp,-,"assert(!isa<LValueType>(origParamType) && ""Self can't be @lvalue"");",238,download/apple_swift217.cpp
66ff05820e5e42db72dbfe88775472c276f4a5f9,"SILGen: Remove SubstFormalType computation

There was a lot of rather elaborate code that didn't do
anything at all.",lib/SILGen/SILGenApply.cpp,-,assert(tuple->getNumElements() == 1);,244,download/apple_swift217.cpp
66ff05820e5e42db72dbfe88775472c276f4a5f9,"SILGen: Remove SubstFormalType computation

There was a lot of rather elaborate code that didn't do
anything at all.",lib/SILGen/SILGenApply.cpp,-,assert(isa<MetatypeType>(origParamType) == isa<MetatypeType>(selfType));,250,download/apple_swift217.cpp
66ff05820e5e42db72dbfe88775472c276f4a5f9,"SILGen: Remove SubstFormalType computation

There was a lot of rather elaborate code that didn't do
anything at all.",lib/SILGen/SILGenApply.cpp,-,assert(origParamType->getRValueInstanceType()->isTypeParameter());,250,download/apple_swift217.cpp
66ff05820e5e42db72dbfe88775472c276f4a5f9,"SILGen: Remove SubstFormalType computation

There was a lot of rather elaborate code that didn't do
anything at all.",lib/SILGen/SILGenApply.cpp,-,assert(selfType->getRValueInstanceType()->is<ArchetypeType>());,250,download/apple_swift217.cpp
66ff05820e5e42db72dbfe88775472c276f4a5f9,"SILGen: Remove SubstFormalType computation

There was a lot of rather elaborate code that didn't do
anything at all.",lib/SILGen/SILGenApply.cpp,-,assert(!HasSubstitutions);,368,download/apple_swift217.cpp
66ff05820e5e42db72dbfe88775472c276f4a5f9,"SILGen: Remove SubstFormalType computation

There was a lot of rather elaborate code that didn't do
anything at all.",lib/SILGen/SILGenApply.cpp,+,assert(Substitutions.empty());,368,download/apple_swift217.cpp
66ff05820e5e42db72dbfe88775472c276f4a5f9,"SILGen: Remove SubstFormalType computation

There was a lot of rather elaborate code that didn't do
anything at all.",lib/SILGen/SILGenApply.cpp,-,"assert(fnType && ""found no call sites?"");",821,download/apple_swift217.cpp
4e5b49a1c3b2d63682b42a854b988d1ad76bc433,"Merge pull request #7917 from slavapestov/sil-combiner-cleanup

SILCombiner: Clean up the concrete -> existential peephole a bit",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,+,assert(origTy->isEqual(OpenedArchetype));,713,download/apple_swift218.cpp
4e5b49a1c3b2d63682b42a854b988d1ad76bc433,"Merge pull request #7917 from slavapestov/sil-combiner-cleanup

SILCombiner: Clean up the concrete -> existential peephole a bit",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,+,assert(FnTy->isPolymorphic());,741,download/apple_swift218.cpp
4e5b49a1c3b2d63682b42a854b988d1ad76bc433,"Merge pull request #7917 from slavapestov/sil-combiner-cleanup

SILCombiner: Clean up the concrete -> existential peephole a bit",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,-,"TAI->getNormalBB(), TAI->getErrorBB());",754,download/apple_swift218.cpp
4e5b49a1c3b2d63682b42a854b988d1ad76bc433,"Merge pull request #7917 from slavapestov/sil-combiner-cleanup

SILCombiner: Clean up the concrete -> existential peephole a bit",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,+,"TAI->getNormalBB(), TAI->getErrorBB());",756,download/apple_swift218.cpp
44f2397c362c0141ba9acb61c579d3dcea069157,"SILCombiner: Clean up the concrete -> existential peephole a bit

Use Substitution::subst() to replace the opened existential with
the concrete type. I don't have a test case, but I think the old
code would have failed if a non-Self substitution also contained
the opened existential, which could happen after generic inlining.

Also, it looks like the guard against devirtualizing methods returning
Self is no longer necessary, because the devirtualizer can insert the
necessary casts. In any case, the check was incorrect because we now
allow calling methods on existentials that return Self as part of
another type in covariant position, such as Optional<Self> or
`() -> Self`.",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,+,assert(origTy->isEqual(OpenedArchetype));,713,download/apple_swift219.cpp
44f2397c362c0141ba9acb61c579d3dcea069157,"SILCombiner: Clean up the concrete -> existential peephole a bit

Use Substitution::subst() to replace the opened existential with
the concrete type. I don't have a test case, but I think the old
code would have failed if a non-Self substitution also contained
the opened existential, which could happen after generic inlining.

Also, it looks like the guard against devirtualizing methods returning
Self is no longer necessary, because the devirtualizer can insert the
necessary casts. In any case, the check was incorrect because we now
allow calling methods on existentials that return Self as part of
another type in covariant position, such as Optional<Self> or
`() -> Self`.",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,+,assert(FnTy->isPolymorphic());,741,download/apple_swift219.cpp
44f2397c362c0141ba9acb61c579d3dcea069157,"SILCombiner: Clean up the concrete -> existential peephole a bit

Use Substitution::subst() to replace the opened existential with
the concrete type. I don't have a test case, but I think the old
code would have failed if a non-Self substitution also contained
the opened existential, which could happen after generic inlining.

Also, it looks like the guard against devirtualizing methods returning
Self is no longer necessary, because the devirtualizer can insert the
necessary casts. In any case, the check was incorrect because we now
allow calling methods on existentials that return Self as part of
another type in covariant position, such as Optional<Self> or
`() -> Self`.",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,-,"TAI->getNormalBB(), TAI->getErrorBB());",754,download/apple_swift219.cpp
44f2397c362c0141ba9acb61c579d3dcea069157,"SILCombiner: Clean up the concrete -> existential peephole a bit

Use Substitution::subst() to replace the opened existential with
the concrete type. I don't have a test case, but I think the old
code would have failed if a non-Self substitution also contained
the opened existential, which could happen after generic inlining.

Also, it looks like the guard against devirtualizing methods returning
Self is no longer necessary, because the devirtualizer can insert the
necessary casts. In any case, the check was incorrect because we now
allow calling methods on existentials that return Self as part of
another type in covariant position, such as Optional<Self> or
`() -> Self`.",lib/SILOptimizer/SILCombiner/SILCombinerApplyVisitors.cpp,+,"TAI->getNormalBB(), TAI->getErrorBB());",756,download/apple_swift219.cpp
50fb3b600241218f25e240b22e602d080c376a5f,"Merge pull request #7915 from slavapestov/debug-info-generics-inlining-fix

DebugInfo generics inlining fix",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,-,"F->getEffectsKind(), nullptr, F->getDebugScope());",494,download/apple_swift220.cpp
50fb3b600241218f25e240b22e602d080c376a5f,"Merge pull request #7915 from slavapestov/debug-info-generics-inlining-fix

DebugInfo generics inlining fix",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,F->getDebugScope());,498,download/apple_swift220.cpp
97fce6cb791ffb9f3e7da8dbadc65450f1a2531c,SILOptimizer: Always create SILFunctions with a generic environment,lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,-,"F->getEffectsKind(), nullptr, F->getDebugScope());",494,download/apple_swift221.cpp
97fce6cb791ffb9f3e7da8dbadc65450f1a2531c,SILOptimizer: Always create SILFunctions with a generic environment,lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,F->getDebugScope());,498,download/apple_swift221.cpp
254745d9ad4c5d4d9795104ddcb776c4a45e29ba,Merge pull request #7904 from eeckstein/demangler-speedup,lib/Basic/Demangler.cpp,+,assert(StartingAt <= NumChildren);,314,download/apple_swift222.cpp
254745d9ad4c5d4d9795104ddcb776c4a45e29ba,Merge pull request #7904 from eeckstein/demangler-speedup,lib/Basic/Demangler.cpp,+,assert(NumElems <= Capacity);,374,download/apple_swift222.cpp
254745d9ad4c5d4d9795104ddcb776c4a45e29ba,Merge pull request #7904 from eeckstein/demangler-speedup,lib/Basic/Demangler.cpp,+,"int Length = snprintf(Elems + NumElems, MaxIntPrintSize, ""%d"", Number);",381,download/apple_swift222.cpp
254745d9ad4c5d4d9795104ddcb776c4a45e29ba,Merge pull request #7904 from eeckstein/demangler-speedup,lib/Basic/Demangler.cpp,+,assert(Length > 0 && Length < MaxIntPrintSize);,382,download/apple_swift222.cpp
254745d9ad4c5d4d9795104ddcb776c4a45e29ba,Merge pull request #7904 from eeckstein/demangler-speedup,lib/Basic/Demangler.cpp,-,"std::move(DemanglerPrinter() << ""Builtin.Float"" << size).str());",869,download/apple_swift222.cpp
254745d9ad4c5d4d9795104ddcb776c4a45e29ba,Merge pull request #7904 from eeckstein/demangler-speedup,lib/Basic/Demangler.cpp,-,"(DemanglerPrinter() << ""Builtin.Int"" << size).str());",880,download/apple_swift222.cpp
254745d9ad4c5d4d9795104ddcb776c4a45e29ba,Merge pull request #7904 from eeckstein/demangler-speedup,lib/Basic/Demangler.cpp,-,"(DemanglerPrinter() << ""Builtin.Vec"" << elts << ""x"" <<",893,download/apple_swift222.cpp
fe5b1f16b02e309a718b3cc2ccf6eaf2898bf7e8,"Merge pull request #7901 from jckarter/no-bridging-constraints-without-bridging

Sema: Assert that bridging constraints aren't formed when ObjC interop is disabled.",lib/Sema/CSSimplify.cpp,+,assert(TC.Context.LangOpts.EnableObjCInterop,3359,download/apple_swift223.cpp
fe5b1f16b02e309a718b3cc2ccf6eaf2898bf7e8,"Merge pull request #7901 from jckarter/no-bridging-constraints-without-bridging

Sema: Assert that bridging constraints aren't formed when ObjC interop is disabled.",lib/Sema/Constraint.cpp,+,assert(kind != ConstraintKind::BridgingConversion,532,download/apple_swift224.cpp
f220a3b7277a30f16aaad5d166dea1cee5e7cf0c,"Demangler: further speed improvements.

Avoid using std::string and std::vector in the demangler. Instead use vectors/strings with storage allocated by the NodeFactory’s bump pointer allocator.
This brings another 35% speedup. Especially in the case the Demangle::Context is not reused for subsequent demanglings.",lib/Basic/Demangler.cpp,+,assert(StartingAt <= NumChildren);,314,download/apple_swift225.cpp
f220a3b7277a30f16aaad5d166dea1cee5e7cf0c,"Demangler: further speed improvements.

Avoid using std::string and std::vector in the demangler. Instead use vectors/strings with storage allocated by the NodeFactory’s bump pointer allocator.
This brings another 35% speedup. Especially in the case the Demangle::Context is not reused for subsequent demanglings.",lib/Basic/Demangler.cpp,+,assert(NumElems <= Capacity);,374,download/apple_swift225.cpp
f220a3b7277a30f16aaad5d166dea1cee5e7cf0c,"Demangler: further speed improvements.

Avoid using std::string and std::vector in the demangler. Instead use vectors/strings with storage allocated by the NodeFactory’s bump pointer allocator.
This brings another 35% speedup. Especially in the case the Demangle::Context is not reused for subsequent demanglings.",lib/Basic/Demangler.cpp,+,"int Length = snprintf(Elems + NumElems, MaxIntPrintSize, ""%d"", Number);",381,download/apple_swift225.cpp
f220a3b7277a30f16aaad5d166dea1cee5e7cf0c,"Demangler: further speed improvements.

Avoid using std::string and std::vector in the demangler. Instead use vectors/strings with storage allocated by the NodeFactory’s bump pointer allocator.
This brings another 35% speedup. Especially in the case the Demangle::Context is not reused for subsequent demanglings.",lib/Basic/Demangler.cpp,+,assert(Length > 0 && Length < MaxIntPrintSize);,382,download/apple_swift225.cpp
f220a3b7277a30f16aaad5d166dea1cee5e7cf0c,"Demangler: further speed improvements.

Avoid using std::string and std::vector in the demangler. Instead use vectors/strings with storage allocated by the NodeFactory’s bump pointer allocator.
This brings another 35% speedup. Especially in the case the Demangle::Context is not reused for subsequent demanglings.",lib/Basic/Demangler.cpp,-,"std::move(DemanglerPrinter() << ""Builtin.Float"" << size).str());",869,download/apple_swift225.cpp
f220a3b7277a30f16aaad5d166dea1cee5e7cf0c,"Demangler: further speed improvements.

Avoid using std::string and std::vector in the demangler. Instead use vectors/strings with storage allocated by the NodeFactory’s bump pointer allocator.
This brings another 35% speedup. Especially in the case the Demangle::Context is not reused for subsequent demanglings.",lib/Basic/Demangler.cpp,-,"(DemanglerPrinter() << ""Builtin.Int"" << size).str());",880,download/apple_swift225.cpp
f220a3b7277a30f16aaad5d166dea1cee5e7cf0c,"Demangler: further speed improvements.

Avoid using std::string and std::vector in the demangler. Instead use vectors/strings with storage allocated by the NodeFactory’s bump pointer allocator.
This brings another 35% speedup. Especially in the case the Demangle::Context is not reused for subsequent demanglings.",lib/Basic/Demangler.cpp,-,"(DemanglerPrinter() << ""Builtin.Vec"" << elts << ""x"" <<",893,download/apple_swift225.cpp
3456d049253a80bcc5f241196d89a4166a4b5d9c,"""-swift-version 3"" means Swift 3.1, not 3.0. (#7883)

Put in a general mechanism for mapping user-specified ""compatibility
versions"" to proper ""effective versions"" (what #if and @available
checking should respect). This may still be different from the
intrinsic ""language version""; right now master is considered a ""3.1""
compiler with a ""Swift 4 mode"", and we plan to ship a ""4.0"" compiler
with a ""Swift 3 mode"" that will have a version number of something
like ""3.2"".

rdar://problem/29884401 / SR-3791",lib/Basic/Version.cpp,-,assert(currentVersion.hasValue() &&,254,download/apple_swift226.cpp
3456d049253a80bcc5f241196d89a4166a4b5d9c,"""-swift-version 3"" means Swift 3.1, not 3.0. (#7883)

Put in a general mechanism for mapping user-specified ""compatibility
versions"" to proper ""effective versions"" (what #if and @available
checking should respect). This may still be different from the
intrinsic ""language version""; right now master is considered a ""3.1""
compiler with a ""Swift 4 mode"", and we plan to ship a ""4.0"" compiler
with a ""Swift 3 mode"" that will have a version number of something
like ""3.2"".

rdar://problem/29884401 / SR-3791",lib/Basic/Version.cpp,-,assert(v.hasValue());,305,download/apple_swift226.cpp
3456d049253a80bcc5f241196d89a4166a4b5d9c,"""-swift-version 3"" means Swift 3.1, not 3.0. (#7883)

Put in a general mechanism for mapping user-specified ""compatibility
versions"" to proper ""effective versions"" (what #if and @available
checking should respect). This may still be different from the
intrinsic ""language version""; right now master is considered a ""3.1""
compiler with a ""Swift 4 mode"", and we plan to ship a ""4.0"" compiler
with a ""Swift 3 mode"" that will have a version number of something
like ""3.2"".

rdar://problem/29884401 / SR-3791",lib/Basic/Version.cpp,+,"static_assert(SWIFT_VERSION_MAJOR == 3,",332,download/apple_swift226.cpp
f662ed86b3cf7db5ec5906372385b01d76b2d0d5,Sema: Assert that bridging constraints aren't formed when ObjC interop is disabled.,lib/Sema/CSSimplify.cpp,+,assert(TC.Context.LangOpts.EnableObjCInterop,3359,download/apple_swift227.cpp
f662ed86b3cf7db5ec5906372385b01d76b2d0d5,Sema: Assert that bridging constraints aren't formed when ObjC interop is disabled.,lib/Sema/Constraint.cpp,+,assert(kind != ConstraintKind::BridgingConversion,532,download/apple_swift228.cpp
8ec3bd3c0a30c0c926b2f87696c48e58746185fd,"[FixCode] When fixing missing enum elements in a switch statement, print associated payloads as well. (#7899)",lib/Sema/TypeCheckStmt.cpp,+,"printPayloads(EE, OS);",311,download/apple_swift229.cpp
ebac07074f4125e728b782271a0a9ccd31889c5e,"Merge pull request #7894 from DougGregor/fix-wacky-indentation

Fix wacky indentation",lib/AST/ProtocolConformance.cpp,-,assert((!isComplete() || isInvalid(),466,download/apple_swift230.cpp
ebac07074f4125e728b782271a0a9ccd31889c5e,"Merge pull request #7894 from DougGregor/fix-wacky-indentation

Fix wacky indentation",lib/AST/ProtocolConformance.cpp,+,assert((!isComplete() || isInvalid() ||,469,download/apple_swift230.cpp
6668d14d5234e50e22a6cc59ca76a495288ad18f,Fix wacky indentation. NFC,lib/AST/ProtocolConformance.cpp,-,assert((!isComplete() || isInvalid(),466,download/apple_swift231.cpp
6668d14d5234e50e22a6cc59ca76a495288ad18f,Fix wacky indentation. NFC,lib/AST/ProtocolConformance.cpp,+,assert((!isComplete() || isInvalid() ||,469,download/apple_swift231.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()",69,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()",73,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,DEBUG(llvm::dbgs() <<,118,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,DEBUG(for (auto Sub : ParamSubs) {,119,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Partial specialization is not supported.\n"");",123,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(for (auto Sub : ParamSubs) { Sub.dump(); });,124,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(llvm::dbgs(),123,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,assert(RI.isFormalIndirect());,144,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Partial specialization is not supported if """,194,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(for (auto Sub : ParamSubs) {,196,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""\n\nPartially specialized types for function: """,229,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(CalleeFnTy->isPolymorphic());,244,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,247,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,249,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!SpecializedSubstFnTy->isPolymorphic() &&,255,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!SpecializedSubstFnTy->hasTypeParameter() &&,257,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(SpecializedSubstFnTy == SpecializedCalleeSubstFnTy &&,279,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""The new specialized type is the same as """,287,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""Specializing the call:\n"";",299,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(FnTy);,391,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,"FnTy->getOptionalErrorResult(), M.getASTContext());",397,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"FnTy->getParameters(), FnTy->getResults(), FnTy->getOptionalErrorResult(),",398,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()",522,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!Sub.getReplacement()->hasError() &&,579,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,875,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,877,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,-,"Arguments, ResultBB, TAI->getErrorBB());",911,download/apple_swift232.cpp
8e439da07d1e91aeaafc33c137cca5d81461d4a9,"Merge pull request #7888 from swiftix/wip-partial-specialization-v77

Implement partial specialization behind a flag.",lib/SILOptimizer/Utils/Generics.cpp,+,"ResultBB, TAI->getErrorBB());",912,download/apple_swift232.cpp
5cef3fead99c6ee37773cc54d3365f8213db9836,Merge pull request #7886 from DougGregor/sr-3917,lib/AST/ProtocolConformance.cpp,-,"assert((!isComplete() || isInvalid()) && ""Conformance already complete?"");",466,download/apple_swift233.cpp
5cef3fead99c6ee37773cc54d3365f8213db9836,Merge pull request #7886 from DougGregor/sr-3917,lib/AST/ProtocolConformance.cpp,+,assert((!isComplete() || isInvalid(),466,download/apple_swift233.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()",69,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << Callee->getName()",73,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,DEBUG(llvm::dbgs() <<,118,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,DEBUG(for (auto Sub : ParamSubs) {,119,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Partial specialization is not supported.\n"");",123,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(for (auto Sub : ParamSubs) { Sub.dump(); });,124,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(llvm::dbgs(),123,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,assert(RI.isFormalIndirect());,144,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""    Partial specialization is not supported if """,194,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,DEBUG(for (auto Sub : ParamSubs) {,196,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""\n\nPartially specialized types for function: """,229,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(CalleeFnTy->isPolymorphic());,244,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,247,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,249,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!SpecializedSubstFnTy->isPolymorphic() &&,255,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!SpecializedSubstFnTy->hasTypeParameter() &&,257,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(SpecializedSubstFnTy == SpecializedCalleeSubstFnTy &&,279,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""The new specialized type is the same as """,287,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"DEBUG(llvm::dbgs() << ""Specializing the call:\n"";",299,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(FnTy);,391,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,"FnTy->getOptionalErrorResult(), M.getASTContext());",397,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"FnTy->getParameters(), FnTy->getResults(), FnTy->getOptionalErrorResult(),",398,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,"DEBUG(llvm::dbgs() << ""    Cannot specialize function "" << OrigF->getName()",522,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!Sub.getReplacement()->hasError() &&,579,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->isPolymorphic() &&,875,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,assert(!CalleeSubstFnTy->hasTypeParameter() &&,877,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,-,"Arguments, ResultBB, TAI->getErrorBB());",911,download/apple_swift234.cpp
a9db867e8da2b5085518067ed0765cb3b4100919,"Implement partial specialization behind a flag.

Partial specialization is disabled by default. Use -sil-partial-specialization to enable it.

Use -sil-partial-specialization-with-generic-substitutions to enable the partial specialization even in cases of substitutions containing generic replacement types.",lib/SILOptimizer/Utils/Generics.cpp,+,"ResultBB, TAI->getErrorBB());",912,download/apple_swift234.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/AST/GenericEnvironment.cpp,+,assert(reqts.size() == sub.getConformances().size());,424,download/apple_swift235.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/AST/GenericEnvironment.cpp,-,assert(contextTy->hasError());,430,download/apple_swift235.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/AST/GenericEnvironment.cpp,+,assert(contextTy->hasError());,431,download/apple_swift235.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/AST/GenericSignature.cpp,-,assert(getGenericParams().empty() || areAllParamsConcrete());,394,download/apple_swift236.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/AST/GenericSignature.cpp,+,assert(reqts.size() == sub.getConformances().size());,406,download/apple_swift236.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/SIL/Mangle.cpp,-,"assert(idx == Subs.size() && ""subs not parallel to dependent types"");",82,download/apple_swift237.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"assert(SubIt != SubEnd && ""Not enough substitutions."");",344,download/apple_swift238.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,assert(!Replacement->hasTypeParameter());,350,download/apple_swift238.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/SILOptimizer/IPO/EagerSpecializer.cpp,+,assert(!Replacement->hasTypeParameter());,371,download/apple_swift238.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"assert(SubIt == SubEnd && ""Too many substitutions."");",392,download/apple_swift238.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"GenericFunc->mapTypeIntoContext(t).print(dbgs()); },",705,download/apple_swift238.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/SILOptimizer/Utils/SpecializationMangler.cpp,-,"assert(idx == Subs.size() && ""subs not parallel to dependent types"");",80,download/apple_swift239.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/Serialization/Serialization.cpp,-,assert(sig->getAllDependentTypes().size(),3294,download/apple_swift240.cpp
f0300be51fc03d14c936b5f45af8a967e3c53a1b,"Merge pull request #7884 from slavapestov/remove-get-all-dependent-types

AST: Remove GenericSignature::getAllDependentTypes()",lib/Serialization/Serialization.cpp,+,assert(sig->getSubstitutionListSize(),3294,download/apple_swift240.cpp
3246b728bdf70fb71e404b059d8fbde66bc14618,"[SR-3917] Allow missing witnesses for optional and unavailable requirements.

This is a bit of a hack to dodge an assertion. In essence, it's a
harmless hack, but we'd like to make the handling of optional and
unavailable requirements more rigorous.",lib/AST/ProtocolConformance.cpp,-,"assert((!isComplete() || isInvalid()) && ""Conformance already complete?"");",369,download/apple_swift241.cpp
3246b728bdf70fb71e404b059d8fbde66bc14618,"[SR-3917] Allow missing witnesses for optional and unavailable requirements.

This is a bit of a hack to dodge an assertion. In essence, it's a
harmless hack, but we'd like to make the handling of optional and
unavailable requirements more rigorous.",lib/AST/ProtocolConformance.cpp,+,assert((!isComplete() || isInvalid(),369,download/apple_swift241.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/AST/GenericEnvironment.cpp,+,assert(reqts.size() == sub.getConformances().size());,424,download/apple_swift242.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/AST/GenericEnvironment.cpp,-,assert(contextTy->hasError());,430,download/apple_swift242.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/AST/GenericEnvironment.cpp,+,assert(contextTy->hasError());,431,download/apple_swift242.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/AST/GenericSignature.cpp,-,assert(getGenericParams().empty() || areAllParamsConcrete());,394,download/apple_swift243.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/AST/GenericSignature.cpp,+,assert(reqts.size() == sub.getConformances().size());,406,download/apple_swift243.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/SIL/Mangle.cpp,-,"assert(idx == Subs.size() && ""subs not parallel to dependent types"");",82,download/apple_swift244.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"assert(SubIt != SubEnd && ""Not enough substitutions."");",344,download/apple_swift245.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,assert(!Replacement->hasTypeParameter());,350,download/apple_swift245.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/SILOptimizer/IPO/EagerSpecializer.cpp,+,assert(!Replacement->hasTypeParameter());,371,download/apple_swift245.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"assert(SubIt == SubEnd && ""Too many substitutions."");",392,download/apple_swift245.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/SILOptimizer/IPO/EagerSpecializer.cpp,-,"GenericFunc->mapTypeIntoContext(t).print(dbgs()); },",705,download/apple_swift245.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/SILOptimizer/Utils/SpecializationMangler.cpp,-,"assert(idx == Subs.size() && ""subs not parallel to dependent types"");",80,download/apple_swift246.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/Serialization/Serialization.cpp,-,assert(sig->getAllDependentTypes().size(),3294,download/apple_swift247.cpp
0f4a7d246f1e0174f457a58630010890c1b97642,"AST: Remove GenericSignature::getAllDependentTypes()

This was a remnant of the old generics implementation, where
all nested types were expanded into an AllArchetypes list.

For quite some time, this method no longer returned *all*
dependent types, only those with generic requirements on
them, and all if its remaining uses were a bit convoluted.

- In the generic specialization code, we used this to mangle
  substitutions for generic parameters that are not subject
  to a concrete same-type constraint.

  A new GenericSignature::getSubstitutableParams()
  function handles this use-case instead. It is similar
  to getGenericParams(), but only returns generic parameters
  which require substitution.

  In the future, SubstitutionLists will only store replacement
  types for these generic parameters, instead of the list of
  types that we used to produce from getAllDependentTypes().

- In specialization mangling and speculative devirtualization,
  we relied on SubstitutionLists having the same size and
  order as getAllDependentTypes(). It's better to turn the
  SubstitutionList into a SubstitutionMap instead, and do lookups
  into the map.

- In the SIL parser, we were making a pass over the generic
  requirements before looking at getAllDependentTypes();
  enumeratePairedRequirements() gives the correct information
  upfront.

- In SIL box serialization, we don't serialize the size of the
  substitution list, since it's available from the generic
  signature. Add a GenericSignature::getSubstitutionListSize()
  method, but that will go away soon once SubstitionList
  serialization only serializes replacement types for generic
  parameters.

- A few remaining uses now call enumeratePairedRequirements()
  directly.",lib/Serialization/Serialization.cpp,+,assert(sig->getSubstitutionListSize(),3294,download/apple_swift247.cpp
3ef06881c29a191b39a3073d3b7fe204f4449885,"Merge pull request #7881 from eeckstein/thunk-demangling

demangler: add an API function to get the target of a thunk symbol.",lib/Basic/Demangler.cpp,+,"assert(MangledName.startswith(""_T""));",232,download/apple_swift248.cpp
3ef06881c29a191b39a3073d3b7fe204f4449885,"Merge pull request #7881 from eeckstein/thunk-demangling

demangler: add an API function to get the target of a thunk symbol.",lib/Basic/Demangler.cpp,+,"assert(Remaining.startswith(""To"") || Remaining.startswith(""TO""));",238,download/apple_swift248.cpp
3ef06881c29a191b39a3073d3b7fe204f4449885,"Merge pull request #7881 from eeckstein/thunk-demangling

demangler: add an API function to get the target of a thunk symbol.",tools/swift-demangle/swift-demangle.cpp,+,assert(DCtx.getThunkTarget(name).empty());,149,download/apple_swift249.cpp
0724ab6585470f655f2c91195b37928e738c73e7,Merge pull request #7880 from gottesmm/destroying_destructor_fixes,lib/Parse/ParseSIL.cpp,+,"parseSILOwnership(RHSKind) || parseSILDebugLocation(InstLoc, B)) {",2184,download/apple_swift250.cpp
0724ab6585470f655f2c91195b37928e738c73e7,Merge pull request #7880 from gottesmm/destroying_destructor_fixes,lib/SILGen/SILGenDestructor.cpp,+,assert(resultSelfValue.getOwnershipKind() ==,97,download/apple_swift251.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::DeclModifier);,45,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 4);,46,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Kind == tok::kw_class ||,51,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, DeclModifierSyntax::Cursor::LeftParen,",59,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, DeclModifierSyntax::Cursor::Argument,",61,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, DeclModifierSyntax::Cursor::RightParen,",63,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(NewName->getTokenKind() == tok::identifier);,97,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",107,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(NewArgument->getTokenKind() == tok::identifier);,118,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",128,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 8);,473,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionParameterSyntax::Cursor::ExternalName,",474,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionParameterSyntax::Cursor::LocalName,",476,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionParameterSyntax::Cursor::Colon,",478,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionParameterSyntax::Cursor::Type)->isType());,480,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionParameterSyntax::Cursor::Ellipsis,",481,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",483,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(,486,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",488,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(NewExternalName->getTokenKind() == tok::identifier);,528,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(NewLocalName->getTokenKind() == tok::identifier);,539,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewColonToken, tok::colon, "":"");",550,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(NewEqualToken->getTokenKind() == tok::equal);,593,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewTrailingComma, tok::comma, "","");",637,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 7);,649,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",650,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionSignatureSyntax::Cursor::ParameterList)->Kind ==,654,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",657,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(cast<TokenSyntax>(ThrowsRethrows)->getTokenKind() == tok::kw_throws ||,663,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionSignatureSyntax::Cursor::Arrow,",666,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw,",668,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionSignatureSyntax::Cursor::ReturnType)->isType());,671,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",707,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",741,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewThrowsToken, tok::kw_throws, ""throws"");",756,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRethrowsToken, tok::kw_rethrows, ""rethrows"");",772,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewArrowToken, tok::arrow, ""->"");",783,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::FunctionDecl);,841,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 8);,842,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Attributes,",843,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Modifiers,",845,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionDeclSyntax::Cursor::FuncKeyword,",847,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionDeclSyntax::Cursor::Identifier,",849,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw,",851,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Signature,",854,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::GenericWhereClause,",856,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Body,",858,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewFuncKeyword, tok::kw_func, ""func"");",936,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/DeclSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,948,download/apple_swift252.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/ExprSyntax.cpp,-,assert(Child->Kind == SyntaxKind::FunctionCallArgument);,313,download/apple_swift253.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/ExprSyntax.cpp,-,assert(Index <= getRaw()->Layout.size());,352,download/apple_swift253.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/GenericSyntax.cpp,-,assert(Raw->Kind == SyntaxKind::GenericRequirementList);,235,download/apple_swift254.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(NewWhereKeyword, tok::kw_where, ""where"");",270,download/apple_swift254.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",lib/Syntax/StmtSyntax.cpp,-,assert(Raw->Kind == SyntaxKind::StmtList);,391,download/apple_swift255.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankDeclModifier().print(OS);,28,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",29,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedDeclModifier().print(OS);,34,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""private(set)"");",35,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Private, Mod.getName());",46,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(LParen, Mod.getLeftParenToken());",47,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Set, Mod.getArgument());",48,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(RParen, Mod.getRightParenToken());",49,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,65,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""private(set)"");",66,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedFunctionParameter().print(OS);,225,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""with radius: Int = -1, "");",226,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionParameter().print(OS);,231,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",232,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(ExternalName, Param.getExternalName());",255,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(LocalName, Param.getLocalName());",256,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Colon, Param.getColonToken());",257,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenType.hasSameIdentityAs(GottenType2));,261,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Equal, Param.getEqualToken());",263,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenDefaultValue.hasSameIdentityAs(GottenDefaultValue2));,267,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Comma, Param.getTrailingComma());",269,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_FALSE(Decimated.getTypeSyntax().hasValue());,276,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_FALSE(Decimated.getDefaultValue().hasValue());,277,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,306,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""for integer : Int = 1,"");",307,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,315,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""with radius: = , "");",316,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionParameterList().print(OS);,326,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",327,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeFunctionParameterList(Params).print(OS);,334,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",335,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionSignature().print(OS);,364,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",365,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedFunctionSignature().print(OS);,370,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",371,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(LParen, Sig.getLeftParenToken());",395,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenList1.hasSameIdentityAs(GottenList2));,402,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,GottenList1.print(OS);,403,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",404,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(RParen, Sig.getRightParenToken());",410,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Throws, Sig.getThrowsToken());",411,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(Sig.getRethrowsToken()->isMissing());,412,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Arrow, Sig.getArrowToken());",413,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenAttrs1.hasSameIdentityAs(GottenAttrs2));,420,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",421,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenReturnType1.hasSameIdentityAs(GottenReturnType2));,429,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,GottenReturnType1.print(OS);,430,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""Int"");",431,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,459,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",460,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionDecl().print(OS);,559,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",560,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedFunctionDecl().print(OS);,565,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",566,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionDecl().print(OS);,582,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",583,download/apple_swift256.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/ExprSyntaxTests.cpp,-,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",268,download/apple_swift257.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.size(), size_t(3));",268,download/apple_swift257.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/ExprSyntaxTests.cpp,-,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",327,download/apple_swift257.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.size(), size_t(3));",327,download/apple_swift257.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/ExprSyntaxTests.cpp,-,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",336,download/apple_swift257.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.size(), size_t(3));",336,download/apple_swift257.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/ExprSyntaxTests.cpp,-,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",338,download/apple_swift257.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.size(), size_t(3));",338,download/apple_swift257.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Empty.empty());,25,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());,26,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(Empty.size(), size_t(0));",31,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(Empty.appending(getCannedArgument()).size(), size_t(1));",32,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_DEATH({ Empty[0]; }, """");",38,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,Arg.print(OS);,44,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,List[0].print(GottenOS);,50,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), GottenOS.str().str());",52,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg1.hasSameIdentityAs(GottenArg2));,56,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(List.size(), size_t(3));",67,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,71,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, x: foo, x: foo"");",73,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg0_1.hasSameIdentityAs(GottenArg0_2));,77,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg1_1.hasSameIdentityAs(GottenArg1_2));,81,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg2_1.hasSameIdentityAs(GottenArg2_2));,85,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_DEATH({,89,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,101,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, x: foo, "");",102,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(List.size(), size_t(3));",114,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,118,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, schwifty: foo, x: foo"");",120,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg0_1.hasSameIdentityAs(GottenArg0_2));,124,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg1_1.hasSameIdentityAs(GottenArg1_2));,128,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg2_1.hasSameIdentityAs(GottenArg2_2));,132,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_DEATH({,136,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,149,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, x: foo"");",150,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_DEATH({,157,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(InsertedOS);,169,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(PrependedOS);,177,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(InsertedOS.str().str(), PrependedOS.str().str());",178,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(InsertedOS);,188,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(AppendedOS);,196,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(InsertedOS.str().str(), AppendedOS.str().str());",197,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(OS);,209,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, schwifty: foo, x: foo, "");",210,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,224,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",225,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(List.empty());,226,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(List.size(), size_t(0));",227,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,Element.print(IteratedOS);,244,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(IteratedOS.str().str(), ""x: foo, x: foo, x: foo, "");",246,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Element0.hasSameIdentityAs(IteratedElement0));,252,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Element1.hasSameIdentityAs(IteratedElement1));,253,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Element2.hasSameIdentityAs(IteratedElement2));,254,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,258,download/apple_swift258.cpp
4e3f294a02d12fbff7b351d2ee75d2f36c384ec3,"Merge pull request #7878 from bitjammer/sr-4067-function-declaration-syntax

Sr 4067 function declaration syntax",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), IteratedOS.str().str());",259,download/apple_swift258.cpp
a41312288d1e1713190d358a28bb0157ecc43e16,"demangler: add an API function to get the target of a thunk symbol.

rdar://problem/30820093",lib/Basic/Demangler.cpp,+,"assert(MangledName.startswith(""_T""));",232,download/apple_swift259.cpp
a41312288d1e1713190d358a28bb0157ecc43e16,"demangler: add an API function to get the target of a thunk symbol.

rdar://problem/30820093",lib/Basic/Demangler.cpp,+,"assert(Remaining.startswith(""To"") || Remaining.startswith(""TO""));",238,download/apple_swift259.cpp
a41312288d1e1713190d358a28bb0157ecc43e16,"demangler: add an API function to get the target of a thunk symbol.

rdar://problem/30820093",tools/swift-demangle/swift-demangle.cpp,+,assert(DCtx.getThunkTarget(name).empty());,149,download/apple_swift260.cpp
cfb5893663e33df5fc3f91dcf93202bc9d0c74d8,"[silgen] Fix destroying destructor to use proper ownership with its @owned return value.

rdar://29791263",lib/Parse/ParseSIL.cpp,+,"parseSILOwnership(RHSKind) || parseSILDebugLocation(InstLoc, B)) {",2184,download/apple_swift261.cpp
cfb5893663e33df5fc3f91dcf93202bc9d0c74d8,"[silgen] Fix destroying destructor to use proper ownership with its @owned return value.

rdar://29791263",lib/SILGen/SILGenDestructor.cpp,+,assert(resultSelfValue.getOwnershipKind() ==,97,download/apple_swift262.cpp
bb4253e3d3c2ceeb5678a473f056ec9f62d40197,"Convert generic-requirement-list to SyntaxCollection, implement function-declaration

This mostly wraps up the first cut of function-declaration.

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,-,"syntax_assert_child_token(Raw, DeclModifierSyntax::Cursor::Name,",47,download/apple_swift263.cpp
bb4253e3d3c2ceeb5678a473f056ec9f62d40197,"Convert generic-requirement-list to SyntaxCollection, implement function-declaration

This mostly wraps up the first cut of function-declaration.

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,assert(Kind == tok::kw_class ||,52,download/apple_swift263.cpp
bb4253e3d3c2ceeb5678a473f056ec9f62d40197,"Convert generic-requirement-list to SyntaxCollection, implement function-declaration

This mostly wraps up the first cut of function-declaration.

https://bugs.swift.org/browse/SR-4043",lib/Syntax/GenericSyntax.cpp,-,assert(Raw->Kind == SyntaxKind::GenericRequirementList);,235,download/apple_swift264.cpp
bb4253e3d3c2ceeb5678a473f056ec9f62d40197,"Convert generic-requirement-list to SyntaxCollection, implement function-declaration

This mostly wraps up the first cut of function-declaration.

https://bugs.swift.org/browse/SR-4043",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(NewWhereKeyword, tok::kw_where, ""where"");",270,download/apple_swift264.cpp
ceb3babbc646d604582aa0de6985e2dfb3f3b241,[Syntax] Short diversion converting StmtListSyntax to a SyntaxCollection,lib/Syntax/StmtSyntax.cpp,-,assert(Raw->Kind == SyntaxKind::StmtList);,391,download/apple_swift265.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::FunctionDecl);,831,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 8);,832,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Attributes,",833,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Modifiers,",835,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionDeclSyntax::Cursor::FuncKeyword,",837,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionDeclSyntax::Cursor::Identifier,",839,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw,",841,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Signature,",844,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::GenericWhereClause,",846,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionDeclSyntax::Cursor::Body,",848,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewFuncKeyword, tok::kw_func, ""func"");",926,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,938,download/apple_swift266.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionDecl().print(OS);,544,download/apple_swift267.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",545,download/apple_swift267.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedFunctionDecl().print(OS);,550,download/apple_swift267.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",551,download/apple_swift267.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionDecl().print(OS);,562,download/apple_swift267.cpp
f900fbdceab767437ad5efd9b7471cbf9515542b,"Implement function-declaration in lib/Syntax

https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",563,download/apple_swift267.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::DeclModifier);,42,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 4);,43,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, DeclModifierSyntax::Cursor::Name,",44,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, DeclModifierSyntax::Cursor::LeftParen,",46,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, DeclModifierSyntax::Cursor::Argument,",48,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, DeclModifierSyntax::Cursor::RightParen,",50,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,assert(NewName->getTokenKind() == tok::identifier);,84,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",94,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,assert(NewArgument->getTokenKind() == tok::identifier);,105,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",115,download/apple_swift268.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankDeclModifier().print(OS);,27,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",28,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedDeclModifier().print(OS);,33,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""private(set)"");",34,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Private, Mod.getName());",45,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(LParen, Mod.getLeftParenToken());",46,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Set, Mod.getArgument());",47,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(RParen, Mod.getRightParenToken());",48,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,64,download/apple_swift269.cpp
18ee4e19a16ab7e0d23f511ed87c331c1283c667,"Implement declaration-modifier(s) in lib/Syntax

- declaration-modifier
  - DeclModifierSyntax
- declaration-modifiers
  - DeclModifierListSyntax

https://bugs.swift.org/browse/SR-4146",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""private(set)"");",65,download/apple_swift269.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 7);,551,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",552,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionSignatureSyntax::Cursor::ParameterList)->Kind ==,556,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",559,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,assert(cast<TokenSyntax>(ThrowsRethrows)->getTokenKind() == tok::kw_throws ||,565,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionSignatureSyntax::Cursor::Arrow,",568,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw,",570,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionSignatureSyntax::Cursor::ReturnType)->isType());,573,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",609,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",643,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewThrowsToken, tok::kw_throws, ""throws"");",658,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewRethrowsToken, tok::kw_rethrows, ""rethrows"");",674,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewArrowToken, tok::arrow, ""->"");",685,download/apple_swift270.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionSignature().print(OS);,310,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",311,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedFunctionSignature().print(OS);,316,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",317,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(LParen, Sig.getLeftParenToken());",341,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenList1.hasSameIdentityAs(GottenList2));,348,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,GottenList1.print(OS);,349,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",350,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(RParen, Sig.getRightParenToken());",356,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Throws, Sig.getThrowsToken());",357,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(Sig.getRethrowsToken()->isMissing());,358,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Arrow, Sig.getArrowToken());",359,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenAttrs1.hasSameIdentityAs(GottenAttrs2));,366,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",367,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenReturnType1.hasSameIdentityAs(GottenReturnType2));,375,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,GottenReturnType1.print(OS);,376,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""Int"");",377,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,406,download/apple_swift271.cpp
288da665e324baa69e41d39fdf60e3097b79405c,"Implement function-signature in lib/Syntax

Part of:
https://bugs.swift.org/browse/SR-4043",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",407,download/apple_swift271.cpp
e70a65882fb86d937693ee53bbfbb381b17c544b,"[Syntax] function-parameter-list is now a SyntaxCollection

Removes some code duplication.",unittests/Syntax/DeclSyntaxTests.cpp,-,"ASSERT_EQ(OS.str().str(), ""with radius: Int = -1,"");",171,download/apple_swift272.cpp
e70a65882fb86d937693ee53bbfbb381b17c544b,"[Syntax] function-parameter-list is now a SyntaxCollection

Removes some code duplication.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""with radius: Int = -1, "");",171,download/apple_swift272.cpp
e70a65882fb86d937693ee53bbfbb381b17c544b,"[Syntax] function-parameter-list is now a SyntaxCollection

Removes some code duplication.",unittests/Syntax/DeclSyntaxTests.cpp,-,"ASSERT_EQ(OS.str().str(), ""with radius: = ,"");",261,download/apple_swift272.cpp
e70a65882fb86d937693ee53bbfbb381b17c544b,"[Syntax] function-parameter-list is now a SyntaxCollection

Removes some code duplication.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""with radius: = , "");",261,download/apple_swift272.cpp
e70a65882fb86d937693ee53bbfbb381b17c544b,"[Syntax] function-parameter-list is now a SyntaxCollection

Removes some code duplication.",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionParameterList().print(OS);,280,download/apple_swift272.cpp
e70a65882fb86d937693ee53bbfbb381b17c544b,"[Syntax] function-parameter-list is now a SyntaxCollection

Removes some code duplication.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",281,download/apple_swift272.cpp
e70a65882fb86d937693ee53bbfbb381b17c544b,"[Syntax] function-parameter-list is now a SyntaxCollection

Removes some code duplication.",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeFunctionParameterList(Params).print(OS);,288,download/apple_swift272.cpp
e70a65882fb86d937693ee53bbfbb381b17c544b,"[Syntax] function-parameter-list is now a SyntaxCollection

Removes some code duplication.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",289,download/apple_swift272.cpp
e565392f817524b35dbbd27e76d3d863b707c64e,[Syntax] Add convenience iterator for SyntaxCollections,unittests/Syntax/SyntaxCollectionTests.cpp,+,Element.print(IteratedOS);,244,download/apple_swift273.cpp
e565392f817524b35dbbd27e76d3d863b707c64e,[Syntax] Add convenience iterator for SyntaxCollections,unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(IteratedOS.str().str(), ""x: foo, x: foo, x: foo, "");",246,download/apple_swift273.cpp
e565392f817524b35dbbd27e76d3d863b707c64e,[Syntax] Add convenience iterator for SyntaxCollections,unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Element0.hasSameIdentityAs(IteratedElement0));,252,download/apple_swift273.cpp
e565392f817524b35dbbd27e76d3d863b707c64e,[Syntax] Add convenience iterator for SyntaxCollections,unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Element1.hasSameIdentityAs(IteratedElement1));,253,download/apple_swift273.cpp
e565392f817524b35dbbd27e76d3d863b707c64e,[Syntax] Add convenience iterator for SyntaxCollections,unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Element2.hasSameIdentityAs(IteratedElement2));,254,download/apple_swift273.cpp
e565392f817524b35dbbd27e76d3d863b707c64e,[Syntax] Add convenience iterator for SyntaxCollections,unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,258,download/apple_swift273.cpp
e565392f817524b35dbbd27e76d3d863b707c64e,[Syntax] Add convenience iterator for SyntaxCollections,unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), IteratedOS.str().str());",259,download/apple_swift273.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",lib/Syntax/ExprSyntax.cpp,-,assert(Child->Kind == SyntaxKind::FunctionCallArgument);,313,download/apple_swift274.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",lib/Syntax/ExprSyntax.cpp,-,assert(Index <= getRaw()->Layout.size());,352,download/apple_swift274.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/ExprSyntaxTests.cpp,-,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",268,download/apple_swift275.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.size(), size_t(3));",268,download/apple_swift275.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/ExprSyntaxTests.cpp,-,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",327,download/apple_swift275.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.size(), size_t(3));",327,download/apple_swift275.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/ExprSyntaxTests.cpp,-,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",336,download/apple_swift275.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.size(), size_t(3));",336,download/apple_swift275.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/ExprSyntaxTests.cpp,-,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",338,download/apple_swift275.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.size(), size_t(3));",338,download/apple_swift275.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(Empty.empty());,25,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_FALSE(Empty.appending(getCannedArgument()).empty());,26,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(Empty.size(), size_t(0));",31,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(Empty.appending(getCannedArgument()).size(), size_t(1));",32,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_DEATH({ Empty[0]; }, """");",38,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,Arg.print(OS);,44,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,List[0].print(GottenOS);,50,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), GottenOS.str().str());",52,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg1.hasSameIdentityAs(GottenArg2));,56,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(List.size(), size_t(3));",67,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,71,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, x: foo, x: foo"");",73,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg0_1.hasSameIdentityAs(GottenArg0_2));,77,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg1_1.hasSameIdentityAs(GottenArg1_2));,81,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg2_1.hasSameIdentityAs(GottenArg2_2));,85,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_DEATH({,89,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,101,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, x: foo, "");",102,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(List.size(), size_t(3));",114,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,118,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, schwifty: foo, x: foo"");",120,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg0_1.hasSameIdentityAs(GottenArg0_2));,124,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg1_1.hasSameIdentityAs(GottenArg1_2));,128,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(GottenArg2_1.hasSameIdentityAs(GottenArg2_2));,132,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_DEATH({,136,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,149,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, x: foo"");",150,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_DEATH({,157,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(InsertedOS);,169,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(PrependedOS);,177,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(InsertedOS.str().str(), PrependedOS.str().str());",178,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(InsertedOS);,188,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(AppendedOS);,196,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(InsertedOS.str().str(), AppendedOS.str().str());",197,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,.print(OS);,209,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, schwifty: foo, x: foo, "");",210,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,List.print(OS);,224,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",225,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,ASSERT_TRUE(List.empty());,226,download/apple_swift276.cpp
7ce3b810019527884a36daa638af07c4cb99131d,"Add generic Syntax collection for unbounded list of nodes

Just a little reusable collection type for things like argument lists,
statement lists, etc.",unittests/Syntax/SyntaxCollectionTests.cpp,+,"ASSERT_EQ(List.size(), size_t(0));",227,download/apple_swift276.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Layout.size() == 8);,375,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionParameterSyntax::Cursor::ExternalName,",376,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionParameterSyntax::Cursor::LocalName,",378,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionParameterSyntax::Cursor::Colon,",380,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(FunctionParameterSyntax::Cursor::Type)->isType());,382,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionParameterSyntax::Cursor::Ellipsis,",383,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",385,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->getChild(,388,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",390,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,assert(NewExternalName->getTokenKind() == tok::identifier);,434,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,assert(NewLocalName->getTokenKind() == tok::identifier);,445,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewColonToken, tok::colon, "":"");",456,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,assert(NewEqualToken->getTokenKind() == tok::equal);,499,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewTrailingComma, tok::comma, "","");",543,download/apple_swift277.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,getCannedFunctionParameter().print(OS);,170,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""with radius: Int = -1,"");",171,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionParameter().print(OS);,176,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",177,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(ExternalName, Param.getExternalName());",200,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(LocalName, Param.getLocalName());",201,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Colon, Param.getColonToken());",202,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenType.hasSameIdentityAs(GottenType2));,206,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Equal, Param.getEqualToken());",208,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_TRUE(GottenDefaultValue.hasSameIdentityAs(GottenDefaultValue2));,212,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(Comma, Param.getTrailingComma());",214,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_FALSE(Decimated.getTypeSyntax().hasValue());,221,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,ASSERT_FALSE(Decimated.getDefaultValue().hasValue());,222,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,251,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""for integer : Int = 1,"");",252,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,260,download/apple_swift278.cpp
cac51bd69b7335290d93dd87f671f34eafa35565,"Implement function-parameter-list and friends in lib/Syntax

Implements the following grammar productions:

- function-parameter-list
- function-parameter

This is mostly reusable for other flavors of function declarations,
such as initializers and whatnot, but those will have separate
top-level syntax nodes.

https://bugs.swift.org/browse/SR-4067",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""with radius: = ,"");",261,download/apple_swift278.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Inferring associated types from decl:\n"";",3070,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Considering whether "" << result.first->getName()",3093,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,-,if (result.second->hasError()),3098,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,if (result.second->hasError()) {,3098,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- has error type\n"");",3099,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- duplicate\n"");",3107,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""++ we can same-type to:\n"";",3165,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- tautological\n"");",3180,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""** contradicts explicit type witness, """,3198,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- doesn't fulfill requirements\n"");",3220,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""++ seems legit\n"");",3225,download/apple_swift279.cpp
c88064b5b6df2eba8572feead3c31f3a6de888c7,"Merge pull request #7875 from jckarter/assoc-type-inference-same-type-candidate

Sema: Accept tautological assoc type inference candidates when same-typed.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Candidates for inference:\n"";",3735,download/apple_swift279.cpp
d6cc431a8d9545fc4b9a1e83aafad490536e4887,[FixCode] Enhance existing fill-protocol-stub fixit so that all missing witnesses can fixed at once.,lib/Sema/TypeCheckProtocol.cpp,+,"printProtocolStubFixitString(SourceLoc TypeLoc, ProtocolConformance *Conf,",2434,download/apple_swift280.cpp
d6cc431a8d9545fc4b9a1e83aafad490536e4887,[FixCode] Enhance existing fill-protocol-stub fixit so that all missing witnesses can fixed at once.,lib/Sema/TypeCheckProtocol.cpp,+,"if (!printRequirementStub(VD, Conf->getDeclContext(), Conf->getType(),",2441,download/apple_swift280.cpp
d6cc431a8d9545fc4b9a1e83aafad490536e4887,[FixCode] Enhance existing fill-protocol-stub fixit so that all missing witnesses can fixed at once.,lib/Sema/TypeCheckProtocol.cpp,-,"bool AddFixit = printRequirementStub(Requirement, Adopter,",2448,download/apple_swift280.cpp
d6cc431a8d9545fc4b9a1e83aafad490536e4887,[FixCode] Enhance existing fill-protocol-stub fixit so that all missing witnesses can fixed at once.,lib/Sema/TypeCheckProtocol.cpp,+,"printProtocolStubFixitString(TypeLoc, Conf,",2492,download/apple_swift280.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Inferring associated types from decl:\n"";",3035,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Considering whether "" << result.first->getName()",3058,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,-,if (result.second->hasError()),3063,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,if (result.second->hasError()) {,3063,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- has error type\n"");",3064,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- duplicate\n"");",3072,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""++ we can same-type to:\n"";",3130,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- tautological\n"");",3145,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""** contradicts explicit type witness, """,3163,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""-- doesn't fulfill requirements\n"");",3185,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""++ seems legit\n"");",3190,download/apple_swift281.cpp
cdc3c1b49bedfe8dff6d897bb790820db084511b,"Sema: Accept tautological assoc type inference candidates when same-typed.

`X := Self.X` is still interesting information if it came from a witness candidate in a context where `X == Y` and we can infer a concrete witness for Y, for example:

```swift
protocol SameTypedDefault {
    associatedtype X
    associatedtype Y
    static var x: X { get }
    static var y: Y { get }
}
extension SameTypedDefault where Y == X {
    static var x: X {
        return y
    }
}

struct UsesSameTypedDefault: SameTypedDefault {
    static var y: Int {
        return 0
    }
}
```

Defer checking whether such a witness candidate satisfies associated type requirements until we consider a complete solution system, since `ConformingType.X` isn't a valid type until we've settled on a witness for X, and its abilities depend on what we choose for Y. Fixes SR-4143.",lib/Sema/TypeCheckProtocol.cpp,+,"DEBUG(llvm::dbgs() << ""Candidates for inference:\n"";",3700,download/apple_swift281.cpp
ac12480fd0e573ff378200378694d921e40d20df,Merge pull request #7869 from practicalswift/gardening-20170302,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"assert(hashIter != valueHashMap.end() && ""Missing SILValue"");",100,download/apple_swift282.cpp
ac12480fd0e573ff378200378694d921e40d20df,Merge pull request #7869 from practicalswift/gardening-20170302,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"assert(hashResult.second && ""SILValue already mapped"");",106,download/apple_swift282.cpp
17b616011553eca6a7a6238ecd60c54c98b3330f,"[gardening] Remove unused method replaceValue(..., ...)",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"assert(hashIter != valueHashMap.end() && ""Missing SILValue"");",100,download/apple_swift283.cpp
17b616011553eca6a7a6238ecd60c54c98b3330f,"[gardening] Remove unused method replaceValue(..., ...)",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"assert(hashResult.second && ""SILValue already mapped"");",106,download/apple_swift283.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/AST/ProtocolConformance.cpp,+,assert(assocType->isTypeParameter() &&,362,download/apple_swift284.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/AST/ProtocolConformance.cpp,+,assert(type->isEqual(getProtocol()->getSelfInterfaceType()) &&,368,download/apple_swift284.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/AST/ProtocolConformance.cpp,+,assert(memberType.getBase()->isEqual(getProtocol()->getSelfInterfaceType()) &&,376,download/apple_swift284.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/AST/ProtocolConformance.cpp,+,assert(assocType->isTypeParameter() &&,389,download/apple_swift284.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/AST/ProtocolConformance.cpp,+,assert(foundInRequirements &&,403,download/apple_swift284.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/AST/ProtocolConformance.cpp,+,assert(type->isEqual(getProtocol()->getSelfInterfaceType()) &&,410,download/apple_swift284.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/AST/ProtocolConformance.cpp,+,"assert(conf && ""inherited conformances cannot be abstract"");",413,download/apple_swift284.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/AST/ProtocolConformance.cpp,+,assert(memberType.getBase()->isEqual(getProtocol()->getSelfInterfaceType()) &&,420,download/apple_swift284.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenArchetype.cpp,+,assert(memberType.getBase()->isEqual(source->getSelfInterfaceType()));,122,download/apple_swift285.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenArchetype.cpp,-,assert(associate &&,416,download/apple_swift285.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenDecl.cpp,-,assert(conformance->getProtocol() == associate->getProtocol());,3313,download/apple_swift286.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(baseEntry.isBase());,764,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(piEntry.getOutOfLineBaseIndex().getValue() == Table.size(),1042,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1043,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(piEntry.getFunctionIndex().getValue() == Table.size(),1086,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1087,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(piEntry.getAssociatedTypeIndex().getValue() == Table.size(),1121,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1122,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(protos.size() == sub.getConformances().size());,1130,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(!associate->hasTypeParameter());,1148,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,1156,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Requirement == requirement,1158,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Protocol == protocol,1159,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,1162,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Requirement->isEqual(associatedType),1165,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Protocol == protocol,1167,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1172,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,+,assert(isa<GenericTypeParamType>(depAssociatedType)); // Self,1349,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/GenProto.cpp,-,assert(entry.isOutOfLineBase());,2080,download/apple_swift287.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/IRGen/Linking.cpp,+,assert(isa<GenericTypeParamType>(assocType));,88,download/apple_swift288.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/Parse/ParseSIL.cpp,+,assert(isa<GenericTypeParamType>(assocType));,4608,download/apple_swift289.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SIL/SILPrinter.cpp,+,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {",2255,download/apple_swift290.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SIL/SILPrinter.cpp,+,"if (printAssociatedTypePath(OS, memberType.getBase()))",2257,download/apple_swift290.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SIL/SILPrinter.cpp,+,assert(isa<GenericTypeParamType>(path));,2262,download/apple_swift290.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SIL/SILPrinter.cpp,+,"(void) printAssociatedTypePath(OS, assocProtoWitness.Requirement);",2326,download/apple_swift290.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SILGen/SILGenDecl.cpp,-,assert(protos.size() == witness.getConformances().size(),1739,download/apple_swift291.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SILGen/SILGenDecl.cpp,-,assert(witness.getConformances().empty(),1742,download/apple_swift291.cpp
13111c24cb43640ad7d14d74a7c01fb3c0031b1d,Merge pull request #7852 from rjmccall/sil-irgen-generalized-proto-requirements,lib/SILGen/SILGenDecl.cpp,-,assert(foundConformance != witness.getConformances().end());,1768,download/apple_swift291.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/AST/ProtocolConformance.cpp,+,assert(assocType->isTypeParameter() &&,362,download/apple_swift292.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/AST/ProtocolConformance.cpp,+,assert(type->isEqual(getProtocol()->getSelfInterfaceType()) &&,368,download/apple_swift292.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/AST/ProtocolConformance.cpp,+,assert(memberType.getBase()->isEqual(getProtocol()->getSelfInterfaceType()) &&,376,download/apple_swift292.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/AST/ProtocolConformance.cpp,+,assert(assocType->isTypeParameter() &&,389,download/apple_swift292.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/AST/ProtocolConformance.cpp,+,assert(foundInRequirements &&,403,download/apple_swift292.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/AST/ProtocolConformance.cpp,+,assert(type->isEqual(getProtocol()->getSelfInterfaceType()) &&,410,download/apple_swift292.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/AST/ProtocolConformance.cpp,+,"assert(conf && ""inherited conformances cannot be abstract"");",413,download/apple_swift292.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/AST/ProtocolConformance.cpp,+,assert(memberType.getBase()->isEqual(getProtocol()->getSelfInterfaceType()) &&,420,download/apple_swift292.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenArchetype.cpp,+,assert(memberType.getBase()->isEqual(source->getSelfInterfaceType()));,122,download/apple_swift293.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenArchetype.cpp,-,assert(associate &&,416,download/apple_swift293.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenDecl.cpp,-,assert(conformance->getProtocol() == associate->getProtocol());,3313,download/apple_swift294.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(baseEntry.isBase());,764,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(piEntry.getOutOfLineBaseIndex().getValue() == Table.size(),1042,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1043,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(piEntry.getFunctionIndex().getValue() == Table.size(),1086,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1087,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(piEntry.getAssociatedTypeIndex().getValue() == Table.size(),1121,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1122,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(protos.size() == sub.getConformances().size());,1130,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(!associate->hasTypeParameter());,1148,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,1156,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Requirement == requirement,1158,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(associatedWitness.Protocol == protocol,1159,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(entry.getKind() == SILWitnessTable::AssociatedTypeProtocol,1162,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Requirement->isEqual(associatedType),1165,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(associatedWitness.Protocol == protocol,1167,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(piIndex.getValue() == Table.size(),1172,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,+,assert(isa<GenericTypeParamType>(depAssociatedType)); // Self,1349,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/GenProto.cpp,-,assert(entry.isOutOfLineBase());,2080,download/apple_swift295.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/IRGen/Linking.cpp,+,assert(isa<GenericTypeParamType>(assocType));,88,download/apple_swift296.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/Parse/ParseSIL.cpp,+,assert(isa<GenericTypeParamType>(assocType));,4608,download/apple_swift297.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SIL/SILPrinter.cpp,+,"static bool printAssociatedTypePath(llvm::raw_ostream &OS, CanType path) {",2255,download/apple_swift298.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SIL/SILPrinter.cpp,+,"if (printAssociatedTypePath(OS, memberType.getBase()))",2257,download/apple_swift298.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SIL/SILPrinter.cpp,+,assert(isa<GenericTypeParamType>(path));,2262,download/apple_swift298.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SIL/SILPrinter.cpp,+,"(void) printAssociatedTypePath(OS, assocProtoWitness.Requirement);",2326,download/apple_swift298.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SILGen/SILGenDecl.cpp,-,assert(protos.size() == witness.getConformances().size(),1739,download/apple_swift299.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SILGen/SILGenDecl.cpp,-,assert(witness.getConformances().empty(),1742,download/apple_swift299.cpp
fe7915d09e1ab151afdb88b6cc1ff4b3680f7a9d,"Rework a number of SIL and IRGen witness-table abstractions
to correctly handle generalized protocol requirements.

The major missing pieces here are that the conformance search
algorithms in both the AST (type substitution) and IRGen
(witness table reference emission) need to be rewritten to
back-track requirement sources, and the AST needs to actually
represent this stuff in NormalProtocolConformances instead
of just doing ???.

The new generality isn't tested yet; I'm looking into that,
but I wanted to get the abstractions in place first.",lib/SILGen/SILGenDecl.cpp,-,assert(foundConformance != witness.getConformances().end());,1768,download/apple_swift299.cpp
33d7246abaf0b7f4034ebc7e7be4a788b8d8488a,Merge pull request #7853 from DougGregor/normal-conformance-requirement-signature,lib/AST/ASTContext.cpp,+,assert(proto->isSpecificProtocol(KPK_ObjectiveCBridgeable) &&,3621,download/apple_swift300.cpp
33d7246abaf0b7f4034ebc7e7be4a788b8d8488a,Merge pull request #7853 from DougGregor/normal-conformance-requirement-signature,lib/AST/ProtocolConformance.cpp,+,assert(idx < conformances.size());,264,download/apple_swift301.cpp
33d7246abaf0b7f4034ebc7e7be4a788b8d8488a,Merge pull request #7853 from DougGregor/normal-conformance-requirement-signature,lib/AST/ProtocolConformance.cpp,+,assert(conformances[idx].getRequirement() ==,265,download/apple_swift301.cpp
33d7246abaf0b7f4034ebc7e7be4a788b8d8488a,Merge pull request #7853 from DougGregor/normal-conformance-requirement-signature,lib/AST/ProtocolConformance.cpp,+,"assert(idx == conformances.size() && ""Too many conformances"");",270,download/apple_swift301.cpp
33d7246abaf0b7f4034ebc7e7be4a788b8d8488a,Merge pull request #7853 from DougGregor/normal-conformance-requirement-signature,lib/ClangImporter/ImportDecl.cpp,+,assert(req.getFirstType()->isEqual(proto->getSelfInterfaceType()));,6974,download/apple_swift302.cpp
33d7246abaf0b7f4034ebc7e7be4a788b8d8488a,Merge pull request #7853 from DougGregor/normal-conformance-requirement-signature,lib/ClangImporter/ImportDecl.cpp,+,assert(reqConformance && reqConformance->isConcrete() &&,6980,download/apple_swift302.cpp
33d7246abaf0b7f4034ebc7e7be4a788b8d8488a,Merge pull request #7853 from DougGregor/normal-conformance-requirement-signature,lib/Serialization/Serialization.cpp,+,"writeConformance(reqConformance, DeclTypeAbbrCodes);",1323,download/apple_swift303.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},49,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},54,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},59,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,63,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },",70,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },",79,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"static bool writeFilelistIfNecessary(const Job *job, DiagnosticEngine &diags);",107,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";",208,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,IncrementalTracer->printPath(,209,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";",233,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Blocked by: "" << LogJob(Blocking)",245,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"<< LogJobArray(BlockingCommands[Blocking]) << ""\n"";",247,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);",257,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"assert(success && ""failed to write filelist"");",258,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,assert(Cmd->getExtraEnvironment().empty() &&,261,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";",265,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,",272,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"<< "": "" << LogJob(Cmd) << ""\n"";",286,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"<< LogJobArray(AllBlocked) << ""\n"";",295,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,OS << LogJob(BeganCmd);,312,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,BeganCmd->printCommandLine(llvm::errs());,323,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,358,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,assert(DepGraph.isMarked(FinishedCmd));,395,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,assert(BlockingCommands.empty() &&,662,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,",721,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,+,Result = Comp.Diags.hadAnyError();,735,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,"IncrementalTracer->printPath(llvm::outs(), cmd,",836,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,"bool success = writeFilelistIfNecessary(Cmd, Diags);",855,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,"assert(success && ""failed to write filelist"");",855,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,assert(Cmd->getExtraEnvironment().empty() &&,857,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,BeganCmd->printCommandLine(llvm::errs());,1012,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,assert(FinishedCmd->getCondition() == Job::Condition::Always);,1057,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,assert(DepGraph.isMarked(FinishedCmd));,1094,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,assert(State.BlockingCommands.empty() &&,1210,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Compilation.cpp,-,Result = Diags.hadAnyError();,1247,download/apple_swift304.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Driver/Job.cpp,+,void Job::printSummary(raw_ostream &os) const {,112,download/apple_swift305.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Parse/ParseIfConfig.cpp,-,return ConditionalCompilationExprState::error();,374,download/apple_swift306.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/Parse/ParseIfConfig.cpp,-,return ConditionalCompilationExprState::error();,405,download/apple_swift306.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,lib/SIL/SILType.cpp,-,"assert(isObject() && ""Should only be called on object types."");",379,download/apple_swift307.cpp
ce718eeb5465902a86fd74bff90c3a2c68a0d865,Merge branch 'master' into normal-conformance-requirement-signature,tools/swift-demangle/swift-demangle.cpp,+,assert(remangled.find(MANGLING_PREFIX_STR) == 0);,109,download/apple_swift308.cpp
a34697b949664fd995e9158567a5d7d59de02838,"Merge pull request #7850 from eeckstein/demangle-swiftcc

demangler: swiftcc check and support of _S",tools/swift-demangle/swift-demangle.cpp,+,assert(remangled.find(MANGLING_PREFIX_STR) == 0);,109,download/apple_swift309.cpp
6c376400e9bb34d72b97c31cd9fcca934bd7fed7,"Merge pull request #7854 from slavapestov/small-sil-verifier-fix

SIL: Fix verifier crash with metatypes of dynamic Self",lib/SIL/SILType.cpp,-,"assert(isObject() && ""Should only be called on object types."");",379,download/apple_swift310.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},49,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},54,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},59,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,63,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },",70,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },",79,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"static bool writeFilelistIfNecessary(const Job *job, DiagnosticEngine &diags);",107,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";",208,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,IncrementalTracer->printPath(,209,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";",233,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Blocked by: "" << LogJob(Blocking)",245,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"<< LogJobArray(BlockingCommands[Blocking]) << ""\n"";",247,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);",257,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"assert(success && ""failed to write filelist"");",258,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,assert(Cmd->getExtraEnvironment().empty() &&,261,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";",265,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,",272,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"<< "": "" << LogJob(Cmd) << ""\n"";",286,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"<< LogJobArray(AllBlocked) << ""\n"";",295,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,OS << LogJob(BeganCmd);,312,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,BeganCmd->printCommandLine(llvm::errs());,323,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,358,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,assert(DepGraph.isMarked(FinishedCmd));,395,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,assert(BlockingCommands.empty() &&,662,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,",721,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,+,Result = Comp.Diags.hadAnyError();,735,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,"IncrementalTracer->printPath(llvm::outs(), cmd,",836,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,"bool success = writeFilelistIfNecessary(Cmd, Diags);",855,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,"assert(success && ""failed to write filelist"");",855,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,assert(Cmd->getExtraEnvironment().empty() &&,857,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,BeganCmd->printCommandLine(llvm::errs());,1012,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,assert(FinishedCmd->getCondition() == Job::Condition::Always);,1057,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,assert(DepGraph.isMarked(FinishedCmd));,1094,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,assert(State.BlockingCommands.empty() &&,1210,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Compilation.cpp,-,Result = Diags.hadAnyError();,1247,download/apple_swift311.cpp
babf6ffaadb429264691ca2f6256bef14f0409e8,"Merge pull request #7827 from graydon/compilation-cleanup

Compilation cleanup",lib/Driver/Job.cpp,+,void Job::printSummary(raw_ostream &os) const {,112,download/apple_swift312.cpp
5b44e358be082c34e871167f7d6627629d5b4d59,"SIL: Fix verifier crash with metatypes of dynamic Self

Fixes <rdar://problem/30786388>.",lib/SIL/SILType.cpp,-,"assert(isObject() && ""Should only be called on object types."");",379,download/apple_swift313.cpp
348c6b800129d531e10d462ef9a0a0c92b2d9be2,"Protocol conformance: store conformances needed for the requirement signature.

The protocol conformance checker verifies that all of the requirements
in the protocol's requirement signature are fulfilled. Save the
conformances from that check into the NormalProtocolConformance,
because this is the record of how that concrete type satisfies the
protocol requirements.

Compute, deserialize, and verify this information, but don't use it
for anything just yet. We'll use this to eliminate the ""inherited
protocol map"" and possibility some redundant type-witness
information.",lib/AST/ProtocolConformance.cpp,+,assert(idx < conformances.size());,264,download/apple_swift314.cpp
348c6b800129d531e10d462ef9a0a0c92b2d9be2,"Protocol conformance: store conformances needed for the requirement signature.

The protocol conformance checker verifies that all of the requirements
in the protocol's requirement signature are fulfilled. Save the
conformances from that check into the NormalProtocolConformance,
because this is the record of how that concrete type satisfies the
protocol requirements.

Compute, deserialize, and verify this information, but don't use it
for anything just yet. We'll use this to eliminate the ""inherited
protocol map"" and possibility some redundant type-witness
information.",lib/AST/ProtocolConformance.cpp,+,assert(conformances[idx].getRequirement() ==,265,download/apple_swift314.cpp
348c6b800129d531e10d462ef9a0a0c92b2d9be2,"Protocol conformance: store conformances needed for the requirement signature.

The protocol conformance checker verifies that all of the requirements
in the protocol's requirement signature are fulfilled. Save the
conformances from that check into the NormalProtocolConformance,
because this is the record of how that concrete type satisfies the
protocol requirements.

Compute, deserialize, and verify this information, but don't use it
for anything just yet. We'll use this to eliminate the ""inherited
protocol map"" and possibility some redundant type-witness
information.",lib/AST/ProtocolConformance.cpp,+,"assert(idx == conformances.size() && ""Too many conformances"");",270,download/apple_swift314.cpp
348c6b800129d531e10d462ef9a0a0c92b2d9be2,"Protocol conformance: store conformances needed for the requirement signature.

The protocol conformance checker verifies that all of the requirements
in the protocol's requirement signature are fulfilled. Save the
conformances from that check into the NormalProtocolConformance,
because this is the record of how that concrete type satisfies the
protocol requirements.

Compute, deserialize, and verify this information, but don't use it
for anything just yet. We'll use this to eliminate the ""inherited
protocol map"" and possibility some redundant type-witness
information.",lib/ClangImporter/ImportDecl.cpp,+,assert(req.getFirstType()->isEqual(proto->getSelfInterfaceType()));,6974,download/apple_swift315.cpp
348c6b800129d531e10d462ef9a0a0c92b2d9be2,"Protocol conformance: store conformances needed for the requirement signature.

The protocol conformance checker verifies that all of the requirements
in the protocol's requirement signature are fulfilled. Save the
conformances from that check into the NormalProtocolConformance,
because this is the record of how that concrete type satisfies the
protocol requirements.

Compute, deserialize, and verify this information, but don't use it
for anything just yet. We'll use this to eliminate the ""inherited
protocol map"" and possibility some redundant type-witness
information.",lib/ClangImporter/ImportDecl.cpp,+,assert(reqConformance && reqConformance->isConcrete() &&,6980,download/apple_swift315.cpp
348c6b800129d531e10d462ef9a0a0c92b2d9be2,"Protocol conformance: store conformances needed for the requirement signature.

The protocol conformance checker verifies that all of the requirements
in the protocol's requirement signature are fulfilled. Save the
conformances from that check into the NormalProtocolConformance,
because this is the record of how that concrete type satisfies the
protocol requirements.

Compute, deserialize, and verify this information, but don't use it
for anything just yet. We'll use this to eliminate the ""inherited
protocol map"" and possibility some redundant type-witness
information.",lib/Serialization/Serialization.cpp,+,"writeConformance(reqConformance, DeclTypeAbbrCodes);",1323,download/apple_swift316.cpp
f8f172a46b261670aa3b3b9fc2773bffac38d5f2,demangler: also support the future mangling prefix ‘_S’,tools/swift-demangle/swift-demangle.cpp,+,assert(remangled.find(MANGLING_PREFIX_STR) == 0);,109,download/apple_swift317.cpp
99df2082cdfe87e487c1358467b142722189c07b,[Driver] Clear deferred commands on each task queue iteration.,lib/Driver/Compilation.cpp,-,"llvm::outs() << ""Job finished: "" << LogJob(Cmd) << ""\n"";",228,download/apple_swift318.cpp
99df2082cdfe87e487c1358467b142722189c07b,[Driver] Clear deferred commands on each task queue iteration.,lib/Driver/Compilation.cpp,+,"<< "": "" << LogJob(Cmd) << ""\n"";",230,download/apple_swift318.cpp
1f3c66226c207a1c706da4bc6fd964524c977c02,[LangOptions] Introduce a new enum class for platform conditions (#7843),lib/Parse/ParseIfConfig.cpp,-,return ConditionalCompilationExprState::error();,374,download/apple_swift319.cpp
1f3c66226c207a1c706da4bc6fd964524c977c02,[LangOptions] Introduce a new enum class for platform conditions (#7843),lib/Parse/ParseIfConfig.cpp,-,return ConditionalCompilationExprState::error();,405,download/apple_swift319.cpp
ec4bf005af0e75defdf411fdce43b0460e935f13,[AST] Eliminate unnecessary #includes of AST/ProtocolConformance.h.,lib/AST/ASTContext.cpp,+,assert(proto->isSpecificProtocol(KPK_ObjectiveCBridgeable) &&,3621,download/apple_swift320.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunction.cpp,-,if (t->hasErrorResult()) {,220,download/apple_swift321.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunction.cpp,-,errorResult = t->getErrorResult().map([&](CanType elt) -> CanType {,220,download/apple_swift321.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,"OrigResults(origFnType->getResults()), ForeignError(foreignError) {}",1781,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,assert(NextOrigResultIndex == OrigResults.size() &&,1783,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,assert(NextOrigParamIndex == OrigParams.size() &&,1790,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,maybeSkipForeignErrorParameter();,1795,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,assert(origType.getNumTupleElements() == substTuple->getNumElements());,1799,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,assert(isIndirectFormalParameter(substConvention),1825,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,maybeSkipForeignErrorParameter();,1834,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,void maybeSkipForeignErrorParameter() {,1841,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,NextOrigParamIndex != ForeignError->getErrorParameterIndex()),1842,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,= origFnType->getOptionalErrorResult();,1988,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,assert(!substErrorResult ||,1988,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,assert(!origFnType->getExtInfo().hasContext(),1996,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,assert(substLoweredInterfaceType->getExtInfo().getSILRepresentation(),1997,download/apple_swift322.cpp
af33162da6ad2d1dc18f534e4771c80995d7fa74,"Merge pull request #7842 from slavapestov/sil-type-subst-works-so-use-it

SIL type substitution cleanup",lib/SIL/SILFunctionType.cpp,-,"assert(TheSILModule.Types.getLoweredType(abstraction, origType)",1984,download/apple_swift322.cpp
5dea03e1b728a2026ca1cc351b0110bd232239e4,"SIL: Use SILType::subst() to implement SILFunction::mapTypeIntoContext()

Now that we no longer rely on the push/pop context in
SILType::subst(), we can use that here instead of
duplicating the ""visit types in lowered position"" logic.",lib/SIL/SILFunction.cpp,-,if (t->hasErrorResult()) {,220,download/apple_swift323.cpp
5dea03e1b728a2026ca1cc351b0110bd232239e4,"SIL: Use SILType::subst() to implement SILFunction::mapTypeIntoContext()

Now that we no longer rely on the push/pop context in
SILType::subst(), we can use that here instead of
duplicating the ""visit types in lowered position"" logic.",lib/SIL/SILFunction.cpp,-,errorResult = t->getErrorResult().map([&](CanType elt) -> CanType {,220,download/apple_swift323.cpp
2b5d97430130f7dc62fe0c39e8545ac61a5e5b01,"SIL: SILType::subst() can now take a generic signature

In order to lower replacement types that appear in lowered
position, we need to know the generic signature of the
original type.

Allow this to be passed in explicitly, but fall back to
the push/pop generic context if not present.

This is a first step toward eliminating the push/pop of
the generic context.

Fixes <rdar://problem/29711782>.",lib/SIL/SILFunctionType.cpp,-,"assert(TheSILModule.Types.getLoweredType(abstraction, origType)",1984,download/apple_swift324.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,"OrigResults(origFnType->getResults()), ForeignError(foreignError) {}",1781,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,assert(NextOrigResultIndex == OrigResults.size() &&,1783,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,assert(NextOrigParamIndex == OrigParams.size() &&,1790,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,maybeSkipForeignErrorParameter();,1795,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,assert(origType.getNumTupleElements() == substTuple->getNumElements());,1799,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,assert(isIndirectFormalParameter(substConvention),1825,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,maybeSkipForeignErrorParameter();,1834,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,void maybeSkipForeignErrorParameter() {,1841,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,NextOrigParamIndex != ForeignError->getErrorParameterIndex()),1842,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,= origFnType->getOptionalErrorResult();,1988,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,assert(!substErrorResult ||,1988,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,assert(!origFnType->getExtInfo().hasContext(),1996,download/apple_swift325.cpp
ec1d9fcfc7fb3dd646dba7edd619a42b0774322f,SIL: Remove TypeConverter::substFunctionType(),lib/SIL/SILFunctionType.cpp,-,assert(substLoweredInterfaceType->getExtInfo().getSILRepresentation(),1997,download/apple_swift325.cpp
15b46e3db0d8003ee9fa71ddc0c2d5d174e972e2,"Merge pull request #7839 from slavapestov/generic-capture-promotion

Generic capture promotion",lib/AST/Type.cpp,-,return getType()->hasError() || getType()->getCanonicalType()->hasError();,56,download/apple_swift326.cpp
15b46e3db0d8003ee9fa71ddc0c2d5d174e972e2,"Merge pull request #7839 from slavapestov/generic-capture-promotion

Generic capture promotion",lib/AST/Type.cpp,+,return getType()->hasError();,56,download/apple_swift326.cpp
a2b594aa9a7aea388d0cf7daf0e242a2ac876410,Merge pull request #7833 from DougGregor/superclass-constraints,lib/AST/GenericSignatureBuilder.cpp,-,Superclass.print(Out);,1525,download/apple_swift327.cpp
a2b594aa9a7aea388d0cf7daf0e242a2ac876410,Merge pull request #7833 from DougGregor/superclass-constraints,lib/AST/GenericSignatureBuilder.cpp,-,"SuperclassSource->print(Out, SrcMgr);",1529,download/apple_swift327.cpp
a2b594aa9a7aea388d0cf7daf0e242a2ac876410,Merge pull request #7833 from DougGregor/superclass-constraints,lib/AST/GenericSignatureBuilder.cpp,+,constraint.concreteType.print(Out);,1535,download/apple_swift327.cpp
a2b594aa9a7aea388d0cf7daf0e242a2ac876410,Merge pull request #7833 from DougGregor/superclass-constraints,lib/AST/GenericSignatureBuilder.cpp,+,"constraint.source->print(Out, SrcMgr);",1541,download/apple_swift327.cpp
a2b594aa9a7aea388d0cf7daf0e242a2ac876410,Merge pull request #7833 from DougGregor/superclass-constraints,lib/AST/GenericSignatureBuilder.cpp,-,"assert(concreteType && ""No concrete type to check"");",2874,download/apple_swift327.cpp
a2b594aa9a7aea388d0cf7daf0e242a2ac876410,Merge pull request #7833 from DougGregor/superclass-constraints,lib/AST/GenericSignatureBuilder.cpp,+,"assert(equivClass->concreteType && ""No concrete type to check"");",3058,download/apple_swift327.cpp
a2b594aa9a7aea388d0cf7daf0e242a2ac876410,Merge pull request #7833 from DougGregor/superclass-constraints,lib/AST/GenericSignatureBuilder.cpp,+,"assert(equivClass->superclass && ""No superclass constraint?"");",3084,download/apple_swift327.cpp
a2b594aa9a7aea388d0cf7daf0e242a2ac876410,Merge pull request #7833 from DougGregor/superclass-constraints,lib/AST/GenericSignatureBuilder.cpp,+,assert(paToComponent.count(superclass.archetype) > 0);,3307,download/apple_swift327.cpp
352449d9ef686817b04615c6f9b3f009bd598f0a,AST: Remove unnecessary getCanonicalType() call,lib/AST/Type.cpp,-,return getType()->hasError() || getType()->getCanonicalType()->hasError();,56,download/apple_swift328.cpp
352449d9ef686817b04615c6f9b3f009bd598f0a,AST: Remove unnecessary getCanonicalType() call,lib/AST/Type.cpp,+,return getType()->hasError();,56,download/apple_swift328.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseDecl.cpp,-,return makeParserError();,3023,download/apple_swift329.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return makeParserError();,52,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,if (Status.isError()),123,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,if (Status.isError()),143,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,"assert(condition && ""Cannot classify a NULL condition expression!"");",167,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,179,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,214,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,223,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,261,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,275,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,284,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,293,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,300,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,313,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,321,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,339,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,347,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,366,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,382,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,389,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,408,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,429,download/apple_swift330.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,"assert(condition && ""Cannot classify a NULL condition expression!"");",1506,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1517,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1551,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1559,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1596,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1609,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1617,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1625,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1631,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1643,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1650,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1667,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1674,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1692,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1707,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1713,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1731,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1751,download/apple_swift331.cpp
af53cb977894af5c42b9738d4fa5d781be9f789a,Merge pull request #7733 from rintaro/parse-ifconfig-refactoring,lib/Parse/ParseStmt.cpp,-,return makeParserError();,1774,download/apple_swift331.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SIL/SILOwnershipVerifier.cpp,+,"assert(F && ""Instructions and arguments should have a function"");",1826,download/apple_swift332.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,assert(operand.getType().isAddress());,139,download/apple_swift333.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");",174,download/apple_swift333.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,assert(!SGF.B.hasValidInsertionPoint() &&,186,download/apple_swift333.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,assert(!SGF.B.hasValidInsertionPoint() &&,206,download/apple_swift333.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");",212,download/apple_swift333.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,assert(operandCMV.getFinalConsumption() == CastConsumptionKind::TakeAlways);,750,download/apple_swift333.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!Value.hasValue() && ""Expected a take_always consumption kind"");",800,download/apple_swift333.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!Value.hasValue() && ""Expected take_always semantics"");",845,download/apple_swift333.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenPattern.cpp,-,"assert(!SGF.B.hasValidInsertionPoint() && ""did not end block"");",1536,download/apple_swift334.cpp
4240d011a1e1fd37a432c9d673ab870d49ee3095,Merge pull request #7829 from gottesmm/checked_cast_br_1,lib/SILGen/SILGenPattern.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""did not end block"");",1545,download/apple_swift334.cpp
2d7491e858b3f95821e471f01bf55189c6d0713d,Merge pull request #7828 from eeckstein/thunk-demangling,lib/Basic/Demangle.cpp,+,print(pointer->getChild(pointer->getNumChildren() - 2));,3420,download/apple_swift335.cpp
cdb38c1e97aaced7480c692946241e341b982e36,"[GSB] Check all superclass constraints during finalization.

Use the same infrastructure we have for same-type-to-concrete
constraints to check superclass constraints. Specifically,

* Track all superclass constraints; never ""update"" a requirement source
* Remove self-derived superclass constraints
* Pick the best superclass constraint within each connected component
  of an equivalence class and use that for requirement generation.
* Diagnose conflicting superclass requirements during finalization
* Diagnose redundant superclass requirements (during finalization)",lib/AST/GenericSignatureBuilder.cpp,-,Superclass.print(Out);,1525,download/apple_swift336.cpp
cdb38c1e97aaced7480c692946241e341b982e36,"[GSB] Check all superclass constraints during finalization.

Use the same infrastructure we have for same-type-to-concrete
constraints to check superclass constraints. Specifically,

* Track all superclass constraints; never ""update"" a requirement source
* Remove self-derived superclass constraints
* Pick the best superclass constraint within each connected component
  of an equivalence class and use that for requirement generation.
* Diagnose conflicting superclass requirements during finalization
* Diagnose redundant superclass requirements (during finalization)",lib/AST/GenericSignatureBuilder.cpp,-,"SuperclassSource->print(Out, SrcMgr);",1529,download/apple_swift336.cpp
cdb38c1e97aaced7480c692946241e341b982e36,"[GSB] Check all superclass constraints during finalization.

Use the same infrastructure we have for same-type-to-concrete
constraints to check superclass constraints. Specifically,

* Track all superclass constraints; never ""update"" a requirement source
* Remove self-derived superclass constraints
* Pick the best superclass constraint within each connected component
  of an equivalence class and use that for requirement generation.
* Diagnose conflicting superclass requirements during finalization
* Diagnose redundant superclass requirements (during finalization)",lib/AST/GenericSignatureBuilder.cpp,+,constraint.concreteType.print(Out);,1535,download/apple_swift336.cpp
cdb38c1e97aaced7480c692946241e341b982e36,"[GSB] Check all superclass constraints during finalization.

Use the same infrastructure we have for same-type-to-concrete
constraints to check superclass constraints. Specifically,

* Track all superclass constraints; never ""update"" a requirement source
* Remove self-derived superclass constraints
* Pick the best superclass constraint within each connected component
  of an equivalence class and use that for requirement generation.
* Diagnose conflicting superclass requirements during finalization
* Diagnose redundant superclass requirements (during finalization)",lib/AST/GenericSignatureBuilder.cpp,+,"constraint.source->print(Out, SrcMgr);",1541,download/apple_swift336.cpp
cdb38c1e97aaced7480c692946241e341b982e36,"[GSB] Check all superclass constraints during finalization.

Use the same infrastructure we have for same-type-to-concrete
constraints to check superclass constraints. Specifically,

* Track all superclass constraints; never ""update"" a requirement source
* Remove self-derived superclass constraints
* Pick the best superclass constraint within each connected component
  of an equivalence class and use that for requirement generation.
* Diagnose conflicting superclass requirements during finalization
* Diagnose redundant superclass requirements (during finalization)",lib/AST/GenericSignatureBuilder.cpp,+,assert(paToComponent.count(superclass.archetype) > 0);,3298,download/apple_swift336.cpp
2d06da7de9bf53d3b5c74e834b5ab5c93205dcf0,"demangler: be a bit more verbose when printing the simplified mangling for a thunk

Instead of just printing “thunk” it now also includes the source function type

rdar://problem/30541796",lib/Basic/Demangle.cpp,+,print(pointer->getChild(pointer->getNumChildren() - 2));,3420,download/apple_swift337.cpp
423d9fe0542705bc5ec7b61e5a813770e483e8e3,[Driver] Extract reloadAndRemarkDeps from taskFinished.,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,287,download/apple_swift338.cpp
423d9fe0542705bc5ec7b61e5a813770e483e8e3,[Driver] Extract reloadAndRemarkDeps from taskFinished.,lib/Driver/Compilation.cpp,+,assert(DepGraph.isMarked(FinishedCmd));,327,download/apple_swift338.cpp
423d9fe0542705bc5ec7b61e5a813770e483e8e3,[Driver] Extract reloadAndRemarkDeps from taskFinished.,lib/Driver/Compilation.cpp,-,assert(FinishedCmd->getCondition() == Job::Condition::Always);,391,download/apple_swift338.cpp
423d9fe0542705bc5ec7b61e5a813770e483e8e3,[Driver] Extract reloadAndRemarkDeps from taskFinished.,lib/Driver/Compilation.cpp,-,assert(DepGraph.isMarked(FinishedCmd));,430,download/apple_swift338.cpp
ab5201f60e07acca4de788900cd449b48030d7ae,[Driver] Make PerformJobsState a mostly-private class.,lib/Driver/Compilation.cpp,+,Result = Comp.Diags.hadAnyError();,659,download/apple_swift339.cpp
ab5201f60e07acca4de788900cd449b48030d7ae,[Driver] Make PerformJobsState a mostly-private class.,lib/Driver/Compilation.cpp,-,State.Result = Diags.hadAnyError();,807,download/apple_swift339.cpp
211d09759cd09929043e3cd886477a091d1c3b7f,[Driver] Move populateInputInfoMap into PerformJobsState.,lib/Driver/Compilation.cpp,+,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,",644,download/apple_swift340.cpp
211d09759cd09929043e3cd886477a091d1c3b7f,[Driver] Move populateInputInfoMap into PerformJobsState.,lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,",705,download/apple_swift340.cpp
9d0e7e0e995d21dc5707d75348947c262f69da2a,[Driver] Factor out PerformJobsState::checkUnfinishedJobs.,lib/Driver/Compilation.cpp,+,assert(BlockingCommands.empty() &&,581,download/apple_swift341.cpp
9d0e7e0e995d21dc5707d75348947c262f69da2a,[Driver] Factor out PerformJobsState::checkUnfinishedJobs.,lib/Driver/Compilation.cpp,-,assert(State.BlockingCommands.empty() &&,792,download/apple_swift341.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,OS << LogJob(BeganCmd);,259,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,BeganCmd->printCommandLine(llvm::errs());,270,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,314,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,assert(DepGraph.isMarked(FinishedCmd));,354,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,-,OS << LogJob(BeganCmd);,745,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,-,BeganCmd->printCommandLine(llvm::errs());,755,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,-,assert(FinishedCmd->getCondition() == Job::Condition::Always);,800,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,-,assert(State.DepGraph.isMarked(FinishedCmd));,839,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,-,Result = Diags.hadAnyError();,789,download/apple_swift342.cpp
6d21711d02a53b02ad92714dcff955673174dd85,[Driver] Move TaskQueue callbacks to PerformJobsState.,lib/Driver/Compilation.cpp,+,State.Result = Diags.hadAnyError();,791,download/apple_swift342.cpp
053c3f8e9efd7938d28f5d8c38618ee111da058c,[Driver] Move DepGraph and MarkTracer to PerformJobsState.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";",165,download/apple_swift343.cpp
053c3f8e9efd7938d28f5d8c38618ee111da058c,[Driver] Move DepGraph and MarkTracer to PerformJobsState.,lib/Driver/Compilation.cpp,+,IncrementalTracer->printPath(,166,download/apple_swift343.cpp
053c3f8e9efd7938d28f5d8c38618ee111da058c,[Driver] Move DepGraph and MarkTracer to PerformJobsState.,lib/Driver/Compilation.cpp,-,"llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";",430,download/apple_swift343.cpp
053c3f8e9efd7938d28f5d8c38618ee111da058c,[Driver] Move DepGraph and MarkTracer to PerformJobsState.,lib/Driver/Compilation.cpp,-,"IncrementalTracer->printPath(llvm::outs(), cmd,",430,download/apple_swift343.cpp
053c3f8e9efd7938d28f5d8c38618ee111da058c,[Driver] Move DepGraph and MarkTracer to PerformJobsState.,lib/Driver/Compilation.cpp,-,assert(DepGraph.isMarked(FinishedCmd));,624,download/apple_swift343.cpp
053c3f8e9efd7938d28f5d8c38618ee111da058c,[Driver] Move DepGraph and MarkTracer to PerformJobsState.,lib/Driver/Compilation.cpp,+,assert(State.DepGraph.isMarked(FinishedCmd));,624,download/apple_swift343.cpp
aee4c83467b6cb0444daecf2d3bdb54e6baa83d3,"[Driver] Move markFinished to PerformJobsState, add logging.",lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Job finished: "" << LogJob(Cmd) << ""\n"";",195,download/apple_swift344.cpp
aee4c83467b6cb0444daecf2d3bdb54e6baa83d3,"[Driver] Move markFinished to PerformJobsState, add logging.",lib/Driver/Compilation.cpp,+,"<< LogJobArray(AllBlocked) << ""\n"";",204,download/apple_swift344.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"static bool writeFilelistIfNecessary(const Job *job, DiagnosticEngine &diags);",107,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Already scheduled: "" << LogJob(Cmd) << ""\n"";",162,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Blocked by: "" << LogJob(Blocking)",170,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"<< LogJobArray(BlockingCommands[Blocking]) << ""\n"";",172,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"bool success = writeFilelistIfNecessary(Cmd, Comp.Diags);",178,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"assert(success && ""failed to write filelist"");",179,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,assert(Cmd->getExtraEnvironment().empty() &&,182,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Added to TaskQueue: "" << LogJob(Cmd) << ""\n"";",186,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,-,"bool success = writeFilelistIfNecessary(Cmd, Diags);",406,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,-,"assert(success && ""failed to write filelist"");",406,download/apple_swift345.cpp
de2c05fa8b415b091107e36894c69decbec2ab68,[Driver] Extract scheduleCommandIfNecessary and add logging.,lib/Driver/Compilation.cpp,-,assert(Cmd->getExtraEnvironment().empty() &&,408,download/apple_swift345.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},49,download/apple_swift346.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},54,download/apple_swift346.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},59,download/apple_swift346.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,63,download/apple_swift346.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },",70,download/apple_swift346.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },",79,download/apple_swift346.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,"llvm::outs() << ""Queuing "" << reason << "": "" << LogJob(cmd) << ""\n"";",354,download/apple_swift346.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Compilation.cpp,+,OS << LogJob(BeganCmd);,522,download/apple_swift346.cpp
a13a0dfbbab61ad03a36dd75e44156aa791def8d,[Driver] Factor out some Job-logging support.,lib/Driver/Job.cpp,+,void Job::printSummary(raw_ostream &os) const {,112,download/apple_swift347.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",lib/Syntax/DeclSyntax.cpp,-,assert(Raw->Kind == SyntaxKind::UnknownStmt);,40,download/apple_swift348.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::UnknownDecl);,41,download/apple_swift348.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",lib/Syntax/UnknownSyntax.cpp,+,assert(Raw->isUnknown());,25,download/apple_swift349.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",lib/Syntax/UnknownSyntax.cpp,+,assert(N < getNumChildren());,69,download/apple_swift349.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",lib/Syntax/UnknownSyntax.cpp,+,assert(N < getRaw()->Layout.size());,70,download/apple_swift349.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",lib/Syntax/UnknownSyntax.cpp,+,assert(RawChild->Kind != SyntaxKind::Token);,89,download/apple_swift349.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,SymbolicRef.print(KnownOS);,53,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");",54,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,Unknown.print(UnknownOS);,68,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());",70,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,GottenExpr.print(KnownOS);,84,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(Unknown.getNumChildren(), size_t(2));",95,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,ExprGottenFromUnknown.print(UnknownOS);,103,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());",105,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,ASSERT_TRUE(ExprGottenFromUnknown,108,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,GottenArgs.print(KnownOS);,119,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(Unknown.getNumChildren(), size_t(2));",130,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,ArgsGottenFromUnknown.print(UnknownOS);,138,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());",140,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,ASSERT_TRUE(ArgsGottenFromUnknown,143,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,CallWithKnownExpr.print(KnownOS);,160,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,CallWithUnknownExpr.print(UnknownOS);,179,download/apple_swift350.cpp
fbe945b13efabd7a285ab7635ba64737afa1dac5,"Merge pull request #7824 from bitjammer/sr-4062-unknown-syntax-children

[Syntax] Allow UnknownSyntax to have children",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());",181,download/apple_swift350.cpp
a97fa06744f6603c2497604a2521e787040d0fce,"[GSB] Factor out the checking of of the concrete-type constraints.

This checking will also be used for other kinds of constraints (e.g.,
superclass constraints), so factor it out in advance.",lib/AST/GenericSignatureBuilder.cpp,-,"assert(concreteType && ""No concrete type to check"");",2886,download/apple_swift351.cpp
a97fa06744f6603c2497604a2521e787040d0fce,"[GSB] Factor out the checking of of the concrete-type constraints.

This checking will also be used for other kinds of constraints (e.g.,
superclass constraints), so factor it out in advance.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(equivClass->concreteType && ""No concrete type to check"");",3015,download/apple_swift351.cpp
a97fa06744f6603c2497604a2521e787040d0fce,"[GSB] Factor out the checking of of the concrete-type constraints.

This checking will also be used for other kinds of constraints (e.g.,
superclass constraints), so factor it out in advance.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(equivClass->superclass && ""No superclass constraint?"");",3040,download/apple_swift351.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",lib/Syntax/DeclSyntax.cpp,-,assert(Raw->Kind == SyntaxKind::UnknownStmt);,40,download/apple_swift352.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::UnknownDecl);,41,download/apple_swift352.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",lib/Syntax/UnknownSyntax.cpp,+,assert(Raw->isUnknown());,25,download/apple_swift353.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",lib/Syntax/UnknownSyntax.cpp,+,assert(N < getNumChildren());,69,download/apple_swift353.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",lib/Syntax/UnknownSyntax.cpp,+,assert(N < getRaw()->Layout.size());,70,download/apple_swift353.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",lib/Syntax/UnknownSyntax.cpp,+,assert(RawChild->Kind != SyntaxKind::Token);,89,download/apple_swift353.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,SymbolicRef.print(KnownOS);,53,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), ""Array<Int>"");",54,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,Unknown.print(UnknownOS);,68,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());",70,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,GottenExpr.print(KnownOS);,84,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(Unknown.getNumChildren(), size_t(2));",95,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,ExprGottenFromUnknown.print(UnknownOS);,103,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());",105,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,ASSERT_TRUE(ExprGottenFromUnknown,108,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,GottenArgs.print(KnownOS);,119,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(Unknown.getNumChildren(), size_t(2));",130,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,ArgsGottenFromUnknown.print(UnknownOS);,138,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());",140,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,ASSERT_TRUE(ArgsGottenFromUnknown,143,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,CallWithKnownExpr.print(KnownOS);,160,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,CallWithUnknownExpr.print(UnknownOS);,179,download/apple_swift354.cpp
c958cd65eb638f85570fbe4748cd9fb31edd2c9e,"[Syntax] Allow UnknownSyntax to have children

This will make it easier to incrementally implement syntax nodes,
while allowing us to embed nodes that we do know about inside ones
that we don't.

https://bugs.swift.org/browse/SR-4062",unittests/Syntax/UnknownSyntaxTests.cpp,+,"ASSERT_EQ(KnownOS.str().str(), UnknownOS.str().str());",181,download/apple_swift354.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SIL/SILOwnershipVerifier.cpp,+,"assert(F && ""Instructions and arguments should have a function"");",1826,download/apple_swift355.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,assert(operand.getType().isAddress());,139,download/apple_swift356.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");",174,download/apple_swift356.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,assert(!SGF.B.hasValidInsertionPoint() &&,186,download/apple_swift356.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,assert(!SGF.B.hasValidInsertionPoint() &&,206,download/apple_swift356.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""handler did not end block"");",212,download/apple_swift356.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,assert(operandCMV.getFinalConsumption() == CastConsumptionKind::TakeAlways);,750,download/apple_swift356.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!Value.hasValue() && ""Expected a take_always consumption kind"");",800,download/apple_swift356.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenDynamicCast.cpp,+,"assert(!Value.hasValue() && ""Expected take_always semantics"");",845,download/apple_swift356.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenPattern.cpp,-,"assert(!SGF.B.hasValidInsertionPoint() && ""did not end block"");",1536,download/apple_swift357.cpp
455c1262388537ad49a98bd25680c49c78ab898e,"[semantic-sil] Pass the uncasted argument as an @owned arg in the failed checked_cast_br cast.

Previously, we would put a destroy_value directly on the value that we tried to
cast. Since checked_cast_br is consuming, this would cause the destroy_value on
the failure path to be flagged as a double consume.

This commit causes SILGen to emit the value consumed by checked_cast_br as an
@owned argument to the failure BB, allowing semantic arc rules to be respected.

As an additional benefit, I also upgraded the ownership_model_eliminator test to
use semantic sil verification.

One issue that did come up though is that I was unable to use the new code in
all locations in the compiler. Specifically, there is one location in
SILGenPattern that uses argument unforwarding. I am going to need to undo
argument unforwarding in SILGenPattern in order to completely eliminate the old
code path.",lib/SILGen/SILGenPattern.cpp,+,"assert(!SGF.B.hasValidInsertionPoint() && ""did not end block"");",1545,download/apple_swift357.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,void maybePrintObjCGenericParameters(const ClassDecl *importedClass) {,176,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,assert(objcClass->getTypeParamList()->size() != 0);,183,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,maybePrintObjCGenericParameters(baseClass);,206,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,maybePrintObjCGenericParameters(baseClass);,338,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,"assert(decl && ""can't print canonicalized GenericTypeParamType"");",1602,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,assert(extendedClass->isGeneric());,1607,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,assert(extension->getGenericParams()->size() ==,1608,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,assert(extension->getGenericSignature()->getCanonicalSignature() ==,1611,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,"assert(decl->getClangDecl() && ""can only handle imported ObjC generics"");",1618,download/apple_swift358.cpp
79b5ea022d56958b42659ba60ac5d7939270aa19,"[PrintAsObjC] Handle generic parameters in extensions. (#7818)

Most of the time, ""generics"" means ""cannot be exposed to Objective-C""
and certainly ""cannot be exposed in the generated header"", but there
is one exception: imported Objective-C parameterized types, and their
extensions. We were previously dropping this on the floor and printing
`Foo</* BarType */>` in the generated header, which is nonsense.

https://bugs.swift.org/browse/SR-3480",lib/PrintAsObjC/PrintAsObjC.cpp,+,printNullability(optionalKind);,1620,download/apple_swift358.cpp
1c6757f946c60a4dbf408590f27af97a294a470c,"Merge pull request #7812 from DougGregor/self-derived-constraints

[GenericSignatureBuilder] Remove self-derived same-type-to-concrete constraints.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(currentPA && ""Missing root potential archetype"");",279,download/apple_swift359.cpp
1c6757f946c60a4dbf408590f27af97a294a470c,"Merge pull request #7812 from DougGregor/self-derived-constraints

[GenericSignatureBuilder] Remove self-derived same-type-to-concrete constraints.",lib/AST/GenericSignatureBuilder.cpp,+,assert(storageKind == StorageKind::RootArchetype);,433,download/apple_swift359.cpp
1c6757f946c60a4dbf408590f27af97a294a470c,"Merge pull request #7812 from DougGregor/self-derived-constraints

[GenericSignatureBuilder] Remove self-derived same-type-to-concrete constraints.",lib/AST/GenericSignatureBuilder.cpp,+,"out << pa->getDebugName() << "": "";",481,download/apple_swift359.cpp
845017cc8199d81185314f8bcdf23db58c927888,Improve how DeclContext chains are printed in AST dumps. (#7786),lib/AST/ASTDumper.cpp,-,"static void printName(raw_ostream &os, Identifier name) {",368,download/apple_swift360.cpp
845017cc8199d81185314f8bcdf23db58c927888,Improve how DeclContext chains are printed in AST dumps. (#7786),lib/AST/ASTDumper.cpp,+,"static void printName(raw_ostream &os, DeclName name) {",369,download/apple_swift360.cpp
845017cc8199d81185314f8bcdf23db58c927888,Improve how DeclContext chains are printed in AST dumps. (#7786),lib/AST/ASTDumper.cpp,+,"printName(os, cast<AbstractFunctionDecl>(dc)->getFullName());",1178,download/apple_swift360.cpp
845017cc8199d81185314f8bcdf23db58c927888,Improve how DeclContext chains are printed in AST dumps. (#7786),lib/AST/ASTDumper.cpp,+,"printName(os, cast<SubscriptDecl>(dc)->getFullName());",1184,download/apple_swift360.cpp
5ec385797f7b33b5fdd9fc17dbc3d95b1a287728,"[GSB] Remove self-derived same-type-to-concrete constraints.

Introduce an operation on RequirementSource to determine whether a
constraint with such a source, when it lands on a given potential
archetype, is ""self-derived"": e.g., the final constraint is derived
from the original constraint. Remove such constraints from the system
during finalization, because otherwise they would make the original
constraint redundant.

Fixes rdar://problem/30478915, although we still need to apply this
same logic to other kinds of constraints in the system.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(currentPA && ""Missing root potential archetype"");",266,download/apple_swift361.cpp
c2da97172b92085dc5cccd67f1a4293fd1348d36,"[GSB] Store the root potential archetype in RequirementSource.

Use TrailingObjects to help us efficiently store the root potential
archetype within requirement sources, so we can reconstruct the
complete path from the point where a requirement was created to the
potential archetype it affects.

The test changes are because we are now dumping the root potential
archetype as part of -debug-generic-signatures.",lib/AST/GenericSignatureBuilder.cpp,+,assert(storageKind == StorageKind::RootArchetype);,383,download/apple_swift362.cpp
c2da97172b92085dc5cccd67f1a4293fd1348d36,"[GSB] Store the root potential archetype in RequirementSource.

Use TrailingObjects to help us efficiently store the root potential
archetype within requirement sources, so we can reconstruct the
complete path from the point where a requirement was created to the
potential archetype it affects.

The test changes are because we are now dumping the root potential
archetype as part of -debug-generic-signatures.",lib/AST/GenericSignatureBuilder.cpp,+,"out << pa->getDebugName() << "": "";",432,download/apple_swift362.cpp
5c2fe3496fe35a8bfc88aab521f2fc4f03e18a1e,"Merge pull request #7740 from huonw/parse-assoc-type-where

(Mostly) Type-check where clauses on associated types",lib/Sema/TypeCheckDecl.cpp,+,assert(D->isBeingValidated() || D->hasValidSignature());,6945,download/apple_swift363.cpp
5c2fe3496fe35a8bfc88aab521f2fc4f03e18a1e,"Merge pull request #7740 from huonw/parse-assoc-type-where

(Mostly) Type-check where clauses on associated types",lib/Sema/TypeCheckGeneric.cpp,+,assert(gp->isEqual(Proto->getSelfInterfaceType()) &&,133,download/apple_swift364.cpp
5c2fe3496fe35a8bfc88aab521f2fc4f03e18a1e,"Merge pull request #7740 from huonw/parse-assoc-type-where

(Mostly) Type-check where clauses on associated types",lib/Sema/TypeCheckGeneric.cpp,+,assert(selfTy->isEqual(Proto->getSelfInterfaceType()));,146,download/apple_swift364.cpp
5c2fe3496fe35a8bfc88aab521f2fc4f03e18a1e,"Merge pull request #7740 from huonw/parse-assoc-type-where

(Mostly) Type-check where clauses on associated types",lib/Sema/TypeCheckType.cpp,-,if (!type || type->hasError()),1092,download/apple_swift365.cpp
5c2fe3496fe35a8bfc88aab521f2fc4f03e18a1e,"Merge pull request #7740 from huonw/parse-assoc-type-where

(Mostly) Type-check where clauses on associated types",lib/Sema/TypeCheckType.cpp,+,auto hasError = type->hasError();,1095,download/apple_swift365.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/AST/Type.cpp,-,assert(!lvt->getObjectType()->isLValueType(),458,download/apple_swift366.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/AST/Type.cpp,-,assert(!t->isLValueType(),477,download/apple_swift366.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/AST/Type.cpp,-,assert(archetypeTy->requiresClass());,551,download/apple_swift366.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/IRGen/GenCast.cpp,-,assert(destClass || toType.is<ArchetypeType>());,149,download/apple_swift367.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/IRGen/GenCast.cpp,+,assert(destClass != nullptr);,155,download/apple_swift367.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/SILGen/SILGenApply.cpp,-,assert(isAnyObjectType(emittedArg.getSwiftType()));,3455,download/apple_swift368.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/SILGen/SILGenApply.cpp,+,assert(isAnyObjectType(emittedArg.getType().getSwiftRValueType()));,3455,download/apple_swift368.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/SILGen/SILGenMaterializeForSet.cpp,-,assert(selfTuple->getNumElements() == 1);,455,download/apple_swift369.cpp
3c6835433e322e405425e7fcea96be8202d041f8,"Merge pull request #7798 from slavapestov/spring-cleaning

Spring cleaning",lib/Sema/CSDiag.cpp,-,if (type->hasError() || type->hasTypeVariable() ||,5919,download/apple_swift370.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Layout.size() == 2);,121,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token(Raw,",122,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_kind(Raw,",124,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,163,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionCallArgumentSyntax::Cursor::Label,",203,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",205,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,assert(,208,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",211,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,assert(NewLabel->getTokenKind() == tok::identifier);,251,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(NewColon, tok::colon, "":"");",262,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(NewTrailingComma, tok::comma, "","");",297,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,assert(Child->Kind == SyntaxKind::FunctionCallArgument);,311,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,assert(Index <= getRaw()->Layout.size());,351,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Layout.size() == 4);,385,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->getChild(FunctionCallExprSyntax::Cursor::CalledExpression),386,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionCallExprSyntax::Cursor::LeftParen,",388,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionCallExprSyntax::Cursor::ArgumentList,",390,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",392,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",455,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",489,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(LeftParen, tok::l_paren, ""("");",503,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(RightParen, tok::r_paren, "")"");",524,download/apple_swift371.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(Ref.getIdentifier(), Array);",29,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));,33,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArgs.print(OS);,38,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""<Int>"");",39,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,SyntaxFactory::makeBlankSymbolicReferenceExpr().print(OS);,57,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"SyntaxFactory::makeSymbolicReferenceExpr(Foo, BlankArgs).print(OS);",67,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs).print(OS);",74,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""Array<Int>"");",75,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,94,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""Array"");",95,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,102,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""<Int>"");",103,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,111,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""Array<Int>"");",112,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(X, Arg.getLabel());",129,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(Colon, Arg.getColonToken());",130,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenExpr.hasSameIdentityAs(GottenExpr2));,134,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenExpr.print(OS);,137,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(""foo"", OS.str().str());",138,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(Comma, Arg.getTrailingComma());",140,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionCallArgument().print(OS);,154,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",155,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,.withExpression(SymbolicRef).print(OS);,162,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo"");",163,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,170,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, "");",171,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,190,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, "");",191,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",262,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArg1.hasSameIdentityAs(GottenArg1_2));,269,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArg1.print(OS);,270,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, "");",271,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArg2.hasSameIdentityAs(GottenArg2_2));,279,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArg2.print(OS);,280,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""y: foo, "");",281,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArg3.hasSameIdentityAs(GottenArg3_2));,289,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArg3.print(OS);,290,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""z: foo"");",291,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionCallArgumentList().print(OS);,299,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",300,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ArgList.print(OS);,323,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",324,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, y: foo, z: foo"");",325,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",333,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ArgList.print(OS);,334,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",335,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, y: foo, z: foo"");",336,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenExpression1.hasSameIdentityAs(GottenExpression2));,354,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenExpression1.print(OS);,357,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo"");",358,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(LeftParen, Call.getLeftParen());",361,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(RightParen, Call.getRightParen());",362,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArgs1.hasSameIdentityAs(GottenArgs2));,367,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArgs1.print(OS);,370,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, y: foo, z: foo"");",371,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,Call.print(OS);,387,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo(x: foo, y: foo, z: foo)"");",388,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionCallExpr().print(OS);,394,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",395,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,413,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo()"");",414,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,424,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo(1, 2, 3)"");",425,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,435,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",436,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,447,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""()"");",448,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,467,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo()"");",468,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,477,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo(1, )"");",478,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,485,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo(1, 1)"");",486,download/apple_swift372.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/TriviaTests.cpp,-,"ASSERT_EQ(Trivia().size(), 0);",258,download/apple_swift373.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/TriviaTests.cpp,-,"ASSERT_EQ(Trivia::spaces(1).size(), 1);",258,download/apple_swift373.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia().size(), size_t(0));",258,download/apple_swift373.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia::spaces(1).size(), size_t(1));",259,download/apple_swift373.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/TriviaTests.cpp,-,"ASSERT_EQ((Trivia::spaces(1) + Trivia::spaces(1)).size(), 2);",262,download/apple_swift373.cpp
6a51c4975243930e7ff4198003880fe42ba2850f,"Merge pull request #7790 from bitjammer/sr-4044-function-call-expr-syntax

[Syntax] Implement stuff for function call expressions",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ((Trivia::spaces(1) + Trivia::spaces(1)).size(), size_t(2));",262,download/apple_swift373.cpp
0611d663b841a61da6949cacc5a1bcf0db50cefe,SIL: Remove SILType::getSwiftType(),lib/SILGen/SILGenApply.cpp,-,assert(isAnyObjectType(emittedArg.getSwiftType()));,3455,download/apple_swift374.cpp
0611d663b841a61da6949cacc5a1bcf0db50cefe,SIL: Remove SILType::getSwiftType(),lib/SILGen/SILGenApply.cpp,+,assert(isAnyObjectType(emittedArg.getType().getSwiftRValueType()));,3455,download/apple_swift374.cpp
e2a4b24fcded79ff909f710630eb82109dd74000,SILGen: Remove sillyness from materializeForSet emission,lib/SILGen/SILGenMaterializeForSet.cpp,-,assert(selfTuple->getNumElements() == 1);,455,download/apple_swift375.cpp
83ca7a852fe8f73ab397cd61fc48d6a7063ea8af,AST: Remove TypeBase::getClassBound(),lib/AST/Type.cpp,-,assert(archetypeTy->requiresClass());,551,download/apple_swift376.cpp
83ca7a852fe8f73ab397cd61fc48d6a7063ea8af,AST: Remove TypeBase::getClassBound(),lib/IRGen/GenCast.cpp,-,assert(destClass || toType.is<ArchetypeType>());,149,download/apple_swift377.cpp
83ca7a852fe8f73ab397cd61fc48d6a7063ea8af,AST: Remove TypeBase::getClassBound(),lib/IRGen/GenCast.cpp,+,assert(destClass != nullptr);,155,download/apple_swift377.cpp
4ca5821dbd7ecda5fd45b5b64ae8b97b5b9ee2ff,AST: Simplify TypeBase::getRValueType(),lib/AST/Type.cpp,-,assert(!lvt->getObjectType()->isLValueType(),454,download/apple_swift378.cpp
4ca5821dbd7ecda5fd45b5b64ae8b97b5b9ee2ff,AST: Simplify TypeBase::getRValueType(),lib/AST/Type.cpp,-,assert(!t->isLValueType(),473,download/apple_swift378.cpp
721e6178f55d657643b01cd6b8ce27e1a69ff751,AST: Remove TypeBase::isUnspecializedGeneric(),lib/Sema/CSDiag.cpp,-,if (type->hasError() || type->hasTypeVariable() ||,5919,download/apple_swift379.cpp
4b6cfaf5337adc647a0667b8682715edcdb3b8e7,"Merge pull request #7796 from shajrawi/deinit_existential

Support for deinit of opaque existentials: deinit_existential_opaque instruction + SILGen support",lib/Parse/ParseSIL.cpp,+,"if (parseTypedValueRef(Val, B) || parseSILDebugLocation(InstLoc, B))",3728,download/apple_swift380.cpp
4b6cfaf5337adc647a0667b8682715edcdb3b8e7,"Merge pull request #7796 from shajrawi/deinit_existential

Support for deinit of opaque existentials: deinit_existential_opaque instruction + SILGen support",lib/SILGen/SILGenConvert.cpp,-,assert(!existentialValue.hasCleanup());,808,download/apple_swift381.cpp
4b6cfaf5337adc647a0667b8682715edcdb3b8e7,"Merge pull request #7796 from shajrawi/deinit_existential

Support for deinit of opaque existentials: deinit_existential_opaque instruction + SILGen support",lib/SILGen/SILGenExpr.cpp,-,assert(lowering.getLoweredType().getAddressType() == v->getType());,293,download/apple_swift382.cpp
4b6cfaf5337adc647a0667b8682715edcdb3b8e7,"Merge pull request #7796 from shajrawi/deinit_existential

Support for deinit of opaque existentials: deinit_existential_opaque instruction + SILGen support",lib/SILGen/SILGenExpr.cpp,+,assert(lowering.getLoweredType().getAddressType() == v->getType() ||,293,download/apple_swift382.cpp
16b6cb5e1dbd8b3e077e289f10804580766277af,Support for deinit of opaque existentials: deinit_existential_opaque instruction + SILGen support,lib/Parse/ParseSIL.cpp,+,"if (parseTypedValueRef(Val, B) || parseSILDebugLocation(InstLoc, B))",3728,download/apple_swift383.cpp
16b6cb5e1dbd8b3e077e289f10804580766277af,Support for deinit of opaque existentials: deinit_existential_opaque instruction + SILGen support,lib/SILGen/SILGenConvert.cpp,-,assert(!existentialValue.hasCleanup());,808,download/apple_swift384.cpp
16b6cb5e1dbd8b3e077e289f10804580766277af,Support for deinit of opaque existentials: deinit_existential_opaque instruction + SILGen support,lib/SILGen/SILGenExpr.cpp,-,assert(lowering.getLoweredType().getAddressType() == v->getType());,293,download/apple_swift385.cpp
16b6cb5e1dbd8b3e077e289f10804580766277af,Support for deinit of opaque existentials: deinit_existential_opaque instruction + SILGen support,lib/SILGen/SILGenExpr.cpp,+,assert(lowering.getLoweredType().getAddressType() == v->getType() ||,293,download/apple_swift385.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Layout.size() == 2);,121,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token(Raw,",122,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_kind(Raw,",124,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,163,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token(Raw, FunctionCallArgumentSyntax::Cursor::Label,",203,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",205,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,assert(,208,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",211,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,assert(NewLabel->getTokenKind() == tok::identifier);,251,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(NewColon, tok::colon, "":"");",262,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(NewTrailingComma, tok::comma, "","");",297,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,assert(Child->Kind == SyntaxKind::FunctionCallArgument);,311,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,assert(Index <= getRaw()->Layout.size());,351,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Layout.size() == 4);,385,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->getChild(FunctionCallExprSyntax::Cursor::CalledExpression),386,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionCallExprSyntax::Cursor::LeftParen,",388,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionCallExprSyntax::Cursor::ArgumentList,",390,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",392,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",455,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",489,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(LeftParen, tok::l_paren, ""("");",503,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_token_is(RightParen, tok::r_paren, "")"");",524,download/apple_swift386.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(Ref.getIdentifier(), Array);",29,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArgs.hasSameIdentityAs(GottenArgs2));,33,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArgs.print(OS);,38,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""<Int>"");",39,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,SyntaxFactory::makeBlankSymbolicReferenceExpr().print(OS);,57,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"SyntaxFactory::makeSymbolicReferenceExpr(Foo, BlankArgs).print(OS);",67,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"SyntaxFactory::makeSymbolicReferenceExpr(Array, GenericArgs).print(OS);",74,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""Array<Int>"");",75,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,94,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""Array"");",95,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,102,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""<Int>"");",103,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,111,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""Array<Int>"");",112,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(X, Arg.getLabel());",129,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(Colon, Arg.getColonToken());",130,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenExpr.hasSameIdentityAs(GottenExpr2));,134,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenExpr.print(OS);,137,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(""foo"", OS.str().str());",138,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(Comma, Arg.getTrailingComma());",140,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionCallArgument().print(OS);,154,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",155,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,.withExpression(SymbolicRef).print(OS);,162,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo"");",163,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,170,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, "");",171,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,190,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, "");",191,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",262,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArg1.hasSameIdentityAs(GottenArg1_2));,269,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArg1.print(OS);,270,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, "");",271,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArg2.hasSameIdentityAs(GottenArg2_2));,279,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArg2.print(OS);,280,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""y: foo, "");",281,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArg3.hasSameIdentityAs(GottenArg3_2));,289,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArg3.print(OS);,290,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""z: foo"");",291,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionCallArgumentList().print(OS);,299,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",300,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ArgList.print(OS);,323,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",324,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, y: foo, z: foo"");",325,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",333,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ArgList.print(OS);,334,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(ArgList.getNumArguments(), size_t(3));",335,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, y: foo, z: foo"");",336,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenExpression1.hasSameIdentityAs(GottenExpression2));,354,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenExpression1.print(OS);,357,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo"");",358,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(LeftParen, Call.getLeftParen());",361,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(RightParen, Call.getRightParen());",362,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,ASSERT_TRUE(GottenArgs1.hasSameIdentityAs(GottenArgs2));,367,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,GottenArgs1.print(OS);,370,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""x: foo, y: foo, z: foo"");",371,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,Call.print(OS);,387,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo(x: foo, y: foo, z: foo)"");",388,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,SyntaxFactory::makeBlankFunctionCallExpr().print(OS);,394,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",395,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,413,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo()"");",414,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,.print(OS);,424,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo(1, 2, 3)"");",425,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,435,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",436,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,447,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""()"");",448,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,467,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo()"");",468,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,477,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo(1, )"");",478,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,CallBuilder.build().print(OS);,485,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/ExprSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""foo(1, 1)"");",486,download/apple_swift387.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/TriviaTests.cpp,-,"ASSERT_EQ(Trivia().size(), 0);",258,download/apple_swift388.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/TriviaTests.cpp,-,"ASSERT_EQ(Trivia::spaces(1).size(), 1);",258,download/apple_swift388.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia().size(), size_t(0));",258,download/apple_swift388.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia::spaces(1).size(), size_t(1));",259,download/apple_swift388.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/TriviaTests.cpp,-,"ASSERT_EQ((Trivia::spaces(1) + Trivia::spaces(1)).size(), 2);",262,download/apple_swift388.cpp
c8bb2b8c32d6c6f7b98fea6f2239f6062635bee6,"[Syntax] Implement function-call-expression in lib/Syntax

Also includes for its substructure:
- function-call-argument
- function-call-argument-list
- symbolic-reference-expression (for the call target)

https://bugs.swift.org/browse/SR-4044",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ((Trivia::spaces(1) + Trivia::spaces(1)).size(), size_t(2));",262,download/apple_swift388.cpp
6c1eec81c44400fd4cefb5d7df32b861a3e6a066,"Merge pull request #7557 from mtake/enhance-assume-single-threaded

Enhance -assume-single-threaded option (SR-3945)",stdlib/public/runtime/HeapObject.cpp,+,assert(object->metadata->isClassObject());,361,download/apple_swift389.cpp
6c1eec81c44400fd4cefb5d7df32b861a3e6a066,"Merge pull request #7557 from mtake/enhance-assume-single-threaded

Enhance -assume-single-threaded option (SR-3945)",stdlib/public/runtime/HeapObject.cpp,+,assert(static_cast<const ClassMetadata*>(object->metadata)->isTypeMetadata());,362,download/apple_swift389.cpp
6c1eec81c44400fd4cefb5d7df32b861a3e6a066,"Merge pull request #7557 from mtake/enhance-assume-single-threaded

Enhance -assume-single-threaded option (SR-3945)",stdlib/public/runtime/HeapObject.cpp,+,assert(object->metadata->isClassObject());,412,download/apple_swift389.cpp
6c1eec81c44400fd4cefb5d7df32b861a3e6a066,"Merge pull request #7557 from mtake/enhance-assume-single-threaded

Enhance -assume-single-threaded option (SR-3945)",stdlib/public/runtime/HeapObject.cpp,+,assert(static_cast<const ClassMetadata*>(object->metadata)->isTypeMetadata());,413,download/apple_swift389.cpp
6c1eec81c44400fd4cefb5d7df32b861a3e6a066,"Merge pull request #7557 from mtake/enhance-assume-single-threaded

Enhance -assume-single-threaded option (SR-3945)",stdlib/public/runtime/HeapObject.cpp,+,assert(object->refCounts.getUnownedCount() &&,507,download/apple_swift389.cpp
6c1eec81c44400fd4cefb5d7df32b861a3e6a066,"Merge pull request #7557 from mtake/enhance-assume-single-threaded

Enhance -assume-single-threaded option (SR-3945)",stdlib/public/runtime/HeapObject.cpp,+,assert(object->refCounts.getUnownedCount() &&,534,download/apple_swift389.cpp
6c1eec81c44400fd4cefb5d7df32b861a3e6a066,"Merge pull request #7557 from mtake/enhance-assume-single-threaded

Enhance -assume-single-threaded option (SR-3945)",stdlib/public/runtime/HeapObject.cpp,+,"assert(!dealloc && ""retain-strong-and-release caused dealloc?"");",542,download/apple_swift389.cpp
958cea5f5c0c4674b945fa65b3287fbabad2f26a,Merge pull request #7787 from DougGregor/same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,-,concreteType.print(Out);,1347,download/apple_swift390.cpp
958cea5f5c0c4674b945fa65b3287fbabad2f26a,Merge pull request #7787 from DougGregor/same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,-,"concreteTypeSource->print(Out, SrcMgr);",1356,download/apple_swift390.cpp
958cea5f5c0c4674b945fa65b3287fbabad2f26a,Merge pull request #7787 from DougGregor/same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,+,constraint.concreteType.print(Out);,1358,download/apple_swift390.cpp
958cea5f5c0c4674b945fa65b3287fbabad2f26a,Merge pull request #7787 from DougGregor/same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,+,"constraint.source->print(Out, SrcMgr);",1364,download/apple_swift390.cpp
958cea5f5c0c4674b945fa65b3287fbabad2f26a,Merge pull request #7787 from DougGregor/same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,+,assert(paToComponent.count(concrete.archetype) > 0);,2958,download/apple_swift390.cpp
47b43097edc869c55dba9849b189ee1bdaee6edf,"Merge pull request #7779 from slavapestov/devirt-gardening

Simplify devirtualization and fix a bug",lib/SILOptimizer/Utils/Devirtualize.cpp,-,assert(substArgIdx == substConv.getNumSILArguments());,912,download/apple_swift391.cpp
47b43097edc869c55dba9849b189ee1bdaee6edf,"Merge pull request #7779 from slavapestov/devirt-gardening

Simplify devirtualization and fix a bug",lib/SILOptimizer/Utils/Local.cpp,+,assert(SrcTy.isAddress() == DestTy.isAddress() &&,490,download/apple_swift392.cpp
0c0de0adf47a1afbfd4b3a51567d04c2ca41b72d,"[AST] Move storage of same-type-to-concrete constraints to EquivalenceClass.

Most clients that will be considering same-type-to-concrete
constraints will need to look at all of the constraints within the
equivalence class together. Store the same-type-to-concrete
constraints on the EquivalenceClass itself, which fits this use case
better, and should reduce the storage requirements by making potential
archetypes two pointers smaller. NFC",lib/AST/GenericSignatureBuilder.cpp,-,concreteType.print(Out);,1347,download/apple_swift393.cpp
0c0de0adf47a1afbfd4b3a51567d04c2ca41b72d,"[AST] Move storage of same-type-to-concrete constraints to EquivalenceClass.

Most clients that will be considering same-type-to-concrete
constraints will need to look at all of the constraints within the
equivalence class together. Store the same-type-to-concrete
constraints on the EquivalenceClass itself, which fits this use case
better, and should reduce the storage requirements by making potential
archetypes two pointers smaller. NFC",lib/AST/GenericSignatureBuilder.cpp,-,"concreteTypeSource->print(Out, SrcMgr);",1356,download/apple_swift393.cpp
0c0de0adf47a1afbfd4b3a51567d04c2ca41b72d,"[AST] Move storage of same-type-to-concrete constraints to EquivalenceClass.

Most clients that will be considering same-type-to-concrete
constraints will need to look at all of the constraints within the
equivalence class together. Store the same-type-to-concrete
constraints on the EquivalenceClass itself, which fits this use case
better, and should reduce the storage requirements by making potential
archetypes two pointers smaller. NFC",lib/AST/GenericSignatureBuilder.cpp,+,constraint.concreteType.print(Out);,1358,download/apple_swift393.cpp
0c0de0adf47a1afbfd4b3a51567d04c2ca41b72d,"[AST] Move storage of same-type-to-concrete constraints to EquivalenceClass.

Most clients that will be considering same-type-to-concrete
constraints will need to look at all of the constraints within the
equivalence class together. Store the same-type-to-concrete
constraints on the EquivalenceClass itself, which fits this use case
better, and should reduce the storage requirements by making potential
archetypes two pointers smaller. NFC",lib/AST/GenericSignatureBuilder.cpp,+,"constraint.source->print(Out, SrcMgr);",1364,download/apple_swift393.cpp
0c0de0adf47a1afbfd4b3a51567d04c2ca41b72d,"[AST] Move storage of same-type-to-concrete constraints to EquivalenceClass.

Most clients that will be considering same-type-to-concrete
constraints will need to look at all of the constraints within the
equivalence class together. Store the same-type-to-concrete
constraints on the EquivalenceClass itself, which fits this use case
better, and should reduce the storage requirements by making potential
archetypes two pointers smaller. NFC",lib/AST/GenericSignatureBuilder.cpp,+,assert(paToComponent.count(concrete.archetype) > 0);,2968,download/apple_swift393.cpp
99ceb78c7dea2a244bb0e775aed2d8c87573901c,"Merge pull request #7723 from practicalswift/gardening-20170223

[gardening] Shell fixes. Consistent headers. a-vs-an typos. Python fixes. Unused variables and methods.",lib/AST/GenericSignatureBuilder.cpp,-,assert(ParamDepth <= MaxDepth);,2328,download/apple_swift394.cpp
2994415343a1914b5fda6f1069220abcbbd1b5a2,SILOptimizer: Simplify castABIcastValueToABICompatibleType(),lib/SILOptimizer/Utils/Local.cpp,+,assert(SrcTy.isAddress() == DestTy.isAddress() &&,487,download/apple_swift395.cpp
4ed09b4a73c920914fef288ac270e8d1ae334447,"SILOptimizer: Remove some workarounds for old problems

It looks like the devirtualizer used to have problems computing
method types in the presence of generic substitutions, covariant
returns and other things, so it would bail if a perticular set
of pre-conditions was not met on the types of original method call
and the devirtualized method call.

I don't think any of this is necessary anymore. If this patch
introduces any regressions, we need to fix the root cause instead
of re-introducing this logic.",lib/SILOptimizer/Utils/Devirtualize.cpp,-,assert(substArgIdx == substConv.getNumSILArguments());,912,download/apple_swift396.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,-,assert(metadata->isClassObject());,366,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,-,assert(classMetadata->isTypeMetadata());,367,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,+,assert(object->metadata->isClassObject());,368,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,+,assert(static_cast<const ClassMetadata*>(object->metadata)->isTypeMetadata());,369,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,-,assert(metadata->isClassObject());,417,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,-,assert(classMetadata->isTypeMetadata());,418,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,+,assert(object->metadata->isClassObject());,419,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,+,assert(static_cast<const ClassMetadata*>(object->metadata)->isTypeMetadata());,420,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,-,assert(object->weakRefCount.getCount() &&,508,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,+,assert(object->refCounts.getUnownedCount() &&,509,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,-,assert(object->weakRefCount.getCount() &&,535,download/apple_swift397.cpp
69768ad5403f922b349ce536a8ddb7ffb937ad3d,Update for the new reference counting mechanism,stdlib/public/runtime/HeapObject.cpp,+,assert(object->refCounts.getUnownedCount() &&,536,download/apple_swift397.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"assert(hashIter != valueHashMap.end() && ""Missing SILValue"");",82,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"assert(hashResult.second && ""SILValue already mapped"");",110,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(onlyHaveDebugUses(inst));,134,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(instsToDelete.count(use->getUser()));,136,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"llvm::report_fatal_error(""Simultaneous use of multiple call results."");",513,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(origDirectResultValues.size() == 1);,560,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(argIdx < loweredFnConv.getSILArgIndexOfFirstParam());,619,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(addr);,624,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!origFnConv.isSILIndirect(resultInfo));,646,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(addr);,659,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(argIdx == loweredFnConv.getSILArgIndexOfFirstParam());,678,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newResultArgIdx == loweredFnConv.getSILArgIndexOfFirstParam());,678,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(origFnConv.getNumDirectSILResults() == 1);,689,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.valueStorageMap.contains(origCallInst));,690,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(loweredFnConv.isSILIndirect(resultInfo));,697,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.valueStorageMap.contains(extractInst));,698,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(extractInst->use_empty());,704,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newCallInst->getType().is<TupleType>());,711,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueStorageI.first->dump());",730,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueDef->dump());",730,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""REWRITE ""; V->dump());",753,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""  REWRITE ""; V->dump());",753,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""CALL ""; applyInst->dump();",760,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""  CALL ""; applyInst->dump();",763,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void visitDebugValueInst(DebugValueInst *debugInst) {,779,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"B.createDebugValueAddr(debugInst->getLoc(), addr);",782,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(currOper->get() == destroyInst->getOperand());,788,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!currOper);,796,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(currOper->get() == returnInst->getOperand());,807,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(origDirectResultValues.size() == numOrigDirectResults);,828,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!origFnConv.isSILIndirect(resultInfo));,858,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newResultArgIdx < loweredFnConv.getSILArgIndexOfFirstParam());,860,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newDirectResults.size() == loweredFnConv.getNumDirectSILResults());,883,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(currOper->get() == storeInst->getSrc());,909,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storeInst->getOwnershipQualifier() ==,912,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(extractInst->use_empty(),912,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""LOWER ""; F->dump());",931,download/apple_swift398.cpp
99de1fd10b13cbfd9b2f89d308c64cfe8c99e280,Merge pull request #7774 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""\nREWRITING: "" << F->getName(); F->dump());",938,download/apple_swift398.cpp
00590167cf07063029baa7dd8ec204b4c63f840b,"Merge pull request #7752 from slavapestov/generic-subscript-materialize-for-set

Generic subscript materializeForSet emission",lib/IRGen/IRGenSIL.cpp,-,assert(subs.size() >= 1);,1892,download/apple_swift399.cpp
00590167cf07063029baa7dd8ec204b4c63f840b,"Merge pull request #7752 from slavapestov/generic-subscript-materialize-for-set

Generic subscript materializeForSet emission",lib/IRGen/IRGenSIL.cpp,-,assert(subs[0].getConformances().size() == 1);,1892,download/apple_swift399.cpp
00590167cf07063029baa7dd8ec204b4c63f840b,"Merge pull request #7752 from slavapestov/generic-subscript-materialize-for-set

Generic subscript materializeForSet emission",lib/IRGen/IRGenSIL.cpp,-,assert(conformance.getRequirement() == proto); (void) proto;,1894,download/apple_swift399.cpp
754c7feb2669bf93ec80a9d30ed4c38b9c279a55,"IRGen: Use SubstitutionMap in one spot

Eventually I'd like SubstitutionLists to be opaque, and not
ArrayRefs.",lib/IRGen/IRGenSIL.cpp,-,assert(subs.size() >= 1);,1892,download/apple_swift400.cpp
754c7feb2669bf93ec80a9d30ed4c38b9c279a55,"IRGen: Use SubstitutionMap in one spot

Eventually I'd like SubstitutionLists to be opaque, and not
ArrayRefs.",lib/IRGen/IRGenSIL.cpp,-,assert(subs[0].getConformances().size() == 1);,1892,download/apple_swift400.cpp
754c7feb2669bf93ec80a9d30ed4c38b9c279a55,"IRGen: Use SubstitutionMap in one spot

Eventually I'd like SubstitutionLists to be opaque, and not
ArrayRefs.",lib/IRGen/IRGenSIL.cpp,-,assert(conformance.getRequirement() == proto); (void) proto;,1894,download/apple_swift400.cpp
4f68ccf86e41a7f1324506f2ecb250448dd06d50,Add swift_nonatomic_unowned(Retain|Release)_n,stdlib/public/runtime/HeapObject.cpp,+,assert(metadata->isClassObject());,413,download/apple_swift401.cpp
4f68ccf86e41a7f1324506f2ecb250448dd06d50,Add swift_nonatomic_unowned(Retain|Release)_n,stdlib/public/runtime/HeapObject.cpp,+,assert(classMetadata->isTypeMetadata());,415,download/apple_swift401.cpp
488d531846e59bcfb50718758c980feb44f3d79e,Enhance -assume-single-threaded option (SR-3945),stdlib/public/runtime/HeapObject.cpp,+,assert(metadata->isClassObject());,363,download/apple_swift402.cpp
488d531846e59bcfb50718758c980feb44f3d79e,Enhance -assume-single-threaded option (SR-3945),stdlib/public/runtime/HeapObject.cpp,+,assert(classMetadata->isTypeMetadata());,365,download/apple_swift402.cpp
488d531846e59bcfb50718758c980feb44f3d79e,Enhance -assume-single-threaded option (SR-3945),stdlib/public/runtime/HeapObject.cpp,+,assert(object->weakRefCount.getCount() &&,481,download/apple_swift402.cpp
488d531846e59bcfb50718758c980feb44f3d79e,Enhance -assume-single-threaded option (SR-3945),stdlib/public/runtime/HeapObject.cpp,+,assert(object->weakRefCount.getCount() &&,508,download/apple_swift402.cpp
488d531846e59bcfb50718758c980feb44f3d79e,Enhance -assume-single-threaded option (SR-3945),stdlib/public/runtime/HeapObject.cpp,+,"assert(!dealloc && ""retain-strong-and-release caused dealloc?"");",516,download/apple_swift402.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"assert(hashIter != valueHashMap.end() && ""Missing SILValue"");",82,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"assert(hashResult.second && ""SILValue already mapped"");",110,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(onlyHaveDebugUses(inst));,134,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(instsToDelete.count(use->getUser()));,136,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"llvm::report_fatal_error(""Simultaneous use of multiple call results."");",513,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(origDirectResultValues.size() == 1);,560,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(argIdx < loweredFnConv.getSILArgIndexOfFirstParam());,619,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(addr);,624,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!origFnConv.isSILIndirect(resultInfo));,646,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(addr);,659,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(argIdx == loweredFnConv.getSILArgIndexOfFirstParam());,678,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newResultArgIdx == loweredFnConv.getSILArgIndexOfFirstParam());,678,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(origFnConv.getNumDirectSILResults() == 1);,689,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.valueStorageMap.contains(origCallInst));,690,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(loweredFnConv.isSILIndirect(resultInfo));,697,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(pass.valueStorageMap.contains(extractInst));,698,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(extractInst->use_empty());,704,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newCallInst->getType().is<TupleType>());,711,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueStorageI.first->dump());",730,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueDef->dump());",730,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""REWRITE ""; V->dump());",753,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""  REWRITE ""; V->dump());",753,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""CALL ""; applyInst->dump();",760,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""  CALL ""; applyInst->dump();",763,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void visitDebugValueInst(DebugValueInst *debugInst) {,779,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"B.createDebugValueAddr(debugInst->getLoc(), addr);",782,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(currOper->get() == destroyInst->getOperand());,788,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!currOper);,796,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(currOper->get() == returnInst->getOperand());,807,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(origDirectResultValues.size() == numOrigDirectResults);,828,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!origFnConv.isSILIndirect(resultInfo));,858,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newResultArgIdx < loweredFnConv.getSILArgIndexOfFirstParam());,860,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(newDirectResults.size() == loweredFnConv.getNumDirectSILResults());,883,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(currOper->get() == storeInst->getSrc());,909,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(storeInst->getOwnershipQualifier() ==,912,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(extractInst->use_empty(),912,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""LOWER ""; F->dump());",931,download/apple_swift403.cpp
38d44c216405817bd8f42b474b7aa968eb12f364,"AddressLowering: rewrite the call-site lowering logic.

This pass now canonicalizes results before lowering and handles all combinations
of direct and indirect multiple return values. The logic is much less ad-hoc and
more robust.

try_apply still isn't handled, but should be much easier now.

Add visitLoadInst, visitStoreInst, visitDebugValueInst, etc.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""\nREWRITING: "" << F->getName(); F->dump());",938,download/apple_swift403.cpp
bf25f8d55bbefcacc1b5414b3b094324711db7c4,"Merge pull request #7771 from jckarter/bogus-noescape-error

Sema: Don't raise bogus escape diagnostics about captures in closures with errors.",lib/Sema/TypeCheckCaptures.cpp,+,!AFR.getType()->hasError() &&,197,download/apple_swift404.cpp
43f841e5853bdae9a8db1a839cb31a752aa52842,Sema: Don't raise bogus escape diagnostics about captures in closures with errors.,lib/Sema/TypeCheckCaptures.cpp,+,!AFR.getType()->hasError() &&,197,download/apple_swift405.cpp
bb0ac20bb6767b21f4f6d6d813c1da903d78917c,"Merge pull request #7770 from slavapestov/irgen-cleanup-and-crashers

IRGen cleanup and crashers",lib/IRGen/IRGenSIL.cpp,-,assert(witnessMetadata->SelfWitnessTable->getType() ==,1999,download/apple_swift406.cpp
bb0ac20bb6767b21f4f6d6d813c1da903d78917c,"Merge pull request #7770 from slavapestov/irgen-cleanup-and-crashers

IRGen cleanup and crashers",lib/IRGen/IRGenSIL.cpp,-,assert(wtable->getType() == IGF.IGM.WitnessTablePtrTy);,2222,download/apple_swift406.cpp
18550b171dbba1c9cbf9aa763ea3fcc13ef0df3b,"IRGen: witness_method function values no longer carry witness table

This was an unnecessary complication and didn't make a lot of
logical sense, because we can recover the witness table from
substitutions when we call a @convention(witness_method) anyway.

Also, to fix materializeForSet for generic subscripts, I want the
materializeForSet *callback* of a protocol witness to have
@convention(witness_method), which requires representing such
functions as a single function pointer in IRGen.",lib/IRGen/IRGenSIL.cpp,-,assert(witnessMetadata->SelfWitnessTable->getType() ==,1999,download/apple_swift407.cpp
18550b171dbba1c9cbf9aa763ea3fcc13ef0df3b,"IRGen: witness_method function values no longer carry witness table

This was an unnecessary complication and didn't make a lot of
logical sense, because we can recover the witness table from
substitutions when we call a @convention(witness_method) anyway.

Also, to fix materializeForSet for generic subscripts, I want the
materializeForSet *callback* of a protocol witness to have
@convention(witness_method), which requires representing such
functions as a single function pointer in IRGen.",lib/IRGen/IRGenSIL.cpp,-,assert(wtable->getType() == IGF.IGM.WitnessTablePtrTy);,2222,download/apple_swift407.cpp
a0c03d0a5bf327fab085d5a1bae3a122c06bda68,"Merge pull request #7761 from jckarter/nserror-linux-bridging

Sema/SIL: NSError has no special powers without ObjC interop.",lib/SIL/DynamicCasts.cpp,-,if (auto nserror = M.Types.getNSErrorType()),1157,download/apple_swift408.cpp
a0c03d0a5bf327fab085d5a1bae3a122c06bda68,"Merge pull request #7761 from jckarter/nserror-linux-bridging

Sema/SIL: NSError has no special powers without ObjC interop.",lib/SIL/DynamicCasts.cpp,+,if (auto nserror = M.Types.getNSErrorType()),1162,download/apple_swift408.cpp
a0c03d0a5bf327fab085d5a1bae3a122c06bda68,"Merge pull request #7761 from jckarter/nserror-linux-bridging

Sema/SIL: NSError has no special powers without ObjC interop.",lib/SIL/DynamicCasts.cpp,-,if (targetType == M.Types.getNSErrorType()) {,1173,download/apple_swift408.cpp
a0c03d0a5bf327fab085d5a1bae3a122c06bda68,"Merge pull request #7761 from jckarter/nserror-linux-bridging

Sema/SIL: NSError has no special powers without ObjC interop.",lib/SIL/DynamicCasts.cpp,+,&& targetType == M.Types.getNSErrorType()) {,1174,download/apple_swift408.cpp
a0c03d0a5bf327fab085d5a1bae3a122c06bda68,"Merge pull request #7761 from jckarter/nserror-linux-bridging

Sema/SIL: NSError has no special powers without ObjC interop.",lib/Sema/TypeCheckConstraints.cpp,-,if (auto NSErrorTy = getNSErrorType(dc)),3372,download/apple_swift409.cpp
a0c03d0a5bf327fab085d5a1bae3a122c06bda68,"Merge pull request #7761 from jckarter/nserror-linux-bridging

Sema/SIL: NSError has no special powers without ObjC interop.",lib/Sema/TypeCheckConstraints.cpp,+,if (auto NSErrorTy = getNSErrorType(dc)),3382,download/apple_swift409.cpp
d998692b60c72976eac83cd0616babe7567a9a19,"Sema/SIL: NSError has no special powers without ObjC interop.

In particular, it doesn't ""toll-free bridge"" to the Error existential on non-ObjC-interop platforms, and we would miscompile as if it could. This should fix SR-585.",lib/SIL/DynamicCasts.cpp,-,if (auto nserror = M.Types.getNSErrorType()),1157,download/apple_swift410.cpp
d998692b60c72976eac83cd0616babe7567a9a19,"Sema/SIL: NSError has no special powers without ObjC interop.

In particular, it doesn't ""toll-free bridge"" to the Error existential on non-ObjC-interop platforms, and we would miscompile as if it could. This should fix SR-585.",lib/SIL/DynamicCasts.cpp,+,if (auto nserror = M.Types.getNSErrorType()),1162,download/apple_swift410.cpp
d998692b60c72976eac83cd0616babe7567a9a19,"Sema/SIL: NSError has no special powers without ObjC interop.

In particular, it doesn't ""toll-free bridge"" to the Error existential on non-ObjC-interop platforms, and we would miscompile as if it could. This should fix SR-585.",lib/SIL/DynamicCasts.cpp,-,if (targetType == M.Types.getNSErrorType()) {,1173,download/apple_swift410.cpp
d998692b60c72976eac83cd0616babe7567a9a19,"Sema/SIL: NSError has no special powers without ObjC interop.

In particular, it doesn't ""toll-free bridge"" to the Error existential on non-ObjC-interop platforms, and we would miscompile as if it could. This should fix SR-585.",lib/SIL/DynamicCasts.cpp,+,&& targetType == M.Types.getNSErrorType()) {,1174,download/apple_swift410.cpp
d998692b60c72976eac83cd0616babe7567a9a19,"Sema/SIL: NSError has no special powers without ObjC interop.

In particular, it doesn't ""toll-free bridge"" to the Error existential on non-ObjC-interop platforms, and we would miscompile as if it could. This should fix SR-585.",lib/Sema/TypeCheckConstraints.cpp,-,if (auto NSErrorTy = getNSErrorType(dc)),3372,download/apple_swift411.cpp
d998692b60c72976eac83cd0616babe7567a9a19,"Sema/SIL: NSError has no special powers without ObjC interop.

In particular, it doesn't ""toll-free bridge"" to the Error existential on non-ObjC-interop platforms, and we would miscompile as if it could. This should fix SR-585.",lib/Sema/TypeCheckConstraints.cpp,+,if (auto NSErrorTy = getNSErrorType(dc)),3382,download/apple_swift411.cpp
76525439d0d08e9606cced9c39960c80a0a196db,[TypeCheck] Bad Self GTPTs from invalid protocols shouldn't crash.,lib/Sema/TypeCheckGeneric.cpp,-,assert(gp->getDepth() == 0 && gp->getIndex() == 0 &&,133,download/apple_swift412.cpp
76525439d0d08e9606cced9c39960c80a0a196db,[TypeCheck] Bad Self GTPTs from invalid protocols shouldn't crash.,lib/Sema/TypeCheckGeneric.cpp,+,assert(gp->isEqual(Proto->getSelfInterfaceType()) &&,133,download/apple_swift412.cpp
76525439d0d08e9606cced9c39960c80a0a196db,[TypeCheck] Bad Self GTPTs from invalid protocols shouldn't crash.,lib/Sema/TypeCheckGeneric.cpp,+,assert(selfTy->isEqual(Proto->getSelfInterfaceType()));,146,download/apple_swift412.cpp
fbd2c99936ebe671e147938c0367f8731105537e,Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child.get(), depth + 1);",48,download/apple_swift413.cpp
fbd2c99936ebe671e147938c0367f8731105537e,Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/DemangleWrappers.cpp,+,"printNode(Out, child, depth + 1);",48,download/apple_swift413.cpp
fbd2c99936ebe671e147938c0367f8731105537e,Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, Root.get(), 0);",55,download/apple_swift413.cpp
fbd2c99936ebe671e147938c0367f8731105537e,Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/DemangleWrappers.cpp,+,"printNode(Out, Root, 0);",55,download/apple_swift413.cpp
fbd2c99936ebe671e147938c0367f8731105537e,Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/Demangler.cpp,+,"assert(Child && ""adding null child!"");",265,download/apple_swift414.cpp
fbd2c99936ebe671e147938c0367f8731105537e,Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/Demangler.cpp,+,assert(NumChildren < ReservedChildren);,268,download/apple_swift414.cpp
fbd2c99936ebe671e147938c0367f8731105537e,Merge pull request #7758 from eeckstein/bumpptr-allocation,lib/Basic/Demangler.cpp,+,assert(End == CurPtr + SlabSize);,305,download/apple_swift414.cpp
2b29cd12ed3e255c285364aee578b23e02508f91,"[TypeCheck] Introduce simple ProtocolRequirementTypeResolver.

This does the limited form of resolution required when
validating/resolving types in protocol where clauses.",lib/Sema/TypeCheckGeneric.cpp,+,assert(gp->getDepth() == 0 && gp->getIndex() == 0 &&,133,download/apple_swift415.cpp
b762acf676a615cd29d50a17a287feb12b9cf765,"[TypeCheck] Diagnose inheriting from invalid things more reliably.

This in-particular is seemingly needed to cover the (rather broken)
following code:

    protocol P { associatedtype AT: AT }",lib/Sema/TypeCheckType.cpp,-,if (!type || type->hasError()),1090,download/apple_swift416.cpp
b762acf676a615cd29d50a17a287feb12b9cf765,"[TypeCheck] Diagnose inheriting from invalid things more reliably.

This in-particular is seemingly needed to cover the (rather broken)
following code:

    protocol P { associatedtype AT: AT }",lib/Sema/TypeCheckType.cpp,+,auto hasError = type->hasError();,1093,download/apple_swift416.cpp
84e0a109a2092bffebe2819958819350ccd85ed4,"[AST] Explicitly track the validation state of Decls.

Previously some decls (TypeAliasDecl and ExtensionDecl) had bits
explicitly marking whether they've been validated, while other decls
just deduced this from hasInterfaceType. The doing the latter doesn't
work when the interface type can be computed before doing full
validation (such as protocols and associatedtypes, which have trivial
interface types), and so an explicit bit is adopted for all decls.",lib/Sema/TypeCheckDecl.cpp,+,assert(D->isBeingValidated() || D->hasValidSignature());,6919,download/apple_swift417.cpp
7d7dc5aaac0f5581863c1d0d32fe5d2752d75e2a,"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child.get(), depth + 1);",48,download/apple_swift418.cpp
7d7dc5aaac0f5581863c1d0d32fe5d2752d75e2a,"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/DemangleWrappers.cpp,+,"printNode(Out, child, depth + 1);",48,download/apple_swift418.cpp
7d7dc5aaac0f5581863c1d0d32fe5d2752d75e2a,"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, Root.get(), 0);",55,download/apple_swift418.cpp
7d7dc5aaac0f5581863c1d0d32fe5d2752d75e2a,"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/DemangleWrappers.cpp,+,"printNode(Out, Root, 0);",55,download/apple_swift418.cpp
7d7dc5aaac0f5581863c1d0d32fe5d2752d75e2a,"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/Demangler.cpp,+,"assert(Child && ""adding null child!"");",265,download/apple_swift419.cpp
7d7dc5aaac0f5581863c1d0d32fe5d2752d75e2a,"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/Demangler.cpp,+,assert(NumChildren < ReservedChildren);,268,download/apple_swift419.cpp
7d7dc5aaac0f5581863c1d0d32fe5d2752d75e2a,"Demangler: Use a bump-pointer allocator for node allocation.

This makes the demangler about 10 times faster.
It also changes the lifetimes of nodes. Previously nodes were reference-counted.
Now the returned demangle  node-tree is owned by the Demangler class and it’s lifetime ends with the lifetime of the Demangler.

Therefore the old (and already deprecated) global functions demangleSymbolAsNode and demangleTypeAsNode are no longer available.

Another change is that the demangling for reflection now only supports the new mangling (which should be no problem because
we are generating only new mangled names for reflection).",lib/Basic/Demangler.cpp,+,assert(End == CurPtr + SlabSize);,305,download/apple_swift419.cpp
d64f7637859e51aeb39fada6fadcc6a44a1e9d1a,"Merge pull request #7732 from jckarter/retain-negative-pointers

Runtime: Have native refcounting entry points ignore negative pointer values on x86-64 and arm64.",stdlib/public/runtime/HeapObject.cpp,-,assert(object);,374,download/apple_swift420.cpp
d64f7637859e51aeb39fada6fadcc6a44a1e9d1a,"Merge pull request #7732 from jckarter/retain-negative-pointers

Runtime: Have native refcounting entry points ignore negative pointer values on x86-64 and arm64.",stdlib/public/runtime/HeapObject.cpp,+,assert(isValidPointerForNativeRetain(object));,374,download/apple_swift420.cpp
fc86f3547175eb3b9f7544e9ef4649f9fe360501,"Merge pull request #7750 from jckarter/static-stored-vars-in-concrete-extensions

SILGen: Allow static stored properties in fully-concrete extensions of generic types.",lib/SILGen/SILGenGlobalVariable.cpp,-,assert(!pd->getDeclContext()->isGenericContext());,205,download/apple_swift421.cpp
fc86f3547175eb3b9f7544e9ef4649f9fe360501,"Merge pull request #7750 from jckarter/static-stored-vars-in-concrete-extensions

SILGen: Allow static stored properties in fully-concrete extensions of generic types.",lib/SILGen/SILGenGlobalVariable.cpp,+,assert(!pd->getDeclContext()->isGenericContext(),206,download/apple_swift421.cpp
fc86f3547175eb3b9f7544e9ef4649f9fe360501,"Merge pull request #7750 from jckarter/static-stored-vars-in-concrete-extensions

SILGen: Allow static stored properties in fully-concrete extensions of generic types.",lib/SILGen/SILGenLValue.cpp,-,assert(!baseMeta->is<BoundGenericType>() &&,1762,download/apple_swift422.cpp
fc86f3547175eb3b9f7544e9ef4649f9fe360501,"Merge pull request #7750 from jckarter/static-stored-vars-in-concrete-extensions

SILGen: Allow static stored properties in fully-concrete extensions of generic types.",lib/SILGen/SILGenType.cpp,-,"assert(!generics && ""generic static properties not implemented"");",305,download/apple_swift423.cpp
fc86f3547175eb3b9f7544e9ef4649f9fe360501,"Merge pull request #7750 from jckarter/static-stored-vars-in-concrete-extensions

SILGen: Allow static stored properties in fully-concrete extensions of generic types.",lib/SILGen/SILGenType.cpp,+,assert(var->getDeclContext()->getGenericSignatureOfContext(),306,download/apple_swift423.cpp
b729f4c44def6c67bab3a066137a0f829689d48d,Merge pull request #7757 from jrose-apple/dump-truck,lib/Serialization/Deserialization.cpp,-,assert(!typeOrOffset.get()->hasError());,4243,download/apple_swift424.cpp
b729f4c44def6c67bab3a066137a0f829689d48d,Merge pull request #7757 from jrose-apple/dump-truck,lib/Serialization/Deserialization.cpp,+,if (typeOrOffset.get()->hasError()) {,4243,download/apple_swift424.cpp
41c6247b26531e7476d7c959601bfeb7cba49b54,Merge pull request #7755 from DougGregor/all-same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,-,ConcreteType.print(Out);,1361,download/apple_swift425.cpp
41c6247b26531e7476d7c959601bfeb7cba49b54,Merge pull request #7755 from DougGregor/all-same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,-,"ConcreteTypeSource->print(Out, SrcMgr);",1366,download/apple_swift425.cpp
41c6247b26531e7476d7c959601bfeb7cba49b54,Merge pull request #7755 from DougGregor/all-same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,+,concreteType.print(Out);,1368,download/apple_swift425.cpp
41c6247b26531e7476d7c959601bfeb7cba49b54,Merge pull request #7755 from DougGregor/all-same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,+,"concreteTypeSource->print(Out, SrcMgr);",1375,download/apple_swift425.cpp
41c6247b26531e7476d7c959601bfeb7cba49b54,Merge pull request #7755 from DougGregor/all-same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,-,"assert(llvm::all_of(rep->getEquivalenceClass(),",1493,download/apple_swift425.cpp
41c6247b26531e7476d7c959601bfeb7cba49b54,Merge pull request #7755 from DougGregor/all-same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,+,"assert(llvm::all_of(rep->getEquivalenceClassMembers(),",1493,download/apple_swift425.cpp
41c6247b26531e7476d7c959601bfeb7cba49b54,Merge pull request #7755 from DougGregor/all-same-type-to-concrete,lib/AST/GenericSignatureBuilder.cpp,-,assert(!T1->ConcreteType,1854,download/apple_swift425.cpp
99d2b171d35edbf5ad72b015a5cfa1e6548c6f37,"[Serialization] If we fail to deserialize a type, dump it.

...rather than just printing it, which isn't giving us enough info.

In pursuit of rdar://problem/30382791.",lib/Serialization/Deserialization.cpp,-,assert(!typeOrOffset.get()->hasError());,4243,download/apple_swift426.cpp
99d2b171d35edbf5ad72b015a5cfa1e6548c6f37,"[Serialization] If we fail to deserialize a type, dump it.

...rather than just printing it, which isn't giving us enough info.

In pursuit of rdar://problem/30382791.",lib/Serialization/Deserialization.cpp,+,if (typeOrOffset.get()->hasError()) {,4243,download/apple_swift426.cpp
24367fa5d91ab90641adaef48759c9fd8e4059bb,"Runtime: Have native refcounting entry points ignore negative pointer values on x86-64 and arm64.

The high half of the address space is used by the kernel in these architectures, and it would be useful for us to be able to pack small values into places the ABI otherwise requires a refcountable pointer, such as closures and maybe refcounted existentials.",stdlib/public/runtime/HeapObject.cpp,-,assert(object);,374,download/apple_swift427.cpp
24367fa5d91ab90641adaef48759c9fd8e4059bb,"Runtime: Have native refcounting entry points ignore negative pointer values on x86-64 and arm64.

The high half of the address space is used by the kernel in these architectures, and it would be useful for us to be able to pack small values into places the ABI otherwise requires a refcountable pointer, such as closures and maybe refcounted existentials.",stdlib/public/runtime/HeapObject.cpp,+,assert(isValidPointerForNativeRetain(object));,374,download/apple_swift427.cpp
29256e526c547adc86136e898347aa6b6948579d,"[GenericSigBuilder] Track all same-type-to-concrete constraints.

When we see a second same-type-to-concrete constraint on a particular
potential archetype, record it. Previously, we were checking it and
then updating the requirement source eagerly. That won't work with
proper recursion detection, and meant that we missed out on some
obvious redundant-same-type-constraint diagnostics.

The scheme here is to build up the equivalence classes without losing
any information, and then determine which information is redundant at
the end.",lib/AST/GenericSignatureBuilder.cpp,-,ConcreteType.print(Out);,1361,download/apple_swift428.cpp
29256e526c547adc86136e898347aa6b6948579d,"[GenericSigBuilder] Track all same-type-to-concrete constraints.

When we see a second same-type-to-concrete constraint on a particular
potential archetype, record it. Previously, we were checking it and
then updating the requirement source eagerly. That won't work with
proper recursion detection, and meant that we missed out on some
obvious redundant-same-type-constraint diagnostics.

The scheme here is to build up the equivalence classes without losing
any information, and then determine which information is redundant at
the end.",lib/AST/GenericSignatureBuilder.cpp,-,"ConcreteTypeSource->print(Out, SrcMgr);",1366,download/apple_swift428.cpp
29256e526c547adc86136e898347aa6b6948579d,"[GenericSigBuilder] Track all same-type-to-concrete constraints.

When we see a second same-type-to-concrete constraint on a particular
potential archetype, record it. Previously, we were checking it and
then updating the requirement source eagerly. That won't work with
proper recursion detection, and meant that we missed out on some
obvious redundant-same-type-constraint diagnostics.

The scheme here is to build up the equivalence classes without losing
any information, and then determine which information is redundant at
the end.",lib/AST/GenericSignatureBuilder.cpp,+,concreteType.print(Out);,1368,download/apple_swift428.cpp
29256e526c547adc86136e898347aa6b6948579d,"[GenericSigBuilder] Track all same-type-to-concrete constraints.

When we see a second same-type-to-concrete constraint on a particular
potential archetype, record it. Previously, we were checking it and
then updating the requirement source eagerly. That won't work with
proper recursion detection, and meant that we missed out on some
obvious redundant-same-type-constraint diagnostics.

The scheme here is to build up the equivalence classes without losing
any information, and then determine which information is redundant at
the end.",lib/AST/GenericSignatureBuilder.cpp,+,"concreteTypeSource->print(Out, SrcMgr);",1375,download/apple_swift428.cpp
a562c0e6b8d6176df3577671a360ea8287274909,"Merge pull request #6720 from jrose-apple/one-swift-two-swift-old-swift-new-swift

Begin importing APIs under both Swift 3 and Swift 4 names, to produce errors",lib/ClangImporter/ClangImporter.cpp,+,assert(alternateNamedDecl->getFullName().matchesRef(name) &&,2771,download/apple_swift429.cpp
a562c0e6b8d6176df3577671a360ea8287274909,"Merge pull request #6720 from jrose-apple/one-swift-two-swift-old-swift-new-swift

Begin importing APIs under both Swift 3 and Swift 4 names, to produce errors",lib/ClangImporter/ImportDecl.cpp,+,assert(getVersion() > getActiveSwiftVersion());,2033,download/apple_swift430.cpp
a562c0e6b8d6176df3577671a360ea8287274909,"Merge pull request #6720 from jrose-apple/one-swift-two-swift-old-swift-new-swift

Begin importing APIs under both Swift 3 and Swift 4 names, to produce errors",lib/ClangImporter/ImportDecl.cpp,+,assert(isa<FuncDecl>(rawDecl));,3533,download/apple_swift430.cpp
886c83f6e7767a02047c29fc54beac1f5ed939e6,"SILGen: Allow static stored properties in fully-concrete extensions of generic types.

There's no need for per-instantiation storage in this case, so we can relax the implementation limitation for them.",lib/SILGen/SILGenGlobalVariable.cpp,-,assert(!pd->getDeclContext()->isGenericContext());,205,download/apple_swift431.cpp
886c83f6e7767a02047c29fc54beac1f5ed939e6,"SILGen: Allow static stored properties in fully-concrete extensions of generic types.

There's no need for per-instantiation storage in this case, so we can relax the implementation limitation for them.",lib/SILGen/SILGenGlobalVariable.cpp,+,assert(!pd->getDeclContext()->isGenericContext(),206,download/apple_swift431.cpp
886c83f6e7767a02047c29fc54beac1f5ed939e6,"SILGen: Allow static stored properties in fully-concrete extensions of generic types.

There's no need for per-instantiation storage in this case, so we can relax the implementation limitation for them.",lib/SILGen/SILGenLValue.cpp,-,assert(!baseMeta->is<BoundGenericType>() &&,1740,download/apple_swift432.cpp
886c83f6e7767a02047c29fc54beac1f5ed939e6,"SILGen: Allow static stored properties in fully-concrete extensions of generic types.

There's no need for per-instantiation storage in this case, so we can relax the implementation limitation for them.",lib/SILGen/SILGenType.cpp,-,"assert(!generics && ""generic static properties not implemented"");",305,download/apple_swift433.cpp
886c83f6e7767a02047c29fc54beac1f5ed939e6,"SILGen: Allow static stored properties in fully-concrete extensions of generic types.

There's no need for per-instantiation storage in this case, so we can relax the implementation limitation for them.",lib/SILGen/SILGenType.cpp,+,assert(var->getDeclContext()->getGenericSignatureOfContext(),306,download/apple_swift433.cpp
ba81b66f2654a1c79395c67418cbeb785710edfd,[GenericSigBuilder] Migrate the concrete type into to EquivalenceClass.,lib/AST/GenericSignatureBuilder.cpp,-,assert(!T1->ConcreteType,1839,download/apple_swift434.cpp
04ba576e3f1b807a58d3fda8d3f6e4c6ab55894f,"[GenericSig Builder] Introduce an equivalence-class abstraction.

Introduce an equivalence-class abstraction that captures all of the
members of the equivalence class in a separate type that will maintain
the ""truth"" about the meaning of the equivalence class, rather than
having that information distributed amongst the potential archetypes
within the class.

For now, use it to capture the members of the equivalence classes, so
we have one SmallVector per equivalence class rather than N
SmallVectors.",lib/AST/GenericSignatureBuilder.cpp,-,"assert(llvm::all_of(rep->getEquivalenceClass(),",1478,download/apple_swift435.cpp
04ba576e3f1b807a58d3fda8d3f6e4c6ab55894f,"[GenericSig Builder] Introduce an equivalence-class abstraction.

Introduce an equivalence-class abstraction that captures all of the
members of the equivalence class in a separate type that will maintain
the ""truth"" about the meaning of the equivalence class, rather than
having that information distributed amongst the potential archetypes
within the class.

For now, use it to capture the members of the equivalence classes, so
we have one SmallVector per equivalence class rather than N
SmallVectors.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(llvm::all_of(rep->getEquivalenceClassMembers(),",1478,download/apple_swift435.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/Errors.cpp,+,"swift::fatalError(FatalErrorFlags::ReportBacktrace,",280,download/apple_swift436.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/Errors.cpp,+,"swift::fatalError(FatalErrorFlags::ReportBacktrace,",288,download/apple_swift436.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/Errors.cpp,+,"swift::fatalError(FatalErrorFlags::ReportBacktrace,",292,download/apple_swift436.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,"swift::fatalError(/* flags = */ 0,",101,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,assert(metadata->isClassObject());,331,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,assert(classMetadata->isTypeMetadata());,332,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,assert(object->metadata->isClassObject());,333,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,assert(static_cast<const ClassMetadata*>(object->metadata)->isTypeMetadata());,334,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,assert(metadata->isClassObject());,352,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,assert(classMetadata->isTypeMetadata());,353,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,assert(object->metadata->isClassObject());,354,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,assert(static_cast<const ClassMetadata*>(object->metadata)->isTypeMetadata());,355,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,assert(object->weakRefCount.getCount() &&,435,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,assert(object->refCounts.getUnownedCount() &&,436,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,assert(object->weakRefCount.getCount() &&,449,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,assert(object->refCounts.getUnownedCount() &&,450,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,assert(object->weakRefCount.getCount() &&,467,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,assert(object->refCounts.getUnownedCount() &&,468,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,assert(object->refCount.isDeallocating());,571,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,+,assert(object->refCounts.isDeiniting());,571,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",stdlib/public/runtime/HeapObject.cpp,-,"static_assert(WR_READING < alignof(void*),",671,download/apple_swift437.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",unittests/runtime/LongTests/LongRefcounting.cpp,+,"ASSERT_DEATH(swift_unownedCheck(object),",66,download/apple_swift438.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",unittests/runtime/LongTests/LongRefcounting.cpp,+,"ASSERT_DEATH(swift_retain(object),",166,download/apple_swift438.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",unittests/runtime/LongTests/LongRefcounting.cpp,+,"ASSERT_DEATH(swift_nonatomic_retain(object),",196,download/apple_swift438.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",unittests/runtime/LongTests/LongRefcounting.cpp,+,"ASSERT_DEATH(swift_unownedCheck(object),",322,download/apple_swift438.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",unittests/runtime/LongTests/LongRefcounting.cpp,+,"ASSERT_DEATH(swift_unownedCheck(object),",545,download/apple_swift438.cpp
ae1c9849200b7c72d08eb7f329109f73d97b80af,"New refcount representation (#5282)

New refcount representation and weak variable implementation. See SwiftShims/RefCount.h for details.",unittests/runtime/LongTests/LongRefcounting.cpp,+,"ASSERT_DEATH(swift_unownedCheck(object),",785,download/apple_swift438.cpp
60ae0443f94241f2f0125835d2c75239d9d26c65,"Merge pull request #7748 from shajrawi/globals_load_of_copy

Support load and load of copy for globals in opaque value types",lib/SILGen/SILGenLValue.cpp,-,assert(rvalueTL.isLoadable());,2299,download/apple_swift439.cpp
60ae0443f94241f2f0125835d2c75239d9d26c65,"Merge pull request #7748 from shajrawi/globals_load_of_copy

Support load and load of copy for globals in opaque value types",lib/SILGen/SILGenLValue.cpp,+,assert(rvalueTL.isLoadable() || !silConv.useLoweredAddresses());,2299,download/apple_swift439.cpp
c9124d989dee00c991782f3e5684ed257172b682,"[ClangImporter] Import Swift 3 versions of top-level decls in Swift 4.

...and Swift 4 versions in Swift 3, and Swift 2 and ""raw"" versions in
both. This allows the compiler to produce sensible errors and fix-its
when someone uses the ""wrong"" name for an API. The diagnostics
certainly have room to improve, but at least the essentials are there.

Note that this commit only addresses /top-level/ decls, i.e. those
found by lookup into a module. We're still limited to producing all
members of a nominal type up front, so that'll require a slightly
different approach.

Part of rdar://problem/29170671",lib/ClangImporter/ClangImporter.cpp,+,assert(alternateNamedDecl->getFullName().matchesRef(name) &&,2771,download/apple_swift440.cpp
c9124d989dee00c991782f3e5684ed257172b682,"[ClangImporter] Import Swift 3 versions of top-level decls in Swift 4.

...and Swift 4 versions in Swift 3, and Swift 2 and ""raw"" versions in
both. This allows the compiler to produce sensible errors and fix-its
when someone uses the ""wrong"" name for an API. The diagnostics
certainly have room to improve, but at least the essentials are there.

Note that this commit only addresses /top-level/ decls, i.e. those
found by lookup into a module. We're still limited to producing all
members of a nominal type up front, so that'll require a slightly
different approach.

Part of rdar://problem/29170671",lib/ClangImporter/ImportDecl.cpp,+,assert(getVersion() > getActiveSwiftVersion());,2033,download/apple_swift441.cpp
c9124d989dee00c991782f3e5684ed257172b682,"[ClangImporter] Import Swift 3 versions of top-level decls in Swift 4.

...and Swift 4 versions in Swift 3, and Swift 2 and ""raw"" versions in
both. This allows the compiler to produce sensible errors and fix-its
when someone uses the ""wrong"" name for an API. The diagnostics
certainly have room to improve, but at least the essentials are there.

Note that this commit only addresses /top-level/ decls, i.e. those
found by lookup into a module. We're still limited to producing all
members of a nominal type up front, so that'll require a slightly
different approach.

Part of rdar://problem/29170671",lib/ClangImporter/ImportDecl.cpp,+,assert(isa<FuncDecl>(rawDecl));,3533,download/apple_swift441.cpp
acc33e895be7e1509e6b778b678181f228acb5b3,Support load and load of copy for globals in opaque value types,lib/SILGen/SILGenLValue.cpp,-,assert(rvalueTL.isLoadable());,2299,download/apple_swift442.cpp
acc33e895be7e1509e6b778b678181f228acb5b3,Support load and load of copy for globals in opaque value types,lib/SILGen/SILGenLValue.cpp,+,assert(rvalueTL.isLoadable() || !silConv.useLoweredAddresses());,2299,download/apple_swift442.cpp
fc0b3dd570b80247aeb8070a2235d85aa6ea6e5e,Merge pull request #7747 from DougGregor/same-type-to-concrete-redundancy,lib/AST/GenericSignatureBuilder.cpp,+,"assert(concreteType && ""No concrete type to check"");",2691,download/apple_swift443.cpp
d697c2fdcb7770521a8a119dce91d61386508059,"[GenericSig Builder] Diagnose redundant same-typeo-t-concrete constraints.

Diagnose when a same-type constraint (to a concrete type) is made
redundant by another same-type constraint. Slightly improve the
diagnostic that handles collisions between two same-type constraints.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(concreteType && ""No concrete type to check"");",2691,download/apple_swift444.cpp
21ebc5bff35f59bb2cc092101ade91b58f0ba979,[gardening] Remove unused method isOuterArchetype(...),lib/AST/GenericSignatureBuilder.cpp,-,assert(ParamDepth <= MaxDepth);,2290,download/apple_swift445.cpp
d352652a72c73157d94e5fdc0fb477453da41c94,"Merge pull request #7727 from practicalswift/typos-20170223

[gardening] Fix typos",lib/IRGen/GenCall.cpp,-,"assert(CanUseError && ""Mulitple error parameters?!"");",254,download/apple_swift446.cpp
d352652a72c73157d94e5fdc0fb477453da41c94,"Merge pull request #7727 from practicalswift/typos-20170223

[gardening] Fix typos",lib/IRGen/GenCall.cpp,+,"assert(CanUseError && ""Multiple error parameters?!"");",254,download/apple_swift446.cpp
82073f9954272e00e432068967db1149033e8fad,Merge pull request #7739 from DougGregor/sr-4056,lib/Sema/CSSolver.cpp,-,"assert(InactiveConstraints.size() == 1 && ""supposed to be an orphan!"");",2154,download/apple_swift447.cpp
99a139695ab9c3580aad2feb8e1033bed5c2818e,"[Constraint solver] Dont assume orphans are along in the inactive list.

The inactive list may contain other disjunctions associated with bound
type variables. For now, make sure we recover the orphan directly to
fix the crash in SR-4056 / rdar://problem/30686926. Later, we can
treat these as orphans, too.",lib/Sema/CSSolver.cpp,-,"assert(InactiveConstraints.size() == 1 && ""supposed to be an orphan!"");",2154,download/apple_swift448.cpp
788c61bf1f797331e7edb6f1683f9dba22194b4d,"Merge pull request #7697 from slavapestov/parsing-generic-subscripts

Parsing generic subscripts",lib/AST/Type.cpp,-,"assert(gpDecl->getDepth() != 0xFFFF && ""parameter hasn't been validated"");",1184,download/apple_swift449.cpp
788c61bf1f797331e7edb6f1683f9dba22194b4d,"Merge pull request #7697 from slavapestov/parsing-generic-subscripts

Parsing generic subscripts",lib/AST/Type.cpp,+,assert(gpDecl->getDepth() != GenericTypeParamDecl::InvalidDepth &&,1184,download/apple_swift449.cpp
fdb0a18647c8bf9b3027476bd877f25ef446604e,"AST: Add a GenericParamList::clone() method

This will be immediately needed for generic subscripts, and also
for fixing the remaining cases where initializer inheritance
doesn't work.",lib/AST/Type.cpp,-,"assert(gpDecl->getDepth() != 0xFFFF && ""parameter hasn't been validated"");",1184,download/apple_swift450.cpp
fdb0a18647c8bf9b3027476bd877f25ef446604e,"AST: Add a GenericParamList::clone() method

This will be immediately needed for generic subscripts, and also
for fixing the remaining cases where initializer inheritance
doesn't work.",lib/AST/Type.cpp,+,assert(gpDecl->getDepth() != GenericTypeParamDecl::InvalidDepth &&,1184,download/apple_swift450.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,getForeignErrorConventionKindString(ForeignErrorConvention::Kind value) {,257,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << "" access="";",674,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""private"";",676,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""fileprivate"";",678,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""internal"";",680,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""public"";",682,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""open"";",684,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor) << "" access=""",686,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,OS << getForeignErrorConventionKindString(fec->getKind());,871,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#column"");",893,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#dsohandle"");",895,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#file"");",897,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#function"");",899,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""inherited"");",901,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#line"");",903,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""nil"");",905,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""[]"");",907,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""[:]"");",909,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""normal"");",911,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"printField(""default_arg"",",914,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" designated"";",969,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" convenience"";",972,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" convenience_factory"";",975,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" factory"";",978,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" failable=Optional"";",986,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor)",989,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, DeclModifierColor) << "" """,993,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""",996,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,void printStringEncoding(StringLiteralExpr::Encoding encoding) {,1686,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""utf8"";",1688,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""utf16"";",1690,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""unicodeScalar"";",1692,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << "" encoding="";",1698,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getEncoding());,1698,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor)",1698,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""",1698,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printCommon(E, ""magic_identifier_literal_expr"") << "" kind="";",1707,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getStringEncoding());,1710,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getStringEncoding());,1714,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"printCommon(E, ""magic_identifier_literal_expr"")",1720,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();",1738,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)",1739,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();",1810,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)",1811,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();",1894,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)",1895,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printFlag(""vararg"");",2700,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printFlag(""autoclosure"");",2701,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printFlag(""escaping"");",2702,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"printFlag(paramFlags.isVariadic(), ""vararg"");",2702,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"printFlag(paramFlags.isAutoClosure(), ""autoclosure"");",2703,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"printFlag(paramFlags.isEscaping(), ""escaping"");",2704,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,void printMetatypeRepresentation(MetatypeRepresentation representation) {,2846,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printMetatypeRepresentation(T->getRepresentation());,2863,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,printMetatypeRepresentation(T->getRepresentation());,2858,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""block"");",2954,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""c"");",2957,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""thin"");",2960,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""method"");",2963,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""objc_method"");",2966,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""witness_method"");",2969,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""closure"");",2972,download/apple_swift451.cpp
6fa1c5833a32e2a14849f9f23afc5a47d46492f7,"Merge pull request #7663 from KingOfBrian/gardening/ASTDumper

[Gardening] Cleanup ASTDumper enum to string transformations",lib/AST/ASTDumper.cpp,+,"printField(""representation"",",2975,download/apple_swift451.cpp
0be1cf1dc475dcfe937ffc4cb5a6ad36ab61554e,"[Parse] Consolidate parsing IfConfig clauses

decl list position and stmt list poisiton.",lib/Parse/ParseIfConfig.cpp,+,if (Status.isError()),168,download/apple_swift452.cpp
0be1cf1dc475dcfe937ffc4cb5a6ad36ab61554e,"[Parse] Consolidate parsing IfConfig clauses

decl list position and stmt list poisiton.",lib/Parse/ParseIfConfig.cpp,-,return makeParserError();,153,download/apple_swift452.cpp
0be1cf1dc475dcfe937ffc4cb5a6ad36ab61554e,"[Parse] Consolidate parsing IfConfig clauses

decl list position and stmt list poisiton.",lib/Parse/ParseIfConfig.cpp,+,if (Status.isError()),203,download/apple_swift452.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseDecl.cpp,-,return makeParserError();,3023,download/apple_swift453.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return makeParserError();,48,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return makeParserError();,135,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,"assert(condition && ""Cannot classify a NULL condition expression!"");",200,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,212,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,247,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,256,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,294,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,308,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,317,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,326,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,333,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,346,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,354,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,372,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,380,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,399,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,415,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,422,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,441,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseIfConfig.cpp,+,return ConditionalCompilationExprState::error();,462,download/apple_swift454.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,"assert(condition && ""Cannot classify a NULL condition expression!"");",1506,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1517,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1551,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1559,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1596,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1609,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1617,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1625,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1631,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1643,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1650,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1667,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1674,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1692,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1707,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1713,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1731,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return ConditionalCompilationExprState::error();,1751,download/apple_swift455.cpp
58c079e306e1d3c141a006fdfa14783f7fb4029a,[Parse] Split out IfConfig related functions into ParseIfConfig.cpp,lib/Parse/ParseStmt.cpp,-,return makeParserError();,1774,download/apple_swift455.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",lib/Syntax/Trivia.cpp,-,"printRepeated(OS, ';', Count);",135,download/apple_swift456.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::spaces(0).print(OS);,12,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",13,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::tabs(0).print(OS);,18,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",19,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::newlines(0).print(OS);,24,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",25,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,28,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"Trivia::lineComment("""").print(OS);",31,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",32,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,34,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"Trivia::blockComment("""").print(OS);",37,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",38,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,40,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"Trivia::docLineComment("""").print(OS);",43,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",44,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,46,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"Trivia::docBlockComment("""").print(OS);",49,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",50,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia().print(OS);,56,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",57,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia(), Trivia::spaces(0));",62,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Trivia().empty());,63,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE((Trivia() + Trivia()).empty());,64,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia(), Trivia::tabs(0));",65,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia(), Trivia::newlines(0));",66,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia() + Trivia(), Trivia());",67,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::backtick().print(OS);,73,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""`"");",74,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::spaces(4).print(OS);,80,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""    "");",81,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::tabs(4).print(OS);,87,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""\t\t\t\t"");",88,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Trivia::newlines(4).print(OS);,94,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""\n\n\n\n"");",95,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Lines.print(OS);,104,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""// Line 1\n// Line 2"");",105,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""/* Block Line 1\n\n  Block Line 2 */"");",112,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Lines.print(OS);,121,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""/// Line 1\n/// Line 2"");",122,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""/** Block Line 1\n\n  Block Line 2 */"");",129,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,(Trivia() + Trivia()).print(OS);,136,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",137,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,(Trivia::newlines(2) + Trivia::spaces(2)).print(OS);,143,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""\n\n  "");",144,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,CCCCombo.print(OS);,154,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), "" \t\n`"");",155,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::Backtick));,164,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::BlockComment));,165,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::DocBlockComment));,166,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::DocLineComment));,167,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::Formfeed));,168,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::LineComment));,169,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::Newline));,170,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::Space));,171,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Trivia::backtick().contains(TriviaKind::Backtick));,173,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_TRUE(Trivia::blockComment(""/**/"").contains(TriviaKind::BlockComment));",174,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_TRUE(Trivia::docBlockComment(""/***/"")",175,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_TRUE(Trivia::docLineComment(""///"")",177,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_TRUE(Trivia::lineComment(""//"").contains(TriviaKind::LineComment));",179,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Trivia::newlines(1).contains(TriviaKind::Newline));,180,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Trivia::spaces(1).contains(TriviaKind::Space));,181,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Combo.contains(TriviaKind::Space));,186,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Combo.contains(TriviaKind::Newline));,187,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Combo.contains(TriviaKind::Backtick));,188,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Combo.contains(TriviaKind::Tab));,189,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Combo.contains(TriviaKind::LineComment));,190,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Combo.contains(TriviaKind::Formfeed));,191,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Triv.print(WholeOS);,199,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Piece.print(PiecesOS);,204,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(WholeOS.str().str(), PiecesOS.str().str());",207,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Triv.print(OS);,217,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""```"");",218,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,Triv.print(OS);,229,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""` ` "");",230,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,235,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia::spaces(1).front(), TriviaPiece::spaces(1));",240,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ((Trivia::spaces(1) + Trivia::newlines(1)).front(),",242,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,248,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia::spaces(1).back(), TriviaPiece::spaces(1));",252,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ((Trivia::spaces(1) + Trivia::newlines(1)).back(),",253,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia().size(), 0);",258,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia::spaces(1).size(), 1);",259,download/apple_swift457.cpp
7b3749d71ff303527561a4880e8f63cbf101d1c4,"Merge pull request #7722 from bitjammer/trivia-tests

[Syntax] Add Trivia C++ unit tests",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ((Trivia::spaces(1) + Trivia::spaces(1)).size(), 2);",262,download/apple_swift457.cpp
4392a109174ba2b235d35e36650a56ffcbb3becd,Merge pull request #7728 from DougGregor/abstract-conformance-via-existential,lib/AST/GenericSignatureBuilder.cpp,+,assert(conformance->isConcrete() || Concrete->isExistentialType());,1959,download/apple_swift458.cpp
33a5601ad1b4ec3877a6715a6c1e8525aaa05e43,[gardening] Fix typos,lib/IRGen/GenCall.cpp,-,"assert(CanUseError && ""Mulitple error parameters?!"");",254,download/apple_swift459.cpp
33a5601ad1b4ec3877a6715a6c1e8525aaa05e43,[gardening] Fix typos,lib/IRGen/GenCall.cpp,+,"assert(CanUseError && ""Multiple error parameters?!"");",254,download/apple_swift459.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",lib/Syntax/Trivia.cpp,-,"printRepeated(OS, ';', Count);",135,download/apple_swift460.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::spaces(0).print(OS);,12,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",13,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::tabs(0).print(OS);,18,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",19,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::newlines(0).print(OS);,24,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",25,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,28,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"Trivia::lineComment("""").print(OS);",31,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",32,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,34,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"Trivia::blockComment("""").print(OS);",37,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",38,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,40,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"Trivia::docLineComment("""").print(OS);",43,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",44,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,46,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"Trivia::docBlockComment("""").print(OS);",49,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",50,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia().print(OS);,56,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",57,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia(), Trivia::spaces(0));",62,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Trivia().empty());,63,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE((Trivia() + Trivia()).empty());,64,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia(), Trivia::tabs(0));",65,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia(), Trivia::newlines(0));",66,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia() + Trivia(), Trivia());",67,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::backtick().print(OS);,73,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""`"");",74,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::spaces(4).print(OS);,80,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""    "");",81,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::tabs(4).print(OS);,87,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""\t\t\t\t"");",88,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Trivia::newlines(4).print(OS);,94,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""\n\n\n\n"");",95,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Lines.print(OS);,104,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""// Line 1\n// Line 2"");",105,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""/* Block Line 1\n\n  Block Line 2 */"");",112,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Lines.print(OS);,121,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""/// Line 1\n/// Line 2"");",122,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""/** Block Line 1\n\n  Block Line 2 */"");",129,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,(Trivia() + Trivia()).print(OS);,136,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",137,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,(Trivia::newlines(2) + Trivia::spaces(2)).print(OS);,143,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""\n\n  "");",144,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,CCCCombo.print(OS);,154,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), "" \t\n`"");",155,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::Backtick));,164,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::BlockComment));,165,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::DocBlockComment));,166,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::DocLineComment));,167,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::Formfeed));,168,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::LineComment));,169,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::Newline));,170,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Trivia().contains(TriviaKind::Space));,171,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Trivia::backtick().contains(TriviaKind::Backtick));,173,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_TRUE(Trivia::blockComment(""/**/"").contains(TriviaKind::BlockComment));",174,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_TRUE(Trivia::docBlockComment(""/***/"")",175,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_TRUE(Trivia::docLineComment(""///"")",177,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_TRUE(Trivia::lineComment(""//"").contains(TriviaKind::LineComment));",179,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Trivia::newlines(1).contains(TriviaKind::Newline));,180,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Trivia::spaces(1).contains(TriviaKind::Space));,181,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Combo.contains(TriviaKind::Space));,186,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Combo.contains(TriviaKind::Newline));,187,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_TRUE(Combo.contains(TriviaKind::Backtick));,188,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Combo.contains(TriviaKind::Tab));,189,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Combo.contains(TriviaKind::LineComment));,190,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_FALSE(Combo.contains(TriviaKind::Formfeed));,191,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Triv.print(WholeOS);,199,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Piece.print(PiecesOS);,204,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(WholeOS.str().str(), PiecesOS.str().str());",207,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Triv.print(OS);,217,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""```"");",218,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,Triv.print(OS);,229,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""` ` "");",230,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,235,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia::spaces(1).front(), TriviaPiece::spaces(1));",240,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ((Trivia::spaces(1) + Trivia::newlines(1)).front(),",242,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,ASSERT_DEATH({,248,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia::spaces(1).back(), TriviaPiece::spaces(1));",252,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ((Trivia::spaces(1) + Trivia::newlines(1)).back(),",253,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia().size(), 0);",258,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ(Trivia::spaces(1).size(), 1);",259,download/apple_swift461.cpp
733988cdfe5d47e97e8126b4597ea04f0ae9ec85,"[Syntax] Add Trivia C++ unit tests

https://bugs.swift.org/browse/SR-4053",unittests/Syntax/TriviaTests.cpp,+,"ASSERT_EQ((Trivia::spaces(1) + Trivia::spaces(1)).size(), 2);",262,download/apple_swift461.cpp
cbbf4154359f62c628f1b171de253fa4ab1f23e1,[GenericSigBuilder] Archetypes no longer make it to this path. NFC,lib/AST/GenericSignatureBuilder.cpp,-,assert(conformance->isConcrete() || Concrete->isExistentialType());,1953,download/apple_swift462.cpp
cbbf4154359f62c628f1b171de253fa4ab1f23e1,[GenericSigBuilder] Archetypes no longer make it to this path. NFC,lib/AST/GenericSignatureBuilder.cpp,+,assert(conformance->isConcrete() || Concrete->isExistentialType());,1954,download/apple_swift462.cpp
e71788d7a6cf1992210efff67fae999b1d8ab6d7,"[GenericSigBuilder] Conformances due to concrete types can be abstract.

When a type parameter is made concrete via an existential type,
conformance requirements on that type parameter will be
abstract. Fixes rdar://problem/30610428.",lib/AST/GenericSignatureBuilder.cpp,+,assert(conformance->isConcrete() || Concrete->isExistentialType());,1938,download/apple_swift463.cpp
eb898b29cf5e2d77d5082c8b4fe35b35fa469a55,Merge pull request #7718 from DougGregor/make-all-dependent-types-truth,lib/AST/GenericEnvironment.cpp,-,assert(contextTy->hasError() || depTy->is<GenericTypeParamType>());,417,download/apple_swift464.cpp
eb898b29cf5e2d77d5082c8b4fe35b35fa469a55,Merge pull request #7718 from DougGregor/make-all-dependent-types-truth,lib/AST/GenericEnvironment.cpp,+,assert(contextTy->hasError());,417,download/apple_swift464.cpp
5f4b2cfec0a343e88a7628c98a821d949141afa0,"Revert ""[Generic environment] Weaken an assertion when forming a substitution map.""

This reverts commit 485ed7b4ee14b007e4cdcbfe0f03f0a50f12e960. The
original assertion should now suffice.",lib/AST/GenericEnvironment.cpp,-,assert(contextTy->hasError() || depTy->is<GenericTypeParamType>());,417,download/apple_swift465.cpp
5f4b2cfec0a343e88a7628c98a821d949141afa0,"Revert ""[Generic environment] Weaken an assertion when forming a substitution map.""

This reverts commit 485ed7b4ee14b007e4cdcbfe0f03f0a50f12e960. The
original assertion should now suffice.",lib/AST/GenericEnvironment.cpp,+,assert(contextTy->hasError());,417,download/apple_swift465.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenApply.cpp,+,assert(SGF.SelfInitDelegationState ==,1300,download/apple_swift466.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenApply.cpp,+,assert(SGF.SelfInitDelegationState ==,1304,download/apple_swift466.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenApply.cpp,+,assert(super.getCleanup() == SGF.InitDelegationSelf.getCleanup());,1310,download/apple_swift466.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenApply.cpp,+,CleanupHandle newWriteback = SGF.enterDelegateInitSelfWritebackCleanup(,1313,download/apple_swift466.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenApply.cpp,+,assert(SGF.SelfInitDelegationState ==,1481,download/apple_swift466.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenApply.cpp,+,assert(SGF.SelfInitDelegationState ==,1485,download/apple_swift466.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenBuilder.cpp,+,assert(lowering.getLoweredType().getAddressType() == v.getType());,413,download/apple_swift467.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenBuilder.cpp,+,"assert(!lowering.isAddressOnly() && ""cannot retain an unloadable type"");",418,download/apple_swift467.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenBuilder.cpp,+,"assert(value->getType().isObject() && ""Expected only objects here"");",442,download/apple_swift467.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenConstructor.cpp,-,"B.createDebugValue(PrologueLoc, selfArg);",590,download/apple_swift468.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenConstructor.cpp,+,"B.createDebugValue(PrologueLoc, selfArg.getValue());",590,download/apple_swift468.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenConstructor.cpp,+,"assert(!Cleanups.hasAnyActiveCleanups(getCleanupsDepth(),",682,download/apple_swift468.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenExpr.cpp,+,"DelegateInitSelfWritebackCleanup(SILLocation loc, SILValue lvalueAddress,",516,download/apple_swift469.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenExpr.cpp,+,CleanupHandle SILGenFunction::enterDelegateInitSelfWritebackCleanup(,538,download/apple_swift469.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenExpr.cpp,+,assert(SelfInitDelegationState != SILGenFunction::NormalSelf &&,549,download/apple_swift469.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenExpr.cpp,+,assert(F.getTypeLowering(addr->getType()).isLoadable() &&,551,download/apple_swift469.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenExpr.cpp,+,"self, enterDelegateInitSelfWritebackCleanup(*InitDelegationLoc, addr, self));",584,download/apple_swift469.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILGen/SILGenExpr.cpp,+,assert(SelfInitDelegationState == SILGenFunction::DidExclusiveBorrowSelf);,591,download/apple_swift469.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILOptimizer/Mandatory/DIMemoryUseCollector.cpp,+,"if (shouldIgnoreClassMethodUseError(Method, LI))",1350,download/apple_swift470.cpp
dfd3b744d896872a3cd6c41f87b6650f379d94ae,Merge pull request #7714 from gottesmm/completely_refactor_class_constructor_initialization,lib/SILOptimizer/Mandatory/DIMemoryUseCollector.cpp,-,"if (shouldIgnoreClassMethodUseError(Method, LI))",1510,download/apple_swift470.cpp
64c709cfe0ab23ffe2d829d4eca4602634a59598,"[gardening] Refactor load handling code from collectDelegatingClassInitSelfUses into its own function.

The new function is called collectDelegatingClassInitSelfLoadUses. This is just
a classical loop function extraction refactor.",lib/SILOptimizer/Mandatory/DIMemoryUseCollector.cpp,+,"if (shouldIgnoreClassMethodUseError(Method, LI))",1325,download/apple_swift471.cpp
64c709cfe0ab23ffe2d829d4eca4602634a59598,"[gardening] Refactor load handling code from collectDelegatingClassInitSelfUses into its own function.

The new function is called collectDelegatingClassInitSelfLoadUses. This is just
a classical loop function extraction refactor.",lib/SILOptimizer/Mandatory/DIMemoryUseCollector.cpp,-,"if (shouldIgnoreClassMethodUseError(Method, LI))",1474,download/apple_swift471.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenApply.cpp,+,assert(SGF.SelfInitDelegationState ==,1300,download/apple_swift472.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenApply.cpp,+,assert(SGF.SelfInitDelegationState ==,1304,download/apple_swift472.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenApply.cpp,+,assert(super.getCleanup() == SGF.InitDelegationSelf.getCleanup());,1310,download/apple_swift472.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenApply.cpp,+,CleanupHandle newWriteback = SGF.enterDelegateInitSelfWritebackCleanup(,1313,download/apple_swift472.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenApply.cpp,+,assert(SGF.SelfInitDelegationState ==,1481,download/apple_swift472.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenApply.cpp,+,assert(SGF.SelfInitDelegationState ==,1485,download/apple_swift472.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,assert(lowering.getLoweredType().getAddressType() == v.getType());,413,download/apple_swift473.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,"assert(!lowering.isAddressOnly() && ""cannot retain an unloadable type"");",418,download/apple_swift473.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,"assert(value->getType().isObject() && ""Expected only objects here"");",442,download/apple_swift473.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenConstructor.cpp,-,"B.createDebugValue(PrologueLoc, selfArg);",590,download/apple_swift474.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenConstructor.cpp,+,"B.createDebugValue(PrologueLoc, selfArg.getValue());",590,download/apple_swift474.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenConstructor.cpp,+,"assert(!Cleanups.hasAnyActiveCleanups(getCleanupsDepth(),",682,download/apple_swift474.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenExpr.cpp,+,"DelegateInitSelfWritebackCleanup(SILLocation loc, SILValue lvalueAddress,",516,download/apple_swift475.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenExpr.cpp,+,CleanupHandle SILGenFunction::enterDelegateInitSelfWritebackCleanup(,538,download/apple_swift475.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenExpr.cpp,+,assert(SelfInitDelegationState != SILGenFunction::NormalSelf &&,549,download/apple_swift475.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenExpr.cpp,+,assert(F.getTypeLowering(addr->getType()).isLoadable() &&,551,download/apple_swift475.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenExpr.cpp,+,"self, enterDelegateInitSelfWritebackCleanup(*InitDelegationLoc, addr, self));",584,download/apple_swift475.cpp
784d5d16fcb56c22a28578340dd585a65c3fa3a0,"[silgen] Change emitClassConstructorInitializer to use ownership and make calling designated/chaining initializes use proper ownership.

rdar://29791263",lib/SILGen/SILGenExpr.cpp,+,assert(SelfInitDelegationState == SILGenFunction::DidExclusiveBorrowSelf);,591,download/apple_swift475.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::UnknownStmt);,40,download/apple_swift476.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::UnknownExpr);,45,download/apple_swift477.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::IntegerLiteralExpr);,72,download/apple_swift477.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Layout.size() == 2);,73,download/apple_swift477.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token(Raw, IntegerLiteralExprSyntax::Cursor::Sign,",74,download/apple_swift477.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token(Raw, IntegerLiteralExprSyntax::Cursor::Digits,",76,download/apple_swift477.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/ExprSyntax.cpp,+,assert(NewDigits->getTokenKind() == tok::integer_literal);,110,download/apple_swift477.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::ConformanceRequirement);,33,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",34,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",37,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",40,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericParameter);,77,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericParameterList);,112,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",139,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",143,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",147,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericRequirementList);,237,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericWhereClause);,266,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",267,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",269,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::SameTypeRequirement);,314,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Layout.size() == 3);,315,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",316,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",319,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->getChild(SameTypeRequirementSyntax::Cursor::RightType)->isType());,321,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericArgumentList);,352,download/apple_swift478.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::UnknownStmt);,31,download/apple_swift479.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 2);,296,download/apple_swift479.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",297,download/apple_swift479.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->getChild(ReturnStmtSyntax::Cursor::Expression)->isExpr());,300,download/apple_swift479.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_token_is(NewReturnKeyword, tok::kw_return, ""return"");",347,download/apple_swift479.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankReturnStmt().print(OS);,219,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",220,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,"SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne).print(OS);",226,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""return -1"");",227,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(ReturnKW, Return.getReturnKeyword());",238,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,ASSERT_TRUE(GottenExpression.hasSameIdentityAs(GottenExpression2));,241,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankReturnStmt().withReturnKeyword(ReturnKW).print(OS);,253,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""return "");",254,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankReturnStmt().withExpression(MinusOne).print(OS);,260,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""-1"");",261,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,.withExpression(MinusOne).print(OS);,269,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""return -1"");",270,download/apple_swift480.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/ThreadSafeCachingTests.cpp,+,"ASSERT_EQ(FirstDataPointer, SecondDataPointer);",45,download/apple_swift481.cpp
fa50dc500cec8f17314dea2e5193f5d1cd0d29ec,"Merge pull request #7706 from bitjammer/sr-4010-return-statement-syntax

[Syntax] return-statement, integer-literal-expression, child caching",unittests/Syntax/ThreadSafeCachingTests.cpp,+,"ASSERT_EQ(FirstDataPointer, DataPointer);",46,download/apple_swift481.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::UnknownStmt);,40,download/apple_swift482.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::UnknownExpr);,45,download/apple_swift483.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::IntegerLiteralExpr);,72,download/apple_swift483.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/ExprSyntax.cpp,+,assert(Raw->Layout.size() == 2);,73,download/apple_swift483.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token(Raw, IntegerLiteralExprSyntax::Cursor::Sign,",74,download/apple_swift483.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/ExprSyntax.cpp,+,"syntax_assert_child_token(Raw, IntegerLiteralExprSyntax::Cursor::Digits,",76,download/apple_swift483.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/ExprSyntax.cpp,+,assert(NewDigits->getTokenKind() == tok::integer_literal);,110,download/apple_swift483.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::ConformanceRequirement);,33,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",34,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",37,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",40,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericParameter);,77,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericParameterList);,112,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",139,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",143,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",147,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericRequirementList);,237,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericWhereClause);,266,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",267,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",269,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::SameTypeRequirement);,314,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Layout.size() == 3);,315,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_kind(Raw,",316,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",319,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->getChild(SameTypeRequirementSyntax::Cursor::RightType)->isType());,321,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/GenericSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::GenericArgumentList);,352,download/apple_swift484.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::UnknownStmt);,31,download/apple_swift485.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 2);,296,download/apple_swift485.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",297,download/apple_swift485.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->getChild(ReturnStmtSyntax::Cursor::Expression)->isExpr());,300,download/apple_swift485.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_token_is(NewReturnKeyword, tok::kw_return, ""return"");",347,download/apple_swift485.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankReturnStmt().print(OS);,219,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",220,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,"SyntaxFactory::makeReturnStmt(ReturnKW, MinusOne).print(OS);",226,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""return -1"");",227,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(ReturnKW, Return.getReturnKeyword());",238,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,ASSERT_TRUE(GottenExpression.hasSameIdentityAs(GottenExpression2));,241,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankReturnStmt().withReturnKeyword(ReturnKW).print(OS);,253,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""return "");",254,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankReturnStmt().withExpression(MinusOne).print(OS);,260,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""-1"");",261,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,.withExpression(MinusOne).print(OS);,269,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""return -1"");",270,download/apple_swift486.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/ThreadSafeCachingTests.cpp,+,"ASSERT_EQ(FirstDataPointer, SecondDataPointer);",45,download/apple_swift487.cpp
c343298b8ff91d7cc92225c348d8090a27678d08,"[Syntax] Implement return-statement and integer-literal-expr

A return statement needs something to return, so implement
integer-literal-expression too. This necessarily also forced
UnknownExprSyntax, UnknownStmtSyntax, and UnknownDeclSyntax,
which are stand-in token buckets for when we don't know
how to transform/migrate an AST.

This commit also contains the core function for caching
SyntaxData children. This is highly tricky code, with some
detailed comments in SyntaxData.{h,cpp}. The gist is that
we have to atomically swap in a SyntaxData pointer into the
child field, so we can maintain pointer identity of SyntaxData
nodes, while still being able to cache them internally.

To prove that this works, there is a multithreaded test that
checks that two threads can ask for a child that hasn't been
cached yet without crashing or violating pointer identity.

https://bugs.swift.org/browse/SR-4010",unittests/Syntax/ThreadSafeCachingTests.cpp,+,"ASSERT_EQ(FirstDataPointer, DataPointer);",46,download/apple_swift487.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericEnvironment.cpp,-,assert(contextTy->hasError());,415,download/apple_swift488.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericEnvironment.cpp,+,assert(contextTy->hasError() || depTy->is<GenericTypeParamType>());,417,download/apple_swift488.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericSignatureBuilder.cpp,-,assert(!(pa->getParent() && pa->getTypeAliasDecl()) &&,583,download/apple_swift489.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericSignatureBuilder.cpp,-,assert(conformance &&,1049,download/apple_swift489.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericSignatureBuilder.cpp,+,assert(conformance &&,1063,download/apple_swift489.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericSignatureBuilder.cpp,-,"ConcreteTypeSource->print(Out, SrcMgr);",1322,download/apple_swift489.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericSignatureBuilder.cpp,+,"ConcreteTypeSource->print(Out, SrcMgr);",1328,download/apple_swift489.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericSignatureBuilder.cpp,-,"assert(llvm::all_of(pa->getEquivalenceClass(),",1447,download/apple_swift489.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericSignatureBuilder.cpp,+,"assert(llvm::all_of(rep->getEquivalenceClass(),",1447,download/apple_swift489.cpp
f1231a4c4925ef61aa0c6d4d63877261d880407e,Merge pull request #7518 from DougGregor/concrete-archetype-anchors,lib/AST/GenericSignatureBuilder.cpp,-,assert(!T2->ConcreteType,1804,download/apple_swift489.cpp
485ed7b4ee14b007e4cdcbfe0f03f0a50f12e960,"[Generic environment] Weaken an assertion when forming a substitution map.

It turns out that GenericSignature::getAllDependentTypes() sometimes
includes generic type parameter types that have been made
concrete. Tolerate this for now, because fixing it causes issues
elsewhere.",lib/AST/GenericEnvironment.cpp,-,assert(contextTy->hasError());,415,download/apple_swift490.cpp
485ed7b4ee14b007e4cdcbfe0f03f0a50f12e960,"[Generic environment] Weaken an assertion when forming a substitution map.

It turns out that GenericSignature::getAllDependentTypes() sometimes
includes generic type parameter types that have been made
concrete. Tolerate this for now, because fixing it causes issues
elsewhere.",lib/AST/GenericEnvironment.cpp,+,assert(contextTy->hasError() || depTy->is<GenericTypeParamType>());,417,download/apple_swift490.cpp
d1dae728771c73e4bc5abdc821c6be20fe9bf293,"Merge pull request #7700 from shajrawi/unconditional_checked_cast

Add support for unconditional checked cast instruction for opaque value types + SILGen support for it",lib/Parse/ParseSIL.cpp,+,"if (parseSILDebugLocation(InstLoc, B))",2476,download/apple_swift491.cpp
ec1e3ee20e89f94ca57e10a9d13e4fe8491d672b,Add support for unconditional checked cast instruction for opaque value types + SILGen support for it,lib/Parse/ParseSIL.cpp,+,"if (parseSILDebugLocation(InstLoc, B))",2476,download/apple_swift492.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/AST/ASTMangler.cpp,-,if (isMethodDecl(decl) && type && !type->hasError()) {,1504,download/apple_swift493.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/AST/ASTMangler.cpp,+,if (!type->hasError()) {,1520,download/apple_swift493.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/AST/Mangle.cpp,-,if (isMethodDecl(decl) && type && !type->hasError()) {,512,download/apple_swift494.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/AST/Mangle.cpp,+,if (!type->hasError()) {,528,download/apple_swift494.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/CSRanking.cpp,-,"assert(!type1->is<GenericFunctionType>() && ""Odd generic function type?"");",552,download/apple_swift495.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/CSRanking.cpp,-,"assert(!type2->is<GenericFunctionType>() && ""Odd generic function type?"");",552,download/apple_swift495.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/ConstraintSystem.cpp,+,assert(isa<AbstractStorageDecl>(value) ||,1107,download/apple_swift496.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/ConstraintSystem.cpp,-,!selfTy->hasError()),1175,download/apple_swift496.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/ConstraintSystem.cpp,+,!selfTy->hasError()),1190,download/apple_swift496.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/TypeCheckGeneric.cpp,-,assert(isa<GenericTypeDecl>(lookupDC) || isa<ExtensionDecl>(lookupDC) ||,263,download/apple_swift497.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/TypeCheckGeneric.cpp,+,assert((isa<GenericTypeDecl>(lookupDC) ||,264,download/apple_swift497.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/TypeCheckGeneric.cpp,+,sig->print(llvm::errs());,956,download/apple_swift497.cpp
97042d29fc2814ba273b98616ecb52b6a69dd70b,"Merge pull request #7683 from slavapestov/sema-generic-subscripts

Preliminary Sema support for generic subscripts",lib/Sema/TypeCheckGeneric.cpp,+,sig->getCanonicalSignature()->print(llvm::errs());,959,download/apple_swift497.cpp
1a8ba93e59d04f56b2eb69fe52f85f546b57e7af,"Sema: Refactor getTypeOfMemberReference() for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/Sema/ConstraintSystem.cpp,+,assert(isa<AbstractStorageDecl>(value) ||,1107,download/apple_swift498.cpp
1a8ba93e59d04f56b2eb69fe52f85f546b57e7af,"Sema: Refactor getTypeOfMemberReference() for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/Sema/ConstraintSystem.cpp,-,!selfTy->hasError()),1175,download/apple_swift498.cpp
1a8ba93e59d04f56b2eb69fe52f85f546b57e7af,"Sema: Refactor getTypeOfMemberReference() for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/Sema/ConstraintSystem.cpp,+,!selfTy->hasError()),1190,download/apple_swift498.cpp
4f83f6ef2167d41ce74919886fb4d4651cab3db7,"Sema: Fix CSRanking in preparation for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/Sema/CSRanking.cpp,-,"assert(!type1->is<GenericFunctionType>() && ""Odd generic function type?"");",552,download/apple_swift499.cpp
4f83f6ef2167d41ce74919886fb4d4651cab3db7,"Sema: Fix CSRanking in preparation for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/Sema/CSRanking.cpp,-,"assert(!type2->is<GenericFunctionType>() && ""Odd generic function type?"");",552,download/apple_swift499.cpp
8407e11f9cba550e152d787505b0e738f70bc463,"AST: Fix mangling in preparation for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/AST/ASTMangler.cpp,-,if (isMethodDecl(decl) && type && !type->hasError()) {,1504,download/apple_swift500.cpp
8407e11f9cba550e152d787505b0e738f70bc463,"AST: Fix mangling in preparation for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/AST/ASTMangler.cpp,+,if (!type->hasError()) {,1520,download/apple_swift500.cpp
8407e11f9cba550e152d787505b0e738f70bc463,"AST: Fix mangling in preparation for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/AST/Mangle.cpp,-,if (isMethodDecl(decl) && type && !type->hasError()) {,512,download/apple_swift501.cpp
8407e11f9cba550e152d787505b0e738f70bc463,"AST: Fix mangling in preparation for generic subscripts

Subscripts in generic context will soon have a
GenericFunctionType, so get ready to handle that.",lib/AST/Mangle.cpp,+,if (!type->hasError()) {,528,download/apple_swift501.cpp
f8e60e8a57262233cab4a97779de0a11ef80b572,Sema: Type checking of generic subscripts,lib/Sema/TypeCheckGeneric.cpp,-,assert(isa<GenericTypeDecl>(lookupDC) || isa<ExtensionDecl>(lookupDC) ||,263,download/apple_swift502.cpp
f8e60e8a57262233cab4a97779de0a11ef80b572,Sema: Type checking of generic subscripts,lib/Sema/TypeCheckGeneric.cpp,+,assert((isa<GenericTypeDecl>(lookupDC) ||,264,download/apple_swift502.cpp
f8e60e8a57262233cab4a97779de0a11ef80b572,Sema: Type checking of generic subscripts,lib/Sema/TypeCheckGeneric.cpp,+,sig->print(llvm::errs());,912,download/apple_swift502.cpp
f8e60e8a57262233cab4a97779de0a11ef80b572,Sema: Type checking of generic subscripts,lib/Sema/TypeCheckGeneric.cpp,+,sig->getCanonicalSignature()->print(llvm::errs());,915,download/apple_swift502.cpp
10fc3fa54677a7023079f70f0600a209777edffe,"[GenericSig Builder] Make resolve() less representative-dependent.

`GenericSignatureBuilder::resolve()` was always jumping to the
representative, to treat typealias representatives as
special. However, doing this means that we put the same-type
constraint on the wrong potential archetype (with the wrong source).

Eliminate the use of `getRepresentative()`. This unfortunately
causes us to need recursive resolution, because we can't always depend
on jumping to the representative to avoid it.",lib/AST/GenericSignatureBuilder.cpp,-,assert(!(pa->getParent() && pa->getTypeAliasDecl()) &&,583,download/apple_swift503.cpp
10fc3fa54677a7023079f70f0600a209777edffe,"[GenericSig Builder] Make resolve() less representative-dependent.

`GenericSignatureBuilder::resolve()` was always jumping to the
representative, to treat typealias representatives as
special. However, doing this means that we put the same-type
constraint on the wrong potential archetype (with the wrong source).

Eliminate the use of `getRepresentative()`. This unfortunately
causes us to need recursive resolution, because we can't always depend
on jumping to the representative to avoid it.",lib/AST/GenericSignatureBuilder.cpp,-,"assert(llvm::all_of(pa->getEquivalenceClass(),",1447,download/apple_swift503.cpp
10fc3fa54677a7023079f70f0600a209777edffe,"[GenericSig Builder] Make resolve() less representative-dependent.

`GenericSignatureBuilder::resolve()` was always jumping to the
representative, to treat typealias representatives as
special. However, doing this means that we put the same-type
constraint on the wrong potential archetype (with the wrong source).

Eliminate the use of `getRepresentative()`. This unfortunately
causes us to need recursive resolution, because we can't always depend
on jumping to the representative to avoid it.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(llvm::all_of(rep->getEquivalenceClass(),",1447,download/apple_swift503.cpp
23f3ba53f8cfeeccf6fa7bc6bb19446e865b7764,"[GenericSig Builder] Track and canonicalize same-type-to-concrete constraints.

Track each same-type-to-concrete constraint on the potential archetype
against which it was written, and ensure that the requirement sources
for such same-type constraints stay with the potential archetypes on
which they were described. This is similar to the way we track
same-type constraints among potential archetypes.

Use this information to canonicalize same-type-to-concrete constraints
appropriately. For each connected component within an equivalence
class of potential archetypes, select the best requirement source to
the concrete type, or substitute in an abstract requirement source if
none exists. This approach ensures that components that would be
equivalent to that concrete type anyway get a derived source, while
components that get the concrete-type equivalence by being tied to
another

To get here, we also needed to change the notion of the archetype
anchor so that potential archetypes with no same-type constraints
directly in their path are preferred over potential archetypes that do
have a same-type constraint in their path. Otherwise, the anchor might
be something that is always concrete and is, therefore, not terribly
interesting.

Fixes the new case that popped up in rdar://problem/30478915.",lib/AST/GenericSignatureBuilder.cpp,-,assert(conformance &&,1044,download/apple_swift504.cpp
23f3ba53f8cfeeccf6fa7bc6bb19446e865b7764,"[GenericSig Builder] Track and canonicalize same-type-to-concrete constraints.

Track each same-type-to-concrete constraint on the potential archetype
against which it was written, and ensure that the requirement sources
for such same-type constraints stay with the potential archetypes on
which they were described. This is similar to the way we track
same-type constraints among potential archetypes.

Use this information to canonicalize same-type-to-concrete constraints
appropriately. For each connected component within an equivalence
class of potential archetypes, select the best requirement source to
the concrete type, or substitute in an abstract requirement source if
none exists. This approach ensures that components that would be
equivalent to that concrete type anyway get a derived source, while
components that get the concrete-type equivalence by being tied to
another

To get here, we also needed to change the notion of the archetype
anchor so that potential archetypes with no same-type constraints
directly in their path are preferred over potential archetypes that do
have a same-type constraint in their path. Otherwise, the anchor might
be something that is always concrete and is, therefore, not terribly
interesting.

Fixes the new case that popped up in rdar://problem/30478915.",lib/AST/GenericSignatureBuilder.cpp,+,assert(conformance &&,1058,download/apple_swift504.cpp
23f3ba53f8cfeeccf6fa7bc6bb19446e865b7764,"[GenericSig Builder] Track and canonicalize same-type-to-concrete constraints.

Track each same-type-to-concrete constraint on the potential archetype
against which it was written, and ensure that the requirement sources
for such same-type constraints stay with the potential archetypes on
which they were described. This is similar to the way we track
same-type constraints among potential archetypes.

Use this information to canonicalize same-type-to-concrete constraints
appropriately. For each connected component within an equivalence
class of potential archetypes, select the best requirement source to
the concrete type, or substitute in an abstract requirement source if
none exists. This approach ensures that components that would be
equivalent to that concrete type anyway get a derived source, while
components that get the concrete-type equivalence by being tied to
another

To get here, we also needed to change the notion of the archetype
anchor so that potential archetypes with no same-type constraints
directly in their path are preferred over potential archetypes that do
have a same-type constraint in their path. Otherwise, the anchor might
be something that is always concrete and is, therefore, not terribly
interesting.

Fixes the new case that popped up in rdar://problem/30478915.",lib/AST/GenericSignatureBuilder.cpp,-,"ConcreteTypeSource->print(Out, SrcMgr);",1317,download/apple_swift504.cpp
23f3ba53f8cfeeccf6fa7bc6bb19446e865b7764,"[GenericSig Builder] Track and canonicalize same-type-to-concrete constraints.

Track each same-type-to-concrete constraint on the potential archetype
against which it was written, and ensure that the requirement sources
for such same-type constraints stay with the potential archetypes on
which they were described. This is similar to the way we track
same-type constraints among potential archetypes.

Use this information to canonicalize same-type-to-concrete constraints
appropriately. For each connected component within an equivalence
class of potential archetypes, select the best requirement source to
the concrete type, or substitute in an abstract requirement source if
none exists. This approach ensures that components that would be
equivalent to that concrete type anyway get a derived source, while
components that get the concrete-type equivalence by being tied to
another

To get here, we also needed to change the notion of the archetype
anchor so that potential archetypes with no same-type constraints
directly in their path are preferred over potential archetypes that do
have a same-type constraint in their path. Otherwise, the anchor might
be something that is always concrete and is, therefore, not terribly
interesting.

Fixes the new case that popped up in rdar://problem/30478915.",lib/AST/GenericSignatureBuilder.cpp,+,"ConcreteTypeSource->print(Out, SrcMgr);",1323,download/apple_swift504.cpp
23f3ba53f8cfeeccf6fa7bc6bb19446e865b7764,"[GenericSig Builder] Track and canonicalize same-type-to-concrete constraints.

Track each same-type-to-concrete constraint on the potential archetype
against which it was written, and ensure that the requirement sources
for such same-type constraints stay with the potential archetypes on
which they were described. This is similar to the way we track
same-type constraints among potential archetypes.

Use this information to canonicalize same-type-to-concrete constraints
appropriately. For each connected component within an equivalence
class of potential archetypes, select the best requirement source to
the concrete type, or substitute in an abstract requirement source if
none exists. This approach ensures that components that would be
equivalent to that concrete type anyway get a derived source, while
components that get the concrete-type equivalence by being tied to
another

To get here, we also needed to change the notion of the archetype
anchor so that potential archetypes with no same-type constraints
directly in their path are preferred over potential archetypes that do
have a same-type constraint in their path. Otherwise, the anchor might
be something that is always concrete and is, therefore, not terribly
interesting.

Fixes the new case that popped up in rdar://problem/30478915.",lib/AST/GenericSignatureBuilder.cpp,-,assert(!T2->ConcreteType,1810,download/apple_swift504.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/Decl.cpp,-,assert(isa<ClassDecl>(VD) || isa<ProtocolDecl>(VD) || isa<StructDecl>(VD) ||,4982,download/apple_swift505.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/Decl.cpp,-,assert(name->getNumSelectorPieces() == 1);,4985,download/apple_swift505.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/Decl.cpp,-,"printSwiftEnumElemNameInObjC(const EnumElementDecl *EL, llvm::raw_ostream &OS,",5004,download/apple_swift505.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/Decl.cpp,-,"printSwiftEnumElemNameInObjC(EL, OS, PreferredName.getBaseName());",5037,download/apple_swift505.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/SwiftNameTranslation.cpp,+,assert(isa<ClassDecl>(VD) || isa<ProtocolDecl>(VD) || isa<StructDecl>(VD) ||,30,download/apple_swift506.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/SwiftNameTranslation.cpp,+,assert(name->getNumSelectorPieces() == 1);,34,download/apple_swift506.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/SwiftNameTranslation.cpp,+,"printSwiftEnumElemNameInObjC(const EnumElementDecl *EL, llvm::raw_ostream &OS,",54,download/apple_swift506.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/SwiftNameTranslation.cpp,+,"printSwiftEnumElemNameInObjC(EL, OS, PreferredName.getBaseName());",88,download/apple_swift506.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,",49,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,",72,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,assert(Selector);,86,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {",93,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))",99,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"return printObjCUSRFragment(D, ObjCName.first.str(), OS);",106,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,assert(ObjCName.second);,108,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);",110,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"return printObjCUSR(VD, OS);",203,download/apple_swift507.cpp
444775f58ab7cf72f684b46c43e96041d4d0f7bc,"Merge pull request #7670 from nathawes/rdar16271632

Use clang-style USRs for swift decls that are exposed to Objective C",lib/AST/USRGeneration.cpp,+,"return printObjCUSRForAccessor(SD, AccKind, OS);",260,download/apple_swift507.cpp
69b3712c83cec0757a294ab6f02fbc6e16e714cb,"Merge pull request #7677 from bitjammer/rdar-30404063-pcr

Post-commit review: Remove sneaky file, don't use callPrintStructurePost",lib/AST/ASTPrinter.cpp,-,Printer.callPrintStructurePost(PrintStructureKind::GenericRequirement);,1358,download/apple_swift508.cpp
69b3712c83cec0757a294ab6f02fbc6e16e714cb,"Merge pull request #7677 from bitjammer/rdar-30404063-pcr

Post-commit review: Remove sneaky file, don't use callPrintStructurePost",lib/AST/ASTPrinter.cpp,+,Printer.printStructurePost(PrintStructureKind::GenericRequirement);,1358,download/apple_swift508.cpp
202fdf6358b59e6c1c000de92502d943d527e256,"Post-commit review: Remove sneaky file, don't use callPrintStructurePost

- Remove a test file that made its way in to the original commit.
- Don't need a newline forcing wrapper for printStructurePost

rdar://problem/30404063",lib/AST/ASTPrinter.cpp,-,Printer.callPrintStructurePost(PrintStructureKind::GenericRequirement);,1358,download/apple_swift509.cpp
202fdf6358b59e6c1c000de92502d943d527e256,"Post-commit review: Remove sneaky file, don't use callPrintStructurePost

- Remove a test file that made its way in to the original commit.
- Don't need a newline forcing wrapper for printStructurePost

rdar://problem/30404063",lib/AST/ASTPrinter.cpp,+,Printer.printStructurePost(PrintStructureKind::GenericRequirement);,1358,download/apple_swift509.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/Decl.cpp,-,assert(isa<ClassDecl>(VD) || isa<ProtocolDecl>(VD) || isa<StructDecl>(VD) ||,4974,download/apple_swift510.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/Decl.cpp,-,assert(name->getNumSelectorPieces() == 1);,4977,download/apple_swift510.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/Decl.cpp,-,"printSwiftEnumElemNameInObjC(const EnumElementDecl *EL, llvm::raw_ostream &OS,",4996,download/apple_swift510.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/Decl.cpp,-,"printSwiftEnumElemNameInObjC(EL, OS, PreferredName.getBaseName());",5029,download/apple_swift510.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/SwiftNameTranslation.cpp,+,assert(isa<ClassDecl>(VD) || isa<ProtocolDecl>(VD) || isa<StructDecl>(VD) ||,30,download/apple_swift511.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/SwiftNameTranslation.cpp,+,assert(name->getNumSelectorPieces() == 1);,34,download/apple_swift511.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/SwiftNameTranslation.cpp,+,"printSwiftEnumElemNameInObjC(const EnumElementDecl *EL, llvm::raw_ostream &OS,",54,download/apple_swift511.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/SwiftNameTranslation.cpp,+,"printSwiftEnumElemNameInObjC(EL, OS, PreferredName.getBaseName());",88,download/apple_swift511.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"static bool printObjCNameFragment(const ValueDecl *D, StringRef ObjCName,",49,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSRFragment(const ValueDecl *D, StringRef ObjCName,",49,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,",73,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSRForAccessor(const AbstractStorageDecl *ASD,",74,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,assert(Selector);,88,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS) {",95,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))",103,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"if (printObjCUSRFragment(Parent, ObjCName.first.str(), OS))",103,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"return printObjCNameFragment(D, Ident.str(), OS);",108,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"return printObjCNameFragment(D, Selector.getString(Buf), OS);",110,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"return printObjCUSRFragment(D, ObjCName.first.str(), OS);",115,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,assert(ObjCName.second);,117,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"return printObjCUSRFragment(D, ObjCName.second.getString(Buf), OS);",119,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"return printObjCUSR(VD, OS, ObjCName.first, ObjCName.second);",204,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"return printObjCUSR(VD, OS);",205,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"return printObjCUSR(SD, OS, Identifier(), SD->getObjCGetterSelector());",262,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,-,"return printObjCUSR(SD, OS, Identifier(), SD->getObjCSetterSelector());",263,download/apple_swift512.cpp
0dc0985f45fa9138ca0ef738226ea370ab4a1d38,"Move SwiftNameTranslation implementation out of Decl.cpp and into its own file.
Also fix code formatting issues and simplify the code in USRGeneration.cpp based on review comments in PR #7670.",lib/AST/USRGeneration.cpp,+,"return printObjCUSRForAccessor(SD, AccKind, OS);",267,download/apple_swift512.cpp
b023a486a71ebc4de9a72751259c53a0c47c055a,"Merge pull request #7674 from bitjammer/rdar-30561880-missing-constraint-annotation

[ASTPrinter] Restore printing generic requirement contexts",lib/AST/ASTPrinter.cpp,+,Printer.callPrintStructurePre(PrintStructureKind::GenericRequirement);,1350,download/apple_swift513.cpp
b023a486a71ebc4de9a72751259c53a0c47c055a,"Merge pull request #7674 from bitjammer/rdar-30561880-missing-constraint-annotation

[ASTPrinter] Restore printing generic requirement contexts",lib/AST/ASTPrinter.cpp,+,Printer.callPrintStructurePost(PrintStructureKind::GenericRequirement);,1358,download/apple_swift513.cpp
e58c6b368852faffdc4dd15a73172ddb7cce805d,"Merge pull request #7389 from huonw/protocol-type-aliases

[Generic Signature Builder] Improve the handling of typealiases in protocols.",lib/AST/GenericSignatureBuilder.cpp,+,assert(!t->isTypeParameter() &&,523,download/apple_swift514.cpp
e58c6b368852faffdc4dd15a73172ddb7cce805d,"Merge pull request #7389 from huonw/protocol-type-aliases

[Generic Signature Builder] Improve the handling of typealiases in protocols.",lib/AST/GenericSignatureBuilder.cpp,+,assert(!(pa->getParent() && pa->getTypeAliasDecl()) &&,537,download/apple_swift514.cpp
e58c6b368852faffdc4dd15a73172ddb7cce805d,"Merge pull request #7389 from huonw/protocol-type-aliases

[Generic Signature Builder] Improve the handling of typealiases in protocols.",lib/AST/GenericSignatureBuilder.cpp,+,assert(pa->getParent() && pa->getTypeAliasDecl() &&,543,download/apple_swift514.cpp
e58c6b368852faffdc4dd15a73172ddb7cce805d,"Merge pull request #7389 from huonw/protocol-type-aliases

[Generic Signature Builder] Improve the handling of typealiases in protocols.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(llvm::all_of(pa->getEquivalenceClass(),",1377,download/apple_swift514.cpp
450028fbe8cf0c83fedc7545bd9abb65846903e7,"[ASTPrinter] Restore printing generic requirement contexts

cfe9e6a3defb0368c2ef9742b59bf1d83ca66ecf removed calls to pre/post
printing of PrintStructureKind::GenericRequirement, so SourceKit DocInfo
requests started droping the markers for generic requirements, causing
some weirdness with documentation rendering and post-processing.

Restore the calls to printStructPre/Post when printing generic
requirements.

rdar://problem/30561880",lib/AST/ASTPrinter.cpp,+,Printer.callPrintStructurePre(PrintStructureKind::GenericRequirement);,1350,download/apple_swift515.cpp
450028fbe8cf0c83fedc7545bd9abb65846903e7,"[ASTPrinter] Restore printing generic requirement contexts

cfe9e6a3defb0368c2ef9742b59bf1d83ca66ecf removed calls to pre/post
printing of PrintStructureKind::GenericRequirement, so SourceKit DocInfo
requests started droping the markers for generic requirements, causing
some weirdness with documentation rendering and post-processing.

Restore the calls to printStructPre/Post when printing generic
requirements.

rdar://problem/30561880",lib/AST/ASTPrinter.cpp,+,Printer.callPrintStructurePost(PrintStructureKind::GenericRequirement);,1358,download/apple_swift515.cpp
c9758c2c0fa6cb63d1ace0151f6241083fc02f2f,Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"static bool printObjCNameFragment(const ValueDecl *D, StringRef ObjCName,",49,download/apple_swift516.cpp
c9758c2c0fa6cb63d1ace0151f6241083fc02f2f,Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"static bool printObjCUSR(const ValueDecl *D, raw_ostream &OS, Identifier Ident,",73,download/apple_swift516.cpp
c9758c2c0fa6cb63d1ace0151f6241083fc02f2f,Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"if (printObjCNameFragment(Parent, ObjCName.first.str(), OS))",80,download/apple_swift516.cpp
c9758c2c0fa6cb63d1ace0151f6241083fc02f2f,Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"return printObjCNameFragment(D, Ident.str(), OS);",85,download/apple_swift516.cpp
c9758c2c0fa6cb63d1ace0151f6241083fc02f2f,Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"return printObjCNameFragment(D, Selector.getString(Buf), OS);",88,download/apple_swift516.cpp
c9758c2c0fa6cb63d1ace0151f6241083fc02f2f,Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"return printObjCUSR(VD, OS, ObjCName.first, ObjCName.second);",184,download/apple_swift516.cpp
c9758c2c0fa6cb63d1ace0151f6241083fc02f2f,Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"return printObjCUSR(SD, OS, Identifier(), SD->getObjCGetterSelector());",243,download/apple_swift516.cpp
c9758c2c0fa6cb63d1ace0151f6241083fc02f2f,Use clang-style USRs for swift decls that are exposed to Objective C,lib/AST/USRGeneration.cpp,+,"return printObjCUSR(SD, OS, Identifier(), SD->getObjCSetterSelector());",245,download/apple_swift516.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,getForeignErrorConventionKindString(ForeignErrorConvention::Kind value) {,257,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << "" access="";",674,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""private"";",676,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""fileprivate"";",678,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""internal"";",680,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""public"";",682,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << ""open"";",684,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor) << "" access=""",686,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,OS << getForeignErrorConventionKindString(fec->getKind());,871,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#column"");",893,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#dsohandle"");",895,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#file"");",897,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#function"");",899,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""inherited"");",901,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""#line"");",903,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""nil"");",905,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""[]"");",907,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""[:]"");",909,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""default_arg"", ""normal"");",911,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"printField(""default_arg"",",914,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" designated"";",969,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" convenience"";",972,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" convenience_factory"";",975,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" factory"";",978,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor) << "" failable=Optional"";",986,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, DeclModifierColor)",989,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, DeclModifierColor) << "" """,993,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, DeclModifierColor) << "" failable=""",996,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,void printStringEncoding(StringLiteralExpr::Encoding encoding) {,1686,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""utf8"";",1688,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""utf16"";",1690,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << ""unicodeScalar"";",1692,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor) << "" encoding="";",1698,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getEncoding());,1698,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, LiteralValueColor)",1698,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, LiteralValueColor) << "" encoding=""",1698,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printCommon(E, ""magic_identifier_literal_expr"") << "" kind="";",1707,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getStringEncoding());,1710,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printStringEncoding(E->getStringEncoding());,1714,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"printCommon(E, ""magic_identifier_literal_expr"")",1720,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();",1738,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)",1739,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();",1810,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)",1811,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"PrintWithColorRAII(OS, AccessibilityColor) << E->getAccessSemantics();",1894,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"PrintWithColorRAII(OS, AccessibilityColor)",1895,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printFlag(""vararg"");",2700,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printFlag(""autoclosure"");",2701,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printFlag(""escaping"");",2702,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"printFlag(paramFlags.isVariadic(), ""vararg"");",2702,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"printFlag(paramFlags.isAutoClosure(), ""autoclosure"");",2703,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"printFlag(paramFlags.isEscaping(), ""escaping"");",2704,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,void printMetatypeRepresentation(MetatypeRepresentation representation) {,2846,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printMetatypeRepresentation(T->getRepresentation());,2863,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,printMetatypeRepresentation(T->getRepresentation());,2858,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""block"");",2954,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""c"");",2957,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""thin"");",2960,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""method"");",2963,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""objc_method"");",2966,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""witness_method"");",2969,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,-,"printField(""representation"", ""closure"");",2972,download/apple_swift517.cpp
5f734c2f15b918732ca3dd157265d433c6e9dcc2,Clean up enum to string transformations,lib/AST/ASTDumper.cpp,+,"printField(""representation"",",2975,download/apple_swift517.cpp
147f844ce41fdd41c467853ef620f8e45082c155,"Merge pull request #7654 from shajrawi/init_opaque

Add support for Init Existentials for opaque value types",lib/Parse/ParseSIL.cpp,+,"parseSILType(ExistentialTy) || parseSILDebugLocation(InstLoc, B))",3759,download/apple_swift518.cpp
d759522a5b4c78bbcfab04dc1fa8a599a15e639e,"Merge pull request #7655 from DougGregor/orphaned-constraints

[Constraint solver] Handle disjunctions as separate connected components",lib/Sema/CSSolver.cpp,+,"assert(InactiveConstraints.size() == 1 && ""supposed to be an orphan!"");",2166,download/apple_swift519.cpp
d759522a5b4c78bbcfab04dc1fa8a599a15e639e,"Merge pull request #7655 from DougGregor/orphaned-constraints

[Constraint solver] Handle disjunctions as separate connected components",lib/Sema/ConstraintGraph.cpp,+,"assert(known != OrphanedConstraints.end() && ""missing orphaned constraint"");",389,download/apple_swift520.cpp
88581372c3da566ab894b76ce62dda556cd4bdfb,"Merge pull request #7651 from eeckstein/fix-fs-demangling

Demangler: fix the function specialization de-mangling",lib/Basic/Demangler.cpp,+,assert(KindNd->getKind() ==,1200,download/apple_swift521.cpp
88581372c3da566ab894b76ce62dda556cd4bdfb,"Merge pull request #7651 from eeckstein/fix-fs-demangling

Demangler: fix the function specialization de-mangling",lib/Basic/Demangler.cpp,+,assert(ParamKind == FunctionSigSpecializationParamKind::ClosureProp);,1210,download/apple_swift521.cpp
9cfd86e4ea2461813888a4a7a4fe06cb6e2309e7,"Merge pull request #7652 from swiftix/wip-generics-inlining-flag-66

[sil-performance-inliner] Fix recent performance regressions",lib/SILOptimizer/Transforms/PerformanceInliner.cpp,+,assert(EnableSILInliningOfGenerics || !IsGeneric);,330,download/apple_swift522.cpp
40b6764e80a71e46531c770851beff0962a51db2,"[Constraint solver] Handle disjunctions as separate connected components.

The constraint graph models type variables (as the nodes) and
constraints (as the multi-edges connecting nodes). The connected
components within this (multi-)graph are independent subproblems that
are solved separately; the results from each subproblem are then
combined. The approach helps curtail exponential behavior, because
(e.g.) the disjunctions/type variables in one component won't ever be
explored while solving for another component

This approach assumes that all of the constraints that cannot be
immediately solved are associated with one or more type
variables. This is almost entirely true---constraints that don't
involve type variables are immediately simplified.

Except for disjunctions. A disjunction involving no type variables
would not appear *at all* in the constraint graph. Worse, it's
independence from other constraints could not be established, so the
constraint solver would go exponential for every one of these
constraints. This has always been an issue, but it got worse with the
separation of type checking of ""as"" into the ""coercion"" case and the
""bridging"" case, which introduced more of these disjunctions. This led
to counterintuitive behavior where adding ""as Foo"" would cause the
type checking to take *more* time than leaving it off, if both sides
of the ""as"" were known to be concrete. rdar://problem/30545483
captures a case (now in the new test case) where we saw such
exponential blow-ups.

Teach the constraint graph to keep track of ""orphaned"" constraints
that don't reference any type variables, and treat each ""orphaned""
constraint as a separate connected component. That way, they're solved
independently.

Fixes rdar://problem/30545483 and will likely curtain other
exponential behavior we're seeing in the solver.",lib/Sema/CSSolver.cpp,+,"assert(InactiveConstraints.size() == 1 && ""supposed to be an orphan!"");",2166,download/apple_swift523.cpp
40b6764e80a71e46531c770851beff0962a51db2,"[Constraint solver] Handle disjunctions as separate connected components.

The constraint graph models type variables (as the nodes) and
constraints (as the multi-edges connecting nodes). The connected
components within this (multi-)graph are independent subproblems that
are solved separately; the results from each subproblem are then
combined. The approach helps curtail exponential behavior, because
(e.g.) the disjunctions/type variables in one component won't ever be
explored while solving for another component

This approach assumes that all of the constraints that cannot be
immediately solved are associated with one or more type
variables. This is almost entirely true---constraints that don't
involve type variables are immediately simplified.

Except for disjunctions. A disjunction involving no type variables
would not appear *at all* in the constraint graph. Worse, it's
independence from other constraints could not be established, so the
constraint solver would go exponential for every one of these
constraints. This has always been an issue, but it got worse with the
separation of type checking of ""as"" into the ""coercion"" case and the
""bridging"" case, which introduced more of these disjunctions. This led
to counterintuitive behavior where adding ""as Foo"" would cause the
type checking to take *more* time than leaving it off, if both sides
of the ""as"" were known to be concrete. rdar://problem/30545483
captures a case (now in the new test case) where we saw such
exponential blow-ups.

Teach the constraint graph to keep track of ""orphaned"" constraints
that don't reference any type variables, and treat each ""orphaned""
constraint as a separate connected component. That way, they're solved
independently.

Fixes rdar://problem/30545483 and will likely curtain other
exponential behavior we're seeing in the solver.",lib/Sema/ConstraintGraph.cpp,+,"assert(known != OrphanedConstraints.end() && ""missing orphaned constraint"");",389,download/apple_swift524.cpp
1e521c453bcdedfe163534328a7400a85dfb921a,Add support for Init Existentials for opaque value types,lib/Parse/ParseSIL.cpp,+,"parseSILType(ExistentialTy) || parseSILDebugLocation(InstLoc, B))",3759,download/apple_swift525.cpp
a35cd0e36c456b86215b348a1ede99300e7677d5,"Demangler: fix the function specialization de-mangling

The order in which the argument parameters were de-mangled was wrong.

rdar://problem/30592808",lib/Basic/Demangler.cpp,+,assert(KindNd->getKind() ==,1200,download/apple_swift526.cpp
a35cd0e36c456b86215b348a1ede99300e7677d5,"Demangler: fix the function specialization de-mangling

The order in which the argument parameters were de-mangled was wrong.

rdar://problem/30592808",lib/Basic/Demangler.cpp,+,assert(ParamKind == FunctionSigSpecializationParamKind::ClosureProp);,1210,download/apple_swift526.cpp
ef088e818d964dc671878266e9b9b07d94b6c8ea,"[sil-performance-inliner] Fix recent performance regressions

Do not perform any inlining of generics if it is not enabled. Don't do it even for always inline functions.",lib/SILOptimizer/Transforms/PerformanceInliner.cpp,+,assert(EnableSILInliningOfGenerics || !IsGeneric);,330,download/apple_swift527.cpp
e6a85f6602934d35d217f2ea23059660d543b5ff,"[ClangImporter] Resolve forward declarations before importing names. (#7555)

This allows a previously-working case of Objective-C forward-declaring
a type in a /different/ Swift module to continue working, as long as
the Swift context being compiled manages to import the other module
properly (including its generated header). This isn't really our
recommended pattern---that would be to @import the module in the
bridging header and forego the forward declaration---but it doesn't
cost much to keep it working. It's also a place where textual and
precompiled bridging headers behaved differently, because precompiled
ones are processed much earlier.

https://bugs.swift.org/browse/SR-3798",lib/ClangImporter/ImportDecl.cpp,-,assert(decl);,4119,download/apple_swift528.cpp
0b5b7d057e683a74fb76af36645c3ab5d32d0e3c,ASTPrinter: Expose a utility to print keywords directly by token kinds. NFC (#7646),lib/AST/ASTPrinter.cpp,-,printer.printKeyword(name);,600,download/apple_swift529.cpp
0b5b7d057e683a74fb76af36645c3ab5d32d0e3c,ASTPrinter: Expose a utility to print keywords directly by token kinds. NFC (#7646),lib/AST/ASTPrinter.cpp,+,printer.printKeyword(Buffer.str());,607,download/apple_swift529.cpp
a79fd9eff14756b04c04dab70e2987dc3d649fcf,"Merge pull request #7639 from slavapestov/sourcekit-indexing-protocol-typealias

SourceKit: Fix indexing crash with protocol typealiases",lib/AST/Decl.cpp,+,assert(isa<ProtocolDecl>(getDeclContext()));,1683,download/apple_swift530.cpp
a79fd9eff14756b04c04dab70e2987dc3d649fcf,"Merge pull request #7639 from slavapestov/sourcekit-indexing-protocol-typealias

SourceKit: Fix indexing crash with protocol typealiases",lib/AST/ProtocolConformance.cpp,+,"assert(requirement->isProtocolRequirement() && ""Not a requirement"");",324,download/apple_swift531.cpp
f64ef032353926f4dbd91267733aa3ecea5142c8,"[Generic signature builder] resolve types deeper in same type requirements.

This adds the concept of an ""unresolved type"" and a ""resolved type"",
where the latter involves stripping away any typealias archetype layers
from the former, to get to the ""true"" potential archetype or concrete
type that something refers to.",lib/AST/GenericSignatureBuilder.cpp,+,assert(!t->isTypeParameter() &&,523,download/apple_swift532.cpp
f64ef032353926f4dbd91267733aa3ecea5142c8,"[Generic signature builder] resolve types deeper in same type requirements.

This adds the concept of an ""unresolved type"" and a ""resolved type"",
where the latter involves stripping away any typealias archetype layers
from the former, to get to the ""true"" potential archetype or concrete
type that something refers to.",lib/AST/GenericSignatureBuilder.cpp,+,assert(!(pa->getParent() && pa->getTypeAliasDecl()) &&,529,download/apple_swift532.cpp
f64ef032353926f4dbd91267733aa3ecea5142c8,"[Generic signature builder] resolve types deeper in same type requirements.

This adds the concept of an ""unresolved type"" and a ""resolved type"",
where the latter involves stripping away any typealias archetype layers
from the former, to get to the ""true"" potential archetype or concrete
type that something refers to.",lib/AST/GenericSignatureBuilder.cpp,+,assert(pa->getParent() && pa->getTypeAliasDecl() &&,535,download/apple_swift532.cpp
f64ef032353926f4dbd91267733aa3ecea5142c8,"[Generic signature builder] resolve types deeper in same type requirements.

This adds the concept of an ""unresolved type"" and a ""resolved type"",
where the latter involves stripping away any typealias archetype layers
from the former, to get to the ""true"" potential archetype or concrete
type that something refers to.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(llvm::all_of(pa->getEquivalenceClass(),",1332,download/apple_swift532.cpp
fe3ed9367ae23c6a4ddddc77866cedaf47e10f9b,Merge pull request #7642 from DougGregor/remove-inherited-protocols,lib/AST/Decl.cpp,-,assert(isInheritedProtocolsValid());,2671,download/apple_swift533.cpp
fe3ed9367ae23c6a4ddddc77866cedaf47e10f9b,Merge pull request #7642 from DougGregor/remove-inherited-protocols,lib/PrintAsObjC/PrintAsObjC.cpp,-,printProtocols(PD->getInheritedProtocols(nullptr));,347,download/apple_swift534.cpp
fe3ed9367ae23c6a4ddddc77866cedaf47e10f9b,Merge pull request #7642 from DougGregor/remove-inherited-protocols,lib/PrintAsObjC/PrintAsObjC.cpp,+,printProtocols(PD->getInheritedProtocols());,347,download/apple_swift534.cpp
042e6510c324c699b86e7a8d0d20068b2ee8feb4,"[AST] Drop ProtocolDecl's ""inherited protocols"" list.

The list of directly inherited protocols of a ProtocolDecl is already
encoded in the requirement signature, as conformance constraints where
the subject is Self. Gather the list from there rather than separately
computing/storing the list of ""inherited protocols"".",lib/AST/Decl.cpp,-,assert(isInheritedProtocolsValid());,2671,download/apple_swift535.cpp
042e6510c324c699b86e7a8d0d20068b2ee8feb4,"[AST] Drop ProtocolDecl's ""inherited protocols"" list.

The list of directly inherited protocols of a ProtocolDecl is already
encoded in the requirement signature, as conformance constraints where
the subject is Self. Gather the list from there rather than separately
computing/storing the list of ""inherited protocols"".",lib/PrintAsObjC/PrintAsObjC.cpp,-,printProtocols(PD->getInheritedProtocols(nullptr));,347,download/apple_swift536.cpp
042e6510c324c699b86e7a8d0d20068b2ee8feb4,"[AST] Drop ProtocolDecl's ""inherited protocols"" list.

The list of directly inherited protocols of a ProtocolDecl is already
encoded in the requirement signature, as conformance constraints where
the subject is Self. Gather the list from there rather than separately
computing/storing the list of ""inherited protocols"".",lib/PrintAsObjC/PrintAsObjC.cpp,+,printProtocols(PD->getInheritedProtocols());,347,download/apple_swift536.cpp
0bc802e7adbff3768a28525bd2da05c9505fdf36,"SourceKit: Fix indexing crash with protocol typealiases

The root cause is that NormalProtocolConformance::forEachValueWitness()
needs to skip protocol members that are not requirements.

Otherwise we end up passing such a non-requirement member down to
NormalProtocolConformance::getWitness() and hit an assert when we
cannot find it.

It looks like this code path was only ever hit from SourceKit.
The fix moves TypeChecker::isRequirement() to a method on ValueDecl,
and calls it in the right places.

Fixes <https://bugs.swift.org/browse/SR-3815>.",lib/AST/Decl.cpp,+,assert(isa<ProtocolDecl>(getDeclContext()));,1683,download/apple_swift537.cpp
0bc802e7adbff3768a28525bd2da05c9505fdf36,"SourceKit: Fix indexing crash with protocol typealiases

The root cause is that NormalProtocolConformance::forEachValueWitness()
needs to skip protocol members that are not requirements.

Otherwise we end up passing such a non-requirement member down to
NormalProtocolConformance::getWitness() and hit an assert when we
cannot find it.

It looks like this code path was only ever hit from SourceKit.
The fix moves TypeChecker::isRequirement() to a method on ValueDecl,
and calls it in the right places.

Fixes <https://bugs.swift.org/browse/SR-3815>.",lib/AST/ProtocolConformance.cpp,+,"assert(requirement->isProtocolRequirement() && ""Not a requirement"");",324,download/apple_swift538.cpp
e824837fdf21850e142d1bc8b9f54de1ba999969,"Merge pull request #7628 from slavapestov/ast-support-for-generic-subscripts

AST and Serialization support for generic subscripts",lib/Sema/TypeCheckGeneric.cpp,+,if (tl.wasValidated() && tl.isError()),403,download/apple_swift539.cpp
e824837fdf21850e142d1bc8b9f54de1ba999969,"Merge pull request #7628 from slavapestov/ast-support-for-generic-subscripts

AST and Serialization support for generic subscripts",lib/Sema/TypeCheckGeneric.cpp,-,if (tl.wasValidated() && tl.isError()),900,download/apple_swift539.cpp
e824837fdf21850e142d1bc8b9f54de1ba999969,"Merge pull request #7628 from slavapestov/ast-support-for-generic-subscripts

AST and Serialization support for generic subscripts",lib/Serialization/Serialization.cpp,+,writeGenericParams(subscript->getGenericParams());,2902,download/apple_swift540.cpp
397dba6dccb2189a273dcd64a5da8fad2e747c16,Merge pull request #7630 from gottesmm/emitpreconditionoptionalfixups_more_enum_extraction_apis,lib/SILGen/SILGenBuilder.cpp,+,assert(lowering.getLoweredType().getAddressType() == v.getType());,387,download/apple_swift541.cpp
397dba6dccb2189a273dcd64a5da8fad2e747c16,Merge pull request #7630 from gottesmm/emitpreconditionoptionalfixups_more_enum_extraction_apis,lib/SILGen/SILGenBuilder.cpp,+,"assert(!lowering.isAddressOnly() && ""cannot retain an unloadable type"");",392,download/apple_swift541.cpp
26a266b15eb00c3f450c296adbd3d0eda1d2baa9,"[silgen] Cleanup emitPreconditionOptionalHasValue and its uses so that they use proper ownership.

The big change here is that this routine will not emit switch_enum as a +1 value
and create a proper owned argument with cleanup.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,assert(lowering.getLoweredType().getAddressType() == v.getType());,387,download/apple_swift542.cpp
26a266b15eb00c3f450c296adbd3d0eda1d2baa9,"[silgen] Cleanup emitPreconditionOptionalHasValue and its uses so that they use proper ownership.

The big change here is that this routine will not emit switch_enum as a +1 value
and create a proper owned argument with cleanup.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,"assert(!lowering.isAddressOnly() && ""cannot retain an unloadable type"");",392,download/apple_swift542.cpp
cc54361b2a2832885adaea38fb5bcaf6e363a2a8,Serialization: Add support for generic subscripts,lib/Serialization/Serialization.cpp,+,writeGenericParams(subscript->getGenericParams());,2902,download/apple_swift543.cpp
fe16cf869d65cd20fca7ce5666350b07e838bf91,Sema: Move some code around for better organization,lib/Sema/TypeCheckGeneric.cpp,+,if (tl.wasValidated() && tl.isError()),403,download/apple_swift544.cpp
fe16cf869d65cd20fca7ce5666350b07e838bf91,Sema: Move some code around for better organization,lib/Sema/TypeCheckGeneric.cpp,-,if (tl.wasValidated() && tl.isError()),900,download/apple_swift544.cpp
fa6eb8d59b0d7dadd44b92e1bcf02a1364b9ce9f,Merge pull request #7618 from gottesmm/more_silgen_refactorings,lib/SILGen/ManagedValue.cpp,+,"assert(gen.InWritebackScope && ""Can only perform a formal access copy in a """,43,download/apple_swift545.cpp
53b777cf9c1cf1891c6134c2b67ea3e58e620394,"[silgen] Add an assert that formalAccessCopy is only called in a FormalEvaluationScope.

NFC.",lib/SILGen/ManagedValue.cpp,+,"assert(gen.InWritebackScope && ""Can only perform a formal access copy in a """,43,download/apple_swift546.cpp
8b2cd866d1e70646792ee4d67f03b095b907d792,"Merge pull request #7616 from gottesmm/refactor_prepare_archetype_callee

[silgen] Refactor prepareArchetypeCallee to use a builder class instead of iterated closures.",lib/SILGen/SILGenApply.cpp,-,assert(gen.silConv.useLoweredAddresses(),746,download/apple_swift547.cpp
8b2cd866d1e70646792ee4d67f03b095b907d792,"Merge pull request #7616 from gottesmm/refactor_prepare_archetype_callee

[silgen] Refactor prepareArchetypeCallee to use a builder class instead of iterated closures.",lib/SILGen/SILGenApply.cpp,+,assert(gen.silConv.useLoweredAddresses() ==,747,download/apple_swift547.cpp
4e5413046df4e7ca177e475dc023f0760fc39091,Merge pull request #7615 from gottesmm/some_helper_routines,lib/SILGen/ManagedValue.cpp,-,assert(gen.getTypeLowering(getType()).isTrivial());,28,download/apple_swift548.cpp
4e5413046df4e7ca177e475dc023f0760fc39091,Merge pull request #7615 from gottesmm/some_helper_routines,lib/SILGen/ManagedValue.cpp,-,"assert(!lowering.isTrivial() && ""trivial value has cleanup?"");",47,download/apple_swift548.cpp
4e5413046df4e7ca177e475dc023f0760fc39091,Merge pull request #7615 from gottesmm/some_helper_routines,lib/SILGen/SILGenBuilder.cpp,+,"assert(!ty.isAddress() && ""Can not perform a copy value of an address typed """,173,download/apple_swift549.cpp
4e5413046df4e7ca177e475dc023f0760fc39091,Merge pull request #7615 from gottesmm/some_helper_routines,lib/SILGen/SILGenBuilder.cpp,+,"assert(!lowering.isAddressOnly() && ""cannot perform a copy value of an """,297,download/apple_swift549.cpp
4e5413046df4e7ca177e475dc023f0760fc39091,Merge pull request #7615 from gottesmm/some_helper_routines,lib/SILGen/SILGenDecl.cpp,+,"assert(InWritebackScope && ""Must be in formal evaluation scope"");",1428,download/apple_swift550.cpp
4e5413046df4e7ca177e475dc023f0760fc39091,Merge pull request #7615 from gottesmm/some_helper_routines,lib/SILGen/SILGenDecl.cpp,+,"assert(InWritebackScope && ""Must be in formal evaluation scope"");",1443,download/apple_swift550.cpp
4e5413046df4e7ca177e475dc023f0760fc39091,Merge pull request #7615 from gottesmm/some_helper_routines,lib/SILGen/SILGenDecl.cpp,+,"assert(InWritebackScope && ""Must be in formal evaluation scope"");",1457,download/apple_swift550.cpp
9a964034960c2ec5cae78336813b63093f8bfe2a,"[silgen] Refactor prepareArchetypeCallee to use a builder class instead of iterated closures.

The way iterated closures were used to propagate around state that caused the
flow of data in the program to be confusing to read. This makes the dataflow
explicit by communicating clearly what variables are ""global"" to the
computation.

Beyond the refactoring this is a NFC.

rdar://29791263",lib/SILGen/SILGenApply.cpp,-,assert(gen.silConv.useLoweredAddresses(),746,download/apple_swift551.cpp
9a964034960c2ec5cae78336813b63093f8bfe2a,"[silgen] Refactor prepareArchetypeCallee to use a builder class instead of iterated closures.

The way iterated closures were used to propagate around state that caused the
flow of data in the program to be confusing to read. This makes the dataflow
explicit by communicating clearly what variables are ""global"" to the
computation.

Beyond the refactoring this is a NFC.

rdar://29791263",lib/SILGen/SILGenApply.cpp,+,assert(gen.silConv.useLoweredAddresses() ==,747,download/apple_swift551.cpp
5717eeba673a3ad6be689d057ab4868fde2a1580,"[silgen] Create a ManagedValue::formalAccessCopy(SILGenFunction &, SILLocation).

This is the same as the current ManagedValue::copy(...) convenience API except
that the cleanups are formal evaluation scoped.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,"assert(!lowering.isAddressOnly() && ""cannot perform a copy value of an """,297,download/apple_swift552.cpp
6b05692d31a24fb1d1f19695e778412ea6775ab8,"[silgen] Remove incorrect assumptions in ManagedValue::copy(SILGenFunction &gen, SILLocation loc).

It was wrongly assumed that no cleanup meant a type must be trivial. This is not
true for shared borrow types.",lib/SILGen/ManagedValue.cpp,-,assert(gen.getTypeLowering(getType()).isTrivial());,28,download/apple_swift553.cpp
6b05692d31a24fb1d1f19695e778412ea6775ab8,"[silgen] Remove incorrect assumptions in ManagedValue::copy(SILGenFunction &gen, SILLocation loc).

It was wrongly assumed that no cleanup meant a type must be trivial. This is not
true for shared borrow types.",lib/SILGen/ManagedValue.cpp,-,"assert(!lowering.isTrivial() && ""trivial value has cleanup?"");",33,download/apple_swift553.cpp
0ae6c2523882be544bb808b0d5a1f20df02e51c1,"[silgen] Make SILGenBuilder::createCopyValue a drop in replacement for SILGenFunction::emitManagedRetain.

The only difference is that the copy value API takes a ManagedValue. Hopefully
once we eliminate direct manipulation of SILValue in SILGen, we can get rid of
the emitManagedRetain API in SILGen.

rdar://29791263",lib/SILGen/SILGenBuilder.cpp,+,"assert(!ty.isAddress() && ""Can not perform a copy value of an address typed """,173,download/apple_swift554.cpp
c6b32aea2c6166513fdd14dfbd79bba5d05a4eff,"[silgen] Add APIs for creating managed buffers and managed rvalues in a FormalEvaluation context.

Eventually I want to move all of these emit* APIs to SILGenBuilder and make them
private details of SILGenBuilder. But that is a refactoring for another time.

rdar://29791263",lib/SILGen/SILGenDecl.cpp,+,"assert(InWritebackScope && ""Must be in formal evaluation scope"");",1428,download/apple_swift555.cpp
c6b32aea2c6166513fdd14dfbd79bba5d05a4eff,"[silgen] Add APIs for creating managed buffers and managed rvalues in a FormalEvaluation context.

Eventually I want to move all of these emit* APIs to SILGenBuilder and make them
private details of SILGenBuilder. But that is a refactoring for another time.

rdar://29791263",lib/SILGen/SILGenDecl.cpp,+,"assert(InWritebackScope && ""Must be in formal evaluation scope"");",1443,download/apple_swift555.cpp
c6b32aea2c6166513fdd14dfbd79bba5d05a4eff,"[silgen] Add APIs for creating managed buffers and managed rvalues in a FormalEvaluation context.

Eventually I want to move all of these emit* APIs to SILGenBuilder and make them
private details of SILGenBuilder. But that is a refactoring for another time.

rdar://29791263",lib/SILGen/SILGenDecl.cpp,+,"assert(InWritebackScope && ""Must be in formal evaluation scope"");",1457,download/apple_swift555.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,+,assert((GenericSigOrEnv.isNull() ||,581,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,+,assert(GenericSigOrEnv.is<GenericSignature *>() &&,592,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,+,"assert(GenericSigOrEnv.isNull() && ""already have a generic signature"");",624,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,assert((GenericSigOrEnv.isNull() ||,842,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,assert(GenericSigOrEnv.is<GenericSignature *>() &&,852,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,"assert(GenericSigOrEnv.isNull() && ""already have a generic signature"");",865,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,assert((GenericSigOrEnv.isNull() ||,2254,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,assert(GenericSigOrEnv.is<GenericSignature *>() &&,2265,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,"assert(GenericSigOrEnv.isNull() && ""already have a generic signature"");",2278,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,assert((GenericSigOrEnv.isNull() ||,4051,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,assert(GenericSigOrEnv.is<GenericSignature *>() &&,4062,download/apple_swift556.cpp
30464a5831b526e4ee587e363d0f596ec922c889,"Merge pull request #7597 from slavapestov/introduce-generic-context

AST: Introduce new GenericContext base class",lib/AST/Decl.cpp,-,"assert(GenericSigOrEnv.isNull() && ""already have a generic signature"");",4076,download/apple_swift556.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,+,assert((GenericSigOrEnv.isNull() ||,581,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,+,assert(GenericSigOrEnv.is<GenericSignature *>() &&,592,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,+,"assert(GenericSigOrEnv.isNull() && ""already have a generic signature"");",624,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,assert((GenericSigOrEnv.isNull() ||,842,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,assert(GenericSigOrEnv.is<GenericSignature *>() &&,852,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,"assert(GenericSigOrEnv.isNull() && ""already have a generic signature"");",865,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,assert((GenericSigOrEnv.isNull() ||,2254,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,assert(GenericSigOrEnv.is<GenericSignature *>() &&,2265,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,"assert(GenericSigOrEnv.isNull() && ""already have a generic signature"");",2278,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,assert((GenericSigOrEnv.isNull() ||,4051,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,assert(GenericSigOrEnv.is<GenericSignature *>() &&,4062,download/apple_swift557.cpp
ad78604e32f30e8259b238894630107b1b675e11,"AST: Introduce new GenericContext base class

This is in preparation for generic subscripts, which will also
expose methods like getGenericSignature(), and so on.

ExtensionDecl, GenericTypeDecl and AbstractFunctionDecl all share
code. Instead of copy and pasting it yet again into SubscriptDecl,
factor it out into a common base class.

There are more yaks to shave here, but this is a step in the right
direction.",lib/AST/Decl.cpp,-,"assert(GenericSigOrEnv.isNull() && ""already have a generic signature"");",4076,download/apple_swift557.cpp
b925ee9acba39f4376c589c39678155e9e745090,Merge pull request #7592 from gottesmm/lvalue_temporaries,lib/SILGen/FormalEvaluation.cpp,+,assert(access.getKind() == FormalAccess::Owned &&,95,download/apple_swift558.cpp
b925ee9acba39f4376c589c39678155e9e745090,Merge pull request #7592 from gottesmm/lvalue_temporaries,lib/SILGen/FormalEvaluation.cpp,+,"assert(!access.isFinished() && ""Can not finish a formal access cleanup """,102,download/apple_swift558.cpp
b925ee9acba39f4376c589c39678155e9e745090,Merge pull request #7592 from gottesmm/lvalue_temporaries,lib/SILGen/SILGenDecl.cpp,+,assert(evaluation.getKind() == FormalAccess::Owned);,1414,download/apple_swift559.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 2);,191,download/apple_swift560.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",192,download/apple_swift560.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token(Raw, ContinueStmtSyntax::Cursor::Label,",195,download/apple_swift560.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_token_is(NewContinueKeyword, tok::kw_continue, ""continue"");",243,download/apple_swift560.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,assert(NewLabel->getTokenKind() == tok::identifier);,254,download/apple_swift560.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,-,"ASSERT_EQ(OS.str().str(), ""forCoffee"");",112,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""theRules"");",112,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,-,"ASSERT_EQ(OS.str().str(), ""break forCoffee"");",120,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break theRules""); // sometimes",120,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,-,"ASSERT_EQ(OS.str().str(), ""break forCoffee"");",133,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break theBuild""); // don't you dare",133,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(ContinueKW, Continue.getContinueKeyword());",150,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(Label, Continue.getLabel());",151,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,Continue.print(OS);,162,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",163,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,169,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""continue"");",170,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,Continue.withLabel(Label).print(OS);,175,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""toCare"");",176,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,184,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""continue toCare""); // for each other",185,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,Continue.print(OS);,196,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""continue toLead""); // by example",197,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankContinueStmtSyntax().print(OS);,202,download/apple_swift561.cpp
792716007000484aa746f132fc3395d22916acd3,"Merge pull request #7590 from bitjammer/sr-3991-continue-statement-syntax

[Syntax] Implement continue-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",203,download/apple_swift561.cpp
03a926b256090d87fb633cea6fcea9f9535f1a2e,"[silgen] When emitting lvalue gets into temporaries, cleanup the temporaries as early as possible.

Previously, we were emitting these cleanups at the end of the lexical scope
instead of at the end of the formal evaluation scope. This change ensures that
we always emit the cleanup immediately at the end of the formal evaluation
scope.

Previously in most cases we got away with this due to the +0 self
hack. Basically we would emit a get for a self parameter and then immediately
use that self parameter as a guaranteed parameter. Then the hack would insert
the destroy value forwarding the lexical scope level cleanup at the same time.

rdar://29791263",lib/SILGen/FormalEvaluation.cpp,+,assert(access.getKind() == FormalAccess::Owned &&,95,download/apple_swift562.cpp
03a926b256090d87fb633cea6fcea9f9535f1a2e,"[silgen] When emitting lvalue gets into temporaries, cleanup the temporaries as early as possible.

Previously, we were emitting these cleanups at the end of the lexical scope
instead of at the end of the formal evaluation scope. This change ensures that
we always emit the cleanup immediately at the end of the formal evaluation
scope.

Previously in most cases we got away with this due to the +0 self
hack. Basically we would emit a get for a self parameter and then immediately
use that self parameter as a guaranteed parameter. Then the hack would insert
the destroy value forwarding the lexical scope level cleanup at the same time.

rdar://29791263",lib/SILGen/FormalEvaluation.cpp,+,"assert(!access.isFinished() && ""Can not finish a formal access cleanup """,102,download/apple_swift562.cpp
03a926b256090d87fb633cea6fcea9f9535f1a2e,"[silgen] When emitting lvalue gets into temporaries, cleanup the temporaries as early as possible.

Previously, we were emitting these cleanups at the end of the lexical scope
instead of at the end of the formal evaluation scope. This change ensures that
we always emit the cleanup immediately at the end of the formal evaluation
scope.

Previously in most cases we got away with this due to the +0 self
hack. Basically we would emit a get for a self parameter and then immediately
use that self parameter as a guaranteed parameter. Then the hack would insert
the destroy value forwarding the lexical scope level cleanup at the same time.

rdar://29791263",lib/SILGen/SILGenDecl.cpp,+,assert(evaluation.getKind() == FormalAccess::Owned);,1414,download/apple_swift563.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 2);,191,download/apple_swift564.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",192,download/apple_swift564.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token(Raw, ContinueStmtSyntax::Cursor::Label,",195,download/apple_swift564.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_token_is(NewContinueKeyword, tok::kw_continue, ""continue"");",243,download/apple_swift564.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",lib/Syntax/StmtSyntax.cpp,+,assert(NewLabel->getTokenKind() == tok::identifier);,254,download/apple_swift564.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,-,"ASSERT_EQ(OS.str().str(), ""forCoffee"");",112,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""theRules"");",112,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,-,"ASSERT_EQ(OS.str().str(), ""break forCoffee"");",120,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break theRules""); // sometimes",120,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,-,"ASSERT_EQ(OS.str().str(), ""break forCoffee"");",133,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break theBuild""); // don't you dare",133,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(ContinueKW, Continue.getContinueKeyword());",150,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(Label, Continue.getLabel());",151,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,Continue.print(OS);,162,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",163,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,169,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""continue"");",170,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,Continue.withLabel(Label).print(OS);,175,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""toCare"");",176,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,184,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""continue toCare""); // for each other",185,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,Continue.print(OS);,196,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""continue toLead""); // by example",197,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankContinueStmtSyntax().print(OS);,202,download/apple_swift565.cpp
1801c1ade1bb1218fa358529f86a978d16b08397,"[Syntax] Implement continue-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3991",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",203,download/apple_swift565.cpp
03a17e1f06f2aedc6f79c0dbd271e47356660355,Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/AST/Decl.cpp,+,assert(isa<ClassDecl>(VD) || isa<ProtocolDecl>(VD) || isa<StructDecl>(VD) ||,5079,download/apple_swift566.cpp
03a17e1f06f2aedc6f79c0dbd271e47356660355,Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/AST/Decl.cpp,+,assert(name->getNumSelectorPieces() == 1);,5083,download/apple_swift566.cpp
03a17e1f06f2aedc6f79c0dbd271e47356660355,Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/AST/Decl.cpp,+,"printSwiftEnumElemNameInObjC(const EnumElementDecl *EL, llvm::raw_ostream &OS,",5103,download/apple_swift566.cpp
03a17e1f06f2aedc6f79c0dbd271e47356660355,Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/AST/Decl.cpp,+,"printSwiftEnumElemNameInObjC(EL, OS, PreferredName.getBaseName());",5137,download/apple_swift566.cpp
03a17e1f06f2aedc6f79c0dbd271e47356660355,Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/PrintAsObjC/PrintAsObjC.cpp,-,assert(isa<ClassDecl>(VD) || isa<ProtocolDecl>(VD) || isa<StructDecl>(VD) ||,101,download/apple_swift567.cpp
03a17e1f06f2aedc6f79c0dbd271e47356660355,Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/PrintAsObjC/PrintAsObjC.cpp,-,assert(name->getNumSelectorPieces() == 1);,104,download/apple_swift567.cpp
03a17e1f06f2aedc6f79c0dbd271e47356660355,Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/PrintAsObjC/PrintAsObjC.cpp,-,"printSwiftEnumElemNameInObjC(const EnumElementDecl *EL, llvm::raw_ostream &OS,",127,download/apple_swift567.cpp
03a17e1f06f2aedc6f79c0dbd271e47356660355,Cleanup: Move Swift to ObjC name translation API to libAST to allow larger audience body. NFC (#7586),lib/PrintAsObjC/PrintAsObjC.cpp,-,"printSwiftEnumElemNameInObjC(EL, OS, PreferredName.getBaseName());",2614,download/apple_swift567.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 2);,120,download/apple_swift568.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw, BreakStmtSyntax::Cursor::BreakKeyword,",121,download/apple_swift568.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token(Raw, BreakStmtSyntax::Cursor::Label,",123,download/apple_swift568.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_token_is(NewBreakKeyword, tok::kw_break, ""break"");",171,download/apple_swift568.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",lib/Syntax/StmtSyntax.cpp,+,assert(NewLabel->getTokenKind() == tok::identifier);,181,download/apple_swift568.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(BreakKW, Break.getBreakKeyword());",84,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(Label, Break.getLabel());",85,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,Break.print(OS);,97,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",98,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,104,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break"");",105,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,Break.withLabel(Label).print(OS);,110,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""forCoffee"");",111,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,118,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break forCoffee"");",119,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,Break.print(OS);,130,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break forCoffee"");",131,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankBreakStmtSyntax().print(OS);,136,download/apple_swift569.cpp
71cf7d9f3100af160a593b74cf81cbaeb9811812,"Merge pull request #7585 from bitjammer/sr-3990-break-statement-syntax

[Syntax] Implement break-statement in lib/Syntax",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",137,download/apple_swift569.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 2);,120,download/apple_swift570.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw, BreakStmtSyntax::Cursor::BreakKeyword,",121,download/apple_swift570.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token(Raw, BreakStmtSyntax::Cursor::Label,",123,download/apple_swift570.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_token_is(NewBreakKeyword, tok::kw_break, ""break"");",171,download/apple_swift570.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",lib/Syntax/StmtSyntax.cpp,+,assert(NewLabel->getTokenKind() == tok::identifier);,181,download/apple_swift570.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(BreakKW, Break.getBreakKeyword());",84,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(Label, Break.getLabel());",85,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,Break.print(OS);,97,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",98,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,104,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break"");",105,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,Break.withLabel(Label).print(OS);,110,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""forCoffee"");",111,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,118,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break forCoffee"");",119,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,Break.print(OS);,130,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""break forCoffee"");",131,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankBreakStmtSyntax().print(OS);,136,download/apple_swift571.cpp
e6ef58af432b48636cf79678ed2d6ffad877364e,"[Syntax] Implement break-statement in lib/Syntax

https://bugs.swift.org/browse/SR-3990",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",137,download/apple_swift571.cpp
be3f74e5813e512c6b59eb77c0568eb5e42c07d4,Merge pull request #7584 from gottesmm/fix_silgenbuilder_names,lib/SILGen/SILGenBuilder.cpp,-,assert(UnownedType->isLoadable(ResilienceExpansion::Maximal));,187,download/apple_swift572.cpp
be3f74e5813e512c6b59eb77c0568eb5e42c07d4,Merge pull request #7584 from gottesmm/fix_silgenbuilder_names,lib/SILGen/SILGenBuilder.cpp,+,assert(unownedType->isLoadable(ResilienceExpansion::Maximal));,191,download/apple_swift572.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::FallthroughStmt);,30,download/apple_swift573.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 1);,31,download/apple_swift573.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",32,download/apple_swift573.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_token_is(NewFallthroughKeyword, tok::kw_fallthrough,",78,download/apple_swift573.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(FallthroughKW, Fallthrough.getFallthroughKeyword());",21,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,32,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""fallthrough"");",34,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeFallthroughStmt(FallthroughKW).print(OS);,44,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""fallthrough"");",45,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeFallthroughStmt(FallthroughKW).print(OS);,54,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""  fallthrough"");",55,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeFallthroughStmt(FallthroughKW).print(OS);,64,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""  fallthrough  "");",65,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankFallthroughStmt().print(OS);,72,download/apple_swift574.cpp
908f1948d7a082aa4dd82dacee587c30255c0d47,"Merge pull request #7582 from bitjammer/sr-3989-syntax-fallthrough-stmt

[Syntax] Implement fallthrough-statement",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",73,download/apple_swift574.cpp
c5bd8abc162f6078bc4be97176460baade0b3632,Merge pull request #7583 from gottesmm/formal_access_rename,lib/SILGen/SILGenExpr.cpp,-,assert(evaluation.getKind() == FormalEvaluation::Shared);,184,download/apple_swift575.cpp
c5bd8abc162f6078bc4be97176460baade0b3632,Merge pull request #7583 from gottesmm/formal_access_rename,lib/SILGen/SILGenExpr.cpp,+,assert(evaluation.getKind() == FormalAccess::Shared);,185,download/apple_swift575.cpp
c5bd8abc162f6078bc4be97176460baade0b3632,Merge pull request #7583 from gottesmm/formal_access_rename,lib/SILGen/SILGenLValue.cpp,-,assert(evaluation.getKind() == FormalEvaluation::Exclusive);,48,download/apple_swift576.cpp
c5bd8abc162f6078bc4be97176460baade0b3632,Merge pull request #7583 from gottesmm/formal_access_rename,lib/SILGen/SILGenLValue.cpp,+,assert(evaluation.getKind() == FormalAccess::Exclusive);,49,download/apple_swift576.cpp
64ad05bfed01bcd4b8c6dafbbf1565e93aefbb8b,[gardening] Standardize variable capitalization in SILGenBuilder to match the rest of SILGen. NFC.,lib/SILGen/SILGenBuilder.cpp,-,assert(UnownedType->isLoadable(ResilienceExpansion::Maximal));,187,download/apple_swift577.cpp
64ad05bfed01bcd4b8c6dafbbf1565e93aefbb8b,[gardening] Standardize variable capitalization in SILGenBuilder to match the rest of SILGen. NFC.,lib/SILGen/SILGenBuilder.cpp,+,assert(unownedType->isLoadable(ResilienceExpansion::Maximal));,191,download/apple_swift577.cpp
78a514cdb18aedee243c24a1d999e5e464908eb7,[silgen] Use the name FormalAccess to refer to state related to accesses in a single formal evaluation context.,lib/SILGen/SILGenExpr.cpp,-,assert(evaluation.getKind() == FormalEvaluation::Shared);,184,download/apple_swift578.cpp
78a514cdb18aedee243c24a1d999e5e464908eb7,[silgen] Use the name FormalAccess to refer to state related to accesses in a single formal evaluation context.,lib/SILGen/SILGenExpr.cpp,+,assert(evaluation.getKind() == FormalAccess::Shared);,185,download/apple_swift578.cpp
78a514cdb18aedee243c24a1d999e5e464908eb7,[silgen] Use the name FormalAccess to refer to state related to accesses in a single formal evaluation context.,lib/SILGen/SILGenLValue.cpp,-,assert(evaluation.getKind() == FormalEvaluation::Exclusive);,48,download/apple_swift579.cpp
78a514cdb18aedee243c24a1d999e5e464908eb7,[silgen] Use the name FormalAccess to refer to state related to accesses in a single formal evaluation context.,lib/SILGen/SILGenLValue.cpp,+,assert(evaluation.getKind() == FormalAccess::Exclusive);,49,download/apple_swift579.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::FallthroughStmt);,30,download/apple_swift580.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 1);,31,download/apple_swift580.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",32,download/apple_swift580.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_token_is(NewFallthroughKeyword, tok::kw_fallthrough,",78,download/apple_swift580.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(FallthroughKW, Fallthrough.getFallthroughKeyword());",21,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,.print(OS);,32,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""fallthrough"");",34,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeFallthroughStmt(FallthroughKW).print(OS);,44,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""fallthrough"");",45,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeFallthroughStmt(FallthroughKW).print(OS);,54,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""  fallthrough"");",55,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeFallthroughStmt(FallthroughKW).print(OS);,64,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""  fallthrough  "");",65,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,SyntaxFactory::makeBlankFallthroughStmt().print(OS);,72,download/apple_swift581.cpp
0d8a82d1ca87a95b86afe6e4c95304aab6ea1c4b,"[Syntax] Implement fallthrough-statement

https://bugs.swift.org/browse/SR-3989",unittests/Syntax/StmtSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",73,download/apple_swift581.cpp
7b55db9c922aa83c76601c6ba4419d98d279c150,"Merge pull request #7575 from bitjammer/localization-key-markup-field

Localization key markup field",lib/IDE/CommentConversion.cpp,+,"printInlinesUnder(LKF.getValue(), OS);",453,download/apple_swift582.cpp
dd19a13221e2eb35a7a350183eeb5e6489f22277,"Merge pull request #7553 from swiftix/wip-generics-inlining-flag-6

Preparation for enabling the  inlining of generics",lib/IRGen/IRGenSIL.cpp,+,"if (isInlinedGeneric(Decl, i->getDebugScope()))",3790,download/apple_swift583.cpp
dd19a13221e2eb35a7a350183eeb5e6489f22277,"Merge pull request #7553 from swiftix/wip-generics-inlining-flag-6

Preparation for enabling the  inlining of generics",lib/SILOptimizer/Transforms/PerformanceInliner.cpp,+,"DEBUG(llvm::dbgs() << ""Devirtualization will be possible after """,444,download/apple_swift584.cpp
dd19a13221e2eb35a7a350183eeb5e6489f22277,"Merge pull request #7553 from swiftix/wip-generics-inlining-flag-6

Preparation for enabling the  inlining of generics",lib/SILOptimizer/Transforms/PerformanceInliner.cpp,+,"DEBUG(llvm::dbgs() << ""Generic specialization will be possible after """,456,download/apple_swift584.cpp
dd19a13221e2eb35a7a350183eeb5e6489f22277,"Merge pull request #7553 from swiftix/wip-generics-inlining-flag-6

Preparation for enabling the  inlining of generics",lib/SILOptimizer/Utils/Devirtualize.cpp,+,"DEBUG(llvm::dbgs() << ""    Trying to devirtualize: "" << *AI.getInstruction());",1150,download/apple_swift585.cpp
677e03df858cb59fd8c83c1b39dfe58b5ef010a8,"[SourceKit] Vend the localization key found in documentation comments

If a documentation comment has a - LocalizationKey: field, strip it
out of the documentation body and report it in cursor/doc info with
the key ""key.localization_key"".

rdar://problem/30383329",lib/IDE/CommentConversion.cpp,+,"printInlinesUnder(LKF.getValue(), OS);",453,download/apple_swift586.cpp
3afb5572c064fc0983703c173f21602d9cdc3975,[RangeInfo] Add a field in ResolvedRangeInfo to indicate whether the range throws uncatched errors. rdar://30586209 (#7574),lib/IDE/SwiftSourceDocInfo.cpp,+,static bool hasUnhandledError(ArrayRef<ASTNode> Nodes) {,267,download/apple_swift587.cpp
3afb5572c064fc0983703c173f21602d9cdc3975,[RangeInfo] Add a field in ResolvedRangeInfo to indicate whether the range throws uncatched errors. rdar://30586209 (#7574),lib/IDE/SwiftSourceDocInfo.cpp,+,bool UnhandledError = hasUnhandledError({Node});,363,download/apple_swift587.cpp
3afb5572c064fc0983703c173f21602d9cdc3975,[RangeInfo] Add a field in ResolvedRangeInfo to indicate whether the range throws uncatched errors. rdar://30586209 (#7574),lib/IDE/SwiftSourceDocInfo.cpp,+,"hasUnhandledError(ContainedASTNodes),",654,download/apple_swift587.cpp
089e12059bf379cd1a28d098a18f9b04f4adca5c,"Merge pull request #7576 from bitjammer/tag-markup-field

[Markup] Add Tag field

rdar://problem/30563792",lib/AST/DocComment.cpp,+,"printInlinesUnder(TF, OS);",276,download/apple_swift588.cpp
675226679883037fcf73190ea36ba457afe95249,"Merge pull request #7534 from jckarter/covariant-self-init-delegation

Sema: Type-check initializer delegation as a covariant expression.",lib/SILGen/SILGenPoly.cpp,+,"assert(inputSubstType->isExactSuperclassOf(outputSubstType, nullptr)",489,download/apple_swift589.cpp
2dd61ad0eb8cd7cdae2546316b55933c2724f838,"[Markup] Add Tag field

You can now specify multiple - Tag: simple fields in documentation
comments for general purpose use. These are not currently intended
to show up in rendered documentation but are for metadata purposes
only.",lib/AST/DocComment.cpp,+,"printInlinesUnder(TF, OS);",276,download/apple_swift590.cpp
36b2927b2cc7642f74773c39883fc3053d378b6a,"Merge pull request #7563 from slavapestov/protocol-typealias-wrong-self

AST: Fix GenericSignatureBuilder bug with protocol typealiases",lib/AST/SubstitutionMap.cpp,-,assert(type->isEqual(protocolSelfType));,235,download/apple_swift591.cpp
36b2927b2cc7642f74773c39883fc3053d378b6a,"Merge pull request #7563 from slavapestov/protocol-typealias-wrong-self

AST: Fix GenericSignatureBuilder bug with protocol typealiases",lib/AST/SubstitutionMap.cpp,-,assert(origType->isEqual(protocolSelfType) &&,245,download/apple_swift591.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->isDecl());,26,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::DeclMembers);,40,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::StructDecl);,86,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, StructDeclSyntax::Cursor::StructKeyword,",87,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, StructDeclSyntax::Cursor::Identifier,",89,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw,",91,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, StructDeclSyntax::Cursor::GenericWhereClause,",94,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, StructDeclSyntax::Cursor::LeftBrace,",96,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, StructDeclSyntax::Cursor::Members,",98,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, StructDeclSyntax::Cursor::RightBrace,",100,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewStructKeyword, tok::kw_struct, ""struct"");",139,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewLeftBrace, tok::l_brace, ""{"");",146,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(StructKeyword, tok::kw_struct, ""struct"");",177,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,assert(Identifier->getTokenKind() == tok::identifier);,185,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(LeftBrace, tok::l_brace, ""{"");",193,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(RightBrace, tok::r_brace, ""}"");",208,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewTypeAliasKeyword, tok::kw_typealias, ""typealias"");",258,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,265,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewEqualToken, tok::equal, ""="");",279,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(TypeAliasKeyword, tok::kw_typealias, ""typealias"");",298,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/DeclSyntax.cpp,+,assert(Identifier->getTokenKind() == tok::identifier);,306,download/apple_swift592.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Format.cpp,+,FormatSyntaxRewriter::rewriteStructDecl(StructDeclSyntax Struct) {,21,download/apple_swift593.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(LeftAngle, tok::l_angle, ""<"");",112,download/apple_swift594.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",121,download/apple_swift594.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(RightAngle, tok::r_angle, "">"");",132,download/apple_swift594.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(NewLeftAngleBracket, tok::l_angle, ""<"");",267,download/apple_swift594.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(NewRightAngleBracket, tok::r_angle, "">"");",276,download/apple_swift594.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(LeftAngle, tok::l_angle, ""<"");",290,download/apple_swift594.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",299,download/apple_swift594.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(RightAngle, tok::r_angle, "">"");",310,download/apple_swift594.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/LegacyASTTransformer.cpp,+,assert(Start != Tokens.end());,58,download/apple_swift595.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/LegacyASTTransformer.cpp,+,assert(End.base() != Tokens.end());,59,download/apple_swift595.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/LegacyASTTransformer.cpp,+,assert(Start <= End.base());,60,download/apple_swift595.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/LegacyASTTransformer.cpp,+,"LegacyASTTransformer::visitErrorExpr(ErrorExpr *E,",579,download/apple_swift595.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/RawSyntax.cpp,+,void RawSyntax::print(llvm::raw_ostream &OS) const {,37,download/apple_swift596.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/RawSyntax.cpp,+,Tok->print(OS);,39,download/apple_swift596.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/RawSyntax.cpp,+,LE->print(OS);,43,download/apple_swift596.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/RawSyntax.cpp,+,void AbsolutePosition::printLineAndColumn(llvm::raw_ostream &OS) const {,153,download/apple_swift596.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 1);,55,download/apple_swift597.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",56,download/apple_swift597.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::CodeBlockStmt);,67,download/apple_swift597.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw, CodeBlockStmtSyntax::Cursor::LeftBrace,",68,download/apple_swift597.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_kind(Raw, CodeBlockStmtSyntax::Cursor::Elements,",70,download/apple_swift597.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw, CodeBlockStmtSyntax::Cursor::RightBrace,",72,download/apple_swift597.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::StmtList);,107,download/apple_swift597.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Syntax.cpp,+,void Syntax::print(llvm::raw_ostream &OS) const {,30,download/apple_swift598.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Syntax.cpp,+,getRaw()->print(OS);,31,download/apple_swift598.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"void printRepeated(llvm::raw_ostream &OS, char c, size_t Count) {",20,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, ' ', Indent);",39,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,void TriviaPiece::print(llvm::raw_ostream &OS) const {,112,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, ' ', Count);",115,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '\t', Count);",118,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '\v', Count);",121,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '\f', Count);",124,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '\n', Count);",127,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '`', Count);",136,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, ';', Count);",139,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,void Trivia::print(llvm::raw_ostream &OS) const {,161,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/Trivia.cpp,+,Piece.print(OS);,163,download/apple_swift599.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::BalancedTokens);,36,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::l_paren);,65,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::r_paren);,66,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::l_square);,67,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::r_square);,68,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::l_brace);,69,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::r_brace);,70,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(IsIdentifier || IsKeyword || IsLiteral || IsOperator ||,76,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TypeAttribute);,93,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 5);,94,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",95,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token(Raw, TypeAttributeSyntax::Cursor::Identifier,",98,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",100,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, TypeAttributeSyntax::Cursor::BalancedTokens,",104,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",106,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewAtSignToken, tok::at_sign, ""@"");",129,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,136,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewLeftParenToken->getTokenKind() == tok::l_paren);,143,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewRightParenToken->getTokenKind() == tok::r_paren);,156,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TypeIdentifier);,205,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 4);,206,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token(Raw, TypeIdentifierSyntax::Cursor::Identifier,",207,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw,",209,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, TypeIdentifierSyntax::Cursor::DotToken,",212,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw,",214,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,269,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewDotToken, tok::period, ""."");",277,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TypeArgumentList);,289,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(i)->Kind == SyntaxKind::TupleTypeElement);,293,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(cast<TokenSyntax>(Raw->getChild(i)), tok::comma,",295,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",330,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TupleType);,347,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 3);,348,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, TupleTypeSyntax::Cursor::LeftParenToken,",349,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, TupleTypeSyntax::Cursor::TypeArgumentList,",352,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, TupleTypeSyntax::Cursor::RightParenToken,",354,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",388,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",402,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",417,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TupleTypeElement);,460,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 5);,461,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token(Raw, TupleTypeElementSyntax::Cursor::Label,",462,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",464,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, TupleTypeElementSyntax::Cursor::Attributes,",467,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",469,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(TupleTypeElementSyntax::Cursor::Type)->isType());,473,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewLabel->getTokenKind() == tok::identifier);,508,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewColonToken, tok::colon, "":"")",515,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewInoutToken, tok::kw_inout, ""inout"");",529,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::MetatypeType);,546,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 3);,547,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(MetatypeTypeSyntax::Cursor::BaseType)->isType());,548,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, MetatypeTypeSyntax::Cursor::DotToken,",549,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token(Raw, MetatypeTypeSyntax::Cursor::TypeToken,",551,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewDotToken, tok::period, ""."");",589,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(NewTypeToken->getTokenKind() == tok::identifier);,596,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"assert(NewTypeToken->getText() == ""Type"" ||",597,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::OptionalType);,609,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 2);,610,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(OptionalTypeSyntax::Cursor::BaseType)->isType());,611,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, OptionalTypeSyntax::Cursor::QuestionToken,",612,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewQuestionToken, tok::question_postfix, ""?"");",648,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::ImplicitlyUnwrappedOptionalType);,660,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 2);,661,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(ImplicitlyUnwrappedOptionalTypeSyntax::Cursor::Type),662,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",664,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewExclaimToken, tok::exclaim_postfix, ""!"");",703,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::ArrayType);,714,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 3);,715,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",716,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(ArrayTypeSyntax::Cursor::Type)->isType());,719,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",720,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftSquareBracketToken, tok::l_square, ""["");",751,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRightSquareBracketToken, tok::r_square, ""]"");",764,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::DictionaryType);,776,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 5);,777,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",779,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(DictionaryTypeSyntax::Cursor::KeyType)->isType());,782,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, DictionaryTypeSyntax::Cursor::ColonToken,",783,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(DictionaryTypeSyntax::Cursor::ValueType)->isType());,785,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",786,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftSquareBracketToken, tok::l_square, ""["");",821,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewColonToken, tok::colon, "":"");",835,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRightSquareBracketToken, tok::r_square, ""]"");",849,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::FunctionType);,897,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionTypeSyntax::Cursor::TypeAttributes,",898,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionTypeSyntax::Cursor::LeftParen,",900,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionTypeSyntax::Cursor::ArgumentList,",902,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionTypeSyntax::Cursor::RightParen,",904,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"assert(ThrowsOrRethrows->is(tok::kw_throws, ""throws"") ||",910,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionTypeSyntax::Cursor::Arrow,",913,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(FunctionTypeSyntax::Cursor::ReturnType)->isType());,915,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",956,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",967,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::r_paren, "")"");",981,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewThrowsKeyword, tok::kw_throws, ""throws"");",988,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewThrowsKeyword, tok::kw_rethrows, ""rethrows"");",996,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewArrow, tok::arrow, ""->"");",1004,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",1031,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",1039,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",1052,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewThrowsKeyword, tok::kw_throws, ""throws"");",1070,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRethrowsKeyword, tok::kw_rethrows, ""rethrows"");",1078,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewArrow, tok::arrow, ""->"");",1086,download/apple_swift600.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",tools/swift-format/swift-format.cpp,+,"InputFilename, Buffer.getError().message());",63,download/apple_swift601.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",tools/swift-format/swift-format.cpp,+,Reformatted.print(llvm::outs());,81,download/apple_swift601.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankTypealiasDecl().print(OS);,16,download/apple_swift602.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",17,download/apple_swift602.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,50,download/apple_swift602.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",51,download/apple_swift602.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,92,download/apple_swift602.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",93,download/apple_swift602.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,136,download/apple_swift602.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",137,download/apple_swift602.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Autoclosure.print(OS);,23,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@autoclosure"");",24,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(cArgs).print(OS);,43,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(c)"");",44,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(swiftArgs).print(OS);,52,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(swift)"");",53,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(blockArgs).print(OS);,61,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(block)"");",62,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Escaping.print(OS);,73,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@escaping"");",74,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Autoclosure.print(OS);,87,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@autoclosure"");",88,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,103,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(c)"");",104,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,114,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(swift)"");",115,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,125,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(block)"");",126,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Escaping.print(OS);,137,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@escaping"");",138,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,148,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""()"");",149,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,157,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""  ( )"");",158,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,167,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""(    )\n"");",168,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,175,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""()"");",176,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,TupleType.print(OS);,199,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""(Int, String, Int)"");",200,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,TupleType.print(OS);,221,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""(x: Int, y: inout Int)"");",222,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,231,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""()"");",232,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Any.print(OS);,243,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""Any"");",244,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Self.print(OS);,251,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""Self"");",252,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,OptionalInt.print(OS);,262,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""Int?"");",263,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,277,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), "" String?"");",278,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,IntBang.print(OS);,288,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""Int!"");",289,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,303,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), "" String!"");",304,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,316,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""T.Type"");",317,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,334,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""T.Type"");",335,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,344,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""T.Protocol"");",345,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,ASSERT_DEATH({,347,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,366,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""[Double]"");",367,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,379,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""[()]"");",380,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,401,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""[String : Int]"");",403,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,RightSquare).print(OS);,419,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""[String : Int]"");",420,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,454,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(x: Int, y: Int) throws -> Int"");",455,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Int).print(OS);,474,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(Int, Int) rethrows -> Int"");",475,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Void).print(OS);,494,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""() -> ()"");",495,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,529,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(x: Int, y: Int) throws -> Int"");",530,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,546,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(Int, Int) rethrows -> Int"");",547,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,559,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""() -> ()"");",560,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Builder.build().print(OS);,593,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(x: Int, y: Int) throws -> Int"");",594,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Builder.build().print(OS);,611,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(Int, Int) rethrows -> Int"");",612,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,Builder.build().print(OS);,626,download/apple_swift603.cpp
3645736ac0444e55c09fb9d52b3f3deecb46a2a1,"Merge pull request #7393 from bitjammer/syntax-tree

Start the Syntax structured editing library",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""() -> ()"");",627,download/apple_swift603.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"print(out, srcMgr);",336,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,void RequirementSource::print() const {,340,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"print(llvm::errs(), nullptr);",341,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"void RequirementSource::print(llvm::raw_ostream &out,",344,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"parent->print(out, srcMgr);",347,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"assert(existingSource == newSource && ""incomparable requirement sources"");",504,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"SuperclassSource->print(Out, SrcMgr);",1184,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,ConcreteType.print(Out);,1191,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"ConcreteTypeSource->print(Out, SrcMgr);",1196,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"ProtoAndSource.second->print(Out, SrcMgr);",1215,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"source->print(out, &Context.SourceMgr);",2737,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"source->print(out, &Context.SourceMgr);",2745,download/apple_swift604.cpp
e4f23a3d62034f007c9589832122fe3574ef68b6,"Merge pull request #7550 from DougGregor/requirement-source

[GenericSig Builder] Rework RequirementSource to describe requirement path",lib/AST/GenericSignatureBuilder.cpp,+,"source->print(out, &Context.SourceMgr);",2755,download/apple_swift604.cpp
879a7586baaf8ca31dcf70502f5289f6a14e7a6e,"AST: Fix crash with invalid protocols in SubstitutionMap::getProtocolSubstitutions()

If a protocol appears inside a generic context, the Self parameter
will not be the only generic parameter; outer generic parameters
will be part of the protocol's signature also.

Change the asserts in getProtocolSubstitutions() to return error
types instead in this case.",lib/AST/SubstitutionMap.cpp,-,assert(type->isEqual(protocolSelfType));,235,download/apple_swift605.cpp
879a7586baaf8ca31dcf70502f5289f6a14e7a6e,"AST: Fix crash with invalid protocols in SubstitutionMap::getProtocolSubstitutions()

If a protocol appears inside a generic context, the Self parameter
will not be the only generic parameter; outer generic parameters
will be part of the protocol's signature also.

Change the asserts in getProtocolSubstitutions() to return error
types instead in this case.",lib/AST/SubstitutionMap.cpp,-,assert(origType->isEqual(protocolSelfType) &&,245,download/apple_swift605.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"print(out, srcMgr);",336,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,void RequirementSource::print() const {,340,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"print(llvm::errs(), nullptr);",341,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"void RequirementSource::print(llvm::raw_ostream &out,",344,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"parent->print(out, srcMgr);",347,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"assert(existingSource == newSource && ""incomparable requirement sources"");",504,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"SuperclassSource->print(Out, SrcMgr);",1184,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,ConcreteType.print(Out);,1191,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"ConcreteTypeSource->print(Out, SrcMgr);",1196,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"ProtoAndSource.second->print(Out, SrcMgr);",1215,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"source->print(out, &Context.SourceMgr);",2737,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"source->print(out, &Context.SourceMgr);",2745,download/apple_swift606.cpp
da39d9b17b4845611f79ae7c4b1124e60d7c6672,"[GenericSig Builder] Rework RequirementSource to describe requirement path.

Reimplement the RequirementSource class, which captures how
a particular requirement is satisfied by a generic signature. The
primary goal of this rework is to keep the complete path one follows
in a generic signature to get from some explicit requirement in the
generic signature to some derived requirement or type, e.g.,

1) Start at an explicit requirement ""C: Collection""
2) Go to the inherited protocol Sequence,
3) Get the ""Iterator"" associated type
4) Get its conformance to ""IteratorProtocol""
5) Get the ""Element"" associated type

We don't currently capture all of the information we want in the path,
but the basic structure is there, and should also allow us to capture
more source-location information, find the ""optimal"" path, etc. There are
are a number of potential uses:

* IRGen could eventually use this to dig out the witness tables and
  type metadata it needs, instead of using its own fulfillment
  strategy
* SubstitutionMap could use this to lookup conformances, rather than
  it's egregious hacks
* The canonical generic signature builder could use this to lookup
  conformances as needed, e.g., for the recursive-conformances case.

... and probably more simplifications, once we get this right.",lib/AST/GenericSignatureBuilder.cpp,+,"source->print(out, &Context.SourceMgr);",2755,download/apple_swift606.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->isDecl());,26,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::DeclMembers);,40,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::StructDecl);,86,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, StructDeclSyntax::Cursor::StructKeyword,",87,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token(Raw, StructDeclSyntax::Cursor::Identifier,",89,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw,",91,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, StructDeclSyntax::Cursor::GenericWhereClause,",94,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, StructDeclSyntax::Cursor::LeftBrace,",96,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_kind(Raw, StructDeclSyntax::Cursor::Members,",98,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_child_token_text(Raw, StructDeclSyntax::Cursor::RightBrace,",100,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewStructKeyword, tok::kw_struct, ""struct"");",139,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewLeftBrace, tok::l_brace, ""{"");",146,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(StructKeyword, tok::kw_struct, ""struct"");",177,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,assert(Identifier->getTokenKind() == tok::identifier);,185,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(LeftBrace, tok::l_brace, ""{"");",193,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(RightBrace, tok::r_brace, ""}"");",208,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewTypeAliasKeyword, tok::kw_typealias, ""typealias"");",258,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,265,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(NewEqualToken, tok::equal, ""="");",279,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,"syntax_assert_token_is(TypeAliasKeyword, tok::kw_typealias, ""typealias"");",298,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/DeclSyntax.cpp,+,assert(Identifier->getTokenKind() == tok::identifier);,306,download/apple_swift607.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Format.cpp,+,FormatSyntaxRewriter::rewriteStructDecl(StructDeclSyntax Struct) {,21,download/apple_swift608.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(LeftAngle, tok::l_angle, ""<"");",112,download/apple_swift609.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",121,download/apple_swift609.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(RightAngle, tok::r_angle, "">"");",132,download/apple_swift609.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(NewLeftAngleBracket, tok::l_angle, ""<"");",267,download/apple_swift609.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(NewRightAngleBracket, tok::r_angle, "">"");",276,download/apple_swift609.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(LeftAngle, tok::l_angle, ""<"");",290,download/apple_swift609.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",299,download/apple_swift609.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/GenericSyntax.cpp,+,"syntax_assert_token_is(RightAngle, tok::r_angle, "">"");",310,download/apple_swift609.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/LegacyASTTransformer.cpp,+,assert(Start != Tokens.end());,58,download/apple_swift610.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/LegacyASTTransformer.cpp,+,assert(End.base() != Tokens.end());,59,download/apple_swift610.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/LegacyASTTransformer.cpp,+,assert(Start <= End.base());,60,download/apple_swift610.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/LegacyASTTransformer.cpp,+,"LegacyASTTransformer::visitErrorExpr(ErrorExpr *E,",575,download/apple_swift610.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/RawSyntax.cpp,+,void RawSyntax::print(llvm::raw_ostream &OS) const {,37,download/apple_swift611.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/RawSyntax.cpp,+,Tok->print(OS);,39,download/apple_swift611.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/RawSyntax.cpp,+,LE->print(OS);,43,download/apple_swift611.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/RawSyntax.cpp,+,void AbsolutePosition::printLineAndColumn(llvm::raw_ostream &OS) const {,153,download/apple_swift611.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Layout.size() == 1);,55,download/apple_swift612.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",56,download/apple_swift612.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::CodeBlockStmt);,67,download/apple_swift612.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw, CodeBlockStmtSyntax::Cursor::LeftBrace,",68,download/apple_swift612.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_kind(Raw, CodeBlockStmtSyntax::Cursor::Elements,",70,download/apple_swift612.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/StmtSyntax.cpp,+,"syntax_assert_child_token_text(Raw, CodeBlockStmtSyntax::Cursor::RightBrace,",72,download/apple_swift612.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/StmtSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::StmtList);,107,download/apple_swift612.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Syntax.cpp,+,void Syntax::print(llvm::raw_ostream &OS) const {,30,download/apple_swift613.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Syntax.cpp,+,getRaw()->print(OS);,31,download/apple_swift613.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"void printRepeated(llvm::raw_ostream &OS, char c, size_t Count) {",20,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, ' ', Indent);",39,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,void TriviaPiece::print(llvm::raw_ostream &OS) const {,112,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, ' ', Count);",115,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '\t', Count);",118,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '\v', Count);",121,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '\f', Count);",124,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '\n', Count);",127,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, '`', Count);",136,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,"printRepeated(OS, ';', Count);",139,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,void Trivia::print(llvm::raw_ostream &OS) const {,161,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/Trivia.cpp,+,Piece.print(OS);,163,download/apple_swift614.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::BalancedTokens);,36,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::l_paren);,65,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::r_paren);,66,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::l_square);,67,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::r_square);,68,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::l_brace);,69,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewBalancedToken->getTokenKind() != tok::r_brace);,70,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(IsIdentifier || IsKeyword || IsLiteral || IsOperator ||,76,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TypeAttribute);,93,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 5);,94,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",95,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token(Raw, TypeAttributeSyntax::Cursor::Identifier,",98,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",100,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, TypeAttributeSyntax::Cursor::BalancedTokens,",104,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",106,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewAtSignToken, tok::at_sign, ""@"");",129,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,136,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewLeftParenToken->getTokenKind() == tok::l_paren);,143,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewRightParenToken->getTokenKind() == tok::r_paren);,156,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TypeIdentifier);,205,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 4);,206,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token(Raw, TypeIdentifierSyntax::Cursor::Identifier,",207,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw,",209,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, TypeIdentifierSyntax::Cursor::DotToken,",212,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw,",214,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewIdentifier->getTokenKind() == tok::identifier);,269,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewDotToken, tok::period, ""."");",277,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TypeArgumentList);,289,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(i)->Kind == SyntaxKind::TupleTypeElement);,293,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(cast<TokenSyntax>(Raw->getChild(i)), tok::comma,",295,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",330,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TupleType);,347,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 3);,348,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, TupleTypeSyntax::Cursor::LeftParenToken,",349,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, TupleTypeSyntax::Cursor::TypeArgumentList,",352,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, TupleTypeSyntax::Cursor::RightParenToken,",354,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",388,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",402,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",417,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::TupleTypeElement);,460,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 5);,461,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token(Raw, TupleTypeElementSyntax::Cursor::Label,",462,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",464,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, TupleTypeElementSyntax::Cursor::Attributes,",467,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",469,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(TupleTypeElementSyntax::Cursor::Type)->isType());,473,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewLabel->getTokenKind() == tok::identifier);,508,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewColonToken, tok::colon, "":"")",515,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewInoutToken, tok::kw_inout, ""inout"");",529,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::MetatypeType);,546,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 3);,547,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(MetatypeTypeSyntax::Cursor::BaseType)->isType());,548,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, MetatypeTypeSyntax::Cursor::DotToken,",549,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token(Raw, MetatypeTypeSyntax::Cursor::TypeToken,",551,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewDotToken, tok::period, ""."");",589,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(NewTypeToken->getTokenKind() == tok::identifier);,596,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"assert(NewTypeToken->getText() == ""Type"" ||",597,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::OptionalType);,609,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 2);,610,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(OptionalTypeSyntax::Cursor::BaseType)->isType());,611,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, OptionalTypeSyntax::Cursor::QuestionToken,",612,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewQuestionToken, tok::question_postfix, ""?"");",648,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::ImplicitlyUnwrappedOptionalType);,660,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 2);,661,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(ImplicitlyUnwrappedOptionalTypeSyntax::Cursor::Type),662,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",664,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewExclaimToken, tok::exclaim_postfix, ""!"");",703,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::ArrayType);,714,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 3);,715,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",716,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(ArrayTypeSyntax::Cursor::Type)->isType());,719,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",720,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftSquareBracketToken, tok::l_square, ""["");",751,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRightSquareBracketToken, tok::r_square, ""]"");",764,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::DictionaryType);,776,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Layout.size() == 5);,777,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",779,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(DictionaryTypeSyntax::Cursor::KeyType)->isType());,782,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, DictionaryTypeSyntax::Cursor::ColonToken,",783,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(DictionaryTypeSyntax::Cursor::ValueType)->isType());,785,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw,",786,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftSquareBracketToken, tok::l_square, ""["");",821,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewColonToken, tok::colon, "":"");",835,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRightSquareBracketToken, tok::r_square, ""]"");",849,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->Kind == SyntaxKind::FunctionType);,897,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionTypeSyntax::Cursor::TypeAttributes,",898,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionTypeSyntax::Cursor::LeftParen,",900,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_kind(Raw, FunctionTypeSyntax::Cursor::ArgumentList,",902,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionTypeSyntax::Cursor::RightParen,",904,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"assert(ThrowsOrRethrows->is(tok::kw_throws, ""throws"") ||",910,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_child_token_text(Raw, FunctionTypeSyntax::Cursor::Arrow,",913,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,assert(Raw->getChild(FunctionTypeSyntax::Cursor::ReturnType)->isType());,915,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",956,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",967,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::r_paren, "")"");",981,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewThrowsKeyword, tok::kw_throws, ""throws"");",988,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewThrowsKeyword, tok::kw_rethrows, ""rethrows"");",996,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewArrow, tok::arrow, ""->"");",1004,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewLeftParen, tok::l_paren, ""("");",1031,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRightParen, tok::r_paren, "")"");",1039,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(MaybeComma.getValue(), tok::comma, "","");",1052,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewThrowsKeyword, tok::kw_throws, ""throws"");",1070,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewRethrowsKeyword, tok::kw_rethrows, ""rethrows"");",1078,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",lib/Syntax/TypeSyntax.cpp,+,"syntax_assert_token_is(NewArrow, tok::arrow, ""->"");",1086,download/apple_swift615.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",tools/swift-format/swift-format.cpp,+,"InputFilename, Buffer.getError().message());",63,download/apple_swift616.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",tools/swift-format/swift-format.cpp,+,Reformatted.print(llvm::outs());,81,download/apple_swift616.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,SyntaxFactory::makeBlankTypealiasDecl().print(OS);,16,download/apple_swift617.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), """");",17,download/apple_swift617.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,50,download/apple_swift617.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",51,download/apple_swift617.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,92,download/apple_swift617.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",93,download/apple_swift617.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,.print(OS);,136,download/apple_swift617.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/DeclSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(),",137,download/apple_swift617.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Autoclosure.print(OS);,23,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@autoclosure"");",24,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(cArgs).print(OS);,43,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(c)"");",44,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(swiftArgs).print(OS);,52,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(swift)"");",53,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Convention.withBalancedTokens(blockArgs).print(OS);,61,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(block)"");",62,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Escaping.print(OS);,73,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@escaping"");",74,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Autoclosure.print(OS);,87,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@autoclosure"");",88,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,103,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(c)"");",104,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,114,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(swift)"");",115,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,125,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@convention(block)"");",126,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Escaping.print(OS);,137,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""@escaping"");",138,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,148,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""()"");",149,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,157,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""  ( )"");",158,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,167,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""(    )\n"");",168,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,175,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""()"");",176,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,TupleType.print(OS);,199,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""(Int, String, Int)"");",200,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,TupleType.print(OS);,221,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""(x: Int, y: inout Int)"");",222,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Void.print(OS);,231,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""()"");",232,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Any.print(OS);,243,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""Any"");",244,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Self.print(OS);,251,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""Self"");",252,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,OptionalInt.print(OS);,262,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""Int?"");",263,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,277,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), "" String?"");",278,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,IntBang.print(OS);,288,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""Int!"");",289,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,303,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), "" String!"");",304,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,316,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""T.Type"");",317,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,334,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""T.Type"");",335,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,344,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""T.Protocol"");",345,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,ASSERT_DEATH({,347,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,366,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""[Double]"");",367,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,379,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""[()]"");",380,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,401,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""[String : Int]"");",403,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,RightSquare).print(OS);,419,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str(), ""[String : Int]"");",420,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,454,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(x: Int, y: Int) throws -> Int"");",455,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Int).print(OS);,474,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(Int, Int) rethrows -> Int"");",475,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Void).print(OS);,494,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""() -> ()"");",495,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,529,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(x: Int, y: Int) throws -> Int"");",530,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,546,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(Int, Int) rethrows -> Int"");",547,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,.print(OS);,559,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""() -> ()"");",560,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Builder.build().print(OS);,593,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(x: Int, y: Int) throws -> Int"");",594,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Builder.build().print(OS);,611,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""(Int, Int) rethrows -> Int"");",612,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,Builder.build().print(OS);,626,download/apple_swift618.cpp
7ee42994c85c3a3b61e75513aafa2c9962977bfa,"Start the Syntax library and optional full token lexing

Add an option to the lexer to go back and get a list of ""full""
tokens, which include their leading and trailing trivia, which
we can index into from SourceLocs in the current AST.

This starts the Syntax sublibrary, which will support structured
editing APIs. Some skeleton support and basic implementations are
in place for types and generics in the grammar. Yes, it's slightly
redundant with what we have right now. lib/AST conflates syntax
and semantics in the same place(s); this is a first step in changing
that to separate the two concepts for clarity and also to get closer
to incremental parsing and type-checking. The goal is to eventually
extract all of the syntactic information from lib/AST and change that
to be more of a semantic/symbolic model.

Stub out a Semantics manager. This ought to eventually be used as a hub
for encapsulating lazily computed semantic information for syntax nodes.
For the time being, it can serve as a temporary place for mapping from
Syntax nodes to semantically full lib/AST nodes.

This is still in a molten state - don't get too close, wear appropriate
proximity suits, etc.",unittests/Syntax/TypeSyntaxTests.cpp,+,"ASSERT_EQ(OS.str().str(), ""() -> ()"");",627,download/apple_swift618.cpp
6717e96ee442d317893ac39caf3c09970a1b8f41,"Merge pull request #7564 from jckarter/assoc-type-mixed-explicit-and-inferred

Sema: Don't infer associated types from witness candidates that contradict explicit type witnesses.",lib/Sema/TypeCheckProtocol.cpp,-,if (result.second->hasError()),3049,download/apple_swift619.cpp
6717e96ee442d317893ac39caf3c09970a1b8f41,"Merge pull request #7564 from jckarter/assoc-type-mixed-explicit-and-inferred

Sema: Don't infer associated types from witness candidates that contradict explicit type witnesses.",lib/Sema/TypeCheckProtocol.cpp,+,if (result.second->hasError()),3098,download/apple_swift619.cpp
749bef78ca7ff45d5f29ca9fe3aebf88bacfc8fe,"Sema: Don't infer associated types from witness candidates that contradict explicit type witnesses.

If a conforming type provided explicit witnesses for some of its associated types and inferred others, we would still harvest inference solutions from methods that contradict the explicit witnesses, leading to bogus ambiguity errors in some situations. Fix this by skipping inference candidates that contradict explicit type witnesses. Fixes SR-3979.",lib/Sema/TypeCheckProtocol.cpp,-,if (result.second->hasError()),3058,download/apple_swift620.cpp
749bef78ca7ff45d5f29ca9fe3aebf88bacfc8fe,"Sema: Don't infer associated types from witness candidates that contradict explicit type witnesses.

If a conforming type provided explicit witnesses for some of its associated types and inferred others, we would still harvest inference solutions from methods that contradict the explicit witnesses, leading to bogus ambiguity errors in some situations. Fix this by skipping inference candidates that contradict explicit type witnesses. Fixes SR-3979.",lib/Sema/TypeCheckProtocol.cpp,+,if (result.second->hasError()),3107,download/apple_swift620.cpp
43885939432c6b2111dfb533451db140266b3fd0,"[sil-performance-inliner] Tweak the inlining profitability heuristic for inlining of generics

Consider the possibility of performing a specialization or devirtualization after inlining of a generic function.",lib/SILOptimizer/Transforms/PerformanceInliner.cpp,+,"DEBUG(llvm::dbgs() << ""Devirtualization will be possible after """,391,download/apple_swift621.cpp
43885939432c6b2111dfb533451db140266b3fd0,"[sil-performance-inliner] Tweak the inlining profitability heuristic for inlining of generics

Consider the possibility of performing a specialization or devirtualization after inlining of a generic function.",lib/SILOptimizer/Transforms/PerformanceInliner.cpp,+,"DEBUG(llvm::dbgs() << ""Generic specialization will be possible after """,403,download/apple_swift621.cpp
b4913a4f2d3e48223d8a030db6c180d9e07f09d7,Merge pull request #7552 from eeckstein/objc-mangling,lib/AST/ASTMangler.cpp,+,assert(isa<ProtocolDecl>(Nominal));,298,download/apple_swift622.cpp
1d499546eb5aba90961c73dd132dddbc6268fa13,"[Parse] Don't construct DeclRefExpr in #if conditions (#7522)

This code should compile:

  func foo(FOO: Int, swift: String, Linux: Bool) {
  #if FOO && swift(>=3.0) && os(Linux)
    // do something
  #endif
  }",lib/Parse/ParseExpr.cpp,-,return new (Context) ErrorExpr(loc.getSourceRange());,1924,download/apple_swift623.cpp
1d499546eb5aba90961c73dd132dddbc6268fa13,"[Parse] Don't construct DeclRefExpr in #if conditions (#7522)

This code should compile:

  func foo(FOO: Int, swift: String, Linux: Bool) {
  #if FOO && swift(>=3.0) && os(Linux)
    // do something
  #endif
  }",lib/Parse/ParseExpr.cpp,+,return new (Context) ErrorExpr(loc.getSourceRange());,1944,download/apple_swift623.cpp
1d499546eb5aba90961c73dd132dddbc6268fa13,"[Parse] Don't construct DeclRefExpr in #if conditions (#7522)

This code should compile:

  func foo(FOO: Int, swift: String, Linux: Bool) {
  #if FOO && swift(>=3.0) && os(Linux)
    // do something
  #endif
  }",lib/Parse/ParseExpr.cpp,+,return new (Context) ErrorExpr(loc.getSourceRange());,1958,download/apple_swift623.cpp
1d499546eb5aba90961c73dd132dddbc6268fa13,"[Parse] Don't construct DeclRefExpr in #if conditions (#7522)

This code should compile:

  func foo(FOO: Int, swift: String, Linux: Bool) {
  #if FOO && swift(>=3.0) && os(Linux)
    // do something
  #endif
  }",lib/Parse/ParseExpr.cpp,-,return new (Context) ErrorExpr(loc.getSourceRange());,1960,download/apple_swift623.cpp
8a6a9461d3ced1551949212ac188d28172df2900,"Only mangle non-private top-level classes and protocol with the old-style for the ObjC metadata.

Only those types can be de-mangled by the ObjC runtime anyway.
Also move this mangling logic into the ASTMangler class. This avoids keeping the old mangler around just for that purpose.",lib/AST/ASTMangler.cpp,+,assert(isa<ProtocolDecl>(Nominal));,298,download/apple_swift624.cpp
b1c5c995a185d6985555dbfaf1766218ecc2c5c9,"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,-,"if (SwiftLangSupport::printUSR(VD, OS))",727,download/apple_swift625.cpp
b1c5c995a185d6985555dbfaf1766218ecc2c5c9,"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,+,"if (SwiftLangSupport::printUSR(VD, OverUSRsStream))",737,download/apple_swift625.cpp
b1c5c995a185d6985555dbfaf1766218ecc2c5c9,"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,-,"SwiftLangSupport::printUSR(RelatedDecl, OS);",759,download/apple_swift625.cpp
b1c5c995a185d6985555dbfaf1766218ecc2c5c9,"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,+,"SwiftLangSupport::printUSR(RelatedDecl, RelDeclsStream);",761,download/apple_swift625.cpp
b1c5c995a185d6985555dbfaf1766218ecc2c5c9,"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,-,XMLEscapingPrinter Printer(OS);,770,download/apple_swift625.cpp
b1c5c995a185d6985555dbfaf1766218ecc2c5c9,"[IDE][Utils] Add an IDE stream utility. (#7546)

This provides a stream utility for writing to a underlying string buffer multiple string pieces and retrieve them later as StringRef when the underlying buffer is stable.",tools/SourceKit/lib/SwiftLang/SwiftSourceDocInfo.cpp,+,XMLEscapingPrinter Printer(RelDeclsStream);,770,download/apple_swift625.cpp
3b48b4b69712d22303de16cf10931f42b470e180,Merge pull request #7532 from atrick/silval,lib/SIL/SILInstruction.cpp,+,assert(!SILModuleConventions(getModule()).useLoweredAddresses());,868,download/apple_swift626.cpp
3b48b4b69712d22303de16cf10931f42b470e180,Merge pull request #7532 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(onlyHaveDebugUses(inst));,120,download/apple_swift627.cpp
3b48b4b69712d22303de16cf10931f42b470e180,Merge pull request #7532 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,598,download/apple_swift627.cpp
3b48b4b69712d22303de16cf10931f42b470e180,Merge pull request #7532 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,634,download/apple_swift627.cpp
3b48b4b69712d22303de16cf10931f42b470e180,Merge pull request #7532 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""LOWER ""; F->dump());",661,download/apple_swift627.cpp
8fc40ba57822de3ababe2213f86589b6ebf0d024,"SILGen: Use unchecked_ref_cast to adjust covariant returns in thunks.

Previously, we would blindly upcast, leading to SIL verifier errors. Fixes SR-3920.",lib/SILGen/SILGenPoly.cpp,+,"assert(inputSubstType->isExactSuperclassOf(outputSubstType, nullptr)",489,download/apple_swift628.cpp
eb86fb894d4402e61fe63d96b8876997cb48f516,Fix debug info emission issues uncovered by enabling the inlining of generics,lib/IRGen/IRGenSIL.cpp,+,"if (isInlinedGeneric(Decl, i->getDebugScope()))",3790,download/apple_swift629.cpp
ab1fd78ffe799871d6bbf78dcfa5224d520b6e7c,"[sil-devirtualizer] Introduce a helper method canDevirtualizeApply

This predicate can be used to check if a given call can be devirtualized. One of the clients of this new API will be the inliner, which may want to check if a given method call becomes devirtualizable after inlining.",lib/SILOptimizer/Utils/Devirtualize.cpp,+,"DEBUG(llvm::dbgs() << ""    Trying to devirtualize: "" << *AI.getInstruction());",1150,download/apple_swift630.cpp
42561121506aede8c890c8ce75f3fab7a300d6b3,AddressLowering: fix handling of result tuples.,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(onlyHaveDebugUses(inst));,120,download/apple_swift631.cpp
42561121506aede8c890c8ce75f3fab7a300d6b3,AddressLowering: fix handling of result tuples.,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,598,download/apple_swift631.cpp
42561121506aede8c890c8ce75f3fab7a300d6b3,AddressLowering: fix handling of result tuples.,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,assert(!pass.valueStorageMap.getStorage(tupleInst).storageAddress);,634,download/apple_swift631.cpp
42561121506aede8c890c8ce75f3fab7a300d6b3,AddressLowering: fix handling of result tuples.,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"DEBUG(llvm::dbgs() << ""LOWER ""; F->dump());",661,download/apple_swift631.cpp
6d5b417eccad80a12d9771edb47ebfc77f9d24a1,Allow DestroyValueInst before addresses are lowered.,lib/SIL/SILInstruction.cpp,+,assert(!SILModuleConventions(getModule()).useLoweredAddresses());,868,download/apple_swift632.cpp
7afa43c15bb56c8ac70699ff7f478c7b620ab10b,"Merge pull request #7488 from hughbe/clangdecl-assert

Change ClangImporter if check to an assertion",lib/ClangImporter/ImportType.cpp,+,"assert(clangDecl && ""expected to have a decl to import"");",1530,download/apple_swift633.cpp
36a60d253cd792b2cb1bf833a9c15faf32798eef,Merge pull request #7519 from rudkx/dump-source-range,lib/Sema/CSSolver.cpp,+,"R.print(log, TC.Context.SourceMgr, /*PrintText=*/ false);",1905,download/apple_swift634.cpp
9178030d925c70f308cf211e25d79644346ae3cb,"Merge pull request #7514 from shajrawi/store_opaque_values

support stores of non-loadable types under opaque mode",lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable());,98,download/apple_swift635.cpp
9178030d925c70f308cf211e25d79644346ae3cb,"Merge pull request #7514 from shajrawi/store_opaque_values

support stores of non-loadable types under opaque mode",lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,98,download/apple_swift635.cpp
58b14ffc2da6464fe43f35574096ba53e88bc662,"Update -debug-constraints to dump the source range immediately.

We end up dumping information during constraint generation, and it's
nice to know which range we're dealing with at that point.",lib/Sema/CSSolver.cpp,+,"R.print(log, TC.Context.SourceMgr, /*PrintText=*/ false);",1905,download/apple_swift636.cpp
cb8bbf05504842ff7c959bd6d0f9e3a23d275934,"Merge pull request #7382 from rintaro/parse-ifconfig-fix1

[Parse] Improve '#if' block parsing",lib/Parse/ParseDecl.cpp,-,"assert(Status.isError() && ""no progress without error?"");",3054,download/apple_swift637.cpp
cfe742d1eb3e24046deeceb3f3d2b01f5a78e858,"[Parse] Minor improvements in conditional compilation block parsing

* Don't emit duplicated 'expected #else or #endif at end of conditional
  compilation block' error.

    class Foo {
      #if true
        func foo() {}
    [EOF]

* Improve error message when seeing '}' in config block.

    class Foo {
    #if true
        func foo();
    } // error: unexpected '}' in conditional compilation block
    #else
    #endif",lib/Parse/ParseDecl.cpp,-,"assert(Status.isError() && ""no progress without error?"");",3053,download/apple_swift638.cpp
ae0b6b1e06759b0c85cbed8bf68470dc63b72fac,"Merge pull request #7186 from aschwaighofer/cow_exist_silgen_support

SIL/SILGen support for copy-on-write existentials",lib/SILGen/SILGenLValue.cpp,+,"assert(false && ""I believe that we should never end up here. One, we """,428,download/apple_swift639.cpp
ae0b6b1e06759b0c85cbed8bf68470dc63b72fac,"Merge pull request #7186 from aschwaighofer/cow_exist_silgen_support

SIL/SILGen support for copy-on-write existentials",lib/Serialization/DeserializeSIL.cpp,+,assert(RecordKind == SIL_ONE_TYPE_ONE_OPERAND &&,851,download/apple_swift640.cpp
ae0b6b1e06759b0c85cbed8bf68470dc63b72fac,"Merge pull request #7186 from aschwaighofer/cow_exist_silgen_support

SIL/SILGen support for copy-on-write existentials",lib/Serialization/SerializeSIL.cpp,+,assert(SI.getNumOperands() - SI.getTypeDependentOperands().size() == 1);,1205,download/apple_swift641.cpp
ae0b6b1e06759b0c85cbed8bf68470dc63b72fac,"Merge pull request #7186 from aschwaighofer/cow_exist_silgen_support

SIL/SILGen support for copy-on-write existentials",lib/Serialization/SerializeSIL.cpp,+,"writeOneTypeOneOperandLayout(SI.getKind(), attrs, SI.getType(),",1209,download/apple_swift641.cpp
992caba90e3105ecaaf02967b5671e2da78beaeb,support stores of non-loadable types under opaque mode,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable());,98,download/apple_swift642.cpp
992caba90e3105ecaaf02967b5671e2da78beaeb,support stores of non-loadable types under opaque mode,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,98,download/apple_swift642.cpp
