commit_message,file_name,change_type,log_statement,context,up_context,down_context
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());

","
      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

     ","
      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

","
      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



   ","
           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()) {,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }
","

  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,"return gen.emitNativeToBridgedError(loc, v, loweredBridgedTy);","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }
","

  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

 ","
    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

   ","
  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(v.getType().isTrivial(gen.SGM.M) || v.hasCleanup());,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

","
    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

   ","
    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

","
                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



   ","
           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()),"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.
","      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,-,"return gen.emitBridgedToNativeError(loc, v);","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.
","      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()),"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

 ","
    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitBridgedToNativeError(loc, v);","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

   ","


  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"static void pushWriteback(SILGenFunction &gen,","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

",,"
                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"static void pushWriteback(SILGenFunction &SGF,","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}
","
                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope);,"static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,
","                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope);,"static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

 ","


  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,"    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

","


      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,"    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

     ","
             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(clonedComponent), base, materialized);","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

","
        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

     ","


      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"void writeback(SILGenFunction &gen, SILLocation loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,
","                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"void writeback(SILGenFunction &SGF, SILLocation loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

",   ,"
                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"LogicalPathComponent::writeback(gen, loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize
","      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"LogicalPathComponent::writeback(SGF, loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

       ","
                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,"    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&
","             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,"    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

     ","
             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(component), result.second,","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

","
        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(component), result.second,","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

       ","
                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



","


  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}


"
Merge pull request #8035 from gottesmm/begin_transition_to_sgf,lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

   ","
    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/RValue.cpp,-,assert(eltTI.isLoadable() || !gen.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());

","
      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/RValue.cpp,+,assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());,"  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

      assert(eltTI.isLoadable() || !SGF.silConv.useLoweredAddresses());

      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

","  void visitObjectTupleType(CanTupleType tupleFormalType, ManagedValue tuple) {

    bool isPlusZero = tuple.isPlusZeroRValueOrTrivial();

    // SEMANTIC ARC TODO: This needs to be a take.

    tuple = tuple.borrow(SGF, loc);



    for (auto i : indices(tupleFormalType->getElements())) {

      CanType eltFormalType = tupleFormalType.getElementType(i);

      assert(eltFormalType->isMaterializable());



      auto eltTy = tuple.getType().getTupleElementType(i);

      assert(eltTy.isAddress() == tuple.getType().isAddress());

      auto &eltTI = SGF.getTypeLowering(eltTy);



      // Project the element.

     ","
      ManagedValue elt = SGF.B.createTupleExtract(loc, tuple, i, eltTy);

      // If we're returning a +1 value, emit a cleanup for the member

      // to cover for the cleanup we disabled for the tuple aggregate.

      if (!isPlusZero)

        elt = SGF.B.createCopyValue(loc, elt);



      visit(eltFormalType, elt);

    }

  }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

","
      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



   ","
           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()) {,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }
","

  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,"return gen.emitNativeToBridgedError(loc, v, loweredBridgedTy);","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }
","

  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

 ","
    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

   ","
  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(v.getType().isTrivial(gen.SGM.M) || v.hasCleanup());,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

","
    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());,"static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

    assert(v.getType().isTrivial(SGF.SGM.M) || v.hasCleanup());

    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

","static ManagedValue emitNativeToCBridgedNonoptionalValue(SILGenFunction &SGF,

                                                         SILLocation loc,

                                                         ManagedValue v,

                                                         SILType bridgedTy) {

  CanType loweredBridgedTy = bridgedTy.getSwiftRValueType();

  CanType loweredNativeTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  // If the input is a native type with a bridged mapping, convert it.

#define BRIDGE_TYPE(BridgedModule,BridgedType, NativeModule,NativeType,Opt) \

  if (loweredNativeTy == SGF.SGM.Types.get##NativeType##Type()              \

      && loweredBridgedTy == SGF.SGM.Types.get##BridgedType##Type()) {      \

    return emitBridge##NativeType##To##BridgedType(SGF, loc, v);            \

  }

#include ""swift/SIL/BridgedTypes.def""



  // Bridge thick to Objective-C metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)) {

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitThickToObjCMetatype(loc, v.getValue(),

                           SILType::getPrimitiveObjectType(loweredBridgedTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() &&

             ""Metatypes are trivial and thus should not have cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge native functions to blocks.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitFuncToBlock(loc, v, bridgedFTy);

  }



  // If the native type conforms to _ObjectiveCBridgeable, use its

  // _bridgeToObjectiveC witness.

  if (auto conformance =

          SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeNativeToObjectiveC(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, bridgedTy);

  }



  // Bridge Error to NSError.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()) {

    return SGF.emitNativeToBridgedError(loc, v, loweredBridgedTy);

  }



  // Fall back to dynamic Any-to-id bridging.

  // The destination type should be AnyObject in this case.

  assert(loweredBridgedTy->isEqual(

           SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

             ->getDeclaredType()));



  // If the input argument is known to be an existential, save the runtime

  // some work by opening it.

  if (loweredNativeTy->isExistentialType()) {

    auto openedTy = ArchetypeType::getOpened(loweredNativeTy);



    auto openedExistential = SGF.emitOpenExistential(

        loc, v, openedTy, SGF.getLoweredType(openedTy), AccessKind::Read);



    v = SGF.manageOpaqueValue(openedExistential, loc, SGFContext());

    loweredNativeTy = openedTy;

  }



  // Call into the stdlib intrinsic.

  if (auto bridgeAnything =

        SGF.getASTContext().getBridgeAnythingToObjectiveC(nullptr)) {

    auto *genericSig = bridgeAnything->getGenericSignature();

    auto subMap = genericSig->getSubstitutionMap(

      [&](SubstitutableType *t) -> Type {

        return loweredNativeTy;

      },

      MakeAbstractConformanceForGenericType());



    // Put the value into memory if necessary.

   ","
    if (v.getType().isObject()) {

      auto tmp = SGF.emitTemporaryAllocation(loc, v.getType());

      v.forwardInto(SGF, loc, tmp);

      v = SGF.emitManagedBufferWithCleanup(tmp);

    }

    return SGF.emitApplyOfLibraryIntrinsic(loc, bridgeAnything, subMap, v,

                                           SGFContext())

      .getAsSingleValue(SGF, loc);

  }

  

  // Shouldn't get here unless the standard library is busted.

  return SGF.emitUndef(loc, bridgedTy);

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,assert(gen.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

","
                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&,"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



   ","
           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,if (loweredBridgedTy == gen.SGM.Types.getNSErrorType()),"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.
","      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,-,"return gen.emitBridgedToNativeError(loc, v);","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.
","      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType()),"static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

 ","
    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenBridging.cpp,+,"return SGF.emitBridgedToNativeError(loc, v);","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

    return SGF.emitBridgedToNativeError(loc, v);



  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

","static ManagedValue emitCBridgedToNativeValue(SILGenFunction &SGF,

                                              SILLocation loc,

                                              ManagedValue v,

                                              SILType nativeTy) {

  CanType loweredNativeTy = nativeTy.getSwiftRValueType();

  CanType loweredBridgedTy = v.getType().getSwiftRValueType();

  if (loweredNativeTy == loweredBridgedTy)

    return v;



  if (loweredNativeTy.getAnyOptionalObjectType()) {

    return SGF.emitOptionalToOptional(loc, v, nativeTy,

                                      emitCBridgedToNativeValue);

  }



  // Bridge Bool to ObjCBool or DarwinBoolean when requested.

  if (loweredNativeTy == SGF.SGM.Types.getBoolType()) {

    if (loweredBridgedTy == SGF.SGM.Types.getObjCBoolType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getObjCBoolToBoolFn());

    }

    if (loweredBridgedTy == SGF.SGM.Types.getDarwinBooleanType()) {

      return emitBridgeForeignBoolToBool(SGF, loc, v,

                                         SGF.SGM.getDarwinBooleanToBoolFn());

    }

  }



  // Bridge Objective-C to thick metatypes.

  if (auto bridgedMetaTy = dyn_cast<AnyMetatypeType>(loweredBridgedTy)){

    if (bridgedMetaTy->getRepresentation() == MetatypeRepresentation::ObjC) {

      SILValue native = SGF.B.emitObjCToThickMetatype(loc, v.getValue(),

                                        SGF.getLoweredType(loweredNativeTy));

      // *NOTE*: ObjCMetatypes are trivial types. They only gain ARC semantics

      // when they are converted to an object via objc_metatype_to_object.

      assert(!v.hasCleanup() && ""Metatypes are trivial and should not have ""

                                ""cleanups"");

      return ManagedValue::forUnmanaged(native);

    }

  }



  // Bridge blocks back into native function types.

  auto bridgedFTy = dyn_cast<SILFunctionType>(loweredBridgedTy);

  if (bridgedFTy

      && bridgedFTy->getRepresentation() == SILFunctionType::Representation::Block){

    auto nativeFTy = cast<SILFunctionType>(loweredNativeTy);



    if (nativeFTy->getRepresentation() != SILFunctionType::Representation::Block)

      return SGF.emitBlockToFunc(loc, v, nativeFTy);

  }



  // Bridge via _ObjectiveCBridgeable.

  if (auto conformance =

        SGF.SGM.getConformanceToObjectiveCBridgeable(loc, loweredNativeTy)) {

    if (auto result = emitBridgeObjectiveCToNative(SGF, loc, v, conformance))

      return *result;



    assert(SGF.SGM.getASTContext().Diags.hadAnyError() &&

           ""Bridging code should have complained"");

    return SGF.emitUndef(loc, nativeTy);

  }



  // Bridge NSError to Error.

  if (loweredBridgedTy == SGF.SGM.Types.getNSErrorType())

   ","


  // id-to-Any bridging.

  if (loweredNativeTy->isAny()) {

    assert(loweredBridgedTy->isEqual(

      SGF.getASTContext().getProtocol(KnownProtocolKind::AnyObject)

        ->getDeclaredType())

      && ""Any should bridge to AnyObject"");



    // TODO: Ever need to handle +0 values here?

    assert(v.hasCleanup());



    // Use a runtime call to bridge the AnyObject to Any. We do this instead of

    // a simple AnyObject-to-Any upcast because the ObjC API may have returned

    // a null object in spite of its annotation.

    

    // Bitcast to Optional. This provides a barrier to the optimizer to prevent

    // it from attempting to eliminate null checks.

    auto optionalBridgedTy = OptionalType::get(loweredBridgedTy)

      ->getCanonicalType();

    auto optionalV = SGF.B.createUncheckedBitCast(loc, v.getValue(),

                          SILType::getPrimitiveObjectType(optionalBridgedTy));

    auto optionalMV = ManagedValue(optionalV, v.getCleanup());

    return SGF.emitApplyOfLibraryIntrinsic(loc,

                           SGF.getASTContext().getBridgeAnyObjectToAny(nullptr),

                           SubstitutionMap(), optionalMV, SGFContext())

      .getAsSingleValue(SGF, loc);

  }



  return v;

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"static void pushWriteback(SILGenFunction &gen,","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

",,"
                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"static void pushWriteback(SILGenFunction &SGF,","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}
","
                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope);,"static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,
","                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope);,"static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

  assert(SGF.InWritebackScope);



  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

","static void pushWriteback(SILGenFunction &SGF,

                          SILLocation loc,

                          std::unique_ptr<LogicalPathComponent> &&comp,

                          ManagedValue base,

                          MaterializedLValue materialized) {

 ","


  // Push a cleanup to execute the writeback consistently.

  auto &context = SGF.FormalEvalContext;

  LValueWritebackCleanup &cleanup =

      SGF.Cleanups.pushCleanup<LValueWritebackCleanup>();

  CleanupHandle handle = SGF.Cleanups.getTopCleanup();



  context.push<ExclusiveBorrowFormalAccess>(loc, std::move(comp), base,

                                            materialized, handle);

  cleanup.Depth = context.stable_begin();

}

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,"    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

","


      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,"    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

     ","
             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(clonedComponent), base, materialized);","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

","
        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

      pushWriteback(SGF, loc, std::move(clonedComponent), base, materialized);



      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

","    ManagedValue getMaterialized(SILGenFunction &SGF,

                                 SILLocation loc,

                                 ManagedValue base,

                                 AccessKind accessKind) && override {

      if (!shouldUseMaterializeForSet(SGF, accessKind)) {

        return std::move(*this).LogicalPathComponent::getMaterialized(SGF,

                                                        loc, base, accessKind);

      }



      assert(decl->getMaterializeForSetFunc() &&

             ""polymorphic storage without materializeForSet"");

      assert(SGF.InWritebackScope &&

             ""materializing l-value for modification without writeback scope"");



      // Allocate opaque storage for the callback to use.

      SILValue callbackStorage = SGF.emitTemporaryAllocation(loc,

        SILType::getPrimitiveObjectType(

                                SGF.getASTContext().TheUnsafeValueBufferType));



      // Allocate a temporary.

      SILValue buffer =

        SGF.emitTemporaryAllocation(loc, getTypeOfRValue());



      // Clone the component without cloning the indices.  We don't actually

      // consume them in writeback().

      std::unique_ptr<LogicalPathComponent> clonedComponent(

          [&]() -> LogicalPathComponent* {

        // Steal the subscript values without copying them so that we

        // can peek at them in diagnoseWritebackConflict.

        //

        // This is *amazingly* unprincipled.

        RValue borrowedSubscripts;

        RValue *optSubscripts = nullptr;

        if (subscripts) {

          CanType type = subscripts.getType();

          SmallVector<ManagedValue, 4> values;

          std::move(subscripts).getAll(values);

          subscripts = RValue::withPreExplodedElements(values, type);

          borrowedSubscripts = RValue::withPreExplodedElements(values, type);

          optSubscripts = &borrowedSubscripts;

        }

        return new GetterSetterComponent(decl, IsSuper, IsDirectAccessorUse,

                                         substitutions, baseFormalType,

                                         getTypeData(), subscriptIndexExpr,

                                         optSubscripts);

      }());



      SILDeclRef materializeForSet =

        SGF.getMaterializeForSetDeclRef(decl, IsDirectAccessorUse);



      MaterializedLValue materialized;

      {

        FormalEvaluationScope Scope(SGF);



        // If the base is a +1 r-value, just borrow it for materializeForSet.

        // prepareAccessorArgs will copy it if necessary.

        ManagedValue borrowedBase =

            base ? base.formalAccessBorrow(SGF, loc) : ManagedValue();



        auto args = std::move(*this).prepareAccessorArgs(SGF, loc, borrowedBase,

                                                         materializeForSet);

        materialized = SGF.emitMaterializeForSetAccessor(

            loc, materializeForSet, substitutions, std::move(args.base),

            IsSuper, IsDirectAccessorUse, std::move(args.subscripts), buffer,

            callbackStorage);



        // Mark a value-dependence on the base.  We do this regardless

        // of whether the base is trivial because even a trivial base

        // may be value-dependent on something non-trivial.

        if (base) {

          SILValue temporary = materialized.temporary.getValue();

          materialized.temporary = ManagedValue::forUnmanaged(

              SGF.B.createMarkDependence(loc, temporary, base.getValue()));

        }

      }



      // TODO: maybe needsWriteback should be a thin function pointer

      // to which we pass the base?  That would let us use direct

      // access for stored properties with didSet.

     ","


      return ManagedValue::forLValue(materialized.temporary.getValue());

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"void writeback(SILGenFunction &gen, SILLocation loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,
","                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"void writeback(SILGenFunction &SGF, SILLocation loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

",   ,"
                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"LogicalPathComponent::writeback(gen, loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize
","      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"LogicalPathComponent::writeback(SGF, loc,","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

        LogicalPathComponent::writeback(SGF, loc,

                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

","    void writeback(SILGenFunction &SGF, SILLocation loc,

                   ManagedValue base, MaterializedLValue materialized,

                   bool isFinal) override {

      // If we don't have a callback, we don't have to conditionalize

      // the writeback.

      if (!materialized.callback) {

       ","
                                        base, materialized,

                                        isFinal);

        return;

      }



      // Otherwise, 'materialized' holds an optional callback and the

      // callback storage.



      // Mark the writeback as auto-generated so that we don't get

      // warnings if we manage to devirtualize materializeForSet.

      loc.markAutoGenerated();



      SILModule &M = SGF.SGM.M;

      ASTContext &ctx = SGF.getASTContext();



      SILBasicBlock *contBB = SGF.createBasicBlock();

      SILBasicBlock *writebackBB = SGF.createBasicBlock(SGF.B.getInsertionBB());



      SGF.B.createSwitchEnum(loc, materialized.callback, /*defaultDest*/ nullptr,

                             { { ctx.getOptionalSomeDecl(), writebackBB },

                               { ctx.getOptionalNoneDecl(), contBB } });



      // The writeback block.

      SGF.B.setInsertionPoint(writebackBB); {

        FullExpr scope(SGF.Cleanups, CleanupLocation::get(loc));



        auto emptyTupleTy =

          SILType::getPrimitiveObjectType(TupleType::getEmpty(ctx));

        auto rawPointerTy = SILType::getRawPointerType(ctx);



        // The callback is a BB argument from the switch_enum.

        SILValue callback = writebackBB->createPHIArgument(

            rawPointerTy, ValueOwnershipKind::Trivial);



        // Cast the callback to the correct polymorphic function type.

        SILFunctionTypeRepresentation rep;

        if (isa<ProtocolDecl>(decl->getDeclContext()))

          rep = SILFunctionTypeRepresentation::WitnessMethod;

        else

          rep = SILFunctionTypeRepresentation::Method;



        auto origCallbackFnType = SGF.SGM.Types.getMaterializeForSetCallbackType(

          decl, materialized.genericSig, materialized.origSelfType, rep);

        auto origCallbackType = SILType::getPrimitiveObjectType(origCallbackFnType);

        callback = SGF.B.createPointerToThinFunction(loc, callback, origCallbackType);



        auto substCallbackFnType = origCallbackFnType->substGenericArgs(

            M, substitutions);

        auto substCallbackType = SILType::getPrimitiveObjectType(substCallbackFnType);

        auto metatypeType =

            SGF.getSILType(substCallbackFnType->getParameters().back());



        // We need to borrow the base here.  We can't just consume it

        // because we're in conditionally-executed code (and because

        // this might be a non-final use).  We also need to pass it

        // indirectly.

        SILValue baseAddress;

        SILValue baseMetatype;

        if (base) {

          if (base.getType().isAddress()) {

            baseAddress = base.getValue();

          } else {

            AbstractionPattern origSelfType(materialized.genericSig,

                                            materialized.origSelfType);

            base = SGF.emitSubstToOrigValue(loc, base, origSelfType,

                                            baseFormalType);



            baseAddress = SGF.emitTemporaryAllocation(loc, base.getType());

            if (base.getOwnershipKind() == ValueOwnershipKind::Guaranteed) {

              SGF.B.createStoreBorrow(loc, base.getValue(), baseAddress);

            } else {

              SGF.B.emitStoreValueOperation(loc, base.getValue(), baseAddress,

                                            StoreOwnershipQualifier::Init);

            }

          }

          baseMetatype = SGF.B.createMetatype(loc, metatypeType);



        // Otherwise, we have to pass something; use an empty tuple

        // and an undef metatype.

        } else {

          baseAddress = SILUndef::get(emptyTupleTy.getAddressType(), M);

          baseMetatype = SILUndef::get(metatypeType, M);

        }



        SILValue temporaryPointer =

          SGF.B.createAddressToPointer(loc,

                                       materialized.temporary.getValue(),

                                       rawPointerTy);



        // Apply the callback.

        SGF.B.createApply(loc, callback, substCallbackType,

                          emptyTupleTy, substitutions, {

                            temporaryPointer,

                            materialized.callbackStorage,

                            baseAddress,

                            baseMetatype

                          }, false);

      }



      // Continue.

      SGF.B.emitBlock(contBB, loc);

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,assert(gen.InWritebackScope &&,"    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&
","             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,assert(SGF.InWritebackScope &&,"    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

     ","
             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"pushWriteback(gen, loc, std::move(component), result.second,","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

","
        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"pushWriteback(SGF, loc, std::move(component), result.second,","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

        pushWriteback(SGF, loc, std::move(component), result.second,

                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

","    ManagedValue offset(SILGenFunction &SGF, SILLocation loc, ManagedValue base,

                        AccessKind accessKind) && override {

      assert(SGF.InWritebackScope &&

             ""offsetting l-value for modification without writeback scope"");



      SILDeclRef addressor = SGF.getAddressorDeclRef(decl, accessKind, 

                                                     IsDirectAccessorUse);

      std::pair<ManagedValue, ManagedValue> result;

      {

        FormalEvaluationScope scope(SGF);



        auto args =

            std::move(*this).prepareAccessorArgs(SGF, loc, base, addressor);

        result = SGF.emitAddressorAccessor(

            loc, addressor, substitutions, std::move(args.base), IsSuper,

            IsDirectAccessorUse, std::move(args.subscripts), SubstFieldType);

      }

      switch (cast<FuncDecl>(addressor.getDecl())->getAddressorKind()) {

      case AddressorKind::NotAddressor:

        llvm_unreachable(""not an addressor!"");



      // For unsafe addressors, we have no owner pointer to manage.

      case AddressorKind::Unsafe:

        assert(!result.second);

        return result.first;



      // For owning addressors, we can just let the owner get released

      // at an appropriate point.

      case AddressorKind::Owning:

      case AddressorKind::NativeOwning:

        return result.first;



      // For pinning addressors, we have to push a writeback.

      case AddressorKind::NativePinning: {

        std::unique_ptr<LogicalPathComponent>

          component(new UnpinPseudoComponent(getTypeData()));

       ","
                      MaterializedLValue());

        return result.first;

      }

      }

      llvm_unreachable(""bad addressor kind"");

    }

"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,-,"auto typeData = getLogicalStorageTypeData(gen.SGM, formalRValueType);","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



","


  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}


"
"[gardening] As per discussion, begin standardizing in SILGen that the SILGenFunction variable is passed around as SGF.

The reason that this is being done is that:

1. SILGenFunction is passed around all throughout SILGen, including in between
APIs some of which call the SILGenFunction variable SGF and others that call it
gen.
2. Thus when one is debugging code in SILGen, one wastes time figuring out what
the variable name of SILGenFunction is in the current frame.

I did not do this by hand. I did this by:

1. Grepping for ""SILGenFunction &gen"".
2. By hand inspecting that the match was truly a SILGenFunction &gen site.
3. If so, use libclang tooling to rename the variable to SGF.

So I did not update any use sites.",lib/SILGen/SILGenLValue.cpp,+,"auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

    auto typeData = getLogicalStorageTypeData(SGF.SGM, formalRValueType);

    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

","static LValue emitLValueForNonMemberVarDecl(SILGenFunction &SGF,

                                            SILLocation loc, VarDecl *var,

                                            CanType formalRValueType,

                                            AccessKind accessKind,

                                            AccessSemantics semantics) {

  LValue lv;



  switch (var->getAccessStrategy(semantics, accessKind)) {



  case AccessStrategy::DispatchToAccessor:

    llvm_unreachable(""can't polymorphically access non-member variable"");



  // If it's a computed variable, push a reference to the getter and setter.

  case AccessStrategy::DirectToAccessor: {

   ","
    lv.add<GetterSetterComponent>(var, /*isSuper=*/false, /*direct*/ true,

                                  SGF.SGM.getNonMemberVarDeclSubstitutions(var),

                                  CanType(), typeData);

    break;

  }



  case AccessStrategy::Addressor: {

    addNonMemberVarDeclAddressorComponent(SGF.SGM, var, formalRValueType, lv);

    break;

  }



  case AccessStrategy::Storage: {

    // If it's a physical value (e.g. a local variable in memory), push its

    // address.

    auto address = SGF.emitLValueForDecl(loc, var, formalRValueType,

                                         accessKind, semantics);

    assert(address.isLValue() &&

           ""physical lvalue decl ref must evaluate to an address"");

    auto typeData = getPhysicalStorageTypeData(SGF.SGM, var, formalRValueType);

    lv.add<ValueComponent>(address, typeData);



    if (address.getType().is<ReferenceStorageType>())

      lv.add<OwnershipComponent>(typeData);

    break;

  }

  

  case AccessStrategy::BehaviorStorage:

    // TODO: Behaviors aren't supported for non-instance properties yet.

    llvm_unreachable(""not implemented"");

  }



  return lv;

}

"
Merge pull request #8023 from huonw/tweak,lib/AST/ASTDumper.cpp,-,Super.getType().print(OS);,"    void visitImportDecl(ImportDecl *ID) {

      printCommon(ID, ""import_decl"");



      if (ID->isExported())

        OS << "" exported"";



      if (ID->getImportKind() != ImportKind::Module)

        OS << "" kind="" << getImportKindString(ID->getImportKind());



      OS << "" '"";

      interleave(ID->getFullAccessPath(),

                 [&](const ImportDecl::AccessPathElement &Elem) {

                   OS << Elem.first;

                 },

                 [&] { OS << '.'; });

      OS << ""')"";

    }

","    void visitImportDecl(ImportDecl *ID) {

      printCommon(ID, ""import_decl"");
","

      if (ID->isExported())

        OS << "" exported"";



      if (ID->getImportKind() != ImportKind::Module)

        OS << "" kind="" << getImportKindString(ID->getImportKind());



      OS << "" '"";

      interleave(ID->getFullAccessPath(),

                 [&](const ImportDecl::AccessPathElement &Elem) {

                   OS << Elem.first;

                 },

                 [&] { OS << '.'; });

      OS << ""')"";

    }


"
"Factor out `first = true; ... if (first) first = false; else ...`.

There's an `interleave` function for this: let's use it.",lib/AST/ASTDumper.cpp,-,Super.getType().print(OS);,"    void visitImportDecl(ImportDecl *ID) {

      printCommon(ID, ""import_decl"");



      if (ID->isExported())

        OS << "" exported"";



      if (ID->getImportKind() != ImportKind::Module)

        OS << "" kind="" << getImportKindString(ID->getImportKind());



      OS << "" '"";

      interleave(ID->getFullAccessPath(),

                 [&](const ImportDecl::AccessPathElement &Elem) {

                   OS << Elem.first;

                 },

                 [&] { OS << '.'; });

      OS << ""')"";

    }

","    void visitImportDecl(ImportDecl *ID) {

      printCommon(ID, ""import_decl"");
","

      if (ID->isExported())

        OS << "" exported"";



      if (ID->getImportKind() != ImportKind::Module)

        OS << "" kind="" << getImportKindString(ID->getImportKind());



      OS << "" '"";

      interleave(ID->getFullAccessPath(),

                 [&](const ImportDecl::AccessPathElement &Elem) {

                   OS << Elem.first;

                 },

                 [&] { OS << '.'; });

      OS << ""')"";

    }


"
"Merge pull request #7973 from swiftix/wip-fso-fixes

[function-signature-opt] Allow FSO on witness_methods when performing  the dead argument signature optimization for partial_apply instructions",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");","  void run() override {

    auto *F = getFunction();



    // Don't optimize callees that should not be optimized.

    if (!F->shouldOptimize())

      return;



    // This is the function to optimize.

    DEBUG(llvm::dbgs() << ""*** FSO on function: "" << F->getName() << "" ***\n"");



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    // No need for CallerAnalysis if we are not optimizing for partial

    // applies.

    if (!OptForPartialApply &&

        !canSpecializeFunction(F, nullptr, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    CallerAnalysis *CA = PM->getAnalysis<CallerAnalysis>();

    const CallerAnalysis::FunctionInfo &FuncInfo = CA->getCallerInfo(F);



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    if (OptForPartialApply &&

        !canSpecializeFunction(F, &FuncInfo, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    auto *RCIA = getAnalysis<RCIdentityAnalysis>();

    auto *EA = PM->getAnalysis<EpilogueARCAnalysis>();



    // Lock BCA so it's not invalidated along with the rest of the call graph.

    AnalysisPreserver BCAP(PM->getAnalysis<BasicCalleeAnalysis>());



    // As we optimize the function more and more, the name of the function is

    // going to change, make sure the mangler is aware of all the changes done

    // to the function.

    Mangle::Mangler M;

    auto P = Demangle::SpecializationPass::FunctionSignatureOpts;

    FunctionSignatureSpecializationMangler OldFM(P, M, F->isFragile(), F);

    NewMangling::FunctionSignatureSpecializationMangler NewFM(P, F->isFragile(),

                                                              F);



    /// Keep a map between the exploded argument index and the original argument

    /// index.

    llvm::SmallDenseMap<int, int> AIM;

    int asize = F->begin()->getArguments().size();

    for (auto i = 0; i < asize; ++i) {

      AIM[i] = i;

    }



    // Allocate the argument and result descriptors.

    llvm::SmallVector<ArgumentDescriptor, 4> ArgumentDescList;

    llvm::SmallVector<ResultDescriptor, 4> ResultDescList;

    auto Args = F->begin()->getFunctionArguments();

    for (unsigned i = 0, e = Args.size(); i != e; ++i) {

      ArgumentDescList.emplace_back(Args[i]);

    }

    for (SILResultInfo IR : F->getLoweredFunctionType()->getResults()) {

      ResultDescList.emplace_back(IR);

    }



    // Owned to guaranteed optimization.

    FunctionSignatureTransform FST(F, RCIA, EA, OldFM, NewFM, AIM,

                                   ArgumentDescList, ResultDescList);



    bool Changed = false;

    if (OptForPartialApply) {

      Changed = FST.removeDeadArgs(FuncInfo.getMinPartialAppliedArgs());

    } else {

      Changed = FST.run(FuncInfo.hasCaller());

    }

    if (Changed) {

      ++ NumFunctionSignaturesOptimized;

      // The old function must be a thunk now.

      assert(F->isThunk() && ""Old function should have been turned into a thunk"");



      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::Everything);



      // Make sure the PM knows about this function. This will also help us

      // with self-recursion.

      notifyPassManagerOfFunction(FST.getOptimizedFunction(), F);



      if (!OptForPartialApply) {

        // We have to restart the pipeline for this thunk in order to run the

        // inliner (and other opts) again. This is important if the new

        // specialized function (which is called from this thunk) is

        // function-signature-optimized again and also becomes an

        // always-inline-thunk.

        restartPassPipeline();

      }

    }

  }

","  void run() override {

    auto *F = getFunction();



    // Don't optimize callees that should not be optimized.

    if (!F->shouldOptimize())

      return;



    // This is the function to optimize.

    DEBUG(llvm::dbgs() << ""*** FSO on function: "" << F->getName() << "" ***\n"");



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    // No need for CallerAnalysis if we are not optimizing for partial

    // applies.

    if (!OptForPartialApply &&

        !canSpecializeFunction(F, nullptr, OptForPartialApply)) {

     ","
      return;

    }



    CallerAnalysis *CA = PM->getAnalysis<CallerAnalysis>();

    const CallerAnalysis::FunctionInfo &FuncInfo = CA->getCallerInfo(F);



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    if (OptForPartialApply &&

        !canSpecializeFunction(F, &FuncInfo, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    auto *RCIA = getAnalysis<RCIdentityAnalysis>();

    auto *EA = PM->getAnalysis<EpilogueARCAnalysis>();



    // Lock BCA so it's not invalidated along with the rest of the call graph.

    AnalysisPreserver BCAP(PM->getAnalysis<BasicCalleeAnalysis>());



    // As we optimize the function more and more, the name of the function is

    // going to change, make sure the mangler is aware of all the changes done

    // to the function.

    Mangle::Mangler M;

    auto P = Demangle::SpecializationPass::FunctionSignatureOpts;

    FunctionSignatureSpecializationMangler OldFM(P, M, F->isFragile(), F);

    NewMangling::FunctionSignatureSpecializationMangler NewFM(P, F->isFragile(),

                                                              F);



    /// Keep a map between the exploded argument index and the original argument

    /// index.

    llvm::SmallDenseMap<int, int> AIM;

    int asize = F->begin()->getArguments().size();

    for (auto i = 0; i < asize; ++i) {

      AIM[i] = i;

    }



    // Allocate the argument and result descriptors.

    llvm::SmallVector<ArgumentDescriptor, 4> ArgumentDescList;

    llvm::SmallVector<ResultDescriptor, 4> ResultDescList;

    auto Args = F->begin()->getFunctionArguments();

    for (unsigned i = 0, e = Args.size(); i != e; ++i) {

      ArgumentDescList.emplace_back(Args[i]);

    }

    for (SILResultInfo IR : F->getLoweredFunctionType()->getResults()) {

      ResultDescList.emplace_back(IR);

    }



    // Owned to guaranteed optimization.

    FunctionSignatureTransform FST(F, RCIA, EA, OldFM, NewFM, AIM,

                                   ArgumentDescList, ResultDescList);



    bool Changed = false;

    if (OptForPartialApply) {

      Changed = FST.removeDeadArgs(FuncInfo.getMinPartialAppliedArgs());

    } else {

      Changed = FST.run(FuncInfo.hasCaller());

    }

    if (Changed) {

      ++ NumFunctionSignaturesOptimized;

      // The old function must be a thunk now.

      assert(F->isThunk() && ""Old function should have been turned into a thunk"");



      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::Everything);



      // Make sure the PM knows about this function. This will also help us

      // with self-recursion.

      notifyPassManagerOfFunction(FST.getOptimizedFunction(), F);



      if (!OptForPartialApply) {

        // We have to restart the pipeline for this thunk in order to run the

        // inliner (and other opts) again. This is important if the new

        // specialized function (which is called from this thunk) is

        // function-signature-optimized again and also becomes an

        // always-inline-thunk.

        restartPassPipeline();

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child, depth + 1);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }
","  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::dump() const { print(llvm::errs()); },"static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

","
    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::print(llvm::raw_ostream &Out) const {,"static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {
","    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, Root, 0);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {
","    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Basic/DemangleWrappers.cpp,-,"printNode(out, TheNode, 4);","  PrettyStackTraceNode(const char *action, Node *node)

    : Action(action), TheNode(node) {}

","  PrettyStackTraceNode(const char *action, Node *node)
","    : Action(action), TheNode(node) {}


"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodeDumper.cpp,+,"static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}
","
  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodeDumper.cpp,+,"printNode(Out, child, depth + 1);","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

   ","
  }

}

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad directness"");","static StringRef toString(Directness d) {

  switch (d) {

  case Directness::Direct:

    return ""direct"";

  case Directness::Indirect:

    return ""indirect"";

  }

  printer_unreachable(""bad directness"");

}

","static StringRef toString(Directness d) {

  switch (d) {

  case Directness::Direct:

    return ""direct"";

  case Directness::Indirect:

    return ""indirect"";

  }

 ","
}

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,NodePrinter(DemangleOptions options) : Options(options) {},"  NodePrinter(DemangleOptions options) : Options(options) {}

", ,"
"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,std::string printRoot(NodePointer root) {,"  std::string printRoot(NodePointer root) {

    print(root);

    return std::move(Printer).str();

  }

", ,"
    print(root);

    return std::move(Printer).str();

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(root);,"  std::string printRoot(NodePointer root) {

    print(root);

    return std::move(Printer).str();

  }

","  std::string printRoot(NodePointer root) {

   ","
    return std::move(Printer).str();

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"void printChildren(Node::iterator begin,","  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

", ,"
                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(*begin);,"  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

","  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

     ","
      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printBoundGenericNoSugar(NodePointer pointer) {,"  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

", ,"
    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,"  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

   ","
    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printChildren(typelist, "", "");","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

   ","
    Printer << "">"";

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,static bool isDebuggerGeneratedModule(NodePointer node) {,"  static bool isDebuggerGeneratedModule(NodePointer node) {

      return (node->getKind() == Node::Kind::Module &&

              node->getText().startswith(LLDB_EXPRESSIONS_MODULE_NAME_PREFIX));

    }

", ,"
      return (node->getKind() == Node::Kind::Module &&

              node->getText().startswith(LLDB_EXPRESSIONS_MODULE_NAME_PREFIX));

    }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad node kind"");","  bool isSimpleType(NodePointer pointer) {

    switch (pointer->getKind()) {

    case Node::Kind::AssociatedType:

    case Node::Kind::AssociatedTypeRef:

    case Node::Kind::BoundGenericClass:

    case Node::Kind::BoundGenericEnum:

    case Node::Kind::BoundGenericStructure:

    case Node::Kind::BuiltinTypeName:

    case Node::Kind::Class:

    case Node::Kind::DependentGenericType:

    case Node::Kind::DependentMemberType:

    case Node::Kind::DependentGenericParamType:

    case Node::Kind::DynamicSelf:

    case Node::Kind::Enum:

    case Node::Kind::ErrorType:

    case Node::Kind::ExistentialMetatype:

    case Node::Kind::Metatype:

    case Node::Kind::MetatypeRepresentation:

    case Node::Kind::Module:

    case Node::Kind::NonVariadicTuple:

    case Node::Kind::Protocol:

    case Node::Kind::QualifiedArchetype:

    case Node::Kind::ReturnType:

    case Node::Kind::SILBoxType:

    case Node::Kind::SILBoxTypeWithLayout:

    case Node::Kind::Structure:

    case Node::Kind::TupleElementName:

    case Node::Kind::Type:

    case Node::Kind::TypeAlias:

    case Node::Kind::TypeList:

    case Node::Kind::VariadicTuple:

      return true;



    case Node::Kind::ProtocolList:

      if (pointer->getChild(0)->getNumChildren() <= 1)

        return true;

      return false;



    case Node::Kind::Allocator:

    case Node::Kind::ArgumentTuple:

    case Node::Kind::AssociatedTypeMetadataAccessor:

    case Node::Kind::AssociatedTypeWitnessTableAccessor:

    case Node::Kind::AutoClosureType:

    case Node::Kind::CFunctionPointer:

    case Node::Kind::Constructor:

    case Node::Kind::CurryThunk:

    case Node::Kind::Deallocator:

    case Node::Kind::DeclContext:

    case Node::Kind::DefaultArgumentInitializer:

    case Node::Kind::DependentAssociatedTypeRef:

    case Node::Kind::DependentGenericSignature:

    case Node::Kind::DependentGenericParamCount:

    case Node::Kind::DependentGenericConformanceRequirement:

    case Node::Kind::DependentGenericLayoutRequirement:

    case Node::Kind::DependentGenericSameTypeRequirement:

    case Node::Kind::DependentPseudogenericSignature:

    case Node::Kind::Destructor:

    case Node::Kind::DidSet:

    case Node::Kind::DirectMethodReferenceAttribute:

    case Node::Kind::Directness:

    case Node::Kind::DynamicAttribute:

    case Node::Kind::ExplicitClosure:

    case Node::Kind::Extension:

    case Node::Kind::FieldOffset:

    case Node::Kind::FullTypeMetadata:

    case Node::Kind::Function:

    case Node::Kind::FunctionSignatureSpecialization:

    case Node::Kind::FunctionSignatureSpecializationParam:

    case Node::Kind::FunctionSignatureSpecializationParamKind:

    case Node::Kind::FunctionSignatureSpecializationParamPayload:

    case Node::Kind::FunctionType:

    case Node::Kind::GenericProtocolWitnessTable:

    case Node::Kind::GenericProtocolWitnessTableInstantiationFunction:

    case Node::Kind::GenericPartialSpecialization:

    case Node::Kind::GenericPartialSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecialization:

    case Node::Kind::GenericSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecializationParam:

    case Node::Kind::GenericTypeMetadataPattern:

    case Node::Kind::Getter:

    case Node::Kind::Global:

    case Node::Kind::GlobalGetter:

    case Node::Kind::Identifier:

    case Node::Kind::Index:

    case Node::Kind::IVarInitializer:

    case Node::Kind::IVarDestroyer:

    case Node::Kind::ImplConvention:

    case Node::Kind::ImplFunctionAttribute:

    case Node::Kind::ImplFunctionType:

    case Node::Kind::ImplicitClosure:

    case Node::Kind::ImplParameter:

    case Node::Kind::ImplResult:

    case Node::Kind::ImplErrorResult:

    case Node::Kind::InOut:

    case Node::Kind::InfixOperator:

    case Node::Kind::Initializer:

    case Node::Kind::LazyProtocolWitnessTableAccessor:

    case Node::Kind::LazyProtocolWitnessTableCacheVariable:

    case Node::Kind::LocalDeclName:

    case Node::Kind::PrivateDeclName:

    case Node::Kind::MaterializeForSet:

    case Node::Kind::Metaclass:

    case Node::Kind::NativeOwningAddressor:

    case Node::Kind::NativeOwningMutableAddressor:

    case Node::Kind::NativePinningAddressor:

    case Node::Kind::NativePinningMutableAddressor:

    case Node::Kind::NominalTypeDescriptor:

    case Node::Kind::NonObjCAttribute:

    case Node::Kind::Number:

    case Node::Kind::ObjCAttribute:

    case Node::Kind::ObjCBlock:

    case Node::Kind::OwningAddressor:

    case Node::Kind::OwningMutableAddressor:

    case Node::Kind::PartialApplyForwarder:

    case Node::Kind::PartialApplyObjCForwarder:

    case Node::Kind::PostfixOperator:

    case Node::Kind::PrefixOperator:

    case Node::Kind::ProtocolConformance:

    case Node::Kind::ProtocolDescriptor:

    case Node::Kind::ProtocolWitness:

    case Node::Kind::ProtocolWitnessTable:

    case Node::Kind::ProtocolWitnessTableAccessor:

    case Node::Kind::ReabstractionThunk:

    case Node::Kind::ReabstractionThunkHelper:

    case Node::Kind::Setter:

    case Node::Kind::SILBoxLayout:

    case Node::Kind::SILBoxMutableField:

    case Node::Kind::SILBoxImmutableField:

    case Node::Kind::SpecializationIsFragile:

    case Node::Kind::SpecializationPassID:

    case Node::Kind::Static:

    case Node::Kind::Subscript:

    case Node::Kind::Suffix:

    case Node::Kind::ThinFunctionType:

    case Node::Kind::TupleElement:

    case Node::Kind::TypeMangling:

    case Node::Kind::TypeMetadata:

    case Node::Kind::TypeMetadataAccessFunction:

    case Node::Kind::TypeMetadataLazyCache:

    case Node::Kind::UncurriedFunctionType:

    case Node::Kind::Unmanaged:

    case Node::Kind::Unowned:

    case Node::Kind::UnsafeAddressor:

    case Node::Kind::UnsafeMutableAddressor:

    case Node::Kind::ValueWitness:

    case Node::Kind::ValueWitnessTable:

    case Node::Kind::Variable:

    case Node::Kind::VTableAttribute:

    case Node::Kind::Weak:

    case Node::Kind::WillSet:

    case Node::Kind::WitnessTableOffset:

    case Node::Kind::ReflectionMetadataBuiltinDescriptor:

    case Node::Kind::ReflectionMetadataFieldDescriptor:

    case Node::Kind::ReflectionMetadataAssocTypeDescriptor:

    case Node::Kind::ReflectionMetadataSuperclassDescriptor:

    case Node::Kind::GenericTypeParamDecl:

    case Node::Kind::ThrowsAnnotation:

    case Node::Kind::EmptyList:

    case Node::Kind::FirstElementMarker:

    case Node::Kind::VariadicMarker:

    case Node::Kind::OutlinedCopy:

    case Node::Kind::OutlinedConsume:

      return false;

    }

    printer_unreachable(""bad node kind"");

  }

","  bool isSimpleType(NodePointer pointer) {

    switch (pointer->getKind()) {

    case Node::Kind::AssociatedType:

    case Node::Kind::AssociatedTypeRef:

    case Node::Kind::BoundGenericClass:

    case Node::Kind::BoundGenericEnum:

    case Node::Kind::BoundGenericStructure:

    case Node::Kind::BuiltinTypeName:

    case Node::Kind::Class:

    case Node::Kind::DependentGenericType:

    case Node::Kind::DependentMemberType:

    case Node::Kind::DependentGenericParamType:

    case Node::Kind::DynamicSelf:

    case Node::Kind::Enum:

    case Node::Kind::ErrorType:

    case Node::Kind::ExistentialMetatype:

    case Node::Kind::Metatype:

    case Node::Kind::MetatypeRepresentation:

    case Node::Kind::Module:

    case Node::Kind::NonVariadicTuple:

    case Node::Kind::Protocol:

    case Node::Kind::QualifiedArchetype:

    case Node::Kind::ReturnType:

    case Node::Kind::SILBoxType:

    case Node::Kind::SILBoxTypeWithLayout:

    case Node::Kind::Structure:

    case Node::Kind::TupleElementName:

    case Node::Kind::Type:

    case Node::Kind::TypeAlias:

    case Node::Kind::TypeList:

    case Node::Kind::VariadicTuple:

      return true;



    case Node::Kind::ProtocolList:

      if (pointer->getChild(0)->getNumChildren() <= 1)

        return true;

      return false;



    case Node::Kind::Allocator:

    case Node::Kind::ArgumentTuple:

    case Node::Kind::AssociatedTypeMetadataAccessor:

    case Node::Kind::AssociatedTypeWitnessTableAccessor:

    case Node::Kind::AutoClosureType:

    case Node::Kind::CFunctionPointer:

    case Node::Kind::Constructor:

    case Node::Kind::CurryThunk:

    case Node::Kind::Deallocator:

    case Node::Kind::DeclContext:

    case Node::Kind::DefaultArgumentInitializer:

    case Node::Kind::DependentAssociatedTypeRef:

    case Node::Kind::DependentGenericSignature:

    case Node::Kind::DependentGenericParamCount:

    case Node::Kind::DependentGenericConformanceRequirement:

    case Node::Kind::DependentGenericLayoutRequirement:

    case Node::Kind::DependentGenericSameTypeRequirement:

    case Node::Kind::DependentPseudogenericSignature:

    case Node::Kind::Destructor:

    case Node::Kind::DidSet:

    case Node::Kind::DirectMethodReferenceAttribute:

    case Node::Kind::Directness:

    case Node::Kind::DynamicAttribute:

    case Node::Kind::ExplicitClosure:

    case Node::Kind::Extension:

    case Node::Kind::FieldOffset:

    case Node::Kind::FullTypeMetadata:

    case Node::Kind::Function:

    case Node::Kind::FunctionSignatureSpecialization:

    case Node::Kind::FunctionSignatureSpecializationParam:

    case Node::Kind::FunctionSignatureSpecializationParamKind:

    case Node::Kind::FunctionSignatureSpecializationParamPayload:

    case Node::Kind::FunctionType:

    case Node::Kind::GenericProtocolWitnessTable:

    case Node::Kind::GenericProtocolWitnessTableInstantiationFunction:

    case Node::Kind::GenericPartialSpecialization:

    case Node::Kind::GenericPartialSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecialization:

    case Node::Kind::GenericSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecializationParam:

    case Node::Kind::GenericTypeMetadataPattern:

    case Node::Kind::Getter:

    case Node::Kind::Global:

    case Node::Kind::GlobalGetter:

    case Node::Kind::Identifier:

    case Node::Kind::Index:

    case Node::Kind::IVarInitializer:

    case Node::Kind::IVarDestroyer:

    case Node::Kind::ImplConvention:

    case Node::Kind::ImplFunctionAttribute:

    case Node::Kind::ImplFunctionType:

    case Node::Kind::ImplicitClosure:

    case Node::Kind::ImplParameter:

    case Node::Kind::ImplResult:

    case Node::Kind::ImplErrorResult:

    case Node::Kind::InOut:

    case Node::Kind::InfixOperator:

    case Node::Kind::Initializer:

    case Node::Kind::LazyProtocolWitnessTableAccessor:

    case Node::Kind::LazyProtocolWitnessTableCacheVariable:

    case Node::Kind::LocalDeclName:

    case Node::Kind::PrivateDeclName:

    case Node::Kind::MaterializeForSet:

    case Node::Kind::Metaclass:

    case Node::Kind::NativeOwningAddressor:

    case Node::Kind::NativeOwningMutableAddressor:

    case Node::Kind::NativePinningAddressor:

    case Node::Kind::NativePinningMutableAddressor:

    case Node::Kind::NominalTypeDescriptor:

    case Node::Kind::NonObjCAttribute:

    case Node::Kind::Number:

    case Node::Kind::ObjCAttribute:

    case Node::Kind::ObjCBlock:

    case Node::Kind::OwningAddressor:

    case Node::Kind::OwningMutableAddressor:

    case Node::Kind::PartialApplyForwarder:

    case Node::Kind::PartialApplyObjCForwarder:

    case Node::Kind::PostfixOperator:

    case Node::Kind::PrefixOperator:

    case Node::Kind::ProtocolConformance:

    case Node::Kind::ProtocolDescriptor:

    case Node::Kind::ProtocolWitness:

    case Node::Kind::ProtocolWitnessTable:

    case Node::Kind::ProtocolWitnessTableAccessor:

    case Node::Kind::ReabstractionThunk:

    case Node::Kind::ReabstractionThunkHelper:

    case Node::Kind::Setter:

    case Node::Kind::SILBoxLayout:

    case Node::Kind::SILBoxMutableField:

    case Node::Kind::SILBoxImmutableField:

    case Node::Kind::SpecializationIsFragile:

    case Node::Kind::SpecializationPassID:

    case Node::Kind::Static:

    case Node::Kind::Subscript:

    case Node::Kind::Suffix:

    case Node::Kind::ThinFunctionType:

    case Node::Kind::TupleElement:

    case Node::Kind::TypeMangling:

    case Node::Kind::TypeMetadata:

    case Node::Kind::TypeMetadataAccessFunction:

    case Node::Kind::TypeMetadataLazyCache:

    case Node::Kind::UncurriedFunctionType:

    case Node::Kind::Unmanaged:

    case Node::Kind::Unowned:

    case Node::Kind::UnsafeAddressor:

    case Node::Kind::UnsafeMutableAddressor:

    case Node::Kind::ValueWitness:

    case Node::Kind::ValueWitnessTable:

    case Node::Kind::Variable:

    case Node::Kind::VTableAttribute:

    case Node::Kind::Weak:

    case Node::Kind::WillSet:

    case Node::Kind::WitnessTableOffset:

    case Node::Kind::ReflectionMetadataBuiltinDescriptor:

    case Node::Kind::ReflectionMetadataFieldDescriptor:

    case Node::Kind::ReflectionMetadataAssocTypeDescriptor:

    case Node::Kind::ReflectionMetadataSuperclassDescriptor:

    case Node::Kind::GenericTypeParamDecl:

    case Node::Kind::ThrowsAnnotation:

    case Node::Kind::EmptyList:

    case Node::Kind::FirstElementMarker:

    case Node::Kind::VariadicMarker:

    case Node::Kind::OutlinedCopy:

    case Node::Kind::OutlinedConsume:

      return false;

    }

   ","
  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getKind() == Node::Kind::BoundGenericStructure);,"  SugarType findSugar(NodePointer pointer) {

    if (pointer->getNumChildren() == 1 && 

        pointer->getKind() == Node::Kind::Type)

      return findSugar(pointer->getChild(0));

    

    if (pointer->getNumChildren() != 2)

      return SugarType::None;

    

    if (pointer->getKind() != Node::Kind::BoundGenericEnum &&

        pointer->getKind() != Node::Kind::BoundGenericStructure)

      return SugarType::None;



    auto unboundType = pointer->getChild(0)->getChild(0); // drill through Type

    auto typeArgs = pointer->getChild(1);

    

    if (pointer->getKind() == Node::Kind::BoundGenericEnum) {

      // Swift.Optional

      if (isIdentifier(unboundType->getChild(1), ""Optional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::Optional;

      }



      // Swift.ImplicitlyUnwrappedOptional

      if (isIdentifier(unboundType->getChild(1), 

                       ""ImplicitlyUnwrappedOptional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::ImplicitlyUnwrappedOptional;

      }



      return SugarType::None;

    }



    assert(pointer->getKind() == Node::Kind::BoundGenericStructure);



    // Array

    if (isIdentifier(unboundType->getChild(1), ""Array"") &&

        typeArgs->getNumChildren() == 1 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Array;

    }



    // Dictionary

    if (isIdentifier(unboundType->getChild(1), ""Dictionary"") &&

        typeArgs->getNumChildren() == 2 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Dictionary;

    }



    return SugarType::None;

  }

","  SugarType findSugar(NodePointer pointer) {

    if (pointer->getNumChildren() == 1 && 

        pointer->getKind() == Node::Kind::Type)

      return findSugar(pointer->getChild(0));

    

    if (pointer->getNumChildren() != 2)

      return SugarType::None;

    

    if (pointer->getKind() != Node::Kind::BoundGenericEnum &&

        pointer->getKind() != Node::Kind::BoundGenericStructure)

      return SugarType::None;



    auto unboundType = pointer->getChild(0)->getChild(0); // drill through Type

    auto typeArgs = pointer->getChild(1);

    

    if (pointer->getKind() == Node::Kind::BoundGenericEnum) {

      // Swift.Optional

      if (isIdentifier(unboundType->getChild(1), ""Optional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::Optional;

      }



      // Swift.ImplicitlyUnwrappedOptional

      if (isIdentifier(unboundType->getChild(1), 

                       ""ImplicitlyUnwrappedOptional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::ImplicitlyUnwrappedOptional;

      }



      return SugarType::None;

    }



   ","


    // Array

    if (isIdentifier(unboundType->getChild(1), ""Array"") &&

        typeArgs->getNumChildren() == 1 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Array;

    }



    // Dictionary

    if (isIdentifier(unboundType->getChild(1), ""Dictionary"") &&

        typeArgs->getNumChildren() == 2 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Dictionary;

    }



    return SugarType::None;

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printBoundGeneric(NodePointer pointer) {,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

", ,"
    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

       ","
        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(type);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

       ","
        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(keyType);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

       ","
        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(valueType);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

       ","
        Printer << ""]"";

        break;

      }

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printFunctionType(NodePointer node) {,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

", ,"
    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

   ","
    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

     ","
      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex));,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

   ","
    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex+1));,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

   ","
  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printImplFunctionType(NodePointer fn) {,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

", ,"
    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(newState >= curState);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

     ","
      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"case Results: printer_unreachable(""no state after Results"");","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

       ","
        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad state"");","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

       ","
      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,assert(curState == Attrs);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

       ","
        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,void printContext(NodePointer context) {,"  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

", ,"
    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,!isDebuggerGeneratedModule(context)),"  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

      ","
    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"print(context, /*asContext*/ true);","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

     ","
      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""not an entity"");","static bool useColonForEntityType(NodePointer entity, NodePointer type) {

  switch (entity->getKind()) {

  case Node::Kind::Variable:

  case Node::Kind::Initializer:

  case Node::Kind::DefaultArgumentInitializer:

  case Node::Kind::IVarInitializer:

  case Node::Kind::Class:

  case Node::Kind::Structure:

  case Node::Kind::Enum:

  case Node::Kind::Protocol:

  case Node::Kind::TypeAlias:

  case Node::Kind::OwningAddressor:

  case Node::Kind::OwningMutableAddressor:

  case Node::Kind::NativeOwningAddressor:

  case Node::Kind::NativeOwningMutableAddressor:

  case Node::Kind::NativePinningAddressor:

  case Node::Kind::NativePinningMutableAddressor:

  case Node::Kind::UnsafeAddressor:

  case Node::Kind::UnsafeMutableAddressor:

  case Node::Kind::GlobalGetter:

  case Node::Kind::Getter:

  case Node::Kind::Setter:

  case Node::Kind::MaterializeForSet:

  case Node::Kind::WillSet:

  case Node::Kind::DidSet:

    return true;



  case Node::Kind::Subscript:

  case Node::Kind::Function:

  case Node::Kind::ExplicitClosure:

  case Node::Kind::ImplicitClosure:

  case Node::Kind::Allocator:

  case Node::Kind::Constructor:

  case Node::Kind::Destructor:

  case Node::Kind::Deallocator:

  case Node::Kind::IVarDestroyer: {

    // We expect to see a function type here, but if we don't, use the colon.

    type = type->getChild(0);

    while (type->getKind() == Node::Kind::DependentGenericType)

      type = type->getChild(1)->getChild(0);

    return (type->getKind() != Node::Kind::FunctionType &&

            type->getKind() != Node::Kind::UncurriedFunctionType &&

            type->getKind() != Node::Kind::CFunctionPointer &&

            type->getKind() != Node::Kind::ThinFunctionType);

  }



  default:

    printer_unreachable(""not an entity"");

  }

}

","static bool useColonForEntityType(NodePointer entity, NodePointer type) {

  switch (entity->getKind()) {

  case Node::Kind::Variable:

  case Node::Kind::Initializer:

  case Node::Kind::DefaultArgumentInitializer:

  case Node::Kind::IVarInitializer:

  case Node::Kind::Class:

  case Node::Kind::Structure:

  case Node::Kind::Enum:

  case Node::Kind::Protocol:

  case Node::Kind::TypeAlias:

  case Node::Kind::OwningAddressor:

  case Node::Kind::OwningMutableAddressor:

  case Node::Kind::NativeOwningAddressor:

  case Node::Kind::NativeOwningMutableAddressor:

  case Node::Kind::NativePinningAddressor:

  case Node::Kind::NativePinningMutableAddressor:

  case Node::Kind::UnsafeAddressor:

  case Node::Kind::UnsafeMutableAddressor:

  case Node::Kind::GlobalGetter:

  case Node::Kind::Getter:

  case Node::Kind::Setter:

  case Node::Kind::MaterializeForSet:

  case Node::Kind::WillSet:

  case Node::Kind::DidSet:

    return true;



  case Node::Kind::Subscript:

  case Node::Kind::Function:

  case Node::Kind::ExplicitClosure:

  case Node::Kind::ImplicitClosure:

  case Node::Kind::Allocator:

  case Node::Kind::Constructor:

  case Node::Kind::Destructor:

  case Node::Kind::Deallocator:

  case Node::Kind::IVarDestroyer: {

    // We expect to see a function type here, but if we don't, use the colon.

    type = type->getChild(0);

    while (type->getKind() == Node::Kind::DependentGenericType)

      type = type->getChild(1)->getChild(0);

    return (type->getKind() != Node::Kind::FunctionType &&

            type->getKind() != Node::Kind::UncurriedFunctionType &&

            type->getKind() != Node::Kind::CFunctionPointer &&

            type->getKind() != Node::Kind::ThinFunctionType);

  }



  default:

   ","
  }

}

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",lib/Demangling/OldDemangler.cpp,-,"snprintf(buffer, sizeof(buffer), ""%llu"", n);","    FindPtr(Node *v) : Target(v) {}

",,"

"
"Merge pull request #8006 from eeckstein/demangle-lib

demangler: put the demangler into a separate library",tools/swift-demangle/swift-demangle.cpp,-,swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    llvm::outs() << getNodeTreeAsString(pointer);

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;
","    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    llvm::outs() << getNodeTreeAsString(pointer);

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, child, depth + 1);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }
","  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::dump() const { print(llvm::errs()); },"static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

","
    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,void NodeDumper::print(llvm::raw_ostream &Out) const {,"static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {
","    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(Out, Root, 0);","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(llvm::raw_ostream &Out, const Node *node,

                      unsigned depth) {

  // Indent two spaces per depth.

  Out.indent(depth * 2);

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {
","    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Basic/DemangleWrappers.cpp,-,"printNode(out, TheNode, 4);","  PrettyStackTraceNode(const char *action, Node *node)

    : Action(action), TheNode(node) {}

","  PrettyStackTraceNode(const char *action, Node *node)
","    : Action(action), TheNode(node) {}


"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodeDumper.cpp,+,"static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}
","
  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodeDumper.cpp,+,"printNode(Out, child, depth + 1);","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

    printNode(Out, child, depth + 1);

  }

}

","static void printNode(DemanglerPrinter &Out, const Node *node, unsigned depth) {

  // Indent two spaces per depth.

  for (unsigned i = 0; i < depth * 2; ++i) {

    Out << ' ';

  }

  if (!node) {

    Out << ""<<NULL>>"";

    return;

  }

  Out << ""kind="" << getNodeKindString(node->getKind());

  if (node->hasText()) {

    Out << "", text=\"""" << node->getText() << '\""';

  }

  if (node->hasIndex()) {

    Out << "", index="" << node->getIndex();

  }

  Out << '\n';

  for (auto &child : *node) {

   ","
  }

}

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad directness"");","static StringRef toString(Directness d) {

  switch (d) {

  case Directness::Direct:

    return ""direct"";

  case Directness::Indirect:

    return ""indirect"";

  }

  printer_unreachable(""bad directness"");

}

","static StringRef toString(Directness d) {

  switch (d) {

  case Directness::Direct:

    return ""direct"";

  case Directness::Indirect:

    return ""indirect"";

  }

 ","
}

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,NodePrinter(DemangleOptions options) : Options(options) {},"  NodePrinter(DemangleOptions options) : Options(options) {}

", ,"
"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,std::string printRoot(NodePointer root) {,"  std::string printRoot(NodePointer root) {

    print(root);

    return std::move(Printer).str();

  }

", ,"
    print(root);

    return std::move(Printer).str();

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(root);,"  std::string printRoot(NodePointer root) {

    print(root);

    return std::move(Printer).str();

  }

","  std::string printRoot(NodePointer root) {

   ","
    return std::move(Printer).str();

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"void printChildren(Node::iterator begin,","  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

", ,"
                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(*begin);,"  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

      print(*begin);

      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

","  void printChildren(Node::iterator begin,

                     Node::iterator end,

                     const char *sep = nullptr) {

    for (; begin != end;) {

     ","
      ++begin;

      if (sep && begin != end)

        Printer << sep;

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printBoundGenericNoSugar(NodePointer pointer) {,"  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

", ,"
    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(pointer->getChild(0));,"  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

   ","
    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printChildren(typelist, "", "");","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

    printChildren(typelist, "", "");

    Printer << "">"";

  }

","  void printBoundGenericNoSugar(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    NodePointer typelist = pointer->getChild(1);

    print(pointer->getChild(0));

    Printer << ""<"";

   ","
    Printer << "">"";

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,static bool isDebuggerGeneratedModule(NodePointer node) {,"  static bool isDebuggerGeneratedModule(NodePointer node) {

      return (node->getKind() == Node::Kind::Module &&

              node->getText().startswith(LLDB_EXPRESSIONS_MODULE_NAME_PREFIX));

    }

", ,"
      return (node->getKind() == Node::Kind::Module &&

              node->getText().startswith(LLDB_EXPRESSIONS_MODULE_NAME_PREFIX));

    }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad node kind"");","  bool isSimpleType(NodePointer pointer) {

    switch (pointer->getKind()) {

    case Node::Kind::AssociatedType:

    case Node::Kind::AssociatedTypeRef:

    case Node::Kind::BoundGenericClass:

    case Node::Kind::BoundGenericEnum:

    case Node::Kind::BoundGenericStructure:

    case Node::Kind::BuiltinTypeName:

    case Node::Kind::Class:

    case Node::Kind::DependentGenericType:

    case Node::Kind::DependentMemberType:

    case Node::Kind::DependentGenericParamType:

    case Node::Kind::DynamicSelf:

    case Node::Kind::Enum:

    case Node::Kind::ErrorType:

    case Node::Kind::ExistentialMetatype:

    case Node::Kind::Metatype:

    case Node::Kind::MetatypeRepresentation:

    case Node::Kind::Module:

    case Node::Kind::NonVariadicTuple:

    case Node::Kind::Protocol:

    case Node::Kind::QualifiedArchetype:

    case Node::Kind::ReturnType:

    case Node::Kind::SILBoxType:

    case Node::Kind::SILBoxTypeWithLayout:

    case Node::Kind::Structure:

    case Node::Kind::TupleElementName:

    case Node::Kind::Type:

    case Node::Kind::TypeAlias:

    case Node::Kind::TypeList:

    case Node::Kind::VariadicTuple:

      return true;



    case Node::Kind::ProtocolList:

      if (pointer->getChild(0)->getNumChildren() <= 1)

        return true;

      return false;



    case Node::Kind::Allocator:

    case Node::Kind::ArgumentTuple:

    case Node::Kind::AssociatedTypeMetadataAccessor:

    case Node::Kind::AssociatedTypeWitnessTableAccessor:

    case Node::Kind::AutoClosureType:

    case Node::Kind::CFunctionPointer:

    case Node::Kind::Constructor:

    case Node::Kind::CurryThunk:

    case Node::Kind::Deallocator:

    case Node::Kind::DeclContext:

    case Node::Kind::DefaultArgumentInitializer:

    case Node::Kind::DependentAssociatedTypeRef:

    case Node::Kind::DependentGenericSignature:

    case Node::Kind::DependentGenericParamCount:

    case Node::Kind::DependentGenericConformanceRequirement:

    case Node::Kind::DependentGenericLayoutRequirement:

    case Node::Kind::DependentGenericSameTypeRequirement:

    case Node::Kind::DependentPseudogenericSignature:

    case Node::Kind::Destructor:

    case Node::Kind::DidSet:

    case Node::Kind::DirectMethodReferenceAttribute:

    case Node::Kind::Directness:

    case Node::Kind::DynamicAttribute:

    case Node::Kind::ExplicitClosure:

    case Node::Kind::Extension:

    case Node::Kind::FieldOffset:

    case Node::Kind::FullTypeMetadata:

    case Node::Kind::Function:

    case Node::Kind::FunctionSignatureSpecialization:

    case Node::Kind::FunctionSignatureSpecializationParam:

    case Node::Kind::FunctionSignatureSpecializationParamKind:

    case Node::Kind::FunctionSignatureSpecializationParamPayload:

    case Node::Kind::FunctionType:

    case Node::Kind::GenericProtocolWitnessTable:

    case Node::Kind::GenericProtocolWitnessTableInstantiationFunction:

    case Node::Kind::GenericPartialSpecialization:

    case Node::Kind::GenericPartialSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecialization:

    case Node::Kind::GenericSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecializationParam:

    case Node::Kind::GenericTypeMetadataPattern:

    case Node::Kind::Getter:

    case Node::Kind::Global:

    case Node::Kind::GlobalGetter:

    case Node::Kind::Identifier:

    case Node::Kind::Index:

    case Node::Kind::IVarInitializer:

    case Node::Kind::IVarDestroyer:

    case Node::Kind::ImplConvention:

    case Node::Kind::ImplFunctionAttribute:

    case Node::Kind::ImplFunctionType:

    case Node::Kind::ImplicitClosure:

    case Node::Kind::ImplParameter:

    case Node::Kind::ImplResult:

    case Node::Kind::ImplErrorResult:

    case Node::Kind::InOut:

    case Node::Kind::InfixOperator:

    case Node::Kind::Initializer:

    case Node::Kind::LazyProtocolWitnessTableAccessor:

    case Node::Kind::LazyProtocolWitnessTableCacheVariable:

    case Node::Kind::LocalDeclName:

    case Node::Kind::PrivateDeclName:

    case Node::Kind::MaterializeForSet:

    case Node::Kind::Metaclass:

    case Node::Kind::NativeOwningAddressor:

    case Node::Kind::NativeOwningMutableAddressor:

    case Node::Kind::NativePinningAddressor:

    case Node::Kind::NativePinningMutableAddressor:

    case Node::Kind::NominalTypeDescriptor:

    case Node::Kind::NonObjCAttribute:

    case Node::Kind::Number:

    case Node::Kind::ObjCAttribute:

    case Node::Kind::ObjCBlock:

    case Node::Kind::OwningAddressor:

    case Node::Kind::OwningMutableAddressor:

    case Node::Kind::PartialApplyForwarder:

    case Node::Kind::PartialApplyObjCForwarder:

    case Node::Kind::PostfixOperator:

    case Node::Kind::PrefixOperator:

    case Node::Kind::ProtocolConformance:

    case Node::Kind::ProtocolDescriptor:

    case Node::Kind::ProtocolWitness:

    case Node::Kind::ProtocolWitnessTable:

    case Node::Kind::ProtocolWitnessTableAccessor:

    case Node::Kind::ReabstractionThunk:

    case Node::Kind::ReabstractionThunkHelper:

    case Node::Kind::Setter:

    case Node::Kind::SILBoxLayout:

    case Node::Kind::SILBoxMutableField:

    case Node::Kind::SILBoxImmutableField:

    case Node::Kind::SpecializationIsFragile:

    case Node::Kind::SpecializationPassID:

    case Node::Kind::Static:

    case Node::Kind::Subscript:

    case Node::Kind::Suffix:

    case Node::Kind::ThinFunctionType:

    case Node::Kind::TupleElement:

    case Node::Kind::TypeMangling:

    case Node::Kind::TypeMetadata:

    case Node::Kind::TypeMetadataAccessFunction:

    case Node::Kind::TypeMetadataLazyCache:

    case Node::Kind::UncurriedFunctionType:

    case Node::Kind::Unmanaged:

    case Node::Kind::Unowned:

    case Node::Kind::UnsafeAddressor:

    case Node::Kind::UnsafeMutableAddressor:

    case Node::Kind::ValueWitness:

    case Node::Kind::ValueWitnessTable:

    case Node::Kind::Variable:

    case Node::Kind::VTableAttribute:

    case Node::Kind::Weak:

    case Node::Kind::WillSet:

    case Node::Kind::WitnessTableOffset:

    case Node::Kind::ReflectionMetadataBuiltinDescriptor:

    case Node::Kind::ReflectionMetadataFieldDescriptor:

    case Node::Kind::ReflectionMetadataAssocTypeDescriptor:

    case Node::Kind::ReflectionMetadataSuperclassDescriptor:

    case Node::Kind::GenericTypeParamDecl:

    case Node::Kind::ThrowsAnnotation:

    case Node::Kind::EmptyList:

    case Node::Kind::FirstElementMarker:

    case Node::Kind::VariadicMarker:

    case Node::Kind::OutlinedCopy:

    case Node::Kind::OutlinedConsume:

      return false;

    }

    printer_unreachable(""bad node kind"");

  }

","  bool isSimpleType(NodePointer pointer) {

    switch (pointer->getKind()) {

    case Node::Kind::AssociatedType:

    case Node::Kind::AssociatedTypeRef:

    case Node::Kind::BoundGenericClass:

    case Node::Kind::BoundGenericEnum:

    case Node::Kind::BoundGenericStructure:

    case Node::Kind::BuiltinTypeName:

    case Node::Kind::Class:

    case Node::Kind::DependentGenericType:

    case Node::Kind::DependentMemberType:

    case Node::Kind::DependentGenericParamType:

    case Node::Kind::DynamicSelf:

    case Node::Kind::Enum:

    case Node::Kind::ErrorType:

    case Node::Kind::ExistentialMetatype:

    case Node::Kind::Metatype:

    case Node::Kind::MetatypeRepresentation:

    case Node::Kind::Module:

    case Node::Kind::NonVariadicTuple:

    case Node::Kind::Protocol:

    case Node::Kind::QualifiedArchetype:

    case Node::Kind::ReturnType:

    case Node::Kind::SILBoxType:

    case Node::Kind::SILBoxTypeWithLayout:

    case Node::Kind::Structure:

    case Node::Kind::TupleElementName:

    case Node::Kind::Type:

    case Node::Kind::TypeAlias:

    case Node::Kind::TypeList:

    case Node::Kind::VariadicTuple:

      return true;



    case Node::Kind::ProtocolList:

      if (pointer->getChild(0)->getNumChildren() <= 1)

        return true;

      return false;



    case Node::Kind::Allocator:

    case Node::Kind::ArgumentTuple:

    case Node::Kind::AssociatedTypeMetadataAccessor:

    case Node::Kind::AssociatedTypeWitnessTableAccessor:

    case Node::Kind::AutoClosureType:

    case Node::Kind::CFunctionPointer:

    case Node::Kind::Constructor:

    case Node::Kind::CurryThunk:

    case Node::Kind::Deallocator:

    case Node::Kind::DeclContext:

    case Node::Kind::DefaultArgumentInitializer:

    case Node::Kind::DependentAssociatedTypeRef:

    case Node::Kind::DependentGenericSignature:

    case Node::Kind::DependentGenericParamCount:

    case Node::Kind::DependentGenericConformanceRequirement:

    case Node::Kind::DependentGenericLayoutRequirement:

    case Node::Kind::DependentGenericSameTypeRequirement:

    case Node::Kind::DependentPseudogenericSignature:

    case Node::Kind::Destructor:

    case Node::Kind::DidSet:

    case Node::Kind::DirectMethodReferenceAttribute:

    case Node::Kind::Directness:

    case Node::Kind::DynamicAttribute:

    case Node::Kind::ExplicitClosure:

    case Node::Kind::Extension:

    case Node::Kind::FieldOffset:

    case Node::Kind::FullTypeMetadata:

    case Node::Kind::Function:

    case Node::Kind::FunctionSignatureSpecialization:

    case Node::Kind::FunctionSignatureSpecializationParam:

    case Node::Kind::FunctionSignatureSpecializationParamKind:

    case Node::Kind::FunctionSignatureSpecializationParamPayload:

    case Node::Kind::FunctionType:

    case Node::Kind::GenericProtocolWitnessTable:

    case Node::Kind::GenericProtocolWitnessTableInstantiationFunction:

    case Node::Kind::GenericPartialSpecialization:

    case Node::Kind::GenericPartialSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecialization:

    case Node::Kind::GenericSpecializationNotReAbstracted:

    case Node::Kind::GenericSpecializationParam:

    case Node::Kind::GenericTypeMetadataPattern:

    case Node::Kind::Getter:

    case Node::Kind::Global:

    case Node::Kind::GlobalGetter:

    case Node::Kind::Identifier:

    case Node::Kind::Index:

    case Node::Kind::IVarInitializer:

    case Node::Kind::IVarDestroyer:

    case Node::Kind::ImplConvention:

    case Node::Kind::ImplFunctionAttribute:

    case Node::Kind::ImplFunctionType:

    case Node::Kind::ImplicitClosure:

    case Node::Kind::ImplParameter:

    case Node::Kind::ImplResult:

    case Node::Kind::ImplErrorResult:

    case Node::Kind::InOut:

    case Node::Kind::InfixOperator:

    case Node::Kind::Initializer:

    case Node::Kind::LazyProtocolWitnessTableAccessor:

    case Node::Kind::LazyProtocolWitnessTableCacheVariable:

    case Node::Kind::LocalDeclName:

    case Node::Kind::PrivateDeclName:

    case Node::Kind::MaterializeForSet:

    case Node::Kind::Metaclass:

    case Node::Kind::NativeOwningAddressor:

    case Node::Kind::NativeOwningMutableAddressor:

    case Node::Kind::NativePinningAddressor:

    case Node::Kind::NativePinningMutableAddressor:

    case Node::Kind::NominalTypeDescriptor:

    case Node::Kind::NonObjCAttribute:

    case Node::Kind::Number:

    case Node::Kind::ObjCAttribute:

    case Node::Kind::ObjCBlock:

    case Node::Kind::OwningAddressor:

    case Node::Kind::OwningMutableAddressor:

    case Node::Kind::PartialApplyForwarder:

    case Node::Kind::PartialApplyObjCForwarder:

    case Node::Kind::PostfixOperator:

    case Node::Kind::PrefixOperator:

    case Node::Kind::ProtocolConformance:

    case Node::Kind::ProtocolDescriptor:

    case Node::Kind::ProtocolWitness:

    case Node::Kind::ProtocolWitnessTable:

    case Node::Kind::ProtocolWitnessTableAccessor:

    case Node::Kind::ReabstractionThunk:

    case Node::Kind::ReabstractionThunkHelper:

    case Node::Kind::Setter:

    case Node::Kind::SILBoxLayout:

    case Node::Kind::SILBoxMutableField:

    case Node::Kind::SILBoxImmutableField:

    case Node::Kind::SpecializationIsFragile:

    case Node::Kind::SpecializationPassID:

    case Node::Kind::Static:

    case Node::Kind::Subscript:

    case Node::Kind::Suffix:

    case Node::Kind::ThinFunctionType:

    case Node::Kind::TupleElement:

    case Node::Kind::TypeMangling:

    case Node::Kind::TypeMetadata:

    case Node::Kind::TypeMetadataAccessFunction:

    case Node::Kind::TypeMetadataLazyCache:

    case Node::Kind::UncurriedFunctionType:

    case Node::Kind::Unmanaged:

    case Node::Kind::Unowned:

    case Node::Kind::UnsafeAddressor:

    case Node::Kind::UnsafeMutableAddressor:

    case Node::Kind::ValueWitness:

    case Node::Kind::ValueWitnessTable:

    case Node::Kind::Variable:

    case Node::Kind::VTableAttribute:

    case Node::Kind::Weak:

    case Node::Kind::WillSet:

    case Node::Kind::WitnessTableOffset:

    case Node::Kind::ReflectionMetadataBuiltinDescriptor:

    case Node::Kind::ReflectionMetadataFieldDescriptor:

    case Node::Kind::ReflectionMetadataAssocTypeDescriptor:

    case Node::Kind::ReflectionMetadataSuperclassDescriptor:

    case Node::Kind::GenericTypeParamDecl:

    case Node::Kind::ThrowsAnnotation:

    case Node::Kind::EmptyList:

    case Node::Kind::FirstElementMarker:

    case Node::Kind::VariadicMarker:

    case Node::Kind::OutlinedCopy:

    case Node::Kind::OutlinedConsume:

      return false;

    }

   ","
  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(pointer->getKind() == Node::Kind::BoundGenericStructure);,"  SugarType findSugar(NodePointer pointer) {

    if (pointer->getNumChildren() == 1 && 

        pointer->getKind() == Node::Kind::Type)

      return findSugar(pointer->getChild(0));

    

    if (pointer->getNumChildren() != 2)

      return SugarType::None;

    

    if (pointer->getKind() != Node::Kind::BoundGenericEnum &&

        pointer->getKind() != Node::Kind::BoundGenericStructure)

      return SugarType::None;



    auto unboundType = pointer->getChild(0)->getChild(0); // drill through Type

    auto typeArgs = pointer->getChild(1);

    

    if (pointer->getKind() == Node::Kind::BoundGenericEnum) {

      // Swift.Optional

      if (isIdentifier(unboundType->getChild(1), ""Optional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::Optional;

      }



      // Swift.ImplicitlyUnwrappedOptional

      if (isIdentifier(unboundType->getChild(1), 

                       ""ImplicitlyUnwrappedOptional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::ImplicitlyUnwrappedOptional;

      }



      return SugarType::None;

    }



    assert(pointer->getKind() == Node::Kind::BoundGenericStructure);



    // Array

    if (isIdentifier(unboundType->getChild(1), ""Array"") &&

        typeArgs->getNumChildren() == 1 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Array;

    }



    // Dictionary

    if (isIdentifier(unboundType->getChild(1), ""Dictionary"") &&

        typeArgs->getNumChildren() == 2 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Dictionary;

    }



    return SugarType::None;

  }

","  SugarType findSugar(NodePointer pointer) {

    if (pointer->getNumChildren() == 1 && 

        pointer->getKind() == Node::Kind::Type)

      return findSugar(pointer->getChild(0));

    

    if (pointer->getNumChildren() != 2)

      return SugarType::None;

    

    if (pointer->getKind() != Node::Kind::BoundGenericEnum &&

        pointer->getKind() != Node::Kind::BoundGenericStructure)

      return SugarType::None;



    auto unboundType = pointer->getChild(0)->getChild(0); // drill through Type

    auto typeArgs = pointer->getChild(1);

    

    if (pointer->getKind() == Node::Kind::BoundGenericEnum) {

      // Swift.Optional

      if (isIdentifier(unboundType->getChild(1), ""Optional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::Optional;

      }



      // Swift.ImplicitlyUnwrappedOptional

      if (isIdentifier(unboundType->getChild(1), 

                       ""ImplicitlyUnwrappedOptional"") &&

          typeArgs->getNumChildren() == 1 &&

          isSwiftModule(unboundType->getChild(0))) {

        return SugarType::ImplicitlyUnwrappedOptional;

      }



      return SugarType::None;

    }



   ","


    // Array

    if (isIdentifier(unboundType->getChild(1), ""Array"") &&

        typeArgs->getNumChildren() == 1 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Array;

    }



    // Dictionary

    if (isIdentifier(unboundType->getChild(1), ""Dictionary"") &&

        typeArgs->getNumChildren() == 2 &&

        isSwiftModule(unboundType->getChild(0))) {

      return SugarType::Dictionary;

    }



    return SugarType::None;

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printBoundGeneric(NodePointer pointer) {,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

", ,"
    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,printBoundGenericNoSugar(pointer);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

     ","
      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

       ","
        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(type);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

       ","
        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(keyType);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

       ","
        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(valueType);,"  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

        print(valueType);

        Printer << ""]"";

        break;

      }

    }

  }

","  void printBoundGeneric(NodePointer pointer) {

    if (pointer->getNumChildren() < 2)

      return;

    if (pointer->getNumChildren() != 2) {

      printBoundGenericNoSugar(pointer);

      return;

    }



    if (!Options.SynthesizeSugarOnTypes ||

        pointer->getKind() == Node::Kind::BoundGenericClass)

    {

      // no sugar here

      printBoundGenericNoSugar(pointer);

      return;

    }



    SugarType sugarType = findSugar(pointer);

    

    switch (sugarType) {

      case SugarType::None:

        printBoundGenericNoSugar(pointer);

        break;

      case SugarType::Optional:

      case SugarType::ImplicitlyUnwrappedOptional: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        bool needs_parens = !isSimpleType(type);

        if (needs_parens)

          Printer << ""("";

        print(type);

        if (needs_parens)

          Printer << "")"";

        Printer << (sugarType == SugarType::Optional ? ""?"" : ""!"");

        break;

      }

      case SugarType::Array: {

        NodePointer type = pointer->getChild(1)->getChild(0);

        Printer << ""["";

        print(type);

        Printer << ""]"";

        break;

      }

      case SugarType::Dictionary: {

        NodePointer keyType = pointer->getChild(1)->getChild(0);

        NodePointer valueType = pointer->getChild(1)->getChild(1);

        Printer << ""["";

        print(keyType);

        Printer << "" : "";

       ","
        Printer << ""]"";

        break;

      }

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printFunctionType(NodePointer node) {,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

", ,"
    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

   ","
    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

     ","
      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex));,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

   ","
    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(node->getChild(startIndex+1));,"  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

    print(node->getChild(startIndex+1));

  }

","  void printFunctionType(NodePointer node) {

    assert(node->getNumChildren() == 2 || node->getNumChildren() == 3);

    unsigned startIndex = 0;

    bool throws = false;

    if (node->getNumChildren() == 3) {

      assert(node->getChild(0)->getKind() == Node::Kind::ThrowsAnnotation);

      startIndex++;

      throws = true;

    }

    print(node->getChild(startIndex));

    if (throws) Printer << "" throws"";

   ","
  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printImplFunctionType(NodePointer fn) {,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

", ,"
    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(newState >= curState);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

     ","
      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"case Results: printer_unreachable(""no state after Results"");","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

       ","
        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""bad state"");","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

       ","
      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,assert(curState == Attrs);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

       ","
        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,print(child);,"  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

        print(child);

      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

","  void printImplFunctionType(NodePointer fn) {

    enum State { Attrs, Inputs, Results } curState = Attrs;

    auto transitionTo = [&](State newState) {

      assert(newState >= curState);

      for (; curState != newState; curState = State(curState + 1)) {

        switch (curState) {

        case Attrs: Printer << '('; continue;

        case Inputs: Printer << "") -> (""; continue;

        case Results: printer_unreachable(""no state after Results"");

        }

        printer_unreachable(""bad state"");

      }

    };



    for (auto &child : *fn) {

      if (child->getKind() == Node::Kind::ImplParameter) {

        if (curState == Inputs) Printer << "", "";

        transitionTo(Inputs);

       ","
      } else if (child->getKind() == Node::Kind::ImplResult

                 || child->getKind() == Node::Kind::ImplErrorResult) {

        if (curState == Results) Printer << "", "";

        transitionTo(Results);

        print(child);

      } else {

        assert(curState == Attrs);

        print(child);

        Printer << ' ';

      }

    }

    transitionTo(Results);

    Printer << ')';

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,void printContext(NodePointer context) {,"  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

", ,"
    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,!isDebuggerGeneratedModule(context)),"  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

      ","
    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"print(context, /*asContext*/ true);","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

      print(context, /*asContext*/ true);

      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

","  void printContext(NodePointer context) {

    // TODO: parenthesize local contexts?

    if (Options.DisplayDebuggerGeneratedModule ||

       !isDebuggerGeneratedModule(context))

    {

     ","
      if (context->getKind() == Node::Kind::Module && !Options.DisplayModuleNames)

          return;

      Printer << '.';

    }

  }

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/NodePrinter.cpp,+,"printer_unreachable(""not an entity"");","static bool useColonForEntityType(NodePointer entity, NodePointer type) {

  switch (entity->getKind()) {

  case Node::Kind::Variable:

  case Node::Kind::Initializer:

  case Node::Kind::DefaultArgumentInitializer:

  case Node::Kind::IVarInitializer:

  case Node::Kind::Class:

  case Node::Kind::Structure:

  case Node::Kind::Enum:

  case Node::Kind::Protocol:

  case Node::Kind::TypeAlias:

  case Node::Kind::OwningAddressor:

  case Node::Kind::OwningMutableAddressor:

  case Node::Kind::NativeOwningAddressor:

  case Node::Kind::NativeOwningMutableAddressor:

  case Node::Kind::NativePinningAddressor:

  case Node::Kind::NativePinningMutableAddressor:

  case Node::Kind::UnsafeAddressor:

  case Node::Kind::UnsafeMutableAddressor:

  case Node::Kind::GlobalGetter:

  case Node::Kind::Getter:

  case Node::Kind::Setter:

  case Node::Kind::MaterializeForSet:

  case Node::Kind::WillSet:

  case Node::Kind::DidSet:

    return true;



  case Node::Kind::Subscript:

  case Node::Kind::Function:

  case Node::Kind::ExplicitClosure:

  case Node::Kind::ImplicitClosure:

  case Node::Kind::Allocator:

  case Node::Kind::Constructor:

  case Node::Kind::Destructor:

  case Node::Kind::Deallocator:

  case Node::Kind::IVarDestroyer: {

    // We expect to see a function type here, but if we don't, use the colon.

    type = type->getChild(0);

    while (type->getKind() == Node::Kind::DependentGenericType)

      type = type->getChild(1)->getChild(0);

    return (type->getKind() != Node::Kind::FunctionType &&

            type->getKind() != Node::Kind::UncurriedFunctionType &&

            type->getKind() != Node::Kind::CFunctionPointer &&

            type->getKind() != Node::Kind::ThinFunctionType);

  }



  default:

    printer_unreachable(""not an entity"");

  }

}

","static bool useColonForEntityType(NodePointer entity, NodePointer type) {

  switch (entity->getKind()) {

  case Node::Kind::Variable:

  case Node::Kind::Initializer:

  case Node::Kind::DefaultArgumentInitializer:

  case Node::Kind::IVarInitializer:

  case Node::Kind::Class:

  case Node::Kind::Structure:

  case Node::Kind::Enum:

  case Node::Kind::Protocol:

  case Node::Kind::TypeAlias:

  case Node::Kind::OwningAddressor:

  case Node::Kind::OwningMutableAddressor:

  case Node::Kind::NativeOwningAddressor:

  case Node::Kind::NativeOwningMutableAddressor:

  case Node::Kind::NativePinningAddressor:

  case Node::Kind::NativePinningMutableAddressor:

  case Node::Kind::UnsafeAddressor:

  case Node::Kind::UnsafeMutableAddressor:

  case Node::Kind::GlobalGetter:

  case Node::Kind::Getter:

  case Node::Kind::Setter:

  case Node::Kind::MaterializeForSet:

  case Node::Kind::WillSet:

  case Node::Kind::DidSet:

    return true;



  case Node::Kind::Subscript:

  case Node::Kind::Function:

  case Node::Kind::ExplicitClosure:

  case Node::Kind::ImplicitClosure:

  case Node::Kind::Allocator:

  case Node::Kind::Constructor:

  case Node::Kind::Destructor:

  case Node::Kind::Deallocator:

  case Node::Kind::IVarDestroyer: {

    // We expect to see a function type here, but if we don't, use the colon.

    type = type->getChild(0);

    while (type->getKind() == Node::Kind::DependentGenericType)

      type = type->getChild(1)->getChild(0);

    return (type->getKind() != Node::Kind::FunctionType &&

            type->getKind() != Node::Kind::UncurriedFunctionType &&

            type->getKind() != Node::Kind::CFunctionPointer &&

            type->getKind() != Node::Kind::ThinFunctionType);

  }



  default:

   ","
  }

}

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",lib/Demangling/OldDemangler.cpp,-,"snprintf(buffer, sizeof(buffer), ""%llu"", n);","    FindPtr(Node *v) : Target(v) {}

",,"

"
"demangler: put the demangler into a separate library

Previously it was part of swiftBasic.

The demangler library does not depend on llvm (except some header-only utilities like StringRef). Putting it into its own library makes sure that no llvm stuff will be linked into clients which use the demangler library.

This change also contains other refactoring, like moving demangler code into different files. This makes it easier to remove the old demangler from the runtime library when we switch to the new symbol mangling.

Also in this commit: remove some unused API functions from the demangler Context.

fixes rdar://problem/30503344",tools/swift-demangle/swift-demangle.cpp,-,swift::demangle_wrappers::NodeDumper(pointer).print(llvm::outs());,"static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;

    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    llvm::outs() << getNodeTreeAsString(pointer);

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}

","static void demangle(llvm::raw_ostream &os, llvm::StringRef name,

                     swift::Demangle::Context &DCtx,

                     const swift::Demangle::DemangleOptions &options) {

  bool hadLeadingUnderscore = false;

  if (name.startswith(""__"")) {

    hadLeadingUnderscore = true;
","    name = name.substr(1);

  }

  swift::Demangle::NodePointer pointer = DCtx.demangleSymbolAsNode(name);

  if (ExpandMode || TreeOnly) {

    llvm::outs() << ""Demangling for "" << name << '\n';

    llvm::outs() << getNodeTreeAsString(pointer);

  }

  if (RemangleMode) {

    std::string remangled;

    if (!pointer) {

      // Just reprint the original mangled name if it didn't demangle.

      // This makes it easier to share the same database between the

      // mangling and demangling tests.

      remangled = name;

    } else {

      // Also accept the future mangling prefix.

      // TODO: remove the ""_S"" as soon as MANGLING_PREFIX_STR gets ""_S"".

      remangled = swift::Demangle::mangleNode(pointer,

                          /*NewMangling*/ name.startswith(MANGLING_PREFIX_STR)

                                          || name.startswith(""_S""));

      if (name.startswith(""_S"")) {

        assert(remangled.find(MANGLING_PREFIX_STR) == 0);

        remangled = ""_S"" + remangled.substr(3);

      }

      if (name != remangled) {

        llvm::errs() << ""\nError: re-mangled name \n  "" << remangled

                     << ""\ndoes not match original name\n  "" << name << '\n';

        exit(1);

      }

    }

    if (hadLeadingUnderscore) llvm::outs() << '_';

    llvm::outs() << remangled;

    return;

  }

  if (!TreeOnly) {

    if (RemangleNew) {

      if (!pointer) {

        llvm::errs() << ""Can't de-mangle "" << name << '\n';

        exit(1);

      }

      std::string remangled = swift::Demangle::mangleNode(pointer);

      llvm::outs() << remangled;

      return;

    }

    std::string string = swift::Demangle::nodeToString(pointer, options);

    if (!CompactMode)

      llvm::outs() << name << "" ---> "";



    if (Classify) {

      std::string Classifications;

      std::string cName = name.str();

      if (!swift::Demangle::isSwiftSymbol(cName.c_str()))

        Classifications += 'N';

      if (DCtx.isThunkSymbol(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += ""T:"";

        Classifications += DCtx.getThunkTarget(name);

      } else {

        assert(DCtx.getThunkTarget(name).empty());

      }

      if (pointer && !DCtx.hasSwiftCallingConvention(name)) {

        if (!Classifications.empty())

          Classifications += ',';

        Classifications += 'C';

      }

      if (!Classifications.empty())

        llvm::outs() << '{' << Classifications << ""} "";

    }

    llvm::outs() << (string.empty() ? name : llvm::StringRef(string));

  }

  DCtx.clear();

}


"
"Merge pull request #7976 from slavapestov/kill-gather-all-substitutions

Kill TypeBase::gatherAllSubstitutions()",lib/SILGen/SILGenDynamicCast.cpp,-,assert(fnGenericParams.size() == fromSubsts.size() + toSubsts.size() &&,"static ManagedValue

adjustForConditionalCheckedCastOperand(SILLocation loc, ManagedValue src,

                                       CanType sourceType, CanType targetType,

                                       SILGenFunction &SGF) {

  // Reabstract to the most general abstraction, and put it into a

  // temporary if necessary.

  

  // Figure out if we need the value to be in a temporary.

  bool requiresAddress =

    !canUseScalarCheckedCastInstructions(SGF.SGM.M, sourceType, targetType);

  

  AbstractionPattern abstraction = SGF.SGM.M.Types.getMostGeneralAbstraction();

  auto &srcAbstractTL = SGF.getTypeLowering(abstraction, sourceType);

  

  bool hasAbstraction = (src.getType() != srcAbstractTL.getLoweredType());

  

  // Fast path: no re-abstraction required.

  if (!hasAbstraction &&

      (!requiresAddress ||

       (src.getType().isAddress() || !SGF.silConv.useLoweredAddresses()))) {

    return src;

  }

  

  std::unique_ptr<TemporaryInitialization> init;

  if (requiresAddress) {

    init = SGF.emitTemporary(loc, srcAbstractTL);



    if (hasAbstraction)

      src = SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);



    // Okay, if all we need to do is drop the value in an address,

    // this is easy.

    SGF.B.emitStoreValueOperation(loc, src.forward(SGF), init->getAddress(),

                                  StoreOwnershipQualifier::Init);

    init->finishInitialization(SGF);

    return init->getManagedAddress();

  }

  

  assert(hasAbstraction);

  assert(src.getType().isObject() &&

         ""address-only type with abstraction difference?"");

  

  // Produce the value at +1.

  return SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);

}

","static ManagedValue

adjustForConditionalCheckedCastOperand(SILLocation loc, ManagedValue src,

                                       CanType sourceType, CanType targetType,

                                       SILGenFunction &SGF) {

  // Reabstract to the most general abstraction, and put it into a

  // temporary if necessary.
","  

  // Figure out if we need the value to be in a temporary.

  bool requiresAddress =

    !canUseScalarCheckedCastInstructions(SGF.SGM.M, sourceType, targetType);

  

  AbstractionPattern abstraction = SGF.SGM.M.Types.getMostGeneralAbstraction();

  auto &srcAbstractTL = SGF.getTypeLowering(abstraction, sourceType);

  

  bool hasAbstraction = (src.getType() != srcAbstractTL.getLoweredType());

  

  // Fast path: no re-abstraction required.

  if (!hasAbstraction &&

      (!requiresAddress ||

       (src.getType().isAddress() || !SGF.silConv.useLoweredAddresses()))) {

    return src;

  }

  

  std::unique_ptr<TemporaryInitialization> init;

  if (requiresAddress) {

    init = SGF.emitTemporary(loc, srcAbstractTL);



    if (hasAbstraction)

      src = SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);



    // Okay, if all we need to do is drop the value in an address,

    // this is easy.

    SGF.B.emitStoreValueOperation(loc, src.forward(SGF), init->getAddress(),

                                  StoreOwnershipQualifier::Init);

    init->finishInitialization(SGF);

    return init->getManagedAddress();

  }

  

  assert(hasAbstraction);

  assert(src.getType().isObject() &&

         ""address-only type with abstraction difference?"");

  

  // Produce the value at +1.

  return SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);

}


"
"SILGen: Clean up ad-hoc SubstitutionList construction when calling intrinsics

Change emitApplyOfLibraryIntrinsic() to take a SubstitutionMap,
and use the correct abstractions to build the map.

This gets rid of the last remaining uses of gatherAllSubstitutions()
in SIL.",lib/SILGen/SILGenDynamicCast.cpp,-,assert(fnGenericParams.size() == fromSubsts.size() + toSubsts.size() &&,"static ManagedValue

adjustForConditionalCheckedCastOperand(SILLocation loc, ManagedValue src,

                                       CanType sourceType, CanType targetType,

                                       SILGenFunction &SGF) {

  // Reabstract to the most general abstraction, and put it into a

  // temporary if necessary.

  

  // Figure out if we need the value to be in a temporary.

  bool requiresAddress =

    !canUseScalarCheckedCastInstructions(SGF.SGM.M, sourceType, targetType);

  

  AbstractionPattern abstraction = SGF.SGM.M.Types.getMostGeneralAbstraction();

  auto &srcAbstractTL = SGF.getTypeLowering(abstraction, sourceType);

  

  bool hasAbstraction = (src.getType() != srcAbstractTL.getLoweredType());

  

  // Fast path: no re-abstraction required.

  if (!hasAbstraction &&

      (!requiresAddress ||

       (src.getType().isAddress() || !SGF.silConv.useLoweredAddresses()))) {

    return src;

  }

  

  std::unique_ptr<TemporaryInitialization> init;

  if (requiresAddress) {

    init = SGF.emitTemporary(loc, srcAbstractTL);



    if (hasAbstraction)

      src = SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);



    // Okay, if all we need to do is drop the value in an address,

    // this is easy.

    SGF.B.emitStoreValueOperation(loc, src.forward(SGF), init->getAddress(),

                                  StoreOwnershipQualifier::Init);

    init->finishInitialization(SGF);

    return init->getManagedAddress();

  }

  

  assert(hasAbstraction);

  assert(src.getType().isObject() &&

         ""address-only type with abstraction difference?"");

  

  // Produce the value at +1.

  return SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);

}

","static ManagedValue

adjustForConditionalCheckedCastOperand(SILLocation loc, ManagedValue src,

                                       CanType sourceType, CanType targetType,

                                       SILGenFunction &SGF) {

  // Reabstract to the most general abstraction, and put it into a

  // temporary if necessary.
","  

  // Figure out if we need the value to be in a temporary.

  bool requiresAddress =

    !canUseScalarCheckedCastInstructions(SGF.SGM.M, sourceType, targetType);

  

  AbstractionPattern abstraction = SGF.SGM.M.Types.getMostGeneralAbstraction();

  auto &srcAbstractTL = SGF.getTypeLowering(abstraction, sourceType);

  

  bool hasAbstraction = (src.getType() != srcAbstractTL.getLoweredType());

  

  // Fast path: no re-abstraction required.

  if (!hasAbstraction &&

      (!requiresAddress ||

       (src.getType().isAddress() || !SGF.silConv.useLoweredAddresses()))) {

    return src;

  }

  

  std::unique_ptr<TemporaryInitialization> init;

  if (requiresAddress) {

    init = SGF.emitTemporary(loc, srcAbstractTL);



    if (hasAbstraction)

      src = SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);



    // Okay, if all we need to do is drop the value in an address,

    // this is easy.

    SGF.B.emitStoreValueOperation(loc, src.forward(SGF), init->getAddress(),

                                  StoreOwnershipQualifier::Init);

    init->finishInitialization(SGF);

    return init->getManagedAddress();

  }

  

  assert(hasAbstraction);

  assert(src.getType().isObject() &&

         ""address-only type with abstraction difference?"");

  

  // Produce the value at +1.

  return SGF.emitSubstToOrigValue(loc, src, abstraction, sourceType);

}


"
"[function-signature-opt] Allow FSO on witness_methods when performing the dead argument signature optimization for partial_apply instructions

This improves performance of some benchmarks, which pass static operators like `Int.<` as closure arguments.

Fixes rdar://23428804",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");","  void run() override {

    auto *F = getFunction();



    // Don't optimize callees that should not be optimized.

    if (!F->shouldOptimize())

      return;



    // This is the function to optimize.

    DEBUG(llvm::dbgs() << ""*** FSO on function: "" << F->getName() << "" ***\n"");



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    // No need for CallerAnalysis if we are not optimizing for partial

    // applies.

    if (!OptForPartialApply &&

        !canSpecializeFunction(F, nullptr, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    CallerAnalysis *CA = PM->getAnalysis<CallerAnalysis>();

    const CallerAnalysis::FunctionInfo &FuncInfo = CA->getCallerInfo(F);



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    if (OptForPartialApply &&

        !canSpecializeFunction(F, &FuncInfo, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    auto *RCIA = getAnalysis<RCIdentityAnalysis>();

    auto *EA = PM->getAnalysis<EpilogueARCAnalysis>();



    // Lock BCA so it's not invalidated along with the rest of the call graph.

    AnalysisPreserver BCAP(PM->getAnalysis<BasicCalleeAnalysis>());



    // As we optimize the function more and more, the name of the function is

    // going to change, make sure the mangler is aware of all the changes done

    // to the function.

    Mangle::Mangler M;

    auto P = Demangle::SpecializationPass::FunctionSignatureOpts;

    FunctionSignatureSpecializationMangler OldFM(P, M, F->isFragile(), F);

    NewMangling::FunctionSignatureSpecializationMangler NewFM(P, F->isFragile(),

                                                              F);



    /// Keep a map between the exploded argument index and the original argument

    /// index.

    llvm::SmallDenseMap<int, int> AIM;

    int asize = F->begin()->getArguments().size();

    for (auto i = 0; i < asize; ++i) {

      AIM[i] = i;

    }



    // Allocate the argument and result descriptors.

    llvm::SmallVector<ArgumentDescriptor, 4> ArgumentDescList;

    llvm::SmallVector<ResultDescriptor, 4> ResultDescList;

    auto Args = F->begin()->getFunctionArguments();

    for (unsigned i = 0, e = Args.size(); i != e; ++i) {

      ArgumentDescList.emplace_back(Args[i]);

    }

    for (SILResultInfo IR : F->getLoweredFunctionType()->getResults()) {

      ResultDescList.emplace_back(IR);

    }



    // Owned to guaranteed optimization.

    FunctionSignatureTransform FST(F, RCIA, EA, OldFM, NewFM, AIM,

                                   ArgumentDescList, ResultDescList);



    bool Changed = false;

    if (OptForPartialApply) {

      Changed = FST.removeDeadArgs(FuncInfo.getMinPartialAppliedArgs());

    } else {

      Changed = FST.run(FuncInfo.hasCaller());

    }

    if (Changed) {

      ++ NumFunctionSignaturesOptimized;

      // The old function must be a thunk now.

      assert(F->isThunk() && ""Old function should have been turned into a thunk"");



      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::Everything);



      // Make sure the PM knows about this function. This will also help us

      // with self-recursion.

      notifyPassManagerOfFunction(FST.getOptimizedFunction(), F);



      if (!OptForPartialApply) {

        // We have to restart the pipeline for this thunk in order to run the

        // inliner (and other opts) again. This is important if the new

        // specialized function (which is called from this thunk) is

        // function-signature-optimized again and also becomes an

        // always-inline-thunk.

        restartPassPipeline();

      }

    }

  }

","  void run() override {

    auto *F = getFunction();



    // Don't optimize callees that should not be optimized.

    if (!F->shouldOptimize())

      return;



    // This is the function to optimize.

    DEBUG(llvm::dbgs() << ""*** FSO on function: "" << F->getName() << "" ***\n"");



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    // No need for CallerAnalysis if we are not optimizing for partial

    // applies.

    if (!OptForPartialApply &&

        !canSpecializeFunction(F, nullptr, OptForPartialApply)) {

     ","
      return;

    }



    CallerAnalysis *CA = PM->getAnalysis<CallerAnalysis>();

    const CallerAnalysis::FunctionInfo &FuncInfo = CA->getCallerInfo(F);



    // Check the signature of F to make sure that it is a function that we

    // can specialize. These are conditions independent of the call graph.

    if (OptForPartialApply &&

        !canSpecializeFunction(F, &FuncInfo, OptForPartialApply)) {

      DEBUG(llvm::dbgs() << ""  cannot specialize function -> abort\n"");

      return;

    }



    auto *RCIA = getAnalysis<RCIdentityAnalysis>();

    auto *EA = PM->getAnalysis<EpilogueARCAnalysis>();



    // Lock BCA so it's not invalidated along with the rest of the call graph.

    AnalysisPreserver BCAP(PM->getAnalysis<BasicCalleeAnalysis>());



    // As we optimize the function more and more, the name of the function is

    // going to change, make sure the mangler is aware of all the changes done

    // to the function.

    Mangle::Mangler M;

    auto P = Demangle::SpecializationPass::FunctionSignatureOpts;

    FunctionSignatureSpecializationMangler OldFM(P, M, F->isFragile(), F);

    NewMangling::FunctionSignatureSpecializationMangler NewFM(P, F->isFragile(),

                                                              F);



    /// Keep a map between the exploded argument index and the original argument

    /// index.

    llvm::SmallDenseMap<int, int> AIM;

    int asize = F->begin()->getArguments().size();

    for (auto i = 0; i < asize; ++i) {

      AIM[i] = i;

    }



    // Allocate the argument and result descriptors.

    llvm::SmallVector<ArgumentDescriptor, 4> ArgumentDescList;

    llvm::SmallVector<ResultDescriptor, 4> ResultDescList;

    auto Args = F->begin()->getFunctionArguments();

    for (unsigned i = 0, e = Args.size(); i != e; ++i) {

      ArgumentDescList.emplace_back(Args[i]);

    }

    for (SILResultInfo IR : F->getLoweredFunctionType()->getResults()) {

      ResultDescList.emplace_back(IR);

    }



    // Owned to guaranteed optimization.

    FunctionSignatureTransform FST(F, RCIA, EA, OldFM, NewFM, AIM,

                                   ArgumentDescList, ResultDescList);



    bool Changed = false;

    if (OptForPartialApply) {

      Changed = FST.removeDeadArgs(FuncInfo.getMinPartialAppliedArgs());

    } else {

      Changed = FST.run(FuncInfo.hasCaller());

    }

    if (Changed) {

      ++ NumFunctionSignaturesOptimized;

      // The old function must be a thunk now.

      assert(F->isThunk() && ""Old function should have been turned into a thunk"");



      PM->invalidateAnalysis(F, SILAnalysis::InvalidationKind::Everything);



      // Make sure the PM knows about this function. This will also help us

      // with self-recursion.

      notifyPassManagerOfFunction(FST.getOptimizedFunction(), F);



      if (!OptForPartialApply) {

        // We have to restart the pipeline for this thunk in order to run the

        // inliner (and other opts) again. This is important if the new

        // specialized function (which is called from this thunk) is

        // function-signature-optimized again and also becomes an

        // always-inline-thunk.

        restartPassPipeline();

      }

    }

  }

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(numIndirectResults == loweredFnConv.getNumIndirectSILResults());,"void OpaqueStorageAllocation::convertIndirectFunctionArgs() {

  // Insert temporary argument loads at the top of the function.

  SILBuilder argBuilder(pass.F->getEntryBlock()->begin());



  auto fnConv = pass.F->getConventions();

  unsigned argIdx = fnConv.getSILArgIndexOfFirstParam();

  for (SILParameterInfo param :

       pass.F->getLoweredFunctionType()->getParameters()) {



    if (param.isFormalIndirect() && !fnConv.isSILIndirect(param)) {

      SILArgument *arg = pass.F->getArgument(argIdx);

      SILType addrType = arg->getType().getAddressType();



      LoadInst *loadArg = argBuilder.createLoad(

          RegularLocation(const_cast<ValueDecl *>(arg->getDecl())),

          SILUndef::get(addrType, pass.F->getModule()),

          LoadOwnershipQualifier::Unqualified);



      arg->replaceAllUsesWith(loadArg);

      assert(!pass.valueStorageMap.contains(arg));



      arg = arg->getParent()->replaceFunctionArgument(

          arg->getIndex(), addrType, ValueOwnershipKind::Trivial,

          arg->getDecl());



      loadArg->setOperand(arg);



      pass.valueStorageMap.insertValue(loadArg).storageAddress = arg;

    }

    ++argIdx;

  }

  assert(argIdx

         == fnConv.getSILArgIndexOfFirstParam() + fnConv.getNumSILArguments());

}

","void OpaqueStorageAllocation::convertIndirectFunctionArgs() {

  // Insert temporary argument loads at the top of the function.

  SILBuilder argBuilder(pass.F->getEntryBlock()->begin());


","  auto fnConv = pass.F->getConventions();

  unsigned argIdx = fnConv.getSILArgIndexOfFirstParam();

  for (SILParameterInfo param :

       pass.F->getLoweredFunctionType()->getParameters()) {



    if (param.isFormalIndirect() && !fnConv.isSILIndirect(param)) {

      SILArgument *arg = pass.F->getArgument(argIdx);

      SILType addrType = arg->getType().getAddressType();



      LoadInst *loadArg = argBuilder.createLoad(

          RegularLocation(const_cast<ValueDecl *>(arg->getDecl())),

          SILUndef::get(addrType, pass.F->getModule()),

          LoadOwnershipQualifier::Unqualified);



      arg->replaceAllUsesWith(loadArg);

      assert(!pass.valueStorageMap.contains(arg));



      arg = arg->getParent()->replaceFunctionArgument(

          arg->getIndex(), addrType, ValueOwnershipKind::Trivial,

          arg->getDecl());



      loadArg->setOperand(arg);



      pass.valueStorageMap.insertValue(loadArg).storageAddress = arg;

    }

    ++argIdx;

  }

  assert(argIdx

         == fnConv.getSILArgIndexOfFirstParam() + fnConv.getNumSILArguments());

}


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)","  ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)

      : pass(pass), apply(origCall), argBuilder(origCall) {}

", ,"
      : pass(pass), apply(origCall), argBuilder(origCall) {}

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteParameters();,"  void rewriteParameters();

", ,"
"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ApplyRewriter::rewriteParameters() {,"void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

","void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}
","
  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteIndirectParameter(&operand);,"void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

","void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

       ","
    }

    ++calleeArgIdx;

  }

}

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,void rewriteFunction() {,"  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {
","    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueDef->dump());","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

","
    storage.markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(if (valueStorage.storageAddress) {,"  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

","
    storage.markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(V->dump());,"  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }

","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);
","    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  REWRITE ""; V->dump());","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }

","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;
","    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  CALL ""; applyInst->dump();","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue srcVal = destroyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), srcAddr);

    pass.markDead(destroyInst);

  }

","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue srcVal = destroyInst->getOperand();
","    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), srcAddr);

    pass.markDead(destroyInst);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"B.createDebugValueAddr(debugInst->getLoc(), addr);","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }

","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;

","
    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == destroyInst->getOperand());,"  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }

","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);

","
    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(origDirectResultValues.size() == numOrigDirectResults);,"  void visitEnumInst(EnumInst *enumInst) {

    SILValue enumAddr;

    if (enumInst->hasOperand()) {

      addrMat.initializeOperandMem(&enumInst->getOperandRef());



      assert(storage->storageAddress);

      enumAddr = storage->storageAddress;

    } else

      enumAddr = addrMat.materializeAddress(enumInst);



    B.createInjectEnumAddr(enumInst->getLoc(), enumAddr,

                           enumInst->getElement());



    storage->markRewritten();

  }

","  void visitEnumInst(EnumInst *enumInst) {

    SILValue enumAddr;

    if (enumInst->hasOperand()) {

      addrMat.initializeOperandMem(&enumInst->getOperandRef());
","

      assert(storage->storageAddress);

      enumAddr = storage->storageAddress;

    } else

      enumAddr = addrMat.materializeAddress(enumInst);



    B.createInjectEnumAddr(enumInst->getLoc(), enumAddr,

                           enumInst->getElement());



    storage->markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!origFnConv.isSILIndirect(resultInfo));,"  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }

","  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.
","    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newResultArgIdx < loweredFnConv.getSILArgIndexOfFirstParam());,"  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }

","  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

","
    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newDirectResults.size() == loweredFnConv.getNumDirectSILResults());,"  void visitTupleInst(TupleInst *tupleInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(tupleInst);

    if (storage.isProjection()

        && isa<ReturnInst>(storage.getComposedOperand()->getUser())) {

      // For indirectly returned values, each element has its own storage.

      return;

    }

    // For each element, initialize the operand's memory. Some tuple elements

    // may be loadable types.

    SILValue tupleAddr = addrMat.materializeAddress(tupleInst);

    unsigned eltIdx = 0;

    for (Operand &operand : tupleInst->getAllOperands()) {

      SILType eltTy = operand.get()->getType();

      if (eltTy.isAddressOnly(pass.F->getModule()))

        addrMat.initializeOperandMem(&operand);

      else {

        auto *elementAddr = B.createTupleElementAddr(

            tupleInst->getLoc(), tupleAddr, eltIdx, eltTy.getAddressType());

        B.createStore(tupleInst->getLoc(), operand.get(), elementAddr,

                      StoreOwnershipQualifier::Unqualified);

      }

      ++eltIdx;

    }

  }

","  void visitTupleInst(TupleInst *tupleInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(tupleInst);

    if (storage.isProjection()

        && isa<ReturnInst>(storage.getComposedOperand()->getUser())) {

      // For indirectly returned values, each element has its own storage.

      return;

    }

    // For each element, initialize the operand's memory. Some tuple elements

    // may be loadable types.
","    SILValue tupleAddr = addrMat.materializeAddress(tupleInst);

    unsigned eltIdx = 0;

    for (Operand &operand : tupleInst->getAllOperands()) {

      SILType eltTy = operand.get()->getType();

      if (eltTy.isAddressOnly(pass.F->getModule()))

        addrMat.initializeOperandMem(&operand);

      else {

        auto *elementAddr = B.createTupleElementAddr(

            tupleInst->getLoc(), tupleAddr, eltIdx, eltTy.getAddressType());

        B.createStore(tupleInst->getLoc(), operand.get(), elementAddr,

                      StoreOwnershipQualifier::Unqualified);

      }

      ++eltIdx;

    }

  }


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == storeInst->getSrc());,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);
","  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(storeInst->getOwnershipQualifier() ==,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }
","

  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}


"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter rewriter(applyInst, pass);","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

       ","
        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

"
Merge pull request #7960 from atrick/silval,lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriter.rewriteParameters();,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

       ","
        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

"
"Merge pull request #7959 from DougGregor/inferred-requirements-are-not-redundant

[GSB] Don't complain about redundant requirements with inferred sources.",lib/AST/DiagnosticEngine.cpp,+,Arg.getAsValueDecl()->getFullName().printPretty(Out);,"static void formatDiagnosticArgument(StringRef Modifier, 

                                     StringRef ModifierArguments,

                                     ArrayRef<DiagnosticArgument> Args,

                                     unsigned ArgIndex,

                                     llvm::raw_ostream &Out) {

  const DiagnosticArgument &Arg = Args[ArgIndex];

  switch (Arg.getKind()) {

  case DiagnosticArgumentKind::Integer:

    if (Modifier == ""select"") {

      assert(Arg.getAsInteger() >= 0 && ""Negative selection index"");

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsInteger(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsInteger() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for integer argument"");

      Out << Arg.getAsInteger();

    }

    break;



  case DiagnosticArgumentKind::Unsigned:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsUnsigned(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsUnsigned() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for unsigned argument"");

      Out << Arg.getAsUnsigned();

    }

    break;



  case DiagnosticArgumentKind::String:

    assert(Modifier.empty() && ""Improper modifier for string argument"");

    Out << Arg.getAsString();

    break;



  case DiagnosticArgumentKind::Identifier:

    assert(Modifier.empty() && ""Improper modifier for identifier argument"");

    Out << '\'';

    Arg.getAsIdentifier().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::ObjCSelector:

    assert(Modifier.empty() && ""Improper modifier for selector argument"");

    Out << '\'' << Arg.getAsObjCSelector() << '\'';

    break;



  case DiagnosticArgumentKind::ValueDecl:

    Out << '\'';

    Arg.getAsValueDecl()->getFullName().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::Type: {

    assert(Modifier.empty() && ""Improper modifier for Type argument"");

    

    // Strip extraneous parentheses; they add no value.

    auto type = Arg.getAsType()->getWithoutParens();

    std::string typeName = type->getString();

    Out << '\'' << typeName << '\'';





    // Decide whether to show the desugared type or not.  We filter out some

    // cases to avoid too much noise.

    bool showAKA = !type->isCanonical();



    // If we're complaining about a function type, don't ""aka"" just because of

    // differences in the argument or result types.

    if (showAKA && type->is<AnyFunctionType>() &&

        isa<AnyFunctionType>(type.getPointer()))

      showAKA = false;



    // Don't unwrap intentional sugar types like T? or [T].

    if (showAKA && (isa<SyntaxSugarType>(type.getPointer()) ||

                    isa<DictionaryType>(type.getPointer()) ||

                    type->is<BuiltinType>()))

      showAKA = false;



    // If they are textually the same, don't show them.  This can happen when

    // they are actually different types, because they exist in different scopes

    // (e.g. everyone names their type parameters 'T').

    if (showAKA && typeName == type->getCanonicalType()->getString())

      showAKA = false;



    // Don't show generic type parameters.

    if (showAKA && type->hasTypeParameter())

      showAKA = false;



    if (showAKA)

      Out << "" (aka '"" << type->getCanonicalType() << ""')"";

    break;

  }

  case DiagnosticArgumentKind::TypeRepr:

    assert(Modifier.empty() && ""Improper modifier for TypeRepr argument"");

    Out << '\'' << Arg.getAsTypeRepr() << '\'';

    break;

  case DiagnosticArgumentKind::PatternKind:

    assert(Modifier.empty() && ""Improper modifier for PatternKind argument"");

    Out << Arg.getAsPatternKind();

    break;

  case DiagnosticArgumentKind::StaticSpellingKind:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args,

                              unsigned(Arg.getAsStaticSpellingKind()), Out);

    } else {

      assert(Modifier.empty() &&

             ""Improper modifier for StaticSpellingKind argument"");

      Out << Arg.getAsStaticSpellingKind();

    }

    break;



  case DiagnosticArgumentKind::DescriptiveDeclKind:

    assert(Modifier.empty() &&

           ""Improper modifier for DescriptiveDeclKind argument"");

    Out << Decl::getDescriptiveKindName(Arg.getAsDescriptiveDeclKind());

    break;



  case DiagnosticArgumentKind::DeclAttribute:

    assert(Modifier.empty() &&

           ""Improper modifier for DeclAttribute argument"");

    if (Arg.getAsDeclAttribute()->isDeclModifier())

      Out << '\'' << Arg.getAsDeclAttribute()->getAttrName() << '\'';

    else

      Out << '@' << Arg.getAsDeclAttribute()->getAttrName();

    break;



  case DiagnosticArgumentKind::VersionTuple:

    assert(Modifier.empty() &&

           ""Improper modifier for VersionTuple argument"");

    Out << Arg.getAsVersionTuple().getAsString();

    break;

  case DiagnosticArgumentKind::LayoutConstraint:

    assert(Modifier.empty() && ""Improper modifier for LayoutConstraint argument"");

    Out << '\'' << Arg.getAsLayoutConstraint() << '\'';

    break;

  }

}

","static void formatDiagnosticArgument(StringRef Modifier, 

                                     StringRef ModifierArguments,

                                     ArrayRef<DiagnosticArgument> Args,

                                     unsigned ArgIndex,

                                     llvm::raw_ostream &Out) {

  const DiagnosticArgument &Arg = Args[ArgIndex];

  switch (Arg.getKind()) {

  case DiagnosticArgumentKind::Integer:

    if (Modifier == ""select"") {

      assert(Arg.getAsInteger() >= 0 && ""Negative selection index"");

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsInteger(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsInteger() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for integer argument"");

      Out << Arg.getAsInteger();

    }

    break;



  case DiagnosticArgumentKind::Unsigned:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args, Arg.getAsUnsigned(), 

                              Out);

    } else if (Modifier == ""s"") {

      if (Arg.getAsUnsigned() != 1)

        Out << 's';

    } else {

      assert(Modifier.empty() && ""Improper modifier for unsigned argument"");

      Out << Arg.getAsUnsigned();

    }

    break;



  case DiagnosticArgumentKind::String:

    assert(Modifier.empty() && ""Improper modifier for string argument"");

    Out << Arg.getAsString();

    break;



  case DiagnosticArgumentKind::Identifier:

    assert(Modifier.empty() && ""Improper modifier for identifier argument"");

    Out << '\'';

    Arg.getAsIdentifier().printPretty(Out);

    Out << '\'';

    break;



  case DiagnosticArgumentKind::ObjCSelector:

    assert(Modifier.empty() && ""Improper modifier for selector argument"");

    Out << '\'' << Arg.getAsObjCSelector() << '\'';

    break;



  case DiagnosticArgumentKind::ValueDecl:

    Out << '\'';

   ","
    Out << '\'';

    break;



  case DiagnosticArgumentKind::Type: {

    assert(Modifier.empty() && ""Improper modifier for Type argument"");

    

    // Strip extraneous parentheses; they add no value.

    auto type = Arg.getAsType()->getWithoutParens();

    std::string typeName = type->getString();

    Out << '\'' << typeName << '\'';





    // Decide whether to show the desugared type or not.  We filter out some

    // cases to avoid too much noise.

    bool showAKA = !type->isCanonical();



    // If we're complaining about a function type, don't ""aka"" just because of

    // differences in the argument or result types.

    if (showAKA && type->is<AnyFunctionType>() &&

        isa<AnyFunctionType>(type.getPointer()))

      showAKA = false;



    // Don't unwrap intentional sugar types like T? or [T].

    if (showAKA && (isa<SyntaxSugarType>(type.getPointer()) ||

                    isa<DictionaryType>(type.getPointer()) ||

                    type->is<BuiltinType>()))

      showAKA = false;



    // If they are textually the same, don't show them.  This can happen when

    // they are actually different types, because they exist in different scopes

    // (e.g. everyone names their type parameters 'T').

    if (showAKA && typeName == type->getCanonicalType()->getString())

      showAKA = false;



    // Don't show generic type parameters.

    if (showAKA && type->hasTypeParameter())

      showAKA = false;



    if (showAKA)

      Out << "" (aka '"" << type->getCanonicalType() << ""')"";

    break;

  }

  case DiagnosticArgumentKind::TypeRepr:

    assert(Modifier.empty() && ""Improper modifier for TypeRepr argument"");

    Out << '\'' << Arg.getAsTypeRepr() << '\'';

    break;

  case DiagnosticArgumentKind::PatternKind:

    assert(Modifier.empty() && ""Improper modifier for PatternKind argument"");

    Out << Arg.getAsPatternKind();

    break;

  case DiagnosticArgumentKind::StaticSpellingKind:

    if (Modifier == ""select"") {

      formatSelectionArgument(ModifierArguments, Args,

                              unsigned(Arg.getAsStaticSpellingKind()), Out);

    } else {

      assert(Modifier.empty() &&

             ""Improper modifier for StaticSpellingKind argument"");

      Out << Arg.getAsStaticSpellingKind();

    }

    break;



  case DiagnosticArgumentKind::DescriptiveDeclKind:

    assert(Modifier.empty() &&

           ""Improper modifier for DescriptiveDeclKind argument"");

    Out << Decl::getDescriptiveKindName(Arg.getAsDescriptiveDeclKind());

    break;



  case DiagnosticArgumentKind::DeclAttribute:

    assert(Modifier.empty() &&

           ""Improper modifier for DeclAttribute argument"");

    if (Arg.getAsDeclAttribute()->isDeclModifier())

      Out << '\'' << Arg.getAsDeclAttribute()->getAttrName() << '\'';

    else

      Out << '@' << Arg.getAsDeclAttribute()->getAttrName();

    break;



  case DiagnosticArgumentKind::VersionTuple:

    assert(Modifier.empty() &&

           ""Improper modifier for VersionTuple argument"");

    Out << Arg.getAsVersionTuple().getAsString();

    break;

  case DiagnosticArgumentKind::LayoutConstraint:

    assert(Modifier.empty() && ""Improper modifier for LayoutConstraint argument"");

    Out << '\'' << Arg.getAsLayoutConstraint() << '\'';

    break;

  }

}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(numIndirectResults == loweredFnConv.getNumIndirectSILResults());,"void OpaqueStorageAllocation::convertIndirectFunctionArgs() {

  // Insert temporary argument loads at the top of the function.

  SILBuilder argBuilder(pass.F->getEntryBlock()->begin());



  auto fnConv = pass.F->getConventions();

  unsigned argIdx = fnConv.getSILArgIndexOfFirstParam();

  for (SILParameterInfo param :

       pass.F->getLoweredFunctionType()->getParameters()) {



    if (param.isFormalIndirect() && !fnConv.isSILIndirect(param)) {

      SILArgument *arg = pass.F->getArgument(argIdx);

      SILType addrType = arg->getType().getAddressType();



      LoadInst *loadArg = argBuilder.createLoad(

          RegularLocation(const_cast<ValueDecl *>(arg->getDecl())),

          SILUndef::get(addrType, pass.F->getModule()),

          LoadOwnershipQualifier::Unqualified);



      arg->replaceAllUsesWith(loadArg);

      assert(!pass.valueStorageMap.contains(arg));



      arg = arg->getParent()->replaceFunctionArgument(

          arg->getIndex(), addrType, ValueOwnershipKind::Trivial,

          arg->getDecl());



      loadArg->setOperand(arg);



      pass.valueStorageMap.insertValue(loadArg).storageAddress = arg;

    }

    ++argIdx;

  }

  assert(argIdx

         == fnConv.getSILArgIndexOfFirstParam() + fnConv.getNumSILArguments());

}

","void OpaqueStorageAllocation::convertIndirectFunctionArgs() {

  // Insert temporary argument loads at the top of the function.

  SILBuilder argBuilder(pass.F->getEntryBlock()->begin());


","  auto fnConv = pass.F->getConventions();

  unsigned argIdx = fnConv.getSILArgIndexOfFirstParam();

  for (SILParameterInfo param :

       pass.F->getLoweredFunctionType()->getParameters()) {



    if (param.isFormalIndirect() && !fnConv.isSILIndirect(param)) {

      SILArgument *arg = pass.F->getArgument(argIdx);

      SILType addrType = arg->getType().getAddressType();



      LoadInst *loadArg = argBuilder.createLoad(

          RegularLocation(const_cast<ValueDecl *>(arg->getDecl())),

          SILUndef::get(addrType, pass.F->getModule()),

          LoadOwnershipQualifier::Unqualified);



      arg->replaceAllUsesWith(loadArg);

      assert(!pass.valueStorageMap.contains(arg));



      arg = arg->getParent()->replaceFunctionArgument(

          arg->getIndex(), addrType, ValueOwnershipKind::Trivial,

          arg->getDecl());



      loadArg->setOperand(arg);



      pass.valueStorageMap.insertValue(loadArg).storageAddress = arg;

    }

    ++argIdx;

  }

  assert(argIdx

         == fnConv.getSILArgIndexOfFirstParam() + fnConv.getNumSILArguments());

}


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)","  ApplyRewriter(SILInstruction *origCall, AddressLoweringState &pass)

      : pass(pass), apply(origCall), argBuilder(origCall) {}

", ,"
      : pass(pass), apply(origCall), argBuilder(origCall) {}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void rewriteParameters();,"  void rewriteParameters();

", ,"
"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,void ApplyRewriter::rewriteParameters() {,"void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

","void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}
","
  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriteIndirectParameter(&operand);,"void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

        rewriteIndirectParameter(&operand);

    }

    ++calleeArgIdx;

  }

}

","void ApplyRewriter::rewriteParameters() {

  // Rewrite all incoming indirect operands.

  unsigned calleeArgIdx = apply.getCalleeArgIndexOfFirstAppliedArg();

  for (Operand &operand : apply.getArgumentOperands()) {

    if (operand.get()->getType().isObject()) {

      auto argConv =

          apply.getSubstCalleeConv().getSILArgumentConvention(calleeArgIdx);

      if (argConv.isIndirectConvention())

       ","
    }

    ++calleeArgIdx;

  }

}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,void rewriteFunction() {,"  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {
","    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""VALUE   ""; valueDef->dump());","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

","
    storage.markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(if (valueStorage.storageAddress) {,"  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

    storage.storageAddress = addr;

    storage.markRewritten();

  }

","  void markRewritten(SILValue addr) {

    auto &storage = pass.valueStorageMap.getStorage(currOper->getUser());

","
    storage.markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,DEBUG(V->dump());,"  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }

","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);
","    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  REWRITE ""; V->dump());","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;

    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }

","  void visitCopyValueInst(CopyValueInst *copyInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(copyInst);

    // Fold a copy into a store.

    if (storage.isProjection()

        && isa<StoreInst>(storage.getComposedOperand()->getUser())) {

      return;
","    }

    SILValue srcVal = copyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    SILValue destAddr = addrMat.materializeAddress(copyInst);

    B.createCopyAddr(copyInst->getLoc(), srcAddr, destAddr, IsNotTake,

                     IsInitialization);

    markRewritten(destAddr);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"DEBUG(llvm::dbgs() << ""  CALL ""; applyInst->dump();","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue srcVal = destroyInst->getOperand();

    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), srcAddr);

    pass.markDead(destroyInst);

  }

","  void visitDestroyValueInst(DestroyValueInst *destroyInst) {

    SILValue srcVal = destroyInst->getOperand();
","    SILValue srcAddr = pass.valueStorageMap.getStorage(srcVal).storageAddress;

    B.createDestroyAddr(destroyInst->getLoc(), srcAddr);

    pass.markDead(destroyInst);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,"B.createDebugValueAddr(debugInst->getLoc(), addr);","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }

","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;

","
    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == destroyInst->getOperand());,"  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);



    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }

","  void visitStoreInst(StoreInst *storeInst) {

    SILValue srcVal = storeInst->getSrc();

    assert(currOper->get() == srcVal);



    ValueStorage &storage = pass.valueStorageMap.getStorage(srcVal);

    SILValue srcAddr = storage.storageAddress;



    IsTake_t isTakeFlag = IsTake;

    assert(storeInst->getOwnershipQualifier()

           == StoreOwnershipQualifier::Unqualified);

","
    if (storage.isProjection()) {

      assert(!srcAddr);

      auto *copyInst = cast<CopyValueInst>(srcVal);

      ValueStorage &srcStorage =

          pass.valueStorageMap.getStorage(copyInst->getOperand());

      assert(!srcStorage.isProjection());

      srcAddr = srcStorage.storageAddress;

      isTakeFlag = IsNotTake;

    }

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    B.createCopyAddr(storeInst->getLoc(), srcAddr, storeInst->getDest(),

                     isTakeFlag, IsInitialization);

    pass.markDead(storeInst);

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(origDirectResultValues.size() == numOrigDirectResults);,"  void visitEnumInst(EnumInst *enumInst) {

    SILValue enumAddr;

    if (enumInst->hasOperand()) {

      addrMat.initializeOperandMem(&enumInst->getOperandRef());



      assert(storage->storageAddress);

      enumAddr = storage->storageAddress;

    } else

      enumAddr = addrMat.materializeAddress(enumInst);



    B.createInjectEnumAddr(enumInst->getLoc(), enumAddr,

                           enumInst->getElement());



    storage->markRewritten();

  }

","  void visitEnumInst(EnumInst *enumInst) {

    SILValue enumAddr;

    if (enumInst->hasOperand()) {

      addrMat.initializeOperandMem(&enumInst->getOperandRef());
","

      assert(storage->storageAddress);

      enumAddr = storage->storageAddress;

    } else

      enumAddr = addrMat.materializeAddress(enumInst);



    B.createInjectEnumAddr(enumInst->getLoc(), enumAddr,

                           enumInst->getElement());



    storage->markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(!origFnConv.isSILIndirect(resultInfo));,"  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }

","  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.
","    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newResultArgIdx < loweredFnConv.getSILArgIndexOfFirstParam());,"  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

    SILValue addr = pass.valueStorageMap.getStorage(loadInst).storageAddress;

    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }

","  void visitLoadInst(LoadInst *loadInst) {

    // Bitwise copy the value. Two locations now share ownership. This is

    // modeled as a take-init.

","
    if (addr != loadInst->getOperand()) {

      B.createCopyAddr(loadInst->getLoc(), loadInst->getOperand(), addr, IsTake,

                       IsInitialization);

    }

    storage->markRewritten();

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(newDirectResults.size() == loweredFnConv.getNumDirectSILResults());,"  void visitTupleInst(TupleInst *tupleInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(tupleInst);

    if (storage.isProjection()

        && isa<ReturnInst>(storage.getComposedOperand()->getUser())) {

      // For indirectly returned values, each element has its own storage.

      return;

    }

    // For each element, initialize the operand's memory. Some tuple elements

    // may be loadable types.

    SILValue tupleAddr = addrMat.materializeAddress(tupleInst);

    unsigned eltIdx = 0;

    for (Operand &operand : tupleInst->getAllOperands()) {

      SILType eltTy = operand.get()->getType();

      if (eltTy.isAddressOnly(pass.F->getModule()))

        addrMat.initializeOperandMem(&operand);

      else {

        auto *elementAddr = B.createTupleElementAddr(

            tupleInst->getLoc(), tupleAddr, eltIdx, eltTy.getAddressType());

        B.createStore(tupleInst->getLoc(), operand.get(), elementAddr,

                      StoreOwnershipQualifier::Unqualified);

      }

      ++eltIdx;

    }

  }

","  void visitTupleInst(TupleInst *tupleInst) {

    ValueStorage &storage = pass.valueStorageMap.getStorage(tupleInst);

    if (storage.isProjection()

        && isa<ReturnInst>(storage.getComposedOperand()->getUser())) {

      // For indirectly returned values, each element has its own storage.

      return;

    }

    // For each element, initialize the operand's memory. Some tuple elements

    // may be loadable types.
","    SILValue tupleAddr = addrMat.materializeAddress(tupleInst);

    unsigned eltIdx = 0;

    for (Operand &operand : tupleInst->getAllOperands()) {

      SILType eltTy = operand.get()->getType();

      if (eltTy.isAddressOnly(pass.F->getModule()))

        addrMat.initializeOperandMem(&operand);

      else {

        auto *elementAddr = B.createTupleElementAddr(

            tupleInst->getLoc(), tupleAddr, eltIdx, eltTy.getAddressType());

        B.createStore(tupleInst->getLoc(), operand.get(), elementAddr,

                      StoreOwnershipQualifier::Unqualified);

      }

      ++eltIdx;

    }

  }


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(currOper->get() == storeInst->getSrc());,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);
","  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,-,assert(storeInst->getOwnershipQualifier() ==,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }
","

  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}


"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,"ApplyRewriter rewriter(applyInst, pass);","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

       ","
        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

"
"Overhaul the AddressLowering pass to optimize projections and handle more cases.

This adds the underpinning for optimizing storage projections. When subobjects are composed in aggregate they no longer require individual copies.

Optimize copy->store sequences.

Added support for enums and existentials.

Added a mini design doc file comment.

Added -optimize-opaque-address-lowering unit tests.",lib/SILOptimizer/Mandatory/AddressLowering.cpp,+,rewriter.rewriteParameters();,"static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

        rewriter.rewriteParameters();

        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

","static void rewriteFunction(AddressLoweringState &pass) {

  AddressOnlyDefRewriter defVisitor(pass);

  AddressOnlyUseRewriter useVisitor(pass);



  for (auto &valueStorageI : pass.valueStorageMap) {

    SILValue valueDef = valueStorageI.first;

    if (auto *defInst = dyn_cast<SILInstruction>(valueDef))

      defVisitor.visitInst(defInst);



    SmallVector<Operand *, 8> uses(valueDef->getUses());

    for (Operand *oper : uses)

      useVisitor.visitOperand(oper);

  }



  // Rewrite any remaining (loadable) indirect parameters.

  for (SILInstruction *applyInst : pass.indirectApplies) {

    ApplySite apply(applyInst);

    // Calls with indirect formal results have already been rewritten.

    if (apply.getSubstCalleeType()->hasIndirectFormalResults()) {

      bool isRewritten = false;

      visitCallResults(apply, [&](SILInstruction *result) {

        if (result->getType().isAddressOnly(pass.F->getModule())) {

          assert(pass.valueStorageMap.getStorage(result).isRewritten());

          isRewritten = true;

          return false;

        }

        return true;

      });

      if (!isRewritten) {

        ApplyRewriter rewriter(applyInst, pass);

       ","
        rewriter.convertApplyWithIndirectResults();

        continue;

      }

    }

    ApplyRewriter(applyInst, pass).rewriteParameters();

  }

  if (pass.F->getLoweredFunctionType()->hasIndirectFormalResults())

    ReturnRewriter(pass).rewriteReturns();

}

"
Merge CheckedCastValueBranch with new master,lib/ClangImporter/ImportType.cpp,-,assert(resultTy &&,"static Type

adjustResultTypeForThrowingFunction(ForeignErrorConvention::Info errorInfo,

                                    Type resultTy) {

  switch (errorInfo.TheKind) {

  case ForeignErrorConvention::ZeroResult:

  case ForeignErrorConvention::NonZeroResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return TupleType::getEmpty(resultTy->getASTContext());



  case ForeignErrorConvention::NilResult:

    if (Type unwrappedTy = resultTy->getAnyOptionalObjectType())

      return unwrappedTy;

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    // It's possible an Objective-C method overrides the base method to never

    // fail, and marks the method _Nonnull to indicate that. Swift can't

    // represent that, but it shouldn't fall over either.

    return resultTy;



  case ForeignErrorConvention::ZeroPreservedResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return resultTy;



  case ForeignErrorConvention::NonNilError:

    return resultTy;

  }



  llvm_unreachable(""Invalid ForeignErrorConvention."");

}

","static Type

adjustResultTypeForThrowingFunction(ForeignErrorConvention::Info errorInfo,

                                    Type resultTy) {

  switch (errorInfo.TheKind) {

  case ForeignErrorConvention::ZeroResult:

  case ForeignErrorConvention::NonZeroResult:

    // Check for a bad override.
","    if (resultTy->isVoid())

      return Type();

    return TupleType::getEmpty(resultTy->getASTContext());



  case ForeignErrorConvention::NilResult:

    if (Type unwrappedTy = resultTy->getAnyOptionalObjectType())

      return unwrappedTy;

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    // It's possible an Objective-C method overrides the base method to never

    // fail, and marks the method _Nonnull to indicate that. Swift can't

    // represent that, but it shouldn't fall over either.

    return resultTy;



  case ForeignErrorConvention::ZeroPreservedResult:

    // Check for a bad override.

    if (resultTy->isVoid())

      return Type();

    return resultTy;



  case ForeignErrorConvention::NonNilError:

    return resultTy;

  }



  llvm_unreachable(""Invalid ForeignErrorConvention."");

}


"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJob(const Job *j) : j(j) {},"  LogJob(const Job *j) : j(j) {}

", ,"
"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJobArray(const ArrayRef<const Job *> js) : js(js) {},"  LogJobArray(const ArrayRef<const Job *> js) : js(js) {}

", ,"
"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {},"  LogJobSet(const SmallPtrSetImpl<const Job*> &js) : js(js) {}

", ,"
"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,lj.j->printSummary(os);,"llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

  lj.j->printSummary(os);

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJob &lj) {

 ","
  return os;

}

"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobArray &ljs) {

  os << ""["";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""]"";

  return os;

}

"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,"[&](Job const *j) { os << LogJob(j); },","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

             [&](Job const *j) { os << LogJob(j); },

             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

","llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const LogJobSet &ljs) {

  os << ""{"";

  interleave(ljs.js,

            ","
             [&]() { os << ' '; });

  os << ""}"";

  return os;

}

"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,-,"static_assert(IsTriviallyCopyable<CompileJobAction::InputInfo>::value,","    void

    dependencyLoadFailed(StringRef DependenciesFile, bool Warn=true) {

      if (Warn && Comp.ShowIncrementalBuildDecisions)

        Comp.Diags.diagnose(SourceLoc(),

                            diag::warn_unable_to_load_dependencies,

                            DependenciesFile);

      Comp.disableIncrementalBuild();

      for (const Job *Cmd : DeferredCommands)

        scheduleCommandIfNecessaryAndPossible(Cmd);

      DeferredCommands.clear();

    }

","    void
","    dependencyLoadFailed(StringRef DependenciesFile, bool Warn=true) {

      if (Warn && Comp.ShowIncrementalBuildDecisions)

        Comp.Diags.diagnose(SourceLoc(),

                            diag::warn_unable_to_load_dependencies,

                            DependenciesFile);

      Comp.disableIncrementalBuild();

      for (const Job *Cmd : DeferredCommands)

        scheduleCommandIfNecessaryAndPossible(Cmd);

      DeferredCommands.clear();

    }


"
Merge CheckedCastValueBranch with new master,lib/Driver/Compilation.cpp,+,assert(FinishedCmd->getCondition() == Job::Condition::Always);,"    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

        assert(FinishedCmd->getCondition() == Job::Condition::Always);

      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              dependencyLoadFailed(DependenciesFile);

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

","    void reloadAndRemarkDeps(const Job *FinishedCmd,

                             int ReturnCode,

                             SmallVector<const Job *, N> &Dependents) {

      const CommandOutput &Output = FinishedCmd->getOutput();

      StringRef DependenciesFile =

        Output.getAdditionalOutputForType(types::TY_SwiftDeps);



      if (DependenciesFile.empty()) {

        // If this job doesn't track dependencies, it must always be run.

        // Note: In theory CheckDependencies makes sense as well (for a leaf

        // node in the dependency graph), and maybe even NewlyAdded (for very

        // coarse dependencies that always affect downstream nodes), but we're

        // not using either of those right now, and this logic should probably

        // be revisited when we are.

       ","
      } else {

        // If we have a dependency file /and/ the frontend task exited normally,

        // we can be discerning about what downstream files to rebuild.

        if (ReturnCode == EXIT_SUCCESS || ReturnCode == EXIT_FAILURE) {

          bool wasCascading = DepGraph.isMarked(FinishedCmd);



          switch (DepGraph.loadFromPath(FinishedCmd, DependenciesFile)) {

          case DependencyGraphImpl::LoadResult::HadError:

            if (ReturnCode == EXIT_SUCCESS) {

              dependencyLoadFailed(DependenciesFile);

              Dependents.clear();

            } // else, let the next build handle it.

            break;

          case DependencyGraphImpl::LoadResult::UpToDate:

            if (!wasCascading)

              break;

            LLVM_FALLTHROUGH;

          case DependencyGraphImpl::LoadResult::AffectsDownstream:

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          }

        } else {

          // If there's an abnormal exit (a crash), assume the worst.

          switch (FinishedCmd->getCondition()) {

          case Job::Condition::NewlyAdded:

            // The job won't be treated as newly added next time. Conservatively

            // mark it as affecting other jobs, because some of them may have

            // completed already.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::Always:

            // Any incremental task that shows up here has already been marked;

            // we didn't need to wait for it to finish to start downstream

            // tasks.

            assert(DepGraph.isMarked(FinishedCmd));

            break;

          case Job::Condition::RunWithoutCascading:

            // If this file changed, it might have been a non-cascading change

            // and it might not. Unfortunately, the interface hash has been

            // updated or compromised, so we don't actually know anymore; we

            // have to conservatively assume the changes could affect other

            // files.

            DepGraph.markTransitive(Dependents, FinishedCmd,

                                    IncrementalTracer);

            break;

          case Job::Condition::CheckDependencies:

            // If the only reason we're running this is because something else

            // changed, then we can trust the dependency graph as to whether

            // it's a cascading or non-cascading change. That is, if whatever

            // /caused/ the error isn't supposed to affect other files, and

            // whatever /fixes/ the error isn't supposed to affect other files,

            // then there's no need to recompile any other inputs. If either of

            // those are false, we /do/ need to recompile other inputs.

            break;

          }

        }

      }

    }

"
Merge CheckedCastValueBranch with new master,lib/IRGen/GenClass.cpp,+,"assert(fn && ""null impl provided"");","      static MethodDescriptor getIVarInitializer(llvm::Function *fn) {

        assert(fn && ""null impl provided"");

        return MethodDescriptor(Kind::IVarInitializer, fn);

 