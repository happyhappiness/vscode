commit_message,file_name,change_type,log_node,cdg_nodes,condition_lists
[ASTPrinter] Synthesize protocol extensions introduced by extensions' local conformances. rdar://28725923 (#8632),lib/AST/ASTPrinter.cpp,+,"[""2017"", ""True"", ""Condition"", ""shouldPrint ( E , Options )""]","[[[""False"", ""True""], [2108, ""True"", ""isa < ProtocolDecl > ( Target )"", ""Condition""]], [[], [2114, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""isa"", ""ProtocolDecl"", ""Target"", "">"", ""<""], """"]]"
[ASTPrinter] Synthesize protocol extensions introduced by extensions' local conformances. rdar://28725923 (#8632),lib/AST/ASTPrinter.cpp,-,"[""26097"", ""True"", ""Condition"", ""! shouldPrint ( E , Options )""]","[[[""True""], [26139, ""True"", ""! Unhandled . empty ( )"", ""Condition""]], [[""True"", ""False"", ""True"", ""True"", ""True"", ""False"", ""True""], [26247, ""True"", ""isa < ProtocolDecl > ( Target )"", ""Condition""]], [[], [26253, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Unhandled . empty"", null], ""True""], [[""isa"", ""ProtocolDecl"", ""Target"", "">"", ""<""], """"]]"
[ASTPrinter] Synthesize protocol extensions introduced by extensions' local conformances. rdar://28725923 (#8632),lib/AST/ASTPrinter.cpp,-,"[""25996"", ""True"", ""Condition"", ""! shouldPrint ( E , Options )""]","[[[""False""], [26247, ""True"", ""isa < ProtocolDecl > ( Target )"", ""Condition""]], [[], [26253, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""isa"", ""ProtocolDecl"", ""Target"", "">"", ""<""], ""False""]]"
Merge pull request #8634 from DougGregor/gsb-unresolved-vs-direct,lib/AST/GenericSignatureBuilder.cpp,+,"[""170970"", ""True"", ""ExpressionStatement"", ""assert ( constraintType && \""Missing constraint type?\"" )""]",[],[]
Merge pull request #8634 from DougGregor/gsb-unresolved-vs-direct,lib/AST/GenericSignatureBuilder.cpp,+,"[""170931"", ""True"", ""Condition"", ""source . getLoc ( ) . isValid ( ) && ! constraintType -> hasError ( )""]","[[[], [170952, ""True"", ""! constraintType -> isExistentialType ( ) && ! constraintType -> getClassOrBoundGenericClass ( )"", ""Condition""]]]","[[[""!"", ""constraintType -> isExistentialType"", null], """"], [[""!"", ""constraintType -> getClassOrBoundGenericClass"", null], """"]]"
Merge pull request #8634 from DougGregor/gsb-unresolved-vs-direct,lib/AST/GenericSignatureBuilder.cpp,+,"[""170723"", ""True"", ""ExpressionStatement"", ""assert ( subjectPA && \""No potential archetype?\"" )""]","[[[""False""], [170803, ""True"", ""resolvedSubject -> isType ( )"", ""Condition""]], [[""False""], [170839, ""True"", ""! resolvedSubject"", ""Condition""]], [[""False""], [170952, ""True"", ""! constraintType -> isExistentialType ( ) && ! constraintType -> getClassOrBoundGenericClass ( )"", ""Condition""]]]","[[[null], ""False""], [[""!"", ""resolvedSubject"", null], ""False""], [[""!"", ""constraintType -> isExistentialType"", null], ""False""], [[""!"", ""constraintType -> getClassOrBoundGenericClass"", null], ""False""]]"
Merge pull request #8634 from DougGregor/gsb-unresolved-vs-direct,lib/AST/GenericSignatureBuilder.cpp,-,"[""192520"", ""True"", ""ExpressionStatement"", ""assert ( req . getSecondType ( ) -> getClassOrBoundGenericClass ( ) )""]","[[[""case RequirementKind :: Superclass""], [192540, ""True"", ""! pa"", ""Condition""]], [[""case RequirementKind :: Superclass""], [192568, ""True"", ""req . getKind ( )"", ""Condition""]]]","[[[""! pa"", ""RequirementKind :: Superclass"", ""==""], null], [[""req . getKind ( )"", ""RequirementKind :: Superclass"", ""==""], null]]"
"[GSB] Separate out ""unresolved"" and ""direct"" type requirement handling.

As we've done with layout requirements, introduce a new entry point
(addTypeRequirement) that handles unresolved type requirements of the
form `T: U`, resolves the types, and then can

1. Diagnose any immediate problems with the types,
2. Delay the type requirement if one of the types cannot be resolved,
or
3. Break it into one or more ""direct"" requirements.

This allows us to clean up and centralize a bunch of checking that was
scattered/duplicated across the GSB and type checker.",lib/AST/GenericSignatureBuilder.cpp,+,"[""529950"", ""True"", ""ExpressionStatement"", ""assert ( constraintType && \""Missing constraint type?\"" )""]",[],[]
"[GSB] Separate out ""unresolved"" and ""direct"" type requirement handling.

As we've done with layout requirements, introduce a new entry point
(addTypeRequirement) that handles unresolved type requirements of the
form `T: U`, resolves the types, and then can

1. Diagnose any immediate problems with the types,
2. Delay the type requirement if one of the types cannot be resolved,
or
3. Break it into one or more ""direct"" requirements.

This allows us to clean up and centralize a bunch of checking that was
scattered/duplicated across the GSB and type checker.",lib/AST/GenericSignatureBuilder.cpp,+,"[""529911"", ""True"", ""Condition"", ""source . getLoc ( ) . isValid ( ) && ! constraintType -> hasError ( )""]","[[[], [529932, ""True"", ""! constraintType -> isExistentialType ( ) && ! constraintType -> getClassOrBoundGenericClass ( )"", ""Condition""]]]","[[[""!"", ""constraintType -> isExistentialType"", null], """"], [[""!"", ""constraintType -> getClassOrBoundGenericClass"", null], """"]]"
"[GSB] Separate out ""unresolved"" and ""direct"" type requirement handling.

As we've done with layout requirements, introduce a new entry point
(addTypeRequirement) that handles unresolved type requirements of the
form `T: U`, resolves the types, and then can

1. Diagnose any immediate problems with the types,
2. Delay the type requirement if one of the types cannot be resolved,
or
3. Break it into one or more ""direct"" requirements.

This allows us to clean up and centralize a bunch of checking that was
scattered/duplicated across the GSB and type checker.",lib/AST/GenericSignatureBuilder.cpp,+,"[""529703"", ""True"", ""ExpressionStatement"", ""assert ( subjectPA && \""No potential archetype?\"" )""]","[[[""False""], [529783, ""True"", ""resolvedSubject -> isType ( )"", ""Condition""]], [[""False""], [529819, ""True"", ""! resolvedSubject"", ""Condition""]], [[""False""], [529932, ""True"", ""! constraintType -> isExistentialType ( ) && ! constraintType -> getClassOrBoundGenericClass ( )"", ""Condition""]]]","[[[null], ""False""], [[""!"", ""resolvedSubject"", null], ""False""], [[""!"", ""constraintType -> isExistentialType"", null], ""False""], [[""!"", ""constraintType -> getClassOrBoundGenericClass"", null], ""False""]]"
"[GSB] Separate out ""unresolved"" and ""direct"" type requirement handling.

As we've done with layout requirements, introduce a new entry point
(addTypeRequirement) that handles unresolved type requirements of the
form `T: U`, resolves the types, and then can

1. Diagnose any immediate problems with the types,
2. Delay the type requirement if one of the types cannot be resolved,
or
3. Break it into one or more ""direct"" requirements.

This allows us to clean up and centralize a bunch of checking that was
scattered/duplicated across the GSB and type checker.",lib/AST/GenericSignatureBuilder.cpp,-,"[""551853"", ""True"", ""ExpressionStatement"", ""assert ( req . getSecondType ( ) -> getClassOrBoundGenericClass ( ) )""]","[[[""case RequirementKind :: Superclass""], [551873, ""True"", ""! pa"", ""Condition""]], [[""case RequirementKind :: Superclass""], [551901, ""True"", ""req . getKind ( )"", ""Condition""]]]","[[[""! pa"", ""RequirementKind :: Superclass"", ""==""], null], [[""req . getKind ( )"", ""RequirementKind :: Superclass"", ""==""], null]]"
"Merge pull request #8596 from huonw/symbol-list-3

Use IRGen's LinkInfo in TBDGen.",lib/FrontendTool/FrontendTool.cpp,-,"[""842916"", ""True"", ""ReturnStatement"", ""return writeTBD ( Instance -> getMainModule ( ) , opts . getSingleOutputFilename ( ) ) ;""]","[[[""False""], [842935, ""True"", ""Action == FrontendOptions :: EmitTBD"", ""Condition""]], [[""False""], [842982, ""True"", ""Action == FrontendOptions :: Typecheck"", ""Condition""]], [[""False""], [843025, ""True"", ""Context . hadError ( )"", ""Condition""]], [[""True"", ""False"", ""True""], [843147, ""True"", ""Action == FrontendOptions :: EmitImportedModules"", ""Condition""]]]","[[[""FrontendOptions :: ActionType"", ""FrontendOptions :: EmitTBD"", ""==""], ""False""], [[""FrontendOptions :: ActionType"", ""FrontendOptions :: Typecheck"", ""==""], ""False""], [[null], ""False""], [[""FrontendOptions :: ActionType"", ""FrontendOptions :: EmitImportedModules"", ""==""], """"]]"
"Merge pull request #8596 from huonw/symbol-list-3

Use IRGen's LinkInfo in TBDGen.",lib/FrontendTool/FrontendTool.cpp,+,"[""836887"", ""True"", ""ReturnStatement"", ""return writeTBD ( Instance -> getMainModule ( ) , hasMultipleIRGenThreads , opts . getSingleOutputFilename ( ) ) ;""]","[[[""True""], [836922, ""True"", ""Action == FrontendOptions :: EmitTBD"", ""Condition""]], [[""False""], [836969, ""True"", ""Action == FrontendOptions :: Typecheck"", ""Condition""]], [[""False""], [837012, ""True"", ""Context . hadError ( )"", ""Condition""]], [[""True"", ""False"", ""True""], [837134, ""True"", ""Action == FrontendOptions :: EmitImportedModules"", ""Condition""]]]","[[[""FrontendOptions :: ActionType"", ""FrontendOptions :: EmitTBD"", ""==""], ""True""], [[""FrontendOptions :: ActionType"", ""FrontendOptions :: Typecheck"", ""==""], ""False""], [[null], ""False""], [[""FrontendOptions :: ActionType"", ""FrontendOptions :: EmitImportedModules"", ""==""], """"]]"
"Merge pull request #8596 from huonw/symbol-list-3

Use IRGen's LinkInfo in TBDGen.",lib/FrontendTool/TBD.cpp,-,"[""1061433"", ""True"", ""Parameter"", ""StringRef OutputFilename""]","[[[], [1061537, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Merge pull request #8596 from huonw/symbol-list-3

Use IRGen's LinkInfo in TBDGen.",lib/FrontendTool/TBD.cpp,+,"[""1061154"", ""True"", ""Parameter"", ""bool hasMultipleIRGenThreads""]","[[[], [1061262, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8630 from eeckstein/fix-funcmerge,lib/LLVMPasses/LLVMMergeFunctions.cpp,+,"[""1258850"", ""True"", ""ExpressionStatement"", ""assert ( selfReferencing || matching )""]","[[[""False"", ""True"", ""True""], [1258865, ""True"", ""! selfReferencing && ! matching"", ""Condition""]], [[], [1258905, ""True"", ""Constant * C = dyn_cast < Constant > ( Op )"", ""Condition""]], [[""True"", ""False"", ""True""], [1258905, ""True"", ""Constant * C = dyn_cast < Constant > ( Op )"", ""Condition""]], [[], [1258961, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[], [1258961, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""bool"", null], """"], [[""!"", ""bool"", null], """"], [[""Constant"", ""C"", ""*"", ""dyn_cast"", ""Constant"", ""Value *"", "">"", ""<"", ""=""], """"], [[""Constant"", ""C"", ""*"", ""dyn_cast"", ""Constant"", ""Value *"", "">"", ""<"", ""=""], """"]]"
Merge pull request #8630 from eeckstein/fix-funcmerge,lib/LLVMPasses/LLVMMergeFunctions.cpp,+,"[""1259243"", ""True"", ""ExpressionStatement"", ""DEBUG ( dbgs ( ) << \""    Erase \"" << OrigFunc -> getName ( ) << '\\n' )""]","[[[""True""], [1259327, ""True"", ""replaceDirectCallers ( OrigFunc , NewFunction , Params , FIdx )"", ""Condition""]], [[""True""], [1259354, ""True"", ""FIdx < NumFuncs"", ""Condition""]], [[""False"", ""True""], [1259719, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""True""], [[""FIdx"", ""NumFuncs"", ""<""], ""True""]]"
Merge pull request #8630 from eeckstein/fix-funcmerge,lib/LLVMPasses/LLVMMergeFunctions.cpp,+,"[""1260331"", ""True"", ""ExpressionStatement"", ""assert ( Old -> use_empty ( ) && \""should have replaced all uses of old function\"" )""]","[[[""False"", ""True""], [1260721, ""True"", ""! AllReplaced"", ""Condition""]], [[""False""], [1260843, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""bool"", null], """"]]"
"MergeFunctions: handle self recursive functions correctly.

First, it fixes a crash where the eliminated function is still referenced.
This shows up if two equivalent self-recursive functions are merged and those functions are internal.
Fixes SR-4514, rdar://problem/31479425

Second, it avoids creating a not needed parameter for really equivalent self recursive functions.",lib/LLVMPasses/LLVMMergeFunctions.cpp,+,"[""1396983"", ""True"", ""ExpressionStatement"", ""assert ( selfReferencing || matching )""]","[[[""False"", ""True"", ""True""], [1397038, ""True"", ""Constant * C = dyn_cast < Constant > ( Op )"", ""Condition""]], [[], [1396998, ""True"", ""! selfReferencing && ! matching"", ""Condition""]], [[], [1397094, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[""True"", ""False"", ""True""], [1397038, ""True"", ""Constant * C = dyn_cast < Constant > ( Op )"", ""Condition""]], [[], [1397094, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Constant"", ""C"", ""*"", ""dyn_cast"", ""Constant"", ""Value *"", "">"", ""<"", ""=""], """"], [[""!"", ""bool"", null], """"], [[""!"", ""bool"", null], """"], [[""Constant"", ""C"", ""*"", ""dyn_cast"", ""Constant"", ""Value *"", "">"", ""<"", ""=""], """"]]"
"MergeFunctions: handle self recursive functions correctly.

First, it fixes a crash where the eliminated function is still referenced.
This shows up if two equivalent self-recursive functions are merged and those functions are internal.
Fixes SR-4514, rdar://problem/31479425

Second, it avoids creating a not needed parameter for really equivalent self recursive functions.",lib/LLVMPasses/LLVMMergeFunctions.cpp,+,"[""1397376"", ""True"", ""ExpressionStatement"", ""DEBUG ( dbgs ( ) << \""    Erase \"" << OrigFunc -> getName ( ) << '\\n' )""]","[[[""True""], [1397460, ""True"", ""replaceDirectCallers ( OrigFunc , NewFunction , Params , FIdx )"", ""Condition""]], [[""True""], [1397487, ""True"", ""FIdx < NumFuncs"", ""Condition""]], [[""False"", ""True""], [1397852, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""True""], [[""FIdx"", ""NumFuncs"", ""<""], ""True""]]"
"MergeFunctions: handle self recursive functions correctly.

First, it fixes a crash where the eliminated function is still referenced.
This shows up if two equivalent self-recursive functions are merged and those functions are internal.
Fixes SR-4514, rdar://problem/31479425

Second, it avoids creating a not needed parameter for really equivalent self recursive functions.",lib/LLVMPasses/LLVMMergeFunctions.cpp,+,"[""1398464"", ""True"", ""ExpressionStatement"", ""assert ( Old -> use_empty ( ) && \""should have replaced all uses of old function\"" )""]","[[[""False"", ""True""], [1398854, ""True"", ""! AllReplaced"", ""Condition""]], [[""False""], [1398976, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""bool"", null], """"]]"
"Merge pull request #8598 from eeckstein/demangling-extensions

Demangler: fix de- and re-mangling of constrained extensions",lib/Demangling/NodeDumper.cpp,+,"[""1425835"", ""True"", ""ExpressionStatement"", ""fprintf ( stderr , \""NodeStack[%u] at position %zd:\\n\"" , Idx , NodeStack [ Idx ] . Pos )""]","[[[""True""], [1425855, ""True"", ""Idx < NodeStack . size ( )"", ""Condition""]], [[""True""], [1425872, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Idx"", ""NodeStack . size"", ""<""], ""True""]]"
"Merge pull request #8598 from eeckstein/demangling-extensions

Demangler: fix de- and re-mangling of constrained extensions",lib/Demangling/NodeDumper.cpp,+,"[""1425815"", ""True"", ""ExpressionStatement"", ""fprintf ( stderr , \""\\n\"" )""]","[[[""True""], [1425855, ""True"", ""Idx < NodeStack . size ( )"", ""Condition""]], [[""True""], [1425872, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Idx"", ""NodeStack . size"", ""<""], ""True""]]"
"Merge pull request #8598 from eeckstein/demangling-extensions

Demangler: fix de- and re-mangling of constrained extensions",lib/Demangling/NodeDumper.cpp,+,"[""1425778"", ""True"", ""ExpressionStatement"", ""fprintf ( stderr , \""Position = %zd:\\n%.*s\\n%*s\\n\"" , Pos , ( int ) Text . size ( ) , Text . data ( ) , ( int ) Pos + 1 , \""^\"" )""]","[[[""True""], [1425872, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[TBD] Thread enough through to use UniversalLinkageInfo.,lib/FrontendTool/FrontendTool.cpp,-,"[""1434172"", ""True"", ""ReturnStatement"", ""return writeTBD ( Instance -> getMainModule ( ) , opts . getSingleOutputFilename ( ) ) ;""]","[[[""False""], [1434191, ""True"", ""Action == FrontendOptions :: EmitTBD"", ""Condition""]], [[""False""], [1434238, ""True"", ""Action == FrontendOptions :: Typecheck"", ""Condition""]], [[""False""], [1434281, ""True"", ""Context . hadError ( )"", ""Condition""]], [[""True"", ""False"", ""True""], [1434403, ""True"", ""Action == FrontendOptions :: EmitImportedModules"", ""Condition""]]]","[[[""FrontendOptions :: ActionType"", ""FrontendOptions :: EmitTBD"", ""==""], ""False""], [[""FrontendOptions :: ActionType"", ""FrontendOptions :: Typecheck"", ""==""], ""False""], [[null], ""False""], [[""FrontendOptions :: ActionType"", ""FrontendOptions :: EmitImportedModules"", ""==""], """"]]"
[TBD] Thread enough through to use UniversalLinkageInfo.,lib/FrontendTool/FrontendTool.cpp,+,"[""1428597"", ""True"", ""ReturnStatement"", ""return writeTBD ( Instance -> getMainModule ( ) , hasMultipleIRGenThreads , opts . getSingleOutputFilename ( ) ) ;""]","[[[""True""], [1428632, ""True"", ""Action == FrontendOptions :: EmitTBD"", ""Condition""]], [[""False""], [1428679, ""True"", ""Action == FrontendOptions :: Typecheck"", ""Condition""]], [[""False""], [1428722, ""True"", ""Context . hadError ( )"", ""Condition""]], [[""True"", ""False"", ""True""], [1428844, ""True"", ""Action == FrontendOptions :: EmitImportedModules"", ""Condition""]]]","[[[""FrontendOptions :: ActionType"", ""FrontendOptions :: EmitTBD"", ""==""], ""True""], [[""FrontendOptions :: ActionType"", ""FrontendOptions :: Typecheck"", ""==""], ""False""], [[null], ""False""], [[""FrontendOptions :: ActionType"", ""FrontendOptions :: EmitImportedModules"", ""==""], """"]]"
[TBD] Thread enough through to use UniversalLinkageInfo.,lib/FrontendTool/TBD.cpp,-,"[""1437330"", ""True"", ""Parameter"", ""StringRef OutputFilename""]","[[[], [1437434, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[TBD] Thread enough through to use UniversalLinkageInfo.,lib/FrontendTool/TBD.cpp,+,"[""1437051"", ""True"", ""Parameter"", ""bool hasMultipleIRGenThreads""]","[[[], [1437159, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Merge pull request #8599 from rudkx/propagate-constraints

[Constraint system] Fix some issues with constraint propagation.",lib/Sema/CSPropagate.cpp,+,"[""48570"", ""True"", ""ExpressionStatement"", ""assert ( ! constraint -> isDisabled ( ) && \""Unexpected disabled constraint!\"" )""]","[[[""True""], [48621, ""True"", ""! ActiveConstraints . empty ( )"", ""Condition""]], [[""case SolutionKind :: Unsolved"", ""case SolutionKind :: Solved"", ""case SolutionKind :: Error"", ""True""], [48630, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[], [48500, ""True"", ""failed"", ""Condition""]], [[""case SolutionKind :: Unsolved"", ""case SolutionKind :: Solved"", ""case SolutionKind :: Error"", ""True""], [48621, ""True"", ""! ActiveConstraints . empty ( )"", ""Condition""]], [[""case SolutionKind :: Unsolved"", ""case SolutionKind :: Solved"", ""case SolutionKind :: Error"", ""True""], [48630, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[], [48500, ""True"", ""failed"", ""Condition""]]]","[[[""!"", ""ActiveConstraints . empty"", null], ""True""], [[null], """"], [[""!"", ""ActiveConstraints . empty"", null], """"], [[null], """"]]"
"Merge pull request #8599 from rudkx/propagate-constraints

[Constraint system] Fix some issues with constraint propagation.",lib/Sema/CSPropagate.cpp,+,"[""48708"", ""True"", ""ExpressionStatement"", ""assert ( tyvar && \""Expected type variable!\"" )""]","[[[], [48734, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8600 from adrian-prantl/31482203,lib/IRGen/DebugTypeInfo.cpp,-,"[""51366"", ""True"", ""ExpressionStatement"", ""assert ( ( ! isArchetype ( ) || ( isArchetype ( ) && DC ) ) && \""archetype without a declcontext\"" )""]","[[[], [51387, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Demangler: add a debug dump function to print the internal state of the demangler.

Useful for debugging the demangler.",lib/Demangling/NodeDumper.cpp,+,"[""52721"", ""True"", ""ExpressionStatement"", ""fprintf ( stderr , \""NodeStack[%u] at position %zd:\\n\"" , Idx , NodeStack [ Idx ] . Pos )""]","[[[""True""], [52741, ""True"", ""Idx < NodeStack . size ( )"", ""Condition""]], [[""True""], [52758, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Idx"", ""NodeStack . size"", ""<""], ""True""]]"
"Demangler: add a debug dump function to print the internal state of the demangler.

Useful for debugging the demangler.",lib/Demangling/NodeDumper.cpp,+,"[""52701"", ""True"", ""ExpressionStatement"", ""fprintf ( stderr , \""\\n\"" )""]","[[[""True""], [52741, ""True"", ""Idx < NodeStack . size ( )"", ""Condition""]], [[""True""], [52758, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Idx"", ""NodeStack . size"", ""<""], ""True""]]"
"Demangler: add a debug dump function to print the internal state of the demangler.

Useful for debugging the demangler.",lib/Demangling/NodeDumper.cpp,+,"[""52664"", ""True"", ""ExpressionStatement"", ""fprintf ( stderr , \""Position = %zd:\\n%.*s\\n%*s\\n\"" , Pos , ( int ) Text . size ( ) , Text . data ( ) , ( int ) Pos + 1 , \""^\"" )""]","[[[""True""], [52758, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Remove obsolete assertion.

b872127 made this check unncessary because we are now using the
GenericEnvironment to map Archetypes.

rdar://problem/31482203",lib/IRGen/DebugTypeInfo.cpp,-,"[""53883"", ""True"", ""ExpressionStatement"", ""assert ( ( ! isArchetype ( ) || ( isArchetype ( ) && DC ) ) && \""archetype without a declcontext\"" )""]","[[[], [53904, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[Constraint system] Fix some issues with constraint propagation.

There are a handful of things, but the primary ones are that we really
don't want to track depth of recursion so much as whether we are
processing at the ""top level"" of constraints we're looking at or not so
that we can determine whether we can disable elements from a
disjunction.

Related, there are places where we can bail out earlier if we know
that *any* neighboring constraint passes.

Also updating the way we gather neighboring constraints to be
independent of the function that simplifies them. The original code was
wrong in that in bailed as soon as one of the simplifications
failed (which meant we might not gather all of them).",lib/Sema/CSPropagate.cpp,+,"[""55200"", ""True"", ""ExpressionStatement"", ""assert ( ! constraint -> isDisabled ( ) && \""Unexpected disabled constraint!\"" )""]","[[[""True""], [55251, ""True"", ""! ActiveConstraints . empty ( )"", ""Condition""]], [[""case SolutionKind :: Unsolved"", ""case SolutionKind :: Solved"", ""case SolutionKind :: Error"", ""True""], [55260, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[], [55130, ""True"", ""failed"", ""Condition""]], [[""case SolutionKind :: Unsolved"", ""case SolutionKind :: Solved"", ""case SolutionKind :: Error"", ""True""], [55251, ""True"", ""! ActiveConstraints . empty ( )"", ""Condition""]], [[""case SolutionKind :: Unsolved"", ""case SolutionKind :: Solved"", ""case SolutionKind :: Error"", ""True""], [55260, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[], [55130, ""True"", ""failed"", ""Condition""]]]","[[[""!"", ""ActiveConstraints . empty"", null], ""True""], [[null], """"], [[""!"", ""ActiveConstraints . empty"", null], """"], [[null], """"]]"
"[Constraint system] Fix some issues with constraint propagation.

There are a handful of things, but the primary ones are that we really
don't want to track depth of recursion so much as whether we are
processing at the ""top level"" of constraints we're looking at or not so
that we can determine whether we can disable elements from a
disjunction.

Related, there are places where we can bail out earlier if we know
that *any* neighboring constraint passes.

Also updating the way we gather neighboring constraints to be
independent of the function that simplifies them. The original code was
wrong in that in bailed as soon as one of the simplifications
failed (which meant we might not gather all of them).",lib/Sema/CSPropagate.cpp,+,"[""55338"", ""True"", ""ExpressionStatement"", ""assert ( tyvar && \""Expected type variable!\"" )""]","[[[], [55364, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""58317"", ""True"", ""ExpressionStatement"", ""DEBUG ( llvm :: dbgs ( ) << \""FORWARD \"" << TheForwardingValue << \""  to\"" << * I )""]","[[[""False""], [58346, ""True"", ""! TheForwardingValue"", ""Condition""]], [[""False""], [58385, ""True"", ""! Ctx . collectLocationValues ( I -> getParent ( ) , L , Values , getForwardValIn ( ) )"", ""Condition""]], [[""True"", ""False""], [58486, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""SILValue"", null], ""False""], [[""!"", ""Ctx . collectLocationValues"", null], ""False""]]"
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""60630"", ""True"", ""ExpressionStatement"", ""DEBUG ( llvm :: dbgs ( ) << \""WRITE \"" << * Inst )""]","[[[""False""], [60646, ""True"", ""Inst -> mayWriteToMemory ( )"", ""Condition""]], [[""False""], [60655, ""True"", ""! Inst -> mayReadOrWriteMemory ( )"", ""Condition""]], [[], [60666, ""True"", ""isRLEInertInstruction ( Inst )"", ""Condition""]]]","[[[null], ""False""], [[""!"", ""Inst -> mayReadOrWriteMemory"", null], ""False""], [[null], """"]]"
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""60600"", ""True"", ""ExpressionStatement"", ""DEBUG ( llvm :: dbgs ( ) << \""READ \"" << * Inst )""]","[[[""False""], [60646, ""True"", ""Inst -> mayWriteToMemory ( )"", ""Condition""]], [[""False""], [60655, ""True"", ""! Inst -> mayReadOrWriteMemory ( )"", ""Condition""]], [[], [60666, ""True"", ""isRLEInertInstruction ( Inst )"", ""Condition""]]]","[[[null], ""False""], [[""!"", ""Inst -> mayReadOrWriteMemory"", null], ""False""], [[null], """"]]"
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62336"", ""True"", ""ExpressionStatement"", ""llvm :: dbgs ( ) << \""PROCESS \"" << printCtx . getID ( BB ) << \"" for Gen/Kill:\\n\""""]","[[[], [62368, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62322"", ""True"", ""ExpressionStatement"", """"]","[[[], [62368, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62145"", ""True"", ""ExpressionStatement"", ""DEBUG ( S . dump ( * this ) )""]","[[[""False"", ""True""], [62368, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62494"", ""True"", ""ExpressionStatement"", ""DEBUG ( llvm :: dbgs ( ) << \""PROCESS \"" << printCtx . getID ( BB ) << \"" with Gen/Kill.\\n\"" )""]","[[[""True""], [62529, ""True"", ""! WorkList . empty ( )"", ""Condition""]], [[""False"", ""False"", ""True""], [62577, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""WorkList . empty"", null], ""True""]]"
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62397"", ""True"", ""ExpressionStatement"", ""DEBUG ( Forwarder . dump ( * this ) )""]","[[[""False"", ""True""], [62427, ""True"", ""HandledBBs . find ( X ) != HandledBBs . end ( )"", ""Condition""]], [[], [62455, ""True"", ""Forwarder . processBasicBlockWithGenKillSet ( )"", ""Condition""]], [[""True""], [62455, ""True"", ""Forwarder . processBasicBlockWithGenKillSet ( )"", ""Condition""]], [[""True""], [62529, ""True"", ""! WorkList . empty ( )"", ""Condition""]], [[""True""], [62529, ""True"", ""! WorkList . empty ( )"", ""Condition""]], [[""False"", ""False"", ""True""], [62577, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[""False"", ""False"", ""True""], [62577, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""HandledBBs . find"", ""HandledBBs . end"", ""!=""], """"], [[null], """"], [[null], ""True""], [[""!"", ""WorkList . empty"", null], ""True""], [[""!"", ""WorkList . empty"", null], ""True""]]"
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62661"", ""True"", ""ExpressionStatement"", ""DEBUG ( llvm :: dbgs ( ) << \""PROCESS \"" << printCtx . getID ( BB ) << \"" for available.\\n\"" )""]","[[[], [62696, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62602"", ""True"", ""ExpressionStatement"", ""DEBUG ( Forwarder . dump ( * this ) )""]","[[[], [62696, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62807"", ""True"", ""ExpressionStatement"", ""DEBUG ( llvm :: dbgs ( ) << \""PROCESS \"" << printCtx . getID ( BB ) << \"" for RLE.\\n\"" )""]","[[[], [62842, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""62748"", ""True"", ""ExpressionStatement"", ""DEBUG ( Forwarder . dump ( * this ) )""]","[[[""False""], [62842, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,-,"[""69169"", ""True"", ""ExpressionStatement"", ""llvm :: dbgs ( ) << \""RLE START\\n\""""]","[[[""False""], [69281, ""True"", ""Kind == ProcessKind :: ProcessNone"", ""Condition""]], [[], [69336, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""ProcessKind"", ""ProcessKind :: ProcessNone"", ""==""], ""False""]]"
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,-,"[""69114"", ""True"", ""ExpressionStatement"", ""getLocation ( i ) . print ( llvm :: dbgs ( ) , & Fn -> getModule ( ) )""]","[[[""True""], [69152, ""True"", ""i < LocationVault . size ( )"", ""Condition""]], [[""True"", ""False""], [69281, ""True"", ""Kind == ProcessKind :: ProcessNone"", ""Condition""]], [[], [69336, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""i"", ""LocationVault . size"", ""<""], ""True""], [[""ProcessKind"", ""ProcessKind :: ProcessNone"", ""==""], """"]]"
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""63139"", ""True"", ""UnaryExpression"", ""++ i""]","[[[""True""], [63142, ""True"", ""i < LocationVault . size ( )"", ""Condition""]], [[""True"", ""False""], [63264, ""True"", ""Kind == ProcessKind :: ProcessNone"", ""Condition""]], [[], [63319, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""i"", ""LocationVault . size"", ""<""], ""True""], [[""ProcessKind"", ""ProcessKind :: ProcessNone"", ""==""], """"]]"
[SILOpt] Redundant load elimination. Add debug output.,lib/SILOptimizer/Transforms/RedundantLoadElimination.cpp,+,"[""63104"", ""True"", ""ExpressionStatement"", ""getLocation ( i ) . print ( llvm :: dbgs ( ) , & Fn -> getModule ( ) )""]","[[[""True""], [63142, ""True"", ""i < LocationVault . size ( )"", ""Condition""]], [[""True"", ""False""], [63264, ""True"", ""Kind == ProcessKind :: ProcessNone"", ""Condition""]], [[], [63319, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""i"", ""LocationVault . size"", ""<""], ""True""], [[""ProcessKind"", ""ProcessKind :: ProcessNone"", ""==""], """"]]"
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,+,"[""69617"", ""True"", ""Parameter"", ""raw_ostream & OS""]","[[[], [69658, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,+,"[""69676"", ""True"", ""ExpressionStatement"", ""i . print ( OS )""]","[[[], [69685, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,-,"[""89145"", ""True"", ""ExpressionStatement"", ""* this << \"":\""""]","[[[], [89176, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,+,"[""71820"", ""True"", ""ExpressionStatement"", ""printBlockArguments ( BB )""]","[[[], [71847, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,-,"[""91201"", ""True"", ""ExpressionStatement"", ""* this << \"", error \"" << getID ( AI -> getErrorBB ( ) )""]","[[[], [91331, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,+,"[""73892"", ""True"", ""ExpressionStatement"", ""* this << \"", error \"" << Ctx . getID ( AI -> getErrorBB ( ) )""]","[[[], [74030, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,+,"[""81562"", ""True"", ""Parameter"", ""SILBasicBlock * bb""]","[[[], [81586, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,-,"[""98925"", ""True"", ""ExpressionStatement"", ""OS << SILPrinter ( Ctx ) . getID ( this )""]","[[[], [98946, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,+,"[""81602"", ""True"", ""ExpressionStatement"", ""printBlockID ( OS , this )""]","[[[], [81611, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,+,"[""81721"", ""True"", ""Parameter"", ""SILPrintContext & Ctx""]","[[[], [81743, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
SILPrintContext: support for printing consistent block numbers.,lib/SIL/SILPrinter.cpp,+,"[""81729"", ""True"", ""ExpressionStatement"", ""SILPrinter ( Ctx ) . print ( this )""]","[[[], [81743, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""99662"", ""True"", ""Parameter"", ""inner_t Inner""]","[[[], [99675, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""99689"", ""True"", ""ExpressionStatement"", ""assert ( Value != Invalid )""]","[[[], [99698, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""99712"", ""True"", ""ExpressionStatement"", ""assert ( Value != Invalid )""]","[[[], [99721, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""99735"", ""True"", ""ExpressionStatement"", ""assert ( Value != Invalid )""]","[[[], [99744, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""100147"", ""True"", ""Statement"", "")""]","[[[""True""], [100155, ""True"", ""! Result . HasCompatibleOwnership"", ""Condition""]], [[], [100171, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Result"", ""HasCompatibleOwnership"", null, null], ""True""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""102896"", ""True"", ""ExpressionStatement"", ""assert ( Value && \""Can not initialize a checker with an empty SILValue\"" )""]","[[[], [102905, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""103032"", ""True"", ""ExpressionStatement"", ""assert ( Result . hasValue ( ) && \""Can not call until check() is called\"" )""]","[[[], [103046, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""103018"", ""True"", ""ExpressionStatement"", ""assert ( Result . getValue ( ) && \""Can not call if check() returned false\"" )""]","[[[], [103046, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""103112"", ""True"", ""ExpressionStatement"", ""assert ( Result . hasValue ( ) && \""Can not call until check() is called\"" )""]","[[[], [103126, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""103098"", ""True"", ""ExpressionStatement"", ""assert ( Result . getValue ( ) && \""Can not call if check() returned false\"" )""]","[[[], [103126, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""103365"", ""True"", ""Statement"", "")""]","[[[""True""], [103374, ""True"", ""LifetimeEndingUser . isCondBranchUser ( )"", ""Condition""]], [[""False""], [103393, ""True"", ""Iter == BlocksWithNonLifetimeEndingUses . end ( )"", ""Condition""]], [[], [103414, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""True""], [[""Iter"", ""BlocksWithNonLifetimeEndingUses . end"", ""==""], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""103234"", ""True"", ""Statement"", ""]""]",[],[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,-,"[""109978"", ""True"", ""ExpressionStatement"", ""llvm :: errs ( ) << \""Block: bb\"" << UserBlock -> getDebugID ( ) << \""\\n\\n\""""]","[[[""True"", ""False""], [110050, ""True"", ""( ShouldInsert && BlocksWithLifetimeEndingUses . insert ( UserBlock ) . second ) || ! BlocksWithLifetimeEndingUses . count ( UserBlock )"", ""Condition""]], [[], [110074, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""bool"", ""BlocksWithLifetimeEndingUses . insert"", ""second"", null, ""&&"", ""!"", ""BlocksWithLifetimeEndingUses . count"", null, ""||""], """"]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""103518"", ""True"", ""Statement"", ""]""]","[[[""False""], [103528, ""True"", ""( ShouldInsert && BlocksWithLifetimeEndingUses . insert ( UserBlock ) . second ) || ! BlocksWithLifetimeEndingUses . count ( UserBlock )"", ""Condition""]], [[], [103552, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""bool"", ""BlocksWithLifetimeEndingUses . insert"", ""second"", null, ""&&"", ""!"", ""BlocksWithLifetimeEndingUses . count"", null, ""||""], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""103449"", ""True"", ""ExpressionStatement"", ""llvm :: errs ( ) << \""Block: bb\"" << UserBlock -> getDebugID ( ) << \""\\n\\n\""""]","[[[""True"", ""False""], [103528, ""True"", ""( ShouldInsert && BlocksWithLifetimeEndingUses . insert ( UserBlock ) . second ) || ! BlocksWithLifetimeEndingUses . count ( UserBlock )"", ""Condition""]], [[], [103552, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""bool"", ""BlocksWithLifetimeEndingUses . insert"", ""second"", null, ""&&"", ""!"", ""BlocksWithLifetimeEndingUses . count"", null, ""||""], """"]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""104201"", ""True"", ""Statement"", ""]""]","[[[""False""], [104211, ""True"", ""TUB . isUnreachable ( Arg -> getParent ( ) )"", ""Condition""]], [[""case ValueOwnershipKind :: Owned"", ""case ValueOwnershipKind :: Any""], [104247, ""True"", ""Arg -> getOwnershipKind ( )"", ""Condition""]], [[], [104254, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[null], """"]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""104308"", ""True"", ""Statement"", ""]""]","[[[""True""], [104315, ""True"", ""! isValueAddressOrTrivial ( Value , Mod )"", ""Condition""]], [[""False""], [104369, ""True"", ""TUB . isUnreachable ( ParentBlock )"", ""Condition""]], [[""False""], [104393, ""True"", ""Value . getOwnershipKind ( ) == ValueOwnershipKind :: Unowned"", ""Condition""]], [[""False""], [104405, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]]]","[[[""!"", ""isValueAddressOrTrivial"", null], ""True""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Unowned"", ""==""], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""104551"", ""True"", ""Statement"", ""]""]","[[[""False""], [104560, ""True"", ""Arg -> getOwnershipKind ( ) != ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[], [104569, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Arg -> getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""!=""], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""104650"", ""True"", ""Statement"", ""]""]","[[[], [104656, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""104848"", ""True"", ""ExpressionStatement"", """"]","[[[""True""], [104856, ""True"", ""doesBlockDoubleConsume ( UserBlock , User , true )"", ""Condition""]], [[""False"", ""False""], [104914, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[], [104903, ""True"", ""! isSubobjectProjectionWithLifetimeEndingUses ( Value , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [104935, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [104914, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[""False""], [104976, ""True"", ""LifetimeEndingUsers . empty ( ) && checkValueWithoutLifetimeEndingUses ( )"", ""Condition""]], [[""False""], [104935, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]]]","[[[null], ""True""], [[null], """"], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], """"], [[""!"", ""isSubobjectProjectionWithLifetimeEndingUses"", null], """"], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""], [[null], ""False""], [[null], ""False""], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""104829"", ""True"", ""ExpressionStatement"", """"]","[[[""True""], [104837, ""True"", ""doesBlockContainUseAfterFree ( User , UserBlock )"", ""Condition""]], [[""True"", ""False"", ""False""], [104914, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[], [104903, ""True"", ""! isSubobjectProjectionWithLifetimeEndingUses ( Value , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [104935, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [104914, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[""False""], [104976, ""True"", ""LifetimeEndingUsers . empty ( ) && checkValueWithoutLifetimeEndingUses ( )"", ""Condition""]], [[""False""], [104935, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]]]","[[[null], ""True""], [[null], """"], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], """"], [[""!"", ""isSubobjectProjectionWithLifetimeEndingUses"", null], """"], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""], [[null], ""False""], [[null], ""False""], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""104697"", ""True"", ""ExpressionStatement"", """"]","[[[""True""], [104705, ""True"", ""doesBlockDoubleConsume ( PredBlock , User )"", ""Condition""]], [[""False""], [104743, ""True"", ""LifetimeEndingUsers . size ( ) == 1 && LifetimeEndingUsers [ 0 ] . getParent ( ) == Value -> getParentBlock ( )"", ""Condition""]], [[""False""], [104914, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[], [104903, ""True"", ""! isSubobjectProjectionWithLifetimeEndingUses ( Value , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [104935, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [104914, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]]]","[[[null], ""True""], [[""LifetimeEndingUsers . size"", ""1"", ""==""], ""False""], [[""LifetimeEndingUsers [ 0 ] . getParent"", ""Value -> getParentBlock"", ""==""], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""], [[""!"", ""isSubobjectProjectionWithLifetimeEndingUses"", null], """"], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""105263"", ""True"", ""ExpressionStatement"", """"]","[[[""True""], [105271, ""True"", ""doesBlockDoubleConsume ( PredBlock )"", ""Condition""]], [[""False""], [105292, ""True"", ""BB == Value -> getParentBlock ( )"", ""Condition""]], [[""False""], [105313, ""True"", ""TUB . isUnreachable ( SuccBlock )"", ""Condition""]], [[""True""], [105324, ""True"", ""VisitedBlocks . count ( SuccBlock )"", ""Condition""]]]","[[[null], ""True""], [[""SILBasicBlock *"", ""Value -> getParentBlock"", ""==""], ""False""], [[null], ""False""], [[null], ""True""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,-,"[""111724"", ""True"", ""ExpressionStatement"", ""llvm :: errs ( ) << \""        bb\"" << BB -> getDebugID ( )""]","[[[""True""], [111777, ""True"", ""! SuccessorBlocksThatMustBeVisited . empty ( )"", ""Condition""]], [[""True"", ""True"", ""True"", ""True"", ""False""], [111957, ""True"", ""! Worklist . empty ( )"", ""Condition""]], [[""False"", ""True"", ""True"", ""True"", ""True""], [111978, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[], [111885, ""True"", ""VisitedBlocks . count ( SuccBlock )"", ""Condition""]], [[], [111874, ""True"", ""TUB . isUnreachable ( SuccBlock )"", ""Condition""]], [[], [111832, ""True"", ""doesBlockDoubleConsume ( PredBlock )"", ""Condition""]], [[], [111830, ""True"", ""IsSILOwnershipVerifierTestingEnabled"", ""Condition""]], [[], [111853, ""True"", ""BB == Value -> getParentBlock ( )"", ""Condition""]], [[""True""], [111957, ""True"", ""! Worklist . empty ( )"", ""Condition""]], [[""True""], [111885, ""True"", ""VisitedBlocks . count ( SuccBlock )"", ""Condition""]], [[""False""], [111853, ""True"", ""BB == Value -> getParentBlock ( )"", ""Condition""]], [[""False""], [111832, ""True"", ""doesBlockDoubleConsume ( PredBlock )"", ""Condition""]], [[""False""], [111874, ""True"", ""TUB . isUnreachable ( SuccBlock )"", ""Condition""]]]","[[[""!"", ""SuccessorBlocksThatMustBeVisited . empty"", null], ""True""], [[""!"", ""Worklist . empty"", null], """"], [[null], """"], [[null], """"], [[null], """"], [[null], """"], [[""SILBasicBlock *"", ""Value -> getParentBlock"", ""==""], """"], [[""!"", ""Worklist . empty"", null], ""True""], [[null], ""True""], [[""SILBasicBlock *"", ""Value -> getParentBlock"", ""==""], ""False""], [[null], ""False""], [[null], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""105213"", ""True"", ""Statement"", ""]""]","[[[""True""], [105219, ""True"", ""! SuccessorBlocksThatMustBeVisited . empty ( )"", ""Condition""]], [[""True"", ""True"", ""True"", ""True"", ""False""], [105417, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""SuccessorBlocksThatMustBeVisited . empty"", null], ""True""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""105160"", ""True"", ""ExpressionStatement"", ""llvm :: errs ( ) << \""        bb\"" << BB -> getDebugID ( )""]","[[[""True""], [105219, ""True"", ""! SuccessorBlocksThatMustBeVisited . empty ( )"", ""Condition""]], [[""True"", ""True"", ""True"", ""True"", ""False""], [105417, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""SuccessorBlocksThatMustBeVisited . empty"", null], ""True""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""105132"", ""True"", ""Statement"", ""]""]","[[[""True""], [105138, ""True"", ""! BlocksWithNonLifetimeEndingUses . empty ( )"", ""Condition""]], [[""False"", ""True""], [105417, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""BlocksWithNonLifetimeEndingUses . empty"", null], ""True""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""105843"", ""True"", ""ExpressionStatement"", ""assert ( F && \""Instructions and arguments should have a function\"" )""]","[[[""False""], [105867, ""True"", ""isa < SILUndef > ( Value )"", ""Condition""]], [[], [105894, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""isa"", ""SILUndef"", ""SILValue"", "">"", ""<""], ""False""]]"
Merge pull request #8573 from gottesmm/ownership_verifier_refactoring,lib/SIL/SILOwnershipVerifier.cpp,+,"[""105828"", ""True"", ""IdentifierDeclStatement"", ""ErrorBehaviorKind ErrorBehavior ( ErrorBehaviorKind :: ReturnFalse ) ;""]","[[[""False""], [105836, ""True"", ""F -> hasUnqualifiedOwnership ( )"", ""Condition""]], [[""False""], [105867, ""True"", ""isa < SILUndef > ( Value )"", ""Condition""]], [[], [105894, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[""isa"", ""SILUndef"", ""SILValue"", "">"", ""<""], ""False""]]"
"[semantic-sil] Create a new higher level API for accessing the ownership checker. It is meant to be used by passes.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""118873"", ""True"", ""ExpressionStatement"", ""assert ( F && \""Instructions and arguments should have a function\"" )""]","[[[""False""], [118897, ""True"", ""isa < SILUndef > ( Value )"", ""Condition""]], [[], [118924, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""isa"", ""SILUndef"", ""SILValue"", "">"", ""<""], ""False""]]"
"[semantic-sil] Create a new higher level API for accessing the ownership checker. It is meant to be used by passes.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""118858"", ""True"", ""IdentifierDeclStatement"", ""ErrorBehaviorKind ErrorBehavior ( ErrorBehaviorKind :: ReturnFalse ) ;""]","[[[""False""], [118866, ""True"", ""F -> hasUnqualifiedOwnership ( )"", ""Condition""]], [[""False""], [118897, ""True"", ""isa < SILUndef > ( Value )"", ""Condition""]], [[], [118924, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[""isa"", ""SILUndef"", ""SILValue"", "">"", ""<""], ""False""]]"
Merge pull request #8571 from DougGregor/where-clause-validation,lib/AST/GenericSignatureBuilder.cpp,+,"[""134825"", ""True"", ""Condition"", ""! Req -> getFirstType ( ) -> hasError ( ) && ! Req -> getSecondType ( ) -> hasError ( )""]","[[[""case RequirementReprKind :: SameType""], [134853, ""True"", ""! Req -> getFirstType ( ) -> hasTypeParameter ( ) && ! Req -> getSecondType ( ) -> hasTypeParameter ( )"", ""Condition""]], [[""case RequirementReprKind :: SameType""], [135160, ""True"", ""Req -> getKind ( )"", ""Condition""]]]","[[[""! Req -> getFirstType ( ) -> hasTypeParameter ( ) && ! Req -> getSecondType ( ) -> hasTypeParameter ( )"", ""RequirementReprKind :: SameType"", ""==""], null], [[""Req -> getKind ( )"", ""RequirementReprKind :: SameType"", ""==""], null]]"
"[Type checker] Continue validating requirements after an error.

We want to validate both type in same-type or conformance constraints,
even when the first type is ill-formed, so we don't leave null types
around for later phases to crash on.

Fixes rdar://problem/31093854.",lib/AST/GenericSignatureBuilder.cpp,+,"[""210559"", ""True"", ""Condition"", ""! Req -> getFirstType ( ) -> hasError ( ) && ! Req -> getSecondType ( ) -> hasError ( )""]","[[[""case RequirementReprKind :: SameType""], [210587, ""True"", ""! Req -> getFirstType ( ) -> hasTypeParameter ( ) && ! Req -> getSecondType ( ) -> hasTypeParameter ( )"", ""Condition""]], [[""case RequirementReprKind :: SameType""], [210894, ""True"", ""Req -> getKind ( )"", ""Condition""]]]","[[[""! Req -> getFirstType ( ) -> hasTypeParameter ( ) && ! Req -> getSecondType ( ) -> hasTypeParameter ( )"", ""RequirementReprKind :: SameType"", ""==""], null], [[""Req -> getKind ( )"", ""RequirementReprKind :: SameType"", ""==""], null]]"
"[semantic-sil] Refactor the ownership checker to store the list of uses that it finds and provide the ability to provide these to users of the ownership checker.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""239937"", ""True"", ""ExpressionStatement"", ""assert ( Value && \""Can not initialize a checker with an empty SILValue\"" )""]","[[[], [239946, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker to store the list of uses that it finds and provide the ability to provide these to users of the ownership checker.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""240072"", ""True"", ""ExpressionStatement"", ""assert ( Result . hasValue ( ) && \""Can not call until check() is called\"" )""]","[[[], [240086, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker to store the list of uses that it finds and provide the ability to provide these to users of the ownership checker.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""240058"", ""True"", ""ExpressionStatement"", ""assert ( Result . getValue ( ) && \""Can not call if check() returned false\"" )""]","[[[], [240086, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker to store the list of uses that it finds and provide the ability to provide these to users of the ownership checker.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""240152"", ""True"", ""ExpressionStatement"", ""assert ( Result . hasValue ( ) && \""Can not call until check() is called\"" )""]","[[[], [240166, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker to store the list of uses that it finds and provide the ability to provide these to users of the ownership checker.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""240138"", ""True"", ""ExpressionStatement"", ""assert ( Result . getValue ( ) && \""Can not call if check() returned false\"" )""]","[[[], [240166, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""249883"", ""True"", ""Parameter"", ""inner_t Inner""]","[[[], [249896, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""249910"", ""True"", ""ExpressionStatement"", ""assert ( Value != Invalid )""]","[[[], [249919, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""249933"", ""True"", ""ExpressionStatement"", ""assert ( Value != Invalid )""]","[[[], [249942, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""249956"", ""True"", ""ExpressionStatement"", ""assert ( Value != Invalid )""]","[[[], [249965, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""250368"", ""True"", ""Statement"", "")""]","[[[""True""], [250376, ""True"", ""! Result . HasCompatibleOwnership"", ""Condition""]], [[], [250392, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Result"", ""HasCompatibleOwnership"", null, null], ""True""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""253379"", ""True"", ""Statement"", "")""]","[[[""True""], [253388, ""True"", ""LifetimeEndingUser . isCondBranchUser ( )"", ""Condition""]], [[""False""], [253407, ""True"", ""Iter == BlocksWithNonLifetimeEndingUses . end ( )"", ""Condition""]], [[], [253428, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""True""], [[""Iter"", ""BlocksWithNonLifetimeEndingUses . end"", ""==""], ""False""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""253248"", ""True"", ""Statement"", ""]""]",[],[]
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,-,"[""259830"", ""True"", ""ExpressionStatement"", ""llvm :: errs ( ) << \""Block: bb\"" << UserBlock -> getDebugID ( ) << \""\\n\\n\""""]","[[[""True"", ""False""], [259902, ""True"", ""( ShouldInsert && BlocksWithLifetimeEndingUses . insert ( UserBlock ) . second ) || ! BlocksWithLifetimeEndingUses . count ( UserBlock )"", ""Condition""]], [[], [259926, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""bool"", ""BlocksWithLifetimeEndingUses . insert"", ""second"", null, ""&&"", ""!"", ""BlocksWithLifetimeEndingUses . count"", null, ""||""], """"]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""253532"", ""True"", ""Statement"", ""]""]","[[[""False""], [253542, ""True"", ""( ShouldInsert && BlocksWithLifetimeEndingUses . insert ( UserBlock ) . second ) || ! BlocksWithLifetimeEndingUses . count ( UserBlock )"", ""Condition""]], [[], [253566, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""bool"", ""BlocksWithLifetimeEndingUses . insert"", ""second"", null, ""&&"", ""!"", ""BlocksWithLifetimeEndingUses . count"", null, ""||""], ""False""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""253463"", ""True"", ""ExpressionStatement"", ""llvm :: errs ( ) << \""Block: bb\"" << UserBlock -> getDebugID ( ) << \""\\n\\n\""""]","[[[""True"", ""False""], [253542, ""True"", ""( ShouldInsert && BlocksWithLifetimeEndingUses . insert ( UserBlock ) . second ) || ! BlocksWithLifetimeEndingUses . count ( UserBlock )"", ""Condition""]], [[], [253566, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""bool"", ""BlocksWithLifetimeEndingUses . insert"", ""second"", null, ""&&"", ""!"", ""BlocksWithLifetimeEndingUses . count"", null, ""||""], """"]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""254215"", ""True"", ""Statement"", ""]""]","[[[""False""], [254225, ""True"", ""TUB . isUnreachable ( Arg -> getParent ( ) )"", ""Condition""]], [[""case ValueOwnershipKind :: Owned"", ""case ValueOwnershipKind :: Any""], [254261, ""True"", ""Arg -> getOwnershipKind ( )"", ""Condition""]], [[], [254268, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[null], """"]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""254322"", ""True"", ""Statement"", ""]""]","[[[""True""], [254329, ""True"", ""! isValueAddressOrTrivial ( Value , Mod )"", ""Condition""]], [[""False""], [254383, ""True"", ""TUB . isUnreachable ( ParentBlock )"", ""Condition""]], [[""False""], [254407, ""True"", ""Value . getOwnershipKind ( ) == ValueOwnershipKind :: Unowned"", ""Condition""]], [[""False""], [254419, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]]]","[[[""!"", ""isValueAddressOrTrivial"", null], ""True""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Unowned"", ""==""], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""254565"", ""True"", ""Statement"", ""]""]","[[[""False""], [254574, ""True"", ""Arg -> getOwnershipKind ( ) != ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[], [254583, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Arg -> getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""!=""], ""False""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""254664"", ""True"", ""Statement"", ""]""]","[[[], [254670, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""254862"", ""True"", ""ExpressionStatement"", """"]","[[[""True""], [254870, ""True"", ""doesBlockDoubleConsume ( UserBlock , User , true )"", ""Condition""]], [[""False"", ""False""], [254928, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[], [254917, ""True"", ""! isSubobjectProjectionWithLifetimeEndingUses ( Value , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [254949, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [254928, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[""False""], [254990, ""True"", ""LifetimeEndingUsers . empty ( ) && checkValueWithoutLifetimeEndingUses ( )"", ""Condition""]], [[""False""], [254949, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]]]","[[[null], ""True""], [[null], """"], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], """"], [[""!"", ""isSubobjectProjectionWithLifetimeEndingUses"", null], """"], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""], [[null], ""False""], [[null], ""False""], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""254843"", ""True"", ""ExpressionStatement"", """"]","[[[""True""], [254851, ""True"", ""doesBlockContainUseAfterFree ( User , UserBlock )"", ""Condition""]], [[""True"", ""False"", ""False""], [254928, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[], [254917, ""True"", ""! isSubobjectProjectionWithLifetimeEndingUses ( Value , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [254949, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [254928, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[""False""], [254990, ""True"", ""LifetimeEndingUsers . empty ( ) && checkValueWithoutLifetimeEndingUses ( )"", ""Condition""]], [[""False""], [254949, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]]]","[[[null], ""True""], [[null], """"], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], """"], [[""!"", ""isSubobjectProjectionWithLifetimeEndingUses"", null], """"], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""], [[null], ""False""], [[null], ""False""], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""254711"", ""True"", ""ExpressionStatement"", """"]","[[[""True""], [254719, ""True"", ""doesBlockDoubleConsume ( PredBlock , User )"", ""Condition""]], [[""False""], [254757, ""True"", ""LifetimeEndingUsers . size ( ) == 1 && LifetimeEndingUsers [ 0 ] . getParent ( ) == Value -> getParentBlock ( )"", ""Condition""]], [[""False""], [254928, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]], [[], [254917, ""True"", ""! isSubobjectProjectionWithLifetimeEndingUses ( Value , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [254949, ""True"", ""! isGuaranteedFunctionArgWithLifetimeEndingUses ( Arg , LifetimeEndingUsers )"", ""Condition""]], [[""False""], [254928, ""True"", ""isOwnershipForwardingValue ( Value ) && Value . getOwnershipKind ( ) == ValueOwnershipKind :: Guaranteed"", ""Condition""]]]","[[[null], ""True""], [[""LifetimeEndingUsers . size"", ""1"", ""==""], ""False""], [[""LifetimeEndingUsers [ 0 ] . getParent"", ""Value -> getParentBlock"", ""==""], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""], [[""!"", ""isSubobjectProjectionWithLifetimeEndingUses"", null], """"], [[""!"", ""isGuaranteedFunctionArgWithLifetimeEndingUses"", null], ""False""], [[null], ""False""], [[""Value . getOwnershipKind"", ""ValueOwnershipKind :: Guaranteed"", ""==""], ""False""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""255285"", ""True"", ""ExpressionStatement"", """"]","[[[""True""], [255293, ""True"", ""doesBlockDoubleConsume ( PredBlock )"", ""Condition""]], [[""False""], [255314, ""True"", ""BB == Value -> getParentBlock ( )"", ""Condition""]], [[""False""], [255335, ""True"", ""TUB . isUnreachable ( SuccBlock )"", ""Condition""]], [[""True""], [255346, ""True"", ""VisitedBlocks . count ( SuccBlock )"", ""Condition""]]]","[[[null], ""True""], [[""SILBasicBlock *"", ""Value -> getParentBlock"", ""==""], ""False""], [[null], ""False""], [[null], ""True""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,-,"[""261576"", ""True"", ""ExpressionStatement"", ""llvm :: errs ( ) << \""        bb\"" << BB -> getDebugID ( )""]","[[[""True""], [261629, ""True"", ""! SuccessorBlocksThatMustBeVisited . empty ( )"", ""Condition""]], [[""True"", ""True"", ""True"", ""True"", ""False""], [261809, ""True"", ""! Worklist . empty ( )"", ""Condition""]], [[""False"", ""True"", ""True"", ""True"", ""True""], [261684, ""True"", ""doesBlockDoubleConsume ( PredBlock )"", ""Condition""]], [[], [261830, ""True"", ""ENTRY"", ""CFGEntryNode""]], [[], [261726, ""True"", ""TUB . isUnreachable ( SuccBlock )"", ""Condition""]], [[], [261682, ""True"", ""IsSILOwnershipVerifierTestingEnabled"", ""Condition""]], [[], [261737, ""True"", ""VisitedBlocks . count ( SuccBlock )"", ""Condition""]], [[], [261705, ""True"", ""BB == Value -> getParentBlock ( )"", ""Condition""]], [[""False""], [261705, ""True"", ""BB == Value -> getParentBlock ( )"", ""Condition""]], [[""True""], [261737, ""True"", ""VisitedBlocks . count ( SuccBlock )"", ""Condition""]], [[""False""], [261684, ""True"", ""doesBlockDoubleConsume ( PredBlock )"", ""Condition""]], [[""True""], [261809, ""True"", ""! Worklist . empty ( )"", ""Condition""]], [[""False""], [261726, ""True"", ""TUB . isUnreachable ( SuccBlock )"", ""Condition""]]]","[[[""!"", ""SuccessorBlocksThatMustBeVisited . empty"", null], ""True""], [[""!"", ""Worklist . empty"", null], """"], [[null], """"], [[null], """"], [[null], """"], [[null], """"], [[""SILBasicBlock *"", ""Value -> getParentBlock"", ""==""], """"], [[""SILBasicBlock *"", ""Value -> getParentBlock"", ""==""], ""False""], [[null], ""True""], [[null], ""False""], [[""!"", ""Worklist . empty"", null], ""True""], [[null], ""False""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""255235"", ""True"", ""Statement"", ""]""]","[[[""True""], [255241, ""True"", ""! SuccessorBlocksThatMustBeVisited . empty ( )"", ""Condition""]], [[""True"", ""True"", ""True"", ""True"", ""False""], [255439, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""SuccessorBlocksThatMustBeVisited . empty"", null], ""True""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""255182"", ""True"", ""ExpressionStatement"", ""llvm :: errs ( ) << \""        bb\"" << BB -> getDebugID ( )""]","[[[""True""], [255241, ""True"", ""! SuccessorBlocksThatMustBeVisited . empty ( )"", ""Condition""]], [[""True"", ""True"", ""True"", ""True"", ""False""], [255439, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""SuccessorBlocksThatMustBeVisited . empty"", null], ""True""]]"
"[semantic-sil] Refactor the ownership checker's handling on finding an error.

Today the ownership checker has two different behaviors on detecting an error:

1. In normal operating mode, it prints a message to stderr and asserts.
2. In testing mode, it prints a message to stderr and returns false.

This refactoring will allow me to add a third mode:

1. In optimization mode, it does not print a message and just returns false.

This will allow me to use the verifier in an early ARC optimization that I need
to prevent COW copies due to refactoring in SILGenPattern.

rdar://29870610",lib/SIL/SILOwnershipVerifier.cpp,+,"[""255154"", ""True"", ""Statement"", ""]""]","[[[""True""], [255160, ""True"", ""! BlocksWithNonLifetimeEndingUses . empty ( )"", ""Condition""]], [[""False"", ""True""], [255439, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""BlocksWithNonLifetimeEndingUses . empty"", null], ""True""]]"
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/AST/ProtocolConformance.cpp,-,"[""269535"", ""True"", ""ExpressionStatement"", ""assert ( ( conforms || specializedType -> isTypeVariableOrMember ( ) || specializedType -> isTypeParameter ( ) || specializedType -> hasError ( ) ) && \""Improperly checked substitution\"" )""]","[[[""False""], [269626, ""True"", ""specializedType . getPointer ( ) == genericWitness . getReplacement ( ) . getPointer ( )"", ""Condition""]], [[""False"", ""True""], [269743, ""True"", ""known != TypeWitnesses . end ( )"", ""Condition""]], [[], [269764, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""specializedType . getPointer"", ""genericWitness . getReplacement ( ) . getPointer"", ""==""], ""False""], [[""known"", ""TypeWitnesses . end"", ""!=""], """"]]"
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/AST/SubstitutionMap.cpp,-,"[""274200"", ""True"", ""Statement"", ""&&""]","[[[], [274233, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/AST/SubstitutionMap.cpp,+,"[""273879"", ""True"", ""ExpressionStatement"", ""getGenericSignature ( ) -> print ( out )""]","[[[], [273895, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Sema/CSApply.cpp,-,"[""312526"", ""True"", ""ExpressionStatement"", ""assert ( conformance && \""Missing conformance information\"" )""]","[[[""False""], [312538, ""True"", ""! assocType"", ""Condition""]], [[], [312586, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""AssociatedTypeDecl *"", null], ""False""]]"
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Sema/TypeCheckProtocol.cpp,-,"[""384858"", ""True"", ""ExpressionStatement"", ""assert ( ! replacement -> isTypeParameter ( ) && \""Can't be dependent\"" )""]","[[[], [384874, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Sema/TypeCheckProtocol.cpp,-,"[""384842"", ""True"", ""IdentifierDeclStatement"", ""bool isError = replacement -> hasError ( ) ;""]","[[[], [384874, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Sema/TypeCheckProtocol.cpp,-,"[""384806"", ""True"", ""ExpressionStatement"", ""assert ( ( conformance || isError ) && \""Conformance should already have been verified\"" )""]","[[[], [384874, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Sema/TypeCheckProtocol.cpp,-,"[""385653"", ""True"", ""ExpressionStatement"", ""assert ( Conformance -> getTypeWitness ( assocType , nullptr ) . getReplacement ( ) -> isEqual ( type ) && \""Conflicting type witness deductions\"" )""]","[[[], [385683, ""True"", ""Conformance -> hasTypeWitness ( assocType )"", ""Condition""]], [[], [385692, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Sema/TypeCheckProtocol.cpp,+,"[""358356"", ""True"", ""ExpressionStatement"", ""assert ( Conformance -> getTypeWitness ( assocType , nullptr ) -> isEqual ( type ) && \""Conflicting type witness deductions\"" )""]","[[[], [358381, ""True"", ""Conformance -> hasTypeWitness ( assocType )"", ""Condition""]], [[], [358390, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Sema/TypeCheckProtocol.cpp,+,"[""360885"", ""True"", ""Condition"", ""Conformance -> getTypeWitness ( assocType , nullptr ) -> hasError ( )""]","[[[], [360931, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Sema/TypeCheckProtocol.cpp,+,"[""368814"", ""True"", ""Condition"", ""Conformance -> getTypeWitness ( assocType , nullptr ) -> hasError ( )""]","[[[""False""], [368847, ""True"", ""! requirement -> isProtocolRequirement ( )"", ""Condition""]], [[""False"", ""True""], [368866, ""True"", ""requirement -> isInvalid ( ) || ! requirement -> hasValidSignature ( )"", ""Condition""]], [[""True""], [368973, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""requirement -> isProtocolRequirement"", null], ""False""], [[""requirement -> isInvalid"", ""!"", ""requirement -> hasValidSignature"", null, ""||""], """"]]"
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Serialization/Deserialization.cpp,-,"[""445759"", ""True"", ""ExpressionStatement"", ""assert ( third . hasValue ( ) )""]","[[[""True""], [445817, ""True"", ""typeCount --"", ""Condition""]], [[""True"", ""False""], [446346, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""unsigned"", null, null], ""True""]]"
Merge pull request #8557 from DougGregor/substitution-map-cleanups,lib/Serialization/Serialization.cpp,-,"[""478249"", ""True"", ""ExpressionStatement"", ""writeSubstitutions ( witness , DeclTypeAbbrCodes )""]","[[[""False""], [478378, ""True"", ""! witness . getDecl ( )"", ""Condition""]]]","[[[""!"", ""witness . getDecl"", null], ""False""]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""508027"", ""True"", ""Parameter"", ""Optional < SILLocation > OptLoc""]","[[[], [508056, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""496207"", ""True"", ""Parameter"", ""SILLocation Loc""]","[[[], [496239, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""496232"", ""True"", ""Condition"", ""Loc . isDebugInfoLoc ( )""]","[[[], [496239, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""496225"", ""True"", ""ReturnStatement"", ""return Loc . getDebugInfoLoc ( ) ;""]","[[[], [496232, ""True"", ""Loc . isDebugInfoLoc ( )"", ""Condition""]], [[], [496239, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""496212"", ""True"", ""ReturnStatement"", ""return decodeSourceLoc ( Loc . getDebugSourceLoc ( ) ) ;""]","[[[], [496232, ""True"", ""Loc . isDebugInfoLoc ( )"", ""Condition""]], [[], [496239, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""496249"", ""True"", ""Parameter"", ""Optional < SILLocation > OptLoc""]","[[[], [496278, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""508032"", ""True"", ""ReturnStatement"", ""return OptLoc -> decodeDebugLoc ( SM ) ;""]","[[[""False"", ""True""], [508056, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""496254"", ""True"", ""ReturnStatement"", ""return decodeDebugLoc ( * OptLoc ) ;""]","[[[""False"", ""True""], [496278, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""508211"", ""True"", ""ExpressionStatement"", ""L = CS -> Loc . decodeDebugLoc ( SM )""]","[[[""True""], [508266, ""True"", ""N < Scopes . size ( )"", ""Condition""]], [[""False"", ""True""], [508340, ""True"", ""DS"", ""Condition""]], [[], [508349, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""unsigned"", ""Scopes . size"", ""<""], ""True""], [[null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""496501"", ""True"", ""ExpressionStatement"", ""L = decodeDebugLoc ( CS -> Loc )""]","[[[""False""], [496522, ""True"", ""CachedInlinedAt != InlinedAtCache . end ( )"", ""Condition""]], [[""False""], [496546, ""True"", ""! CS"", ""Condition""]], [[], [496559, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""CachedInlinedAt"", ""InlinedAtCache . end"", ""!=""], ""False""], [[""!"", ""CS"", null], ""False""]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""508743"", ""True"", ""ExpressionStatement"", ""L = getDebugLocation ( Loc , SM )""]","[[[""False""], [508757, ""True"", ""! Scope"", ""Condition""]], [[], [508787, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Scope"", null], ""False""]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""496866"", ""True"", ""ExpressionStatement"", ""L = getDebugLocation ( Loc )""]","[[[""False""], [496894, ""True"", ""shouldIgnoreAbstractClosure ( Loc , DS ) || ( Fn && Fn -> isThunk ( ) )"", ""Condition""]], [[""False""], [496930, ""True"", ""! Scope"", ""Condition""]], [[], [496955, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""shouldIgnoreAbstractClosure"", ""SILFunction *"", ""Fn -> isThunk"", ""&&"", ""||""], ""False""], [[""!"", ""Scope"", null], ""False""]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""509934"", ""True"", ""ExpressionStatement"", ""Loc = getDebugLoc ( SM , NTD )""]",[],[]
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""498122"", ""True"", ""ExpressionStatement"", ""Loc = getDebugLoc ( * this , NTD )""]",[],[]
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""510981"", ""True"", ""ExpressionStatement"", ""L = DS -> Loc . decodeDebugLoc ( SM )""]","[[[""False"", ""False"", ""True""], [510994, ""True"", ""DS && ( ! SILFn || ( ! SILFn -> isBare ( ) && ! SILFn -> isThunk ( ) ) )"", ""Condition""]], [[""False"", ""False"", ""True""], [511168, ""True"", ""Cached != ScopeCache . end ( )"", ""Condition""]], [[], [511189, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""SILFn"", null, ""!"", ""SILFn -> isBare"", null, ""!"", ""SILFn -> isThunk"", null, ""&&"", ""||""], """"], [[""Cached"", ""ScopeCache . end"", ""!=""], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""499175"", ""True"", ""ExpressionStatement"", ""L = decodeDebugLoc ( DS -> Loc )""]","[[[""False"", ""False"", ""True""], [499186, ""True"", ""DS && ( ! SILFn || ( ! SILFn -> isBare ( ) && ! SILFn -> isThunk ( ) ) )"", ""Condition""]], [[""False"", ""False"", ""True""], [499360, ""True"", ""Cached != ScopeCache . end ( )"", ""Condition""]], [[], [499386, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""SILFn"", null, ""!"", ""SILFn -> isBare"", null, ""!"", ""SILFn -> isThunk"", null, ""&&"", ""||""], """"], [[""Cached"", ""ScopeCache . end"", ""!=""], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""511309"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , D )""]","[[[""False""], [511348, ""True"", ""! M"", ""Condition""]], [[""True"", ""False""], [511410, ""True"", ""Opts . DebugInfoKind <= IRGenDebugInfoKind :: LineTables"", ""Condition""]], [[], [511416, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""swift :: ModuleDecl *"", null], ""False""], [[""Opts"", ""DebugInfoKind"", null, ""IRGenDebugInfoKind :: LineTables"", ""<=""], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""499507"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , D )""]","[[[""False""], [499548, ""True"", ""! M"", ""Condition""]], [[""True"", ""False""], [499610, ""True"", ""Opts . DebugInfoKind <= IRGenDebugInfoKind :: LineTables"", ""Condition""]], [[], [499616, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""swift :: ModuleDecl *"", null], ""False""], [[""Opts"", ""DebugInfoKind"", null, ""IRGenDebugInfoKind :: LineTables"", ""<=""], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""512808"", ""True"", ""ExpressionStatement"", ""Loc = getDebugLoc ( SM , VarDecl )""]","[[[""False"", ""True""], [512869, ""True"", ""Opts . DebugInfoKind <= IRGenDebugInfoKind :: LineTables"", ""Condition""]], [[""False"", ""True""], [512877, ""True"", ""! DS"", ""Condition""]], [[""True""], [512903, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Opts"", ""DebugInfoKind"", null, ""IRGenDebugInfoKind :: LineTables"", ""<=""], """"], [[""!"", ""const SILDebugScope *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""501009"", ""True"", ""ExpressionStatement"", ""Loc = getDebugLoc ( * this , VarDecl )""]","[[[""False"", ""True""], [501072, ""True"", ""Opts . DebugInfoKind <= IRGenDebugInfoKind :: LineTables"", ""Condition""]], [[""False"", ""True""], [501080, ""True"", ""! DS"", ""Condition""]], [[""True""], [501106, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Opts"", ""DebugInfoKind"", null, ""IRGenDebugInfoKind :: LineTables"", ""<=""], """"], [[""!"", ""const SILDebugScope *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""518078"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: Struct""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Struct"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""506303"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: Struct""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Struct"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""517952"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: Class""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Class"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""506175"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: Class""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Class"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""517689"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: Protocol""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Protocol"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""505910"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: Protocol""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Protocol"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""517618"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: ProtocolComposition""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: ProtocolComposition"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""505837"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: ProtocolComposition""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: ProtocolComposition"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""517534"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: UnboundGeneric""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: UnboundGeneric"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""505751"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: UnboundGeneric""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: UnboundGeneric"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""517445"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: BoundGenericStruct""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericStruct"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""505660"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: BoundGenericStruct""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericStruct"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""517373"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: BoundGenericClass""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericClass"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""505586"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: BoundGenericClass""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericClass"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""517161"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Archetype -> getAssocType ( ) )""]","[[[""case TypeKind :: Archetype""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Archetype"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""505372"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Archetype -> getAssocType ( ) )""]","[[[""case TypeKind :: Archetype""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Archetype"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""516892"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , DbgTy . getDecl ( ) )""]","[[[""case TypeKind :: Metatype"", ""case TypeKind :: ExistentialMetatype""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""505101"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , DbgTy . getDecl ( ) )""]","[[[""case TypeKind :: Metatype"", ""case TypeKind :: ExistentialMetatype""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""516754"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: Enum""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Enum"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""504961"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: Enum""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Enum"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""516638"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: BoundGenericEnum""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericEnum"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""504843"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: BoundGenericEnum""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericEnum"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""516431"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , DbgTy . getDecl ( ) )""]","[[[""case TypeKind :: WeakStorage"", ""case TypeKind :: UnmanagedStorage"", ""case TypeKind :: UnownedStorage""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""504634"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , DbgTy . getDecl ( ) )""]","[[[""case TypeKind :: WeakStorage"", ""case TypeKind :: UnmanagedStorage"", ""case TypeKind :: UnownedStorage""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,-,"[""516355"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: NameAlias""], [518488, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [518567, ""True"", ""! BaseTy"", ""Condition""]], [[], [518646, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: NameAlias"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/IRGen/IRGenDebugInfo.cpp,+,"[""504556"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: NameAlias""], [506715, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [506794, ""True"", ""! BaseTy"", ""Condition""]], [[], [506873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: NameAlias"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SIL/SILDebugScope.cpp,+,"[""557844"", ""True"", ""Parameter"", ""SILFunction * SILFn""]","[[[], [557873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/SIL/SILDebugScope.cpp,+,"[""557858"", ""True"", ""ExpressionStatement"", ""assert ( SILFn && \""no parent provided\"" )""]","[[[], [557871, ""True"", ""ParentScope"", ""Condition""]], [[], [557873, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SIL/SILDebugScope.cpp,+,"[""557883"", ""True"", ""Parameter"", ""SILLocation Loc""]","[[[], [557887, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/SIL/SILDebugScope.cpp,+,"[""557908"", ""True"", ""ExpressionStatement"", """"]","[[[""False""], [557965, ""True"", ""Parent . isNull ( )"", ""Condition""]], [[], [557972, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SIL/SILPrinter.cpp,-,"[""578043"", ""True"", ""ExpressionStatement"", ""CallSite . getSourceLoc ( ) . print ( PrintState . OS , M . getASTContext ( ) . SourceMgr , LastBufferID )""]","[[[""False"", ""True""], [578070, ""True"", ""! CallSite . isNull ( ) && CallSite . isASTNode ( )"", ""Condition""]], [[""False"", ""True""], [578166, ""True"", ""DS"", ""Condition""]], [[""True"", ""False"", ""True"", ""True"", ""False"", ""False"", ""True""], [578440, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""CallSite . isNull"", null], """"], [[null], """"], [[null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SIL/SILPrinter.cpp,+,"[""561154"", ""True"", ""ExpressionStatement"", ""CallSite . getSourceLoc ( ) . print ( PrintState . OS , M . getASTContext ( ) . SourceMgr , LastBufferID )""]","[[[""True""], [561181, ""True"", ""! CallSite . isNull ( ) && CallSite . isASTNode ( )"", ""Condition""]], [[""True""], [561244, ""True"", ""CS = CS -> InlinedCallSite"", ""Condition""]], [[""False"", ""True"", ""False""], [561266, ""True"", ""! DS"", ""Condition""]], [[""True"", ""False"", ""True"", ""True"", ""False"", ""False"", ""True""], [561542, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""CallSite . isNull"", null], ""True""], [[null], ""True""], [[""const SILDebugScope *"", ""const SILDebugScope *"", ""InlinedCallSite"", null, ""=""], ""True""], [[""!"", ""const SILDebugScope *"", null], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""594249"", ""True"", ""ExpressionStatement"", ""SILDebugScope ( AI . getLoc ( ) , & F , AIScope )""]","[[[""False""], [594282, ""True"", ""IKind == InlineKind :: MandatoryInline"", ""Condition""]], [[""False"", ""True"", ""True""], [594594, ""True"", ""AI . getFunction ( ) == CalleeFunction"", ""Condition""]], [[], [594618, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""IKind"", ""InlineKind :: MandatoryInline"", ""==""], ""False""], [[""AI . getFunction"", ""SILFunction *"", ""==""], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""594233"", ""True"", ""ExpressionStatement"", ""assert ( CallSiteScope -> getParentFunction ( ) == & F )""]","[[[""False""], [594282, ""True"", ""IKind == InlineKind :: MandatoryInline"", ""Condition""]], [[""False"", ""True"", ""True""], [594594, ""True"", ""AI . getFunction ( ) == CalleeFunction"", ""Condition""]], [[], [594618, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""IKind"", ""InlineKind :: MandatoryInline"", ""==""], ""False""], [[""AI . getFunction"", ""SILFunction *"", ""==""], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SILOptimizer/Utils/SILInliner.cpp,+,"[""592456"", ""True"", ""ExpressionStatement"", ""SILDebugScope ( AI . getLoc ( ) , nullptr , AIScope , AIScope -> InlinedCallSite )""]","[[[""False""], [592491, ""True"", ""IKind == InlineKind :: MandatoryInline"", ""Condition""]], [[""False"", ""True"", ""True""], [592803, ""True"", ""AI . getFunction ( ) == CalleeFunction"", ""Condition""]], [[], [592827, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""IKind"", ""InlineKind :: MandatoryInline"", ""==""], ""False""], [[""AI . getFunction"", ""SILFunction *"", ""==""], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SILOptimizer/Utils/SILInliner.cpp,+,"[""592428"", ""True"", ""ExpressionStatement"", ""assert ( CallSiteScope -> getParentFunction ( ) == & F )""]","[[[""True"", ""False""], [592803, ""True"", ""AI . getFunction ( ) == CalleeFunction"", ""Condition""]], [[], [592827, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""AI . getFunction"", ""SILFunction *"", ""==""], """"]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""594878"", ""True"", ""ExpressionStatement"", ""assert ( CalleeScope )""]","[[[], [594885, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8533 from adrian-prantl/28311051,lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""594826"", ""True"", ""ExpressionStatement"", ""SILDebugScope ( CallSiteScope , CalleeScope )""]","[[[""False""], [594857, ""True"", ""it != InlinedScopeCache . end ( )"", ""Condition""]], [[], [594885, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""it"", ""InlinedScopeCache . end"", ""!=""], ""False""]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""594811"", ""True"", ""ExpressionStatement"", ""assert ( CallSiteScope -> Parent == InlineScope -> InlinedCallSite -> Parent )""]","[[[""False""], [594857, ""True"", ""it != InlinedScopeCache . end ( )"", ""Condition""]], [[], [594885, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""it"", ""InlinedScopeCache . end"", ""!=""], ""False""]]"
Merge pull request #8533 from adrian-prantl/28311051,lib/SILOptimizer/Utils/SILInliner.cpp,+,"[""593054"", ""True"", ""Statement"", ""(""]","[[[""False""], [593101, ""True"", ""it != InlinedScopeCache . end ( )"", ""Condition""]], [[""False""], [593125, ""True"", ""! CalleeScope"", ""Condition""]], [[], [593129, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""it"", ""InlinedScopeCache . end"", ""!=""], ""False""], [[""!"", ""const SILDebugScope *"", null], ""False""]]"
[AST] Remove GenericEnvironment from SubstitutionMap; it's unnecessary.,lib/AST/SubstitutionMap.cpp,-,"[""598079"", ""True"", ""Statement"", ""&&""]","[[[], [598112, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[SubstitutionMap] Dump generic signature in debug output.

You can't interpret a conformance map without a generic signature, so
add it to the debug output.",lib/AST/SubstitutionMap.cpp,+,"[""602594"", ""True"", ""ExpressionStatement"", ""getGenericSignature ( ) -> print ( out )""]","[[[], [602610, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/AST/ProtocolConformance.cpp,-,"[""612462"", ""True"", ""ExpressionStatement"", ""assert ( ( conforms || specializedType -> isTypeVariableOrMember ( ) || specializedType -> isTypeParameter ( ) || specializedType -> hasError ( ) ) && \""Improperly checked substitution\"" )""]","[[[""False""], [612553, ""True"", ""specializedType . getPointer ( ) == genericWitness . getReplacement ( ) . getPointer ( )"", ""Condition""]], [[""False"", ""True""], [612670, ""True"", ""known != TypeWitnesses . end ( )"", ""Condition""]], [[], [612691, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""specializedType . getPointer"", ""genericWitness . getReplacement ( ) . getPointer"", ""==""], ""False""], [[""known"", ""TypeWitnesses . end"", ""!=""], """"]]"
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Sema/CSApply.cpp,-,"[""650696"", ""True"", ""ExpressionStatement"", ""assert ( conformance && \""Missing conformance information\"" )""]","[[[""False""], [650708, ""True"", ""! assocType"", ""Condition""]], [[], [650756, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""AssociatedTypeDecl *"", null], ""False""]]"
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Sema/TypeCheckProtocol.cpp,-,"[""723028"", ""True"", ""ExpressionStatement"", ""assert ( ! replacement -> isTypeParameter ( ) && \""Can't be dependent\"" )""]","[[[], [723044, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Sema/TypeCheckProtocol.cpp,-,"[""723012"", ""True"", ""IdentifierDeclStatement"", ""bool isError = replacement -> hasError ( ) ;""]","[[[], [723044, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Sema/TypeCheckProtocol.cpp,-,"[""722976"", ""True"", ""ExpressionStatement"", ""assert ( ( conformance || isError ) && \""Conformance should already have been verified\"" )""]","[[[], [723044, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Sema/TypeCheckProtocol.cpp,-,"[""723823"", ""True"", ""ExpressionStatement"", ""assert ( Conformance -> getTypeWitness ( assocType , nullptr ) . getReplacement ( ) -> isEqual ( type ) && \""Conflicting type witness deductions\"" )""]","[[[], [723853, ""True"", ""Conformance -> hasTypeWitness ( assocType )"", ""Condition""]], [[], [723862, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Sema/TypeCheckProtocol.cpp,+,"[""696526"", ""True"", ""ExpressionStatement"", ""assert ( Conformance -> getTypeWitness ( assocType , nullptr ) -> isEqual ( type ) && \""Conflicting type witness deductions\"" )""]","[[[], [696551, ""True"", ""Conformance -> hasTypeWitness ( assocType )"", ""Condition""]], [[], [696560, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Sema/TypeCheckProtocol.cpp,+,"[""699055"", ""True"", ""Condition"", ""Conformance -> getTypeWitness ( assocType , nullptr ) -> hasError ( )""]","[[[], [699101, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Sema/TypeCheckProtocol.cpp,+,"[""706984"", ""True"", ""Condition"", ""Conformance -> getTypeWitness ( assocType , nullptr ) -> hasError ( )""]","[[[""False""], [707017, ""True"", ""! requirement -> isProtocolRequirement ( )"", ""Condition""]], [[""False"", ""True""], [707036, ""True"", ""requirement -> isInvalid ( ) || ! requirement -> hasValidSignature ( )"", ""Condition""]], [[""True""], [707143, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""requirement -> isProtocolRequirement"", null], ""False""], [[""requirement -> isInvalid"", ""!"", ""requirement -> hasValidSignature"", null, ""||""], """"]]"
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Serialization/Deserialization.cpp,-,"[""783929"", ""True"", ""ExpressionStatement"", ""assert ( third . hasValue ( ) )""]","[[[""True""], [783987, ""True"", ""typeCount --"", ""Condition""]], [[""True"", ""False""], [784516, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""unsigned"", null, null], ""True""]]"
"[AST] Drop substitutions from type witnesses.

Nobody is using the actual substitutions, but we sure did a lot of
work to cope with them.",lib/Serialization/Serialization.cpp,-,"[""816419"", ""True"", ""ExpressionStatement"", ""writeSubstitutions ( witness , DeclTypeAbbrCodes )""]","[[[""False""], [816548, ""True"", ""! witness . getDecl ( )"", ""Condition""]]]","[[[""!"", ""witness . getDecl"", null], ""False""]]"
"Merge pull request #8551 from rjmccall/elementary-access-markers

Start generating elementary access markers in SILGen",lib/SILGen/SILGenLValue.cpp,+,"[""849512"", ""True"", ""ExpressionStatement"", ""assert ( var -> getDeclContext ( ) -> isTypeContext ( ) && ! var -> isInstanceMember ( ) )""]","[[[""False""], [849550, ""True"", ""var -> getDeclContext ( ) -> isModuleScopeContext ( )"", ""Condition""]], [[""True""], [849574, ""True"", ""var -> getDeclContext ( ) -> isLocalContext ( )"", ""Condition""]], [[""case AccessStrategy :: Storage""], [849586, ""True"", ""! var -> isLet ( )"", ""Condition""]], [[""case AccessStrategy :: Storage""], [849727, ""True"", ""var -> getAccessStrategy ( semantics , accessKind )"", ""Condition""]]]","[[[null], ""False""], [[null], ""True""], [[""! var -> isLet ( )"", ""AccessStrategy :: Storage"", ""==""], null], [[""var -> getAccessStrategy ( semantics , accessKind )"", ""AccessStrategy :: Storage"", ""==""], null]]"
Rearrange IRGenDebugInfo::setCurrentLoc() to avoid decoding throwaway locations.,lib/IRGen/IRGenDebugInfo.cpp,-,"[""876088"", ""True"", ""ExpressionStatement"", ""L = getDebugLocation ( Loc )""]","[[[""False""], [876100, ""True"", ""! Scope"", ""Condition""]], [[], [876125, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Scope"", null], ""False""]]"
Rearrange IRGenDebugInfo::setCurrentLoc() to avoid decoding throwaway locations.,lib/IRGen/IRGenDebugInfo.cpp,+,"[""864180"", ""True"", ""ExpressionStatement"", ""L = getDebugLocation ( Loc )""]","[[[""False""], [864208, ""True"", ""shouldIgnoreAbstractClosure ( Loc , DS ) || ( Fn && Fn -> isThunk ( ) )"", ""Condition""]], [[""False""], [864244, ""True"", ""! Scope"", ""Condition""]], [[], [864269, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""shouldIgnoreAbstractClosure"", ""SILFunction *"", ""Fn -> isThunk"", ""&&"", ""||""], ""False""], [[""!"", ""Scope"", null], ""False""]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""899045"", ""True"", ""Parameter"", ""Optional < SILLocation > OptLoc""]","[[[], [899074, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""887243"", ""True"", ""Parameter"", ""SILLocation Loc""]","[[[], [887275, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""887268"", ""True"", ""Condition"", ""Loc . isDebugInfoLoc ( )""]","[[[], [887275, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""887261"", ""True"", ""ReturnStatement"", ""return Loc . getDebugInfoLoc ( ) ;""]","[[[], [887268, ""True"", ""Loc . isDebugInfoLoc ( )"", ""Condition""]], [[], [887275, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""887248"", ""True"", ""ReturnStatement"", ""return decodeSourceLoc ( Loc . getDebugSourceLoc ( ) ) ;""]","[[[], [887268, ""True"", ""Loc . isDebugInfoLoc ( )"", ""Condition""]], [[], [887275, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""887285"", ""True"", ""Parameter"", ""Optional < SILLocation > OptLoc""]","[[[], [887314, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""899050"", ""True"", ""ReturnStatement"", ""return OptLoc -> decodeDebugLoc ( SM ) ;""]","[[[""False"", ""True""], [899074, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""887290"", ""True"", ""ReturnStatement"", ""return decodeDebugLoc ( * OptLoc ) ;""]","[[[""False"", ""True""], [887314, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""899229"", ""True"", ""ExpressionStatement"", ""L = CS -> Loc . decodeDebugLoc ( SM )""]","[[[""True""], [899284, ""True"", ""N < Scopes . size ( )"", ""Condition""]], [[""False"", ""True""], [899358, ""True"", ""DS"", ""Condition""]], [[], [899367, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""unsigned"", ""Scopes . size"", ""<""], ""True""], [[null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""887493"", ""True"", ""ExpressionStatement"", ""L = decodeDebugLoc ( CS -> Loc )""]","[[[""False""], [887514, ""True"", ""CachedInlinedAt != InlinedAtCache . end ( )"", ""Condition""]], [[""False""], [887538, ""True"", ""! CS"", ""Condition""]], [[], [887551, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""CachedInlinedAt"", ""InlinedAtCache . end"", ""!=""], ""False""], [[""!"", ""CS"", null], ""False""]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""899761"", ""True"", ""ExpressionStatement"", ""L = getDebugLocation ( Loc , SM )""]","[[[""False""], [899775, ""True"", ""! Scope"", ""Condition""]], [[], [899805, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Scope"", null], ""False""]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""887940"", ""True"", ""ExpressionStatement"", ""L = getDebugLocation ( Loc )""]","[[[""False""], [887952, ""True"", ""! Scope"", ""Condition""]], [[], [887977, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Scope"", null], ""False""]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""900952"", ""True"", ""ExpressionStatement"", ""Loc = getDebugLoc ( SM , NTD )""]",[],[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""889140"", ""True"", ""ExpressionStatement"", ""Loc = getDebugLoc ( * this , NTD )""]",[],[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""901999"", ""True"", ""ExpressionStatement"", ""L = DS -> Loc . decodeDebugLoc ( SM )""]","[[[""False"", ""False"", ""True""], [902012, ""True"", ""DS && ( ! SILFn || ( ! SILFn -> isBare ( ) && ! SILFn -> isThunk ( ) ) )"", ""Condition""]], [[""False"", ""False"", ""True""], [902186, ""True"", ""Cached != ScopeCache . end ( )"", ""Condition""]], [[], [902207, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""SILFn"", null, ""!"", ""SILFn -> isBare"", null, ""!"", ""SILFn -> isThunk"", null, ""&&"", ""||""], """"], [[""Cached"", ""ScopeCache . end"", ""!=""], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""890193"", ""True"", ""ExpressionStatement"", ""L = decodeDebugLoc ( DS -> Loc )""]","[[[""False"", ""False"", ""True""], [890204, ""True"", ""DS && ( ! SILFn || ( ! SILFn -> isBare ( ) && ! SILFn -> isThunk ( ) ) )"", ""Condition""]], [[""False"", ""False"", ""True""], [890378, ""True"", ""Cached != ScopeCache . end ( )"", ""Condition""]], [[], [890404, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""SILFn"", null, ""!"", ""SILFn -> isBare"", null, ""!"", ""SILFn -> isThunk"", null, ""&&"", ""||""], """"], [[""Cached"", ""ScopeCache . end"", ""!=""], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""902327"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , D )""]","[[[""False""], [902366, ""True"", ""! M"", ""Condition""]], [[""True"", ""False""], [902428, ""True"", ""Opts . DebugInfoKind <= IRGenDebugInfoKind :: LineTables"", ""Condition""]], [[], [902434, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""swift :: ModuleDecl *"", null], ""False""], [[""Opts"", ""DebugInfoKind"", null, ""IRGenDebugInfoKind :: LineTables"", ""<=""], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""890525"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , D )""]","[[[""False""], [890566, ""True"", ""! M"", ""Condition""]], [[""True"", ""False""], [890628, ""True"", ""Opts . DebugInfoKind <= IRGenDebugInfoKind :: LineTables"", ""Condition""]], [[], [890634, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""swift :: ModuleDecl *"", null], ""False""], [[""Opts"", ""DebugInfoKind"", null, ""IRGenDebugInfoKind :: LineTables"", ""<=""], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""903826"", ""True"", ""ExpressionStatement"", ""Loc = getDebugLoc ( SM , VarDecl )""]","[[[""False"", ""True""], [903887, ""True"", ""Opts . DebugInfoKind <= IRGenDebugInfoKind :: LineTables"", ""Condition""]], [[""False"", ""True""], [903895, ""True"", ""! DS"", ""Condition""]], [[""True""], [903921, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Opts"", ""DebugInfoKind"", null, ""IRGenDebugInfoKind :: LineTables"", ""<=""], """"], [[""!"", ""const SILDebugScope *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""892027"", ""True"", ""ExpressionStatement"", ""Loc = getDebugLoc ( * this , VarDecl )""]","[[[""False"", ""True""], [892090, ""True"", ""Opts . DebugInfoKind <= IRGenDebugInfoKind :: LineTables"", ""Condition""]], [[""False"", ""True""], [892098, ""True"", ""! DS"", ""Condition""]], [[""True""], [892124, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""Opts"", ""DebugInfoKind"", null, ""IRGenDebugInfoKind :: LineTables"", ""<=""], """"], [[""!"", ""const SILDebugScope *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""909096"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: Struct""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Struct"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""897321"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: Struct""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Struct"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""908970"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: Class""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Class"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""897193"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: Class""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Class"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""908707"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: Protocol""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Protocol"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""896928"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: Protocol""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Protocol"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""908636"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: ProtocolComposition""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: ProtocolComposition"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""896855"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: ProtocolComposition""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: ProtocolComposition"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""908552"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: UnboundGeneric""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: UnboundGeneric"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""896769"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: UnboundGeneric""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: UnboundGeneric"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""908463"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: BoundGenericStruct""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericStruct"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""896678"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: BoundGenericStruct""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericStruct"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""908391"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: BoundGenericClass""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericClass"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""896604"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: BoundGenericClass""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericClass"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""908179"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Archetype -> getAssocType ( ) )""]","[[[""case TypeKind :: Archetype""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Archetype"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""896390"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Archetype -> getAssocType ( ) )""]","[[[""case TypeKind :: Archetype""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Archetype"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""907910"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , DbgTy . getDecl ( ) )""]","[[[""case TypeKind :: Metatype"", ""case TypeKind :: ExistentialMetatype""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""896119"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , DbgTy . getDecl ( ) )""]","[[[""case TypeKind :: Metatype"", ""case TypeKind :: ExistentialMetatype""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""907772"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: Enum""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Enum"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""895979"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: Enum""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: Enum"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""907656"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: BoundGenericEnum""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericEnum"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""895861"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: BoundGenericEnum""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: BoundGenericEnum"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""907449"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , DbgTy . getDecl ( ) )""]","[[[""case TypeKind :: WeakStorage"", ""case TypeKind :: UnmanagedStorage"", ""case TypeKind :: UnownedStorage""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""895652"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , DbgTy . getDecl ( ) )""]","[[[""case TypeKind :: WeakStorage"", ""case TypeKind :: UnmanagedStorage"", ""case TypeKind :: UnownedStorage""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,-,"[""907373"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( SM , Decl )""]","[[[""case TypeKind :: NameAlias""], [909506, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [909585, ""True"", ""! BaseTy"", ""Condition""]], [[], [909664, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: NameAlias"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/IRGen/IRGenDebugInfo.cpp,+,"[""895574"", ""True"", ""ExpressionStatement"", ""L = getDebugLoc ( * this , Decl )""]","[[[""case TypeKind :: NameAlias""], [897733, ""True"", ""BaseTy -> getKind ( )"", ""Condition""]], [[], [897812, ""True"", ""! BaseTy"", ""Condition""]], [[], [897891, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""BaseTy -> getKind ( )"", ""TypeKind :: NameAlias"", ""==""], null], [[""!"", ""TypeBase *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SIL/SILDebugScope.cpp,+,"[""910373"", ""True"", ""Parameter"", ""SILFunction * SILFn""]","[[[], [910402, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SIL/SILDebugScope.cpp,+,"[""910387"", ""True"", ""ExpressionStatement"", ""assert ( SILFn && \""no parent provided\"" )""]","[[[], [910400, ""True"", ""ParentScope"", ""Condition""]], [[], [910402, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SIL/SILDebugScope.cpp,+,"[""910412"", ""True"", ""Parameter"", ""SILLocation Loc""]","[[[], [910416, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SIL/SILDebugScope.cpp,+,"[""910437"", ""True"", ""ExpressionStatement"", """"]","[[[""False""], [910494, ""True"", ""Parent . isNull ( )"", ""Condition""]], [[], [910501, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SIL/SILPrinter.cpp,-,"[""930572"", ""True"", ""ExpressionStatement"", ""CallSite . getSourceLoc ( ) . print ( PrintState . OS , M . getASTContext ( ) . SourceMgr , LastBufferID )""]","[[[""False"", ""True""], [930599, ""True"", ""! CallSite . isNull ( ) && CallSite . isASTNode ( )"", ""Condition""]], [[""False"", ""True""], [930695, ""True"", ""DS"", ""Condition""]], [[""True"", ""False"", ""True"", ""True"", ""False"", ""False"", ""True""], [930969, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""CallSite . isNull"", null], """"], [[null], """"], [[null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SIL/SILPrinter.cpp,+,"[""913683"", ""True"", ""ExpressionStatement"", ""CallSite . getSourceLoc ( ) . print ( PrintState . OS , M . getASTContext ( ) . SourceMgr , LastBufferID )""]","[[[""True""], [913710, ""True"", ""! CallSite . isNull ( ) && CallSite . isASTNode ( )"", ""Condition""]], [[""True""], [913773, ""True"", ""CS = CS -> InlinedCallSite"", ""Condition""]], [[""False"", ""True"", ""False""], [913795, ""True"", ""! DS"", ""Condition""]], [[""True"", ""False"", ""True"", ""True"", ""False"", ""False"", ""True""], [914071, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""CallSite . isNull"", null], ""True""], [[null], ""True""], [[""const SILDebugScope *"", ""const SILDebugScope *"", ""InlinedCallSite"", null, ""=""], ""True""], [[""!"", ""const SILDebugScope *"", null], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""946778"", ""True"", ""ExpressionStatement"", ""SILDebugScope ( AI . getLoc ( ) , & F , AIScope )""]","[[[""False""], [946811, ""True"", ""IKind == InlineKind :: MandatoryInline"", ""Condition""]], [[""False"", ""True"", ""True""], [947123, ""True"", ""AI . getFunction ( ) == CalleeFunction"", ""Condition""]], [[], [947147, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""IKind"", ""InlineKind :: MandatoryInline"", ""==""], ""False""], [[""AI . getFunction"", ""SILFunction *"", ""==""], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""946762"", ""True"", ""ExpressionStatement"", ""assert ( CallSiteScope -> getParentFunction ( ) == & F )""]","[[[""False""], [946811, ""True"", ""IKind == InlineKind :: MandatoryInline"", ""Condition""]], [[""False"", ""True"", ""True""], [947123, ""True"", ""AI . getFunction ( ) == CalleeFunction"", ""Condition""]], [[], [947147, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""IKind"", ""InlineKind :: MandatoryInline"", ""==""], ""False""], [[""AI . getFunction"", ""SILFunction *"", ""==""], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SILOptimizer/Utils/SILInliner.cpp,+,"[""944985"", ""True"", ""ExpressionStatement"", ""SILDebugScope ( AI . getLoc ( ) , nullptr , AIScope , AIScope -> InlinedCallSite )""]","[[[""False""], [945020, ""True"", ""IKind == InlineKind :: MandatoryInline"", ""Condition""]], [[""False"", ""True"", ""True""], [945332, ""True"", ""AI . getFunction ( ) == CalleeFunction"", ""Condition""]], [[], [945356, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""IKind"", ""InlineKind :: MandatoryInline"", ""==""], ""False""], [[""AI . getFunction"", ""SILFunction *"", ""==""], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SILOptimizer/Utils/SILInliner.cpp,+,"[""944957"", ""True"", ""ExpressionStatement"", ""assert ( CallSiteScope -> getParentFunction ( ) == & F )""]","[[[""True"", ""False""], [945332, ""True"", ""AI . getFunction ( ) == CalleeFunction"", ""Condition""]], [[], [945356, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""AI . getFunction"", ""SILFunction *"", ""==""], """"]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""947407"", ""True"", ""ExpressionStatement"", ""assert ( CalleeScope )""]","[[[], [947414, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""947355"", ""True"", ""ExpressionStatement"", ""SILDebugScope ( CallSiteScope , CalleeScope )""]","[[[""False""], [947386, ""True"", ""it != InlinedScopeCache . end ( )"", ""Condition""]], [[], [947414, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""it"", ""InlinedScopeCache . end"", ""!=""], ""False""]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SILOptimizer/Utils/SILInliner.cpp,-,"[""947340"", ""True"", ""ExpressionStatement"", ""assert ( CallSiteScope -> Parent == InlineScope -> InlinedCallSite -> Parent )""]","[[[""False""], [947386, ""True"", ""it != InlinedScopeCache . end ( )"", ""Condition""]], [[], [947414, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""it"", ""InlinedScopeCache . end"", ""!=""], ""False""]]"
"Improve the performance of IRGenDebugInfo

This commit changes how inline information is stored in SILDebugScope
from a tree to a linear chain of inlined call sites (similar to what
LLVM is using). This makes creating inlined SILDebugScopes slightly
more expensive, but makes lowering SILDebugScopes into LLVM metadata
much faster because entire inlined-at chains can now be cached. This
means that SIL is no longer preserve the inlining history (i.e., ((a
was inlined into b) was inlined into c) is represented the same as (a
was inlined into (b was inlined into c)), but this information was not
used by anyone.

On my late 2012 i7 iMac, this saves about 4 seconds when compiling the
RelWithDebInfo x86_64 swift standard library — or 40% of IRGen time.

rdar://problem/28311051",lib/SILOptimizer/Utils/SILInliner.cpp,+,"[""945583"", ""True"", ""Statement"", ""(""]","[[[""False""], [945630, ""True"", ""it != InlinedScopeCache . end ( )"", ""Condition""]], [[""False""], [945654, ""True"", ""! CalleeScope"", ""Condition""]], [[], [945658, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""it"", ""InlinedScopeCache . end"", ""!=""], ""False""], [[""!"", ""const SILDebugScope *"", null], ""False""]]"
Merge pull request #8550 from DougGregor/repeal-conformance-death-tax,lib/AST/ProtocolConformance.cpp,-,"[""957007"", ""True"", ""ExpressionStatement"", ""assert ( inherited -> getType ( ) -> isEqual ( spec -> getGenericConformance ( ) -> getType ( ) ) && \""inherited conformance doesn't match type?!\"" )""]","[[[""case ProtocolConformanceKind :: Specialized""], [957066, ""True"", ""getKind ( )"", ""Condition""]], [[], [957086, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""getKind ( )"", ""ProtocolConformanceKind :: Specialized"", ""==""], null]]"
Merge pull request #8550 from DougGregor/repeal-conformance-death-tax,lib/AST/ProtocolConformance.cpp,-,"[""956916"", ""True"", ""ExpressionStatement"", ""assert ( getType ( ) -> isEqual ( r -> getType ( ) ) && \""substitution didn't produce conformance for same type?!\"" )""]","[[[""case ProtocolConformanceKind :: Specialized""], [957066, ""True"", ""getKind ( )"", ""Condition""]], [[], [957086, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""getKind ( )"", ""ProtocolConformanceKind :: Specialized"", ""==""], null]]"
Merge pull request #8550 from DougGregor/repeal-conformance-death-tax,lib/AST/ProtocolConformance.cpp,-,"[""956854"", ""True"", ""ExpressionStatement"", ""assert ( protoInherited -> getType ( ) -> isEqual ( classInherited -> getInheritedConformance ( ) -> getType ( ) ) && \""inherited conformance doesn't match type?!\"" )""]","[[[""case ProtocolConformanceKind :: Inherited""], [957066, ""True"", ""getKind ( )"", ""Condition""]], [[], [957086, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""getKind ( )"", ""ProtocolConformanceKind :: Inherited"", ""==""], null]]"
Merge pull request #8550 from DougGregor/repeal-conformance-death-tax,lib/AST/ProtocolConformance.cpp,-,"[""956751"", ""True"", ""ExpressionStatement"", ""assert ( ! isComplete ( ) && \""Missing inherited mapping in conformance\"" )""]","[[[""False""], [956777, ""True"", ""inheritedMapping . first -> inheritsFrom ( protocol )"", ""Condition""]], [[""False""], [956801, ""True"", ""known != inherited . end ( )"", ""Condition""]], [[""case ProtocolConformanceKind :: Normal""], [957066, ""True"", ""getKind ( )"", ""Condition""]], [[], [957086, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[""known"", ""inherited . end"", ""!=""], ""False""], [[""getKind ( )"", ""ProtocolConformanceKind :: Normal"", ""==""], null]]"
Merge pull request #8550 from DougGregor/repeal-conformance-death-tax,lib/AST/ProtocolConformance.cpp,-,"[""956737"", ""True"", ""ExpressionStatement"", ""assert ( C . getLazyResolver ( ) && \""Need a lazy resolver\"" )""]","[[[""False""], [956777, ""True"", ""inheritedMapping . first -> inheritsFrom ( protocol )"", ""Condition""]], [[""False""], [956801, ""True"", ""known != inherited . end ( )"", ""Condition""]], [[""case ProtocolConformanceKind :: Normal""], [957066, ""True"", ""getKind ( )"", ""Condition""]], [[], [957086, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[""known"", ""inherited . end"", ""!=""], ""False""], [[""getKind ( )"", ""ProtocolConformanceKind :: Normal"", ""==""], null]]"
Merge pull request #8550 from DougGregor/repeal-conformance-death-tax,lib/SILGen/SILGenType.cpp,-,"[""965024"", ""True"", ""ExpressionStatement"", ""assert ( foundBaseConformance != Conformance -> getInheritedConformances ( ) . end ( ) && \""no inherited conformance for base protocol\"" )""]","[[[], [965074, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8550 from DougGregor/repeal-conformance-death-tax,lib/Serialization/Deserialization.cpp,-,"[""993118"", ""True"", ""ExpressionStatement"", ""assert ( inheritedRef . isConcrete ( ) )""]","[[[""True""], [993140, ""True"", ""inheritedCount --"", ""Condition""]], [[""True"", ""False"", ""True""], [993235, ""True"", ""conformanceEntry . isComplete ( )"", ""Condition""]], [[""False""], [993357, ""True"", ""kind != NORMAL_PROTOCOL_CONFORMANCE"", ""Condition""]], [[""False""], [993414, ""True"", ""entry . Kind != llvm :: BitstreamEntry :: Record"", ""Condition""]]]","[[[""unsigned"", null, null], ""True""], [[null], """"], [[""unsigned"", ""NORMAL_PROTOCOL_CONFORMANCE"", ""!=""], ""False""], [[""entry"", ""Kind"", null, ""llvm :: BitstreamEntry :: Record"", ""!=""], ""False""]]"
Merge pull request #8550 from DougGregor/repeal-conformance-death-tax,lib/Serialization/Serialization.cpp,-,"[""1043751"", ""True"", ""ExpressionStatement"", ""writeConformance ( conformance -> getInheritedConformance ( inheritedProto ) , DeclTypeAbbrCodes )""]",[],[]
"Start emitting begin_access markers for local and global vars.
NFC by default.

I had a much more comprehensive version of this patch that I had to
back out in order to just get something in to unblock progress.
There's a lot of technical debt in SILGen around l-values.

Enabling this will almost certainly not get past the SIL passes.",lib/SILGen/SILGenLValue.cpp,+,"[""1065259"", ""True"", ""ExpressionStatement"", ""assert ( var -> getDeclContext ( ) -> isTypeContext ( ) && ! var -> isInstanceMember ( ) )""]","[[[""False""], [1065297, ""True"", ""var -> getDeclContext ( ) -> isModuleScopeContext ( )"", ""Condition""]], [[""True""], [1065321, ""True"", ""var -> getDeclContext ( ) -> isLocalContext ( )"", ""Condition""]], [[""case AccessStrategy :: Storage""], [1065333, ""True"", ""! var -> isLet ( )"", ""Condition""]], [[""case AccessStrategy :: Storage""], [1065474, ""True"", ""var -> getAccessStrategy ( semantics , accessKind )"", ""Condition""]]]","[[[null], ""False""], [[null], ""True""], [[""! var -> isLet ( )"", ""AccessStrategy :: Storage"", ""==""], null], [[""var -> getAccessStrategy ( semantics , accessKind )"", ""AccessStrategy :: Storage"", ""==""], null]]"
"[AST] Eliminate ""inherited conformances"" from NormalProtocolConformance.

All of this information is recoverable from the more-general,
more-sane signature conformances, so stop
recording/serializing/deserializing all of this extra stuff.",lib/Serialization/Deserialization.cpp,-,"[""1120341"", ""True"", ""ExpressionStatement"", ""assert ( inheritedRef . isConcrete ( ) )""]","[[[""True""], [1120363, ""True"", ""inheritedCount --"", ""Condition""]], [[""True"", ""False"", ""True""], [1120458, ""True"", ""conformanceEntry . isComplete ( )"", ""Condition""]], [[""False""], [1120580, ""True"", ""kind != NORMAL_PROTOCOL_CONFORMANCE"", ""Condition""]], [[""False""], [1120637, ""True"", ""entry . Kind != llvm :: BitstreamEntry :: Record"", ""Condition""]]]","[[[""unsigned"", null, null], ""True""], [[null], """"], [[""unsigned"", ""NORMAL_PROTOCOL_CONFORMANCE"", ""!=""], ""False""], [[""entry"", ""Kind"", null, ""llvm :: BitstreamEntry :: Record"", ""!=""], ""False""]]"
"[AST] Eliminate ""inherited conformances"" from NormalProtocolConformance.

All of this information is recoverable from the more-general,
more-sane signature conformances, so stop
recording/serializing/deserializing all of this extra stuff.",lib/Serialization/Serialization.cpp,-,"[""1170974"", ""True"", ""ExpressionStatement"", ""writeConformance ( conformance -> getInheritedConformance ( inheritedProto ) , DeclTypeAbbrCodes )""]",[],[]
Stop using ProtocolConformance::getInheritedConformances(),lib/SILGen/SILGenType.cpp,-,"[""1195385"", ""True"", ""ExpressionStatement"", ""assert ( foundBaseConformance != Conformance -> getInheritedConformances ( ) . end ( ) && \""no inherited conformance for base protocol\"" )""]","[[[], [1195435, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[AST] Reimplement ProtocolConformance::getInheritedConformance().

Use getAssociatedConformance() instead, which is far simpler and more correct.",lib/AST/ProtocolConformance.cpp,-,"[""1207847"", ""True"", ""ExpressionStatement"", ""assert ( inherited -> getType ( ) -> isEqual ( spec -> getGenericConformance ( ) -> getType ( ) ) && \""inherited conformance doesn't match type?!\"" )""]","[[[""case ProtocolConformanceKind :: Specialized""], [1207906, ""True"", ""getKind ( )"", ""Condition""]], [[], [1207926, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""getKind ( )"", ""ProtocolConformanceKind :: Specialized"", ""==""], null]]"
"[AST] Reimplement ProtocolConformance::getInheritedConformance().

Use getAssociatedConformance() instead, which is far simpler and more correct.",lib/AST/ProtocolConformance.cpp,-,"[""1207756"", ""True"", ""ExpressionStatement"", ""assert ( getType ( ) -> isEqual ( r -> getType ( ) ) && \""substitution didn't produce conformance for same type?!\"" )""]","[[[""case ProtocolConformanceKind :: Specialized""], [1207906, ""True"", ""getKind ( )"", ""Condition""]], [[], [1207926, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""getKind ( )"", ""ProtocolConformanceKind :: Specialized"", ""==""], null]]"
"[AST] Reimplement ProtocolConformance::getInheritedConformance().

Use getAssociatedConformance() instead, which is far simpler and more correct.",lib/AST/ProtocolConformance.cpp,-,"[""1207694"", ""True"", ""ExpressionStatement"", ""assert ( protoInherited -> getType ( ) -> isEqual ( classInherited -> getInheritedConformance ( ) -> getType ( ) ) && \""inherited conformance doesn't match type?!\"" )""]","[[[""case ProtocolConformanceKind :: Inherited""], [1207906, ""True"", ""getKind ( )"", ""Condition""]], [[], [1207926, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""getKind ( )"", ""ProtocolConformanceKind :: Inherited"", ""==""], null]]"
"[AST] Reimplement ProtocolConformance::getInheritedConformance().

Use getAssociatedConformance() instead, which is far simpler and more correct.",lib/AST/ProtocolConformance.cpp,-,"[""1207591"", ""True"", ""ExpressionStatement"", ""assert ( ! isComplete ( ) && \""Missing inherited mapping in conformance\"" )""]","[[[""False""], [1207617, ""True"", ""inheritedMapping . first -> inheritsFrom ( protocol )"", ""Condition""]], [[""False""], [1207641, ""True"", ""known != inherited . end ( )"", ""Condition""]], [[""case ProtocolConformanceKind :: Normal""], [1207906, ""True"", ""getKind ( )"", ""Condition""]], [[], [1207926, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[""known"", ""inherited . end"", ""!=""], ""False""], [[""getKind ( )"", ""ProtocolConformanceKind :: Normal"", ""==""], null]]"
"[AST] Reimplement ProtocolConformance::getInheritedConformance().

Use getAssociatedConformance() instead, which is far simpler and more correct.",lib/AST/ProtocolConformance.cpp,-,"[""1207577"", ""True"", ""ExpressionStatement"", ""assert ( C . getLazyResolver ( ) && \""Need a lazy resolver\"" )""]","[[[""False""], [1207617, ""True"", ""inheritedMapping . first -> inheritsFrom ( protocol )"", ""Condition""]], [[""False""], [1207641, ""True"", ""known != inherited . end ( )"", ""Condition""]], [[""case ProtocolConformanceKind :: Normal""], [1207906, ""True"", ""getKind ( )"", ""Condition""]], [[], [1207926, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[""known"", ""inherited . end"", ""!=""], ""False""], [[""getKind ( )"", ""ProtocolConformanceKind :: Normal"", ""==""], null]]"
"Cache Code Completion results from PCH files

- Add CompilerInvocation::getPCHHash
  This will be used when creating a unique filename for a persistent
  precompiled bridging header.

- Automatically generate and use a precompiled briding header
  When we're given both -import-objc-header and -pch-output-dir
  arguments, we will try to:
  - Validate what we think the PCH filename should be for the bridging
    header, based on the Swift PCH hash and the clang module hash.
    - If we're successful, we'll just use it.
    - If it's out of date or something else is wrong, we'll try to
      emit it.
  - This gives us a single filename which we can `stat` to check for the
    validity of our code completion cache, which is keyed off of module
    name, module filename, and module file age.

- Cache code completion results from imported modules
  If we just have a single .PCH file imported, we can use that file as
  part of the key used to cache declarations in a module.  Because
  multiple files can contribute to the __ObjC module, we've always given
  it the phony filename ""<imports>"", which never exists, so `stat`-ing it
  always fails and we never cache declarations in it.

  This is extremely problematic for projects with huge bridging headers.
  In the case where we have a single PCH import, this can bring warm code
  completion times down to about 500ms from over 2-3s, so it can provide a
  nice performance win for IDEs.

- Add a new test that performs two code-completion requests with a bridging header.
- Add some -pch-output-dir flags to existing SourceKit tests that import a bridging
  header.

rdar://problem/31198982",tools/SourceKit/tools/sourcekitd/bin/XPC/Client/sourcekitd.cpp,+,"[""1210391"", ""True"", ""ExpressionStatement"", ""llvm :: InitializeAllAsmPrinters ( )""]","[[[], [1210411, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Cache Code Completion results from PCH files

- Add CompilerInvocation::getPCHHash
  This will be used when creating a unique filename for a persistent
  precompiled bridging header.

- Automatically generate and use a precompiled briding header
  When we're given both -import-objc-header and -pch-output-dir
  arguments, we will try to:
  - Validate what we think the PCH filename should be for the bridging
    header, based on the Swift PCH hash and the clang module hash.
    - If we're successful, we'll just use it.
    - If it's out of date or something else is wrong, we'll try to
      emit it.
  - This gives us a single filename which we can `stat` to check for the
    validity of our code completion cache, which is keyed off of module
    name, module filename, and module file age.

- Cache code completion results from imported modules
  If we just have a single .PCH file imported, we can use that file as
  part of the key used to cache declarations in a module.  Because
  multiple files can contribute to the __ObjC module, we've always given
  it the phony filename ""<imports>"", which never exists, so `stat`-ing it
  always fails and we never cache declarations in it.

  This is extremely problematic for projects with huge bridging headers.
  In the case where we have a single PCH import, this can bring warm code
  completion times down to about 500ms from over 2-3s, so it can provide a
  nice performance win for IDEs.

- Add a new test that performs two code-completion requests with a bridging header.
- Add some -pch-output-dir flags to existing SourceKit tests that import a bridging
  header.

rdar://problem/31198982",tools/SourceKit/tools/sourcekitd/lib/API/Requests.cpp,+,"[""1213596"", ""True"", ""ExpressionStatement"", ""llvm :: InitializeAllAsmPrinters ( )""]","[[[], [1213611, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8546 from rudkx/propagate-constraints,lib/Sema/CSPropagate.cpp,-,"[""1242433"", ""True"", ""ExpressionStatement"", ""assert ( tyvar -> isEqual ( found -> getNestedConstraints ( ) . front ( ) -> getFirstType ( ) ) )""]","[[[""False""], [1242531, ""True"", ""! found"", ""Condition""]], [[], [1242620, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Constraint *"", null], ""False""]]"
"Merge pull request #8454 from swiftix/wip-warn-about-unused-generic-params

[type-checker] More correct way to determine if a given generic parameter of a function cannot be inferred because it is not used",lib/Sema/TypeCheckGeneric.cpp,+,"[""1246753"", ""True"", ""ExpressionStatement"", ""assert ( t -> isTypeParameter ( ) )""]","[[[""False"", ""True""], [1246992, ""True"", ""! genericParams"", ""Condition""]], [[], [1247008, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""genericParams"", null], """"]]"
"[Constraint solver] Remove invalid assert from constraint propagation.

It turns out that for disjunctions formed for subscripts, we have an
explicit function type (e.g. ($T1)->$T2) for the LHS of the bind
overload constraint, and when a subscript is mixed with an explicit
call (e.g. x[i](2)) we end up with an applicable function constraint
where the RHS is $T2 (which is a function type itself), so this assert
was invalid.

Fundamentally the assert wasn't checking anything important, so it won't
be missed. The important check here is that the applicable function
constraint that we started with is only involved in one disjunction
since we're only returning one.

This shows up in test/Constraints/overload.swift when I run it with
-propagate-constraints enabled:
  func test20886179(_ handlers: [(Int) -> Void], buttonIndex: Int) {
    handlers[buttonIndex](buttonIndex)
  }",lib/Sema/CSPropagate.cpp,-,"[""1267233"", ""True"", ""ExpressionStatement"", ""assert ( tyvar -> isEqual ( found -> getNestedConstraints ( ) . front ( ) -> getFirstType ( ) ) )""]","[[[""False""], [1267331, ""True"", ""! found"", ""Condition""]], [[], [1267420, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""Constraint *"", null], ""False""]]"
"Merge pull request #8489 from swiftix/wip-func-sig-opt-generic-functions-3

[sil-function-signature-opt] Support FSO for generic functions",lib/SILOptimizer/Analysis/ARCAnalysis.cpp,-,"[""1275875"", ""True"", ""Parameter"", ""RCIdentityFunctionInfo * RCFI""]","[[[], [1275884, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Merge pull request #8489 from swiftix/wip-func-sig-opt-generic-functions-3

[sil-function-signature-opt] Support FSO for generic functions",lib/SILOptimizer/Analysis/ARCAnalysis.cpp,+,"[""1271370"", ""True"", ""Statement"", "")""]","[[[""False""], [1271445, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Merge pull request #8489 from swiftix/wip-func-sig-opt-generic-functions-3

[sil-function-signature-opt] Support FSO for generic functions",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"[""1280391"", ""True"", ""ExpressionStatement"", ""llvm :: dbgs ( ) << \""None of generic parameters are used by \"" << F -> getName ( ) << \""\\n\""""]","[[[""True""], [1280409, ""True"", ""! UsesGenerics"", ""Condition""]], [[""True""], [1280426, ""True"", ""HasGenericSignature"", ""Condition""]], [[""False"", ""False""], [1280586, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""bool"", null], ""True""], [[null], ""True""]]"
"Merge pull request #8489 from swiftix/wip-func-sig-opt-generic-functions-3

[sil-function-signature-opt] Support FSO for generic functions",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"[""1280295"", ""True"", ""Condition"", ""ExpectedFTy -> hasErrorResult ( )""]","[[[""False"", ""True""], [1280586, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"Merge pull request #8489 from swiftix/wip-func-sig-opt-generic-functions-3

[sil-function-signature-opt] Support FSO for generic functions",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"[""1280286"", ""True"", ""ExpressionStatement"", ""InterfaceErrorResult = ExpectedFTy -> getErrorResult ( )""]","[[[""False"", ""True""], [1280295, ""True"", ""ExpectedFTy -> hasErrorResult ( )"", ""Condition""]], [[""False"", ""True""], [1280586, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
"Merge pull request #8489 from swiftix/wip-func-sig-opt-generic-functions-3

[sil-function-signature-opt] Support FSO for generic functions",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,-,"[""1286533"", ""True"", ""ExpressionStatement"", ""Retains = EA -> get ( F ) -> computeEpilogueARCInstructions ( EpilogueARCContext :: EpilogueARCKind :: Retain , RV )""]","[[[""False""], [1286566, ""True"", ""! RV"", ""Condition""]], [[""True""], [1286580, ""True"", ""ResultDescList [ 0 ] . hasConvention ( ResultConvention :: Owned )"", ""Condition""]], [[""False""], [1286601, ""True"", ""fnConv . getNumDirectSILResults ( ) != 1"", ""Condition""]], [[], [1286620, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""RV"", null], ""False""], [[null], ""True""], [[""fnConv . getNumDirectSILResults"", ""1"", ""!=""], ""False""]]"
"Merge pull request #8489 from swiftix/wip-func-sig-opt-generic-functions-3

[sil-function-signature-opt] Support FSO for generic functions",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"[""1282297"", ""True"", ""ExpressionStatement"", ""Retains = EA -> get ( F ) -> computeEpilogueARCInstructions ( EpilogueARCContext :: EpilogueARCKind :: Retain , RV )""]","[[[""False""], [1282330, ""True"", ""! RV"", ""Condition""]], [[""True""], [1282344, ""True"", ""ResultDescList [ 0 ] . hasConvention ( ResultConvention :: Owned )"", ""Condition""]], [[""False""], [1282365, ""True"", ""! fnConv . getIndirectSILResults ( ) . empty ( )"", ""Condition""]], [[], [1282382, ""True"", ""fnConv . getNumDirectSILResults ( ) != 1"", ""Condition""]]]","[[[""!"", ""RV"", null], ""False""], [[null], ""True""], [[""!"", ""fnConv . getIndirectSILResults ( ) . empty"", null], ""False""], [[""fnConv . getNumDirectSILResults"", ""1"", ""!=""], """"]]"
Merge pull request #8521 from DougGregor/substitutionmap-conformance-access-path,lib/AST/GenericEnvironment.cpp,-,"[""1291846"", ""True"", ""ExpressionStatement"", ""assert ( secondArchetype == archetype )""]","[[[""False""], [1291953, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8521 from DougGregor/substitutionmap-conformance-access-path,lib/AST/ProtocolConformance.cpp,+,"[""1294745"", ""True"", ""ExpressionStatement"", ""assert ( ! getSignatureConformances ( ) . empty ( ) && \""signature conformances not yet computed\"" )""]","[[[], [1294778, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8521 from DougGregor/substitutionmap-conformance-access-path,lib/AST/SubstitutionMap.cpp,+,"[""1303071"", ""True"", ""ExpressionStatement"", ""assert ( ! ( type -> isTypeParameter ( ) && ! getGenericSignature ( ) ) && \""type parameter substitution map without generic signature\"" )""]","[[[], [1303094, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8521 from DougGregor/substitutionmap-conformance-access-path,lib/AST/SubstitutionMap.cpp,+,"[""1303061"", ""True"", ""Statement"", ""&&""]","[[[], [1303094, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8521 from DougGregor/substitutionmap-conformance-access-path,lib/AST/SubstitutionMap.cpp,-,"[""1306259"", ""True"", ""ExpressionStatement"", ""assert ( type && parent && assocType )""]","[[[], [1306270, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8521 from DougGregor/substitutionmap-conformance-access-path,lib/AST/SubstitutionMap.cpp,-,"[""1307766"", ""True"", ""ExpressionStatement"", ""parent . first -> print ( out )""]","[[[], [1307940, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8521 from DougGregor/substitutionmap-conformance-access-path,lib/AST/SubstitutionMap.cpp,-,"[""1307724"", ""True"", ""ExpressionStatement"", ""parentType . first -> print ( out )""]","[[[], [1307940, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[ClangImporter] Fix versioned stubs for functions-as-members. (#8539)

That is, the stubs we generate when you rename a C global function
imported as a type member using the SwiftName API note. (See the
test case changes.) Previously we hit an assertion.

For good measure, also fix versioned stubs for types-as-members,
which were always added to their original context rather than the
new context.

rdar://problem/31435658",lib/ClangImporter/ImportDecl.cpp,-,"[""1364118"", ""True"", ""ExpressionStatement"", ""assert ( ! correctSwiftName && \""Swift 2 didn't support import-as-member!\"" )""]","[[[""False""], [1364129, ""True"", ""importedName . importAsMember ( )"", ""Condition""]], [[""False""], [1364158, ""True"", ""! dc"", ""Condition""]], [[], [1364181, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], ""False""], [[""!"", ""dc"", null], ""False""]]"
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1390982"", ""True"", ""ExpressionStatement"", ""assert ( Arg -> hasValue ( ) && \""Expected to have a result\"" )""]","[[[], [1390996, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1390940"", ""True"", ""ExpressionStatement"", ""assert ( ( Arg -> getType ( ) . isAddress ( ) || Arg -> getType ( ) . isTrivial ( Arg -> getModule ( ) ) ) && \""Trivial ownership requires a trivial type or an address\"" )""]","[[[], [1390978, ""True"", ""ValueOwnershipKind :: OWNERSHIP == ValueOwnershipKind :: Trivial"", ""Condition""]], [[], [1390996, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""ValueOwnershipKind :: OWNERSHIP"", ""ValueOwnershipKind :: Trivial"", ""==""], """"]]"
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1391064"", ""True"", ""ExpressionStatement"", ""assert ( ! I -> hasValue ( ) && \""Expected an instruction without a result\"" )""]","[[[], [1391080, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1391410"", ""True"", ""ExpressionStatement"", ""assert ( I -> hasValue ( ) && \""Expected to have a value\"" )""]","[[[], [1391424, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1392047"", ""True"", ""ExpressionStatement"", ""assert ( BI -> hasValue ( ) && \""Can only get here if we have a SILValue\"" )""]","[[[], [1392061, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1392021"", ""True"", ""ExpressionStatement"", ""assert ( BI -> getType ( ) . isTrivial ( BI -> getModule ( ) ) && \""LLVM intrinsics should always be trivial\"" )""]","[[[], [1392061, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1392148"", ""True"", ""ExpressionStatement"", ""assert ( BI -> hasValue ( ) && \""Expected to have type\"" )""]","[[[], [1392162, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1392118"", ""True"", ""ExpressionStatement"", ""assert ( BI -> getType ( ) . isTrivial ( BI -> getModule ( ) ) && \""Only trivial types can have trivial ownership\"" )""]","[[[], [1392144, ""True"", ""ValueOwnershipKind :: OWNERSHIP == ValueOwnershipKind :: Trivial"", ""Condition""]], [[], [1392162, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""ValueOwnershipKind :: OWNERSHIP"", ""ValueOwnershipKind :: Trivial"", ""==""], """"]]"
Merge pull request #8538 from gottesmm/value_ownership_kind_refactoring,lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1392089"", ""True"", ""ExpressionStatement"", ""assert ( ! BI -> getType ( ) . isTrivial ( BI -> getModule ( ) ) && \""Only non trivial types can have non trivial ownership\"" )""]","[[[], [1392144, ""True"", ""ValueOwnershipKind :: OWNERSHIP == ValueOwnershipKind :: Trivial"", ""Condition""]], [[], [1392162, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""ValueOwnershipKind :: OWNERSHIP"", ""ValueOwnershipKind :: Trivial"", ""==""], """"]]"
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1404491"", ""True"", ""ExpressionStatement"", ""assert ( Arg -> hasValue ( ) && \""Expected to have a result\"" )""]","[[[], [1404505, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1404449"", ""True"", ""ExpressionStatement"", ""assert ( ( Arg -> getType ( ) . isAddress ( ) || Arg -> getType ( ) . isTrivial ( Arg -> getModule ( ) ) ) && \""Trivial ownership requires a trivial type or an address\"" )""]","[[[], [1404487, ""True"", ""ValueOwnershipKind :: OWNERSHIP == ValueOwnershipKind :: Trivial"", ""Condition""]], [[], [1404505, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""ValueOwnershipKind :: OWNERSHIP"", ""ValueOwnershipKind :: Trivial"", ""==""], """"]]"
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1404573"", ""True"", ""ExpressionStatement"", ""assert ( ! I -> hasValue ( ) && \""Expected an instruction without a result\"" )""]","[[[], [1404589, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1404919"", ""True"", ""ExpressionStatement"", ""assert ( I -> hasValue ( ) && \""Expected to have a value\"" )""]","[[[], [1404933, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1405556"", ""True"", ""ExpressionStatement"", ""assert ( BI -> hasValue ( ) && \""Can only get here if we have a SILValue\"" )""]","[[[], [1405570, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1405530"", ""True"", ""ExpressionStatement"", ""assert ( BI -> getType ( ) . isTrivial ( BI -> getModule ( ) ) && \""LLVM intrinsics should always be trivial\"" )""]","[[[], [1405570, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1405657"", ""True"", ""ExpressionStatement"", ""assert ( BI -> hasValue ( ) && \""Expected to have type\"" )""]","[[[], [1405671, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1405627"", ""True"", ""ExpressionStatement"", ""assert ( BI -> getType ( ) . isTrivial ( BI -> getModule ( ) ) && \""Only trivial types can have trivial ownership\"" )""]","[[[], [1405653, ""True"", ""ValueOwnershipKind :: OWNERSHIP == ValueOwnershipKind :: Trivial"", ""Condition""]], [[], [1405671, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""ValueOwnershipKind :: OWNERSHIP"", ""ValueOwnershipKind :: Trivial"", ""==""], """"]]"
"[sil] Move ValueOwnershipKind computation code from SILValue.cpp -> ValueOwnerhsipKindClassifier.{cpp,h}.

This piece of code is large enough to be its own local compilation unit.",lib/SIL/ValueOwnershipKindClassifier.cpp,+,"[""1405598"", ""True"", ""ExpressionStatement"", ""assert ( ! BI -> getType ( ) . isTrivial ( BI -> getModule ( ) ) && \""Only non trivial types can have non trivial ownership\"" )""]","[[[], [1405653, ""True"", ""ValueOwnershipKind :: OWNERSHIP == ValueOwnershipKind :: Trivial"", ""Condition""]], [[], [1405671, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""ValueOwnershipKind :: OWNERSHIP"", ""ValueOwnershipKind :: Trivial"", ""==""], """"]]"
"[sil-function-signature-opt] Support FSO for generic functions

In particular, support the following optimizations:
- owned-to-guaranteed
- dead argument elimination

Argument explosion is disabled for generics at the moment as it usually leads to a slower code.",lib/SILOptimizer/Analysis/ARCAnalysis.cpp,-,"[""1413462"", ""True"", ""Parameter"", ""RCIdentityFunctionInfo * RCFI""]","[[[], [1413471, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil-function-signature-opt] Support FSO for generic functions

In particular, support the following optimizations:
- owned-to-guaranteed
- dead argument elimination

Argument explosion is disabled for generics at the moment as it usually leads to a slower code.",lib/SILOptimizer/Analysis/ARCAnalysis.cpp,+,"[""1408957"", ""True"", ""Statement"", "")""]","[[[""False""], [1409032, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil-function-signature-opt] Support FSO for generic functions

In particular, support the following optimizations:
- owned-to-guaranteed
- dead argument elimination

Argument explosion is disabled for generics at the moment as it usually leads to a slower code.",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"[""1417978"", ""True"", ""ExpressionStatement"", ""llvm :: dbgs ( ) << \""None of generic parameters are used by \"" << F -> getName ( ) << \""\\n\""""]","[[[""True""], [1417996, ""True"", ""! UsesGenerics"", ""Condition""]], [[""True""], [1418013, ""True"", ""HasGenericSignature"", ""Condition""]], [[""False"", ""False""], [1418173, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""bool"", null], ""True""], [[null], ""True""]]"
"[sil-function-signature-opt] Support FSO for generic functions

In particular, support the following optimizations:
- owned-to-guaranteed
- dead argument elimination

Argument explosion is disabled for generics at the moment as it usually leads to a slower code.",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"[""1417882"", ""True"", ""Condition"", ""ExpectedFTy -> hasErrorResult ( )""]","[[[""False"", ""True""], [1418173, ""True"", ""ENTRY"", ""CFGEntryNode""]]]",[]
"[sil-function-signature-opt] Support FSO for generic functions

In particular, support the following optimizations:
- owned-to-guaranteed
- dead argument elimination

Argument explosion is disabled for generics at the moment as it usually leads to a slower code.",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"[""1417873"", ""True"", ""ExpressionStatement"", ""InterfaceErrorResult = ExpectedFTy -> getErrorResult ( )""]","[[[""False"", ""True""], [1417882, ""True"", ""ExpectedFTy -> hasErrorResult ( )"", ""Condition""]], [[""False"", ""True""], [1418173, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[null], """"]]"
"[sil-function-signature-opt] Support FSO for generic functions

In particular, support the following optimizations:
- owned-to-guaranteed
- dead argument elimination

Argument explosion is disabled for generics at the moment as it usually leads to a slower code.",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,-,"[""1424120"", ""True"", ""ExpressionStatement"", ""Retains = EA -> get ( F ) -> computeEpilogueARCInstructions ( EpilogueARCContext :: EpilogueARCKind :: Retain , RV )""]","[[[""False""], [1424153, ""True"", ""! RV"", ""Condition""]], [[""True""], [1424167, ""True"", ""ResultDescList [ 0 ] . hasConvention ( ResultConvention :: Owned )"", ""Condition""]], [[""False""], [1424188, ""True"", ""fnConv . getNumDirectSILResults ( ) != 1"", ""Condition""]], [[], [1424207, ""True"", ""ENTRY"", ""CFGEntryNode""]]]","[[[""!"", ""RV"", null], ""False""], [[null], ""True""], [[""fnConv . getNumDirectSILResults"", ""1"", ""!=""], ""False""]]"
"[sil-function-signature-opt] Support FSO for generic functions

In particular, support the following optimizations:
- owned-to-guaranteed
- dead argument elimination

Argument explosion is disabled for generics at the moment as it usually leads to a slower code.",lib/SILOptimizer/Transforms/FunctionSignatureOpts.cpp,+,"[""1419884"", ""True"", ""ExpressionStatement"", ""Retains = EA -> get ( F ) -> computeEpilogueARCInstructions ( EpilogueARCContext :: EpilogueARCKind :: Retain , RV )""]","[[[""False""], [1419917, ""True"", ""! RV"", ""Condition""]], [[""True""], [1419931, ""True"", ""ResultDescList [ 0 ] . hasConvention ( ResultConvention :: Owned )"", ""Condition""]], [[""False""], [1419952, ""True"", ""! fnConv . getIndirectSILResults ( ) . empty ( )"", ""Condition""]], [[], [1419969, ""True"", ""fnConv . getNumDirectSILResults ( ) != 1"", ""Condition""]]]","[[[""!"", ""RV"", null], ""False""], [[null], ""True""], [[""!"", ""fnConv . getIndirectSILResults ( ) . empty"", null], ""False""], [[""fnConv . getNumDirectSILResults"", ""1"", ""!=""], """"]]"
