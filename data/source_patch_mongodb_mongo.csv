commit_message,file_name,log_statement,change_type,loc_info
SERVER-3181 Add nameOnly option to listDatabases,src/mongo/client/dbclient.cpp,"-    uassert(10005,",-
SERVER-3181 Add nameOnly option to listDatabases,src/mongo/client/dbclient.cpp,+    uassert(,+
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/dbtests/chunktests.cpp,"-        ASSERT_BSONOBJ_EQ(expectedShardNames(), b.arr());",-,"    void run() {
        QueryTestServiceContext serviceContext;
        auto opCtx = serviceContext.makeOperationContext();

        ShardKeyPattern shardKeyPattern(shardKey());
        TestableChunkManager chunkManager(
            ""TestDB.TestColl"", shardKeyPattern, defaultCollator(), false);
        chunkManager.setSingleChunkForShards(splitPoints());

        set<ShardId> shardIds;
        chunkManager.getShardIdsForQuery(opCtx.get(), query(), queryCollation(), &shardIds);

        BSONArrayBuilder b;
        for (const ShardId& shardId : shardIds) {
            b << shardId;
        }
        ASSERT_BSONOBJ_EQ(expectedShardNames(), b.arr());
    }
","    void run() {
        QueryTestServiceContext serviceContext;
        auto opCtx = serviceContext.makeOperationContext();

        ShardKeyPattern shardKeyPattern(shardKey());
        TestableChunkManager chunkManager(
            ""TestDB.TestColl"", shardKeyPattern, defaultCollator(), false);
        chunkManager.setSingleChunkForShards(splitPoints());

        set<ShardId> shardIds;
        chunkManager.getShardIdsForQuery(opCtx.get(), query(), queryCollation(), &shardIds);

        BSONArrayBuilder b;
        for (const ShardId& shardId : shardIds) {
            b << shardId;
","        ASSERT_BSONOBJ_EQ(expectedShardNames(), b.arr());
    }
",16
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_client_impl.cpp,"+            uassertStatusOK(Grid::get(txn)->shardRegistry()->getShard(txn, primaryShardId));",+
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_client_impl.cpp,+        auto result = uassertStatusOK(primaryShard->runCommandWithFixedRetryAttempts(,+
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_client_impl.cpp,+        uassertStatusOK(result.commandStatus);,+,"void toBatchError(const Status& status, BatchedCommandResponse* response) {
    response->clear();
    response->setErrCode(status.code());
    response->setErrMessage(status.reason());
    response->setOk(false);
}
",,"    response->clear();
    response->setErrCode(status.code());
    response->setErrMessage(status.reason());
    response->setOk(false);
}
",1
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_client_impl.cpp,"+        uassertStatusOK(bsonExtractIntegerField(result.response, ""n"", &numObjects));",+,"void toBatchError(const Status& status, BatchedCommandResponse* response) {
    response->clear();
    response->setErrCode(status.code());
    response->setErrMessage(status.reason());
    response->setOk(false);
}
","void toBatchError(const Status& status, BatchedCommandResponse* response) {
","    response->setErrCode(status.code());
    response->setErrMessage(status.reason());
    response->setOk(false);
}
",2
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_client_impl.cpp,+            splitPoints = uassertStatusOK(shardutil::selectChunkSplitPoints(,+,"void toBatchError(const Status& status, BatchedCommandResponse* response) {
    response->clear();
    response->setErrCode(status.code());
    response->setErrMessage(status.reason());
    response->setOk(false);
}
","void toBatchError(const Status& status, BatchedCommandResponse* response) {
    response->clear();
    response->setErrCode(status.code());
    response->setErrMessage(status.reason());
","}
",5
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_client_impl.cpp,"+    log() << ""going to create "" << splitPoints.size() + 1 << "" chunk(s) for: "" << nss",+
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_client_impl.cpp,+        Status status = Grid::get(txn)->catalogClient(txn)->insertConfigDocument(,+
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_shard_collection_test.cpp,"-            ASSERT_EQUALS(configHost, request.target);",-,"    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
","    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
","            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
",3
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_shard_collection_test.cpp,"-            ASSERT_BSONOBJ_EQ(kReplSecondaryOkMetadata,",-,"    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
","    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
","
            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
",4
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_shard_collection_test.cpp,"-            ASSERT_EQ(nss.ns(), ChunkType::ConfigNS);",-,"    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
","    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));
","            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
",8
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_shard_collection_test.cpp,"-            auto query = assertGet(QueryRequest::makeFromFindCommand(nss, request.cmdObj, false));",-,"    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
","    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
","            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
",10
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_shard_collection_test.cpp,"-            ASSERT_EQ(ChunkType::ConfigNS, query->ns());",-,"    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
","    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
","
            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
",15
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_shard_collection_test.cpp,"-            ASSERT_BSONOBJ_EQ(expectedQuery, query->getFilter());",-,"    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
","    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();
","            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
",16
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_shard_collection_test.cpp,"-            ASSERT_BSONOBJ_EQ(expectedSort, query->getSort());",-,"    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
","    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

","            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
",17
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/catalog/sharding_catalog_shard_collection_test.cpp,-            ASSERT_FALSE(query->getLimit().is_initialized());,-,"    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
            ASSERT_FALSE(update->getMulti());
            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
","    void expectUpdateCollection(const CollectionType& expectedCollection) {
        onCommand([&](const RemoteCommandRequest& request) {
            ASSERT_EQUALS(configHost, request.target);
            ASSERT_EQUALS(""config"", request.dbname);

            ASSERT_BSONOBJ_EQ(BSON(rpc::kReplSetMetadataFieldName << 1),
                              rpc::TrackingMetadata::removeTrackingData(request.metadata));

            BatchedUpdateRequest actualBatchedUpdate;
            std::string errmsg;
            ASSERT_TRUE(actualBatchedUpdate.parseBSON(request.dbname, request.cmdObj, &errmsg));
            ASSERT_EQUALS(CollectionType::ConfigNS, actualBatchedUpdate.getNS().ns());
            auto updates = actualBatchedUpdate.getUpdates();
            ASSERT_EQUALS(1U, updates.size());
            auto update = updates.front();

            ASSERT_TRUE(update->getUpsert());
","            ASSERT_BSONOBJ_EQ(BSON(CollectionType::fullNs(expectedCollection.getNs().toString())),
                              update->getQuery());
            ASSERT_BSONOBJ_EQ(expectedCollection.toBSON(), update->getUpdateExpr());

            BatchedCommandResponse response;
            response.setOk(true);
            response.setNModified(1);

            return response.toBSON();
        });
    }
",18
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,-    uassertStatusOK(,-,"bool isChunkMapValid(const ChunkMap& chunkMap) {
#define ENSURE(x)                                          \
    do {                                                   \
        if (!(x)) {                                        \
            log() << ""ChunkManager::_isValid failed: "" #x; \
            return false;                                  \
        }                                                  \
    } while (0)

    if (chunkMap.empty()) {
        return true;
    }

    // Check endpoints
    ENSURE(allOfType(MinKey, chunkMap.begin()->second->getMin()));
    ENSURE(allOfType(MaxKey, boost::prior(chunkMap.end())->second->getMax()));

    // Make sure there are no gaps or overlaps
    for (ChunkMap::const_iterator it = boost::next(chunkMap.begin()), end = chunkMap.end();
         it != end;
         ++it) {
        ChunkMap::const_iterator last = boost::prior(it);

        if (SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() !=
                                                        last->second->getMax())) {
            log() << last->second->toString();
            log() << it->second->toString();
            log() << it->second->getMin();
            log() << last->second->getMax();
        }

        ENSURE(SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() ==
                                                           last->second->getMax()));
    }

    return true;

#undef ENSURE
}
","bool isChunkMapValid(const ChunkMap& chunkMap) {
#define ENSURE(x)                                          \
    do {                                                   \
        if (!(x)) {                                        \
            log() << ""ChunkManager::_isValid failed: "" #x; \
            return false;                                  \
        }                                                  \
    } while (0)

    if (chunkMap.empty()) {
        return true;
    }

    // Check endpoints
    ENSURE(allOfType(MinKey, chunkMap.begin()->second->getMin()));
    ENSURE(allOfType(MaxKey, boost::prior(chunkMap.end())->second->getMax()));

    // Make sure there are no gaps or overlaps
    for (ChunkMap::const_iterator it = boost::next(chunkMap.begin()), end = chunkMap.end();
         it != end;
         ++it) {
        ChunkMap::const_iterator last = boost::prior(it);

        if (SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() !=
                                                        last->second->getMax())) {
            log() << last->second->toString();
            log() << it->second->toString();
            log() << it->second->getMin();
","        }

        ENSURE(SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() ==
                                                           last->second->getMax()));
    }

    return true;

#undef ENSURE
}
",29
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,"-        grid.catalogClient(txn)->getChunks(txn,",-,"bool isChunkMapValid(const ChunkMap& chunkMap) {
#define ENSURE(x)                                          \
    do {                                                   \
        if (!(x)) {                                        \
            log() << ""ChunkManager::_isValid failed: "" #x; \
            return false;                                  \
        }                                                  \
    } while (0)

    if (chunkMap.empty()) {
        return true;
    }

    // Check endpoints
    ENSURE(allOfType(MinKey, chunkMap.begin()->second->getMin()));
    ENSURE(allOfType(MaxKey, boost::prior(chunkMap.end())->second->getMax()));

    // Make sure there are no gaps or overlaps
    for (ChunkMap::const_iterator it = boost::next(chunkMap.begin()), end = chunkMap.end();
         it != end;
         ++it) {
        ChunkMap::const_iterator last = boost::prior(it);

        if (SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() !=
                                                        last->second->getMax())) {
            log() << last->second->toString();
            log() << it->second->toString();
            log() << it->second->getMin();
            log() << last->second->getMax();
        }

        ENSURE(SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() ==
                                                           last->second->getMax()));
    }

    return true;

#undef ENSURE
}
","bool isChunkMapValid(const ChunkMap& chunkMap) {
#define ENSURE(x)                                          \
    do {                                                   \
        if (!(x)) {                                        \
            log() << ""ChunkManager::_isValid failed: "" #x; \
            return false;                                  \
        }                                                  \
    } while (0)

    if (chunkMap.empty()) {
        return true;
    }

    // Check endpoints
    ENSURE(allOfType(MinKey, chunkMap.begin()->second->getMin()));
    ENSURE(allOfType(MaxKey, boost::prior(chunkMap.end())->second->getMax()));

    // Make sure there are no gaps or overlaps
    for (ChunkMap::const_iterator it = boost::next(chunkMap.begin()), end = chunkMap.end();
         it != end;
         ++it) {
        ChunkMap::const_iterator last = boost::prior(it);

        if (SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() !=
                                                        last->second->getMax())) {
            log() << last->second->toString();
            log() << it->second->toString();
            log() << it->second->getMin();
            log() << last->second->getMax();
","
        ENSURE(SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() ==
                                                           last->second->getMax()));
    }

    return true;

#undef ENSURE
}
",30
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,+    uassertStatusOK(Grid::get(txn)->catalogClient(txn)->getChunks(,+,"bool isChunkMapValid(const ChunkMap& chunkMap) {
#define ENSURE(x)                                          \
    do {                                                   \
        if (!(x)) {                                        \
            log() << ""ChunkManager::_isValid failed: "" #x; \
            return false;                                  \
        }                                                  \
    } while (0)

    if (chunkMap.empty()) {
        return true;
    }

    // Check endpoints
    ENSURE(allOfType(MinKey, chunkMap.begin()->second->getMin()));
    ENSURE(allOfType(MaxKey, boost::prior(chunkMap.end())->second->getMax()));

    // Make sure there are no gaps or overlaps
    for (ChunkMap::const_iterator it = boost::next(chunkMap.begin()), end = chunkMap.end();
         it != end;
         ++it) {
        ChunkMap::const_iterator last = boost::prior(it);

        if (SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() !=
                                                        last->second->getMax())) {
            log() << last->second->toString();
            log() << it->second->toString();
            log() << it->second->getMin();
            log() << last->second->getMax();
        }

        ENSURE(SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() ==
                                                           last->second->getMax()));
    }

    return true;

#undef ENSURE
}
","bool isChunkMapValid(const ChunkMap& chunkMap) {
#define ENSURE(x)                                          \
    do {                                                   \
        if (!(x)) {                                        \
            log() << ""ChunkManager::_isValid failed: "" #x; \
            return false;                                  \
        }                                                  \
    } while (0)

    if (chunkMap.empty()) {
        return true;
    }

    // Check endpoints
    ENSURE(allOfType(MinKey, chunkMap.begin()->second->getMin()));
    ENSURE(allOfType(MaxKey, boost::prior(chunkMap.end())->second->getMax()));

    // Make sure there are no gaps or overlaps
    for (ChunkMap::const_iterator it = boost::next(chunkMap.begin()), end = chunkMap.end();
         it != end;
         ++it) {
        ChunkMap::const_iterator last = boost::prior(it);

        if (SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() !=
                                                        last->second->getMax())) {
            log() << last->second->toString();
            log() << it->second->toString();
            log() << it->second->getMin();
            log() << last->second->getMax();
        }

        ENSURE(SimpleBSONObjComparator::kInstance.evaluate(it->second->getMin() ==
                                                           last->second->getMax()));
    }

    return true;
","#undef ENSURE
}
",37
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,"-        auto primaryShard = uassertStatusOK(grid.shardRegistry()->getShard(txn, primaryShardId));",-,"void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
","void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

","
        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
",12
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,-        auto result = uassertStatusOK(primaryShard->runCommandWithFixedRetryAttempts(,-,"void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
","void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
","
        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
",15
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,-        uassertStatusOK(result.commandStatus);,-,"void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
","void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
","
                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
",23
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,"-        uassertStatusOK(bsonExtractIntegerField(result.response, ""n"", &numObjects));",-,"void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
","void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);
","                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
",24
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,-            *splitPoints = uassertStatusOK(shardutil::selectChunkSplitPoints(,-,"void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
","void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;
","                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
",27
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,"-    log() << ""going to create "" << splitPoints.size() + 1 << "" chunk(s) for: "" << _ns",-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,-        Status status = grid.catalogClient(txn)->insertConfigDocument(,-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager.cpp,-            error() << errMsg;,-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-            ASSERT_EQ(request.target, HostAndPort(CONFIG_HOST_PORT));",-,"TEST_F(ChunkManagerLoadTest, IncrementalLoadAfterSplit) {
    const ShardKeyPattern shardKeyPattern(BSON(""_id"" << 1));

    auto initialManager(makeChunkManager(shardKeyPattern, nullptr, true, {}));

    ChunkVersion version = initialManager->getVersion();

    CollectionType collType;
    collType.setNs(kNss);
    collType.setEpoch(version.epoch());
    collType.setUpdatedAt(jsTime());
    collType.setKeyPattern(shardKeyPattern.toBSON());
    collType.setUnique(false);

    ChunkManager manager(kNss, version.epoch(), shardKeyPattern, nullptr, true);

    auto future =
        launchAsync([&] { manager.loadExistingRanges(operationContext(), initialManager.get()); });

    // Return set of chunks, which represent a split
    expectFindOnConfigSendBSONObjVector([&]() {
        version.incMajor();

        ChunkType chunk1;
        chunk1.setNS(kNss.ns());
        chunk1.setMin(shardKeyPattern.getKeyPattern().globalMin());
        chunk1.setMax(BSON(""_id"" << 0));
        chunk1.setShard({""0""});
        chunk1.setVersion(version);

        version.incMinor();

        ChunkType chunk2;
        chunk2.setNS(kNss.ns());
        chunk2.setMin(BSON(""_id"" << 0));
        chunk2.setMax(shardKeyPattern.getKeyPattern().globalMax());
        chunk2.setShard({""0""});
        chunk2.setVersion(version);

        return std::vector<BSONObj>{chunk1.toConfigBSON(), chunk2.toConfigBSON()};
    }());

    future.timed_get(kFutureTimeout);
}
","TEST_F(ChunkManagerLoadTest, IncrementalLoadAfterSplit) {
    const ShardKeyPattern shardKeyPattern(BSON(""_id"" << 1));

    auto initialManager(makeChunkManager(shardKeyPattern, nullptr, true, {}));

    ChunkVersion version = initialManager->getVersion();

    CollectionType collType;
    collType.setNs(kNss);
    collType.setEpoch(version.epoch());
    collType.setUpdatedAt(jsTime());
    collType.setKeyPattern(shardKeyPattern.toBSON());
    collType.setUnique(false);

    ChunkManager manager(kNss, version.epoch(), shardKeyPattern, nullptr, true);

    auto future =
        launchAsync([&] { manager.loadExistingRanges(operationContext(), initialManager.get()); });

    // Return set of chunks, which represent a split
    expectFindOnConfigSendBSONObjVector([&]() {
        version.incMajor();

        ChunkType chunk1;
        chunk1.setNS(kNss.ns());
        chunk1.setMin(shardKeyPattern.getKeyPattern().globalMin());
        chunk1.setMax(BSON(""_id"" << 0));
        chunk1.setShard({""0""});
        chunk1.setVersion(version);

        version.incMinor();

        ChunkType chunk2;
        chunk2.setNS(kNss.ns());
        chunk2.setMin(BSON(""_id"" << 0));
","        chunk2.setShard({""0""});
        chunk2.setVersion(version);

        return std::vector<BSONObj>{chunk1.toConfigBSON(), chunk2.toConfigBSON()};
    }());

    future.timed_get(kFutureTimeout);
}
",36
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-            ASSERT_EQ(request.dbname, ""config"");",-,"TEST_F(ChunkManagerLoadTest, IncrementalLoadAfterSplit) {
    const ShardKeyPattern shardKeyPattern(BSON(""_id"" << 1));

    auto initialManager(makeChunkManager(shardKeyPattern, nullptr, true, {}));

    ChunkVersion version = initialManager->getVersion();

    CollectionType collType;
    collType.setNs(kNss);
    collType.setEpoch(version.epoch());
    collType.setUpdatedAt(jsTime());
    collType.setKeyPattern(shardKeyPattern.toBSON());
    collType.setUnique(false);

    ChunkManager manager(kNss, version.epoch(), shardKeyPattern, nullptr, true);

    auto future =
        launchAsync([&] { manager.loadExistingRanges(operationContext(), initialManager.get()); });

    // Return set of chunks, which represent a split
    expectFindOnConfigSendBSONObjVector([&]() {
        version.incMajor();

        ChunkType chunk1;
        chunk1.setNS(kNss.ns());
        chunk1.setMin(shardKeyPattern.getKeyPattern().globalMin());
        chunk1.setMax(BSON(""_id"" << 0));
        chunk1.setShard({""0""});
        chunk1.setVersion(version);

        version.incMinor();

        ChunkType chunk2;
        chunk2.setNS(kNss.ns());
        chunk2.setMin(BSON(""_id"" << 0));
        chunk2.setMax(shardKeyPattern.getKeyPattern().globalMax());
        chunk2.setShard({""0""});
        chunk2.setVersion(version);

        return std::vector<BSONObj>{chunk1.toConfigBSON(), chunk2.toConfigBSON()};
    }());

    future.timed_get(kFutureTimeout);
}
","TEST_F(ChunkManagerLoadTest, IncrementalLoadAfterSplit) {
    const ShardKeyPattern shardKeyPattern(BSON(""_id"" << 1));

    auto initialManager(makeChunkManager(shardKeyPattern, nullptr, true, {}));

    ChunkVersion version = initialManager->getVersion();

    CollectionType collType;
    collType.setNs(kNss);
    collType.setEpoch(version.epoch());
    collType.setUpdatedAt(jsTime());
    collType.setKeyPattern(shardKeyPattern.toBSON());
    collType.setUnique(false);

    ChunkManager manager(kNss, version.epoch(), shardKeyPattern, nullptr, true);

    auto future =
        launchAsync([&] { manager.loadExistingRanges(operationContext(), initialManager.get()); });

    // Return set of chunks, which represent a split
    expectFindOnConfigSendBSONObjVector([&]() {
        version.incMajor();

        ChunkType chunk1;
        chunk1.setNS(kNss.ns());
        chunk1.setMin(shardKeyPattern.getKeyPattern().globalMin());
        chunk1.setMax(BSON(""_id"" << 0));
        chunk1.setShard({""0""});
        chunk1.setVersion(version);

        version.incMinor();

        ChunkType chunk2;
        chunk2.setNS(kNss.ns());
        chunk2.setMin(BSON(""_id"" << 0));
        chunk2.setMax(shardKeyPattern.getKeyPattern().globalMax());
","        chunk2.setVersion(version);

        return std::vector<BSONObj>{chunk1.toConfigBSON(), chunk2.toConfigBSON()};
    }());

    future.timed_get(kFutureTimeout);
}
",37
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-            ASSERT_EQ(request.target, HostAndPort(CONFIG_HOST_PORT));",-,"    void runQueryTest(const BSONObj& shardKey,
                      std::unique_ptr<CollatorInterface> defaultCollator,
                      bool unique,
                      const std::vector<BSONObj>& splitPoints,
                      const BSONObj& query,
                      const BSONObj& queryCollation,
                      const std::set<ShardId> expectedShardIds) {
        const ShardKeyPattern shardKeyPattern(shardKey);
        auto chunkManager =
            makeChunkManager(shardKeyPattern, std::move(defaultCollator), false, splitPoints);

        std::set<ShardId> shardIds;
        chunkManager->getShardIdsForQuery(operationContext(), query, queryCollation, &shardIds);

        BSONArrayBuilder expectedBuilder;
        for (const auto& shardId : expectedShardIds) {
            expectedBuilder << shardId;
        }

        BSONArrayBuilder actualBuilder;
        for (const auto& shardId : shardIds) {
            actualBuilder << shardId;
        }

        ASSERT_BSONOBJ_EQ(expectedBuilder.arr(), actualBuilder.arr());
    }
","    void runQueryTest(const BSONObj& shardKey,
                      std::unique_ptr<CollatorInterface> defaultCollator,
                      bool unique,
                      const std::vector<BSONObj>& splitPoints,
                      const BSONObj& query,
                      const BSONObj& queryCollation,
                      const std::set<ShardId> expectedShardIds) {
        const ShardKeyPattern shardKeyPattern(shardKey);
        auto chunkManager =
            makeChunkManager(shardKeyPattern, std::move(defaultCollator), false, splitPoints);

        std::set<ShardId> shardIds;
        chunkManager->getShardIdsForQuery(operationContext(), query, queryCollation, &shardIds);

        BSONArrayBuilder expectedBuilder;
        for (const auto& shardId : expectedShardIds) {
            expectedBuilder << shardId;
        }

","        for (const auto& shardId : shardIds) {
            actualBuilder << shardId;
        }

        ASSERT_BSONOBJ_EQ(expectedBuilder.arr(), actualBuilder.arr());
    }
",20
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-            ASSERT_EQ(request.dbname, ""config"");",-,"    void runQueryTest(const BSONObj& shardKey,
                      std::unique_ptr<CollatorInterface> defaultCollator,
                      bool unique,
                      const std::vector<BSONObj>& splitPoints,
                      const BSONObj& query,
                      const BSONObj& queryCollation,
                      const std::set<ShardId> expectedShardIds) {
        const ShardKeyPattern shardKeyPattern(shardKey);
        auto chunkManager =
            makeChunkManager(shardKeyPattern, std::move(defaultCollator), false, splitPoints);

        std::set<ShardId> shardIds;
        chunkManager->getShardIdsForQuery(operationContext(), query, queryCollation, &shardIds);

        BSONArrayBuilder expectedBuilder;
        for (const auto& shardId : expectedShardIds) {
            expectedBuilder << shardId;
        }

        BSONArrayBuilder actualBuilder;
        for (const auto& shardId : shardIds) {
            actualBuilder << shardId;
        }

        ASSERT_BSONOBJ_EQ(expectedBuilder.arr(), actualBuilder.arr());
    }
","    void runQueryTest(const BSONObj& shardKey,
                      std::unique_ptr<CollatorInterface> defaultCollator,
                      bool unique,
                      const std::vector<BSONObj>& splitPoints,
                      const BSONObj& query,
                      const BSONObj& queryCollation,
                      const std::set<ShardId> expectedShardIds) {
        const ShardKeyPattern shardKeyPattern(shardKey);
        auto chunkManager =
            makeChunkManager(shardKeyPattern, std::move(defaultCollator), false, splitPoints);

        std::set<ShardId> shardIds;
        chunkManager->getShardIdsForQuery(operationContext(), query, queryCollation, &shardIds);

        BSONArrayBuilder expectedBuilder;
        for (const auto& shardId : expectedShardIds) {
            expectedBuilder << shardId;
        }

        BSONArrayBuilder actualBuilder;
","            actualBuilder << shardId;
        }

        ASSERT_BSONOBJ_EQ(expectedBuilder.arr(), actualBuilder.arr());
    }
",21
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,-            ASSERT(version.majorVersion() == 1);,-,"    void runQueryTest(const BSONObj& shardKey,
                      std::unique_ptr<CollatorInterface> defaultCollator,
                      bool unique,
                      const std::vector<BSONObj>& splitPoints,
                      const BSONObj& query,
                      const BSONObj& queryCollation,
                      const std::set<ShardId> expectedShardIds) {
        const ShardKeyPattern shardKeyPattern(shardKey);
        auto chunkManager =
            makeChunkManager(shardKeyPattern, std::move(defaultCollator), false, splitPoints);

        std::set<ShardId> shardIds;
        chunkManager->getShardIdsForQuery(operationContext(), query, queryCollation, &shardIds);

        BSONArrayBuilder expectedBuilder;
        for (const auto& shardId : expectedShardIds) {
            expectedBuilder << shardId;
        }

        BSONArrayBuilder actualBuilder;
        for (const auto& shardId : shardIds) {
            actualBuilder << shardId;
        }

        ASSERT_BSONOBJ_EQ(expectedBuilder.arr(), actualBuilder.arr());
    }
","    void runQueryTest(const BSONObj& shardKey,
                      std::unique_ptr<CollatorInterface> defaultCollator,
                      bool unique,
                      const std::vector<BSONObj>& splitPoints,
                      const BSONObj& query,
                      const BSONObj& queryCollation,
                      const std::set<ShardId> expectedShardIds) {
        const ShardKeyPattern shardKeyPattern(shardKey);
        auto chunkManager =
            makeChunkManager(shardKeyPattern, std::move(defaultCollator), false, splitPoints);

        std::set<ShardId> shardIds;
        chunkManager->getShardIdsForQuery(operationContext(), query, queryCollation, &shardIds);

        BSONArrayBuilder expectedBuilder;
        for (const auto& shardId : expectedShardIds) {
            expectedBuilder << shardId;
        }

        BSONArrayBuilder actualBuilder;
","            actualBuilder << shardId;
        }

        ASSERT_BSONOBJ_EQ(expectedBuilder.arr(), actualBuilder.arr());
    }
",21
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,-            ASSERT(minorVersions.find(version.minorVersion()) == minorVersions.end());,-,"    void runQueryTest(const BSONObj& shardKey,
                      std::unique_ptr<CollatorInterface> defaultCollator,
                      bool unique,
                      const std::vector<BSONObj>& splitPoints,
                      const BSONObj& query,
                      const BSONObj& queryCollation,
                      const std::set<ShardId> expectedShardIds) {
        const ShardKeyPattern shardKeyPattern(shardKey);
        auto chunkManager =
            makeChunkManager(shardKeyPattern, std::move(defaultCollator), false, splitPoints);

        std::set<ShardId> shardIds;
        chunkManager->getShardIdsForQuery(operationContext(), query, queryCollation, &shardIds);

        BSONArrayBuilder expectedBuilder;
        for (const auto& shardId : expectedShardIds) {
            expectedBuilder << shardId;
        }

        BSONArrayBuilder actualBuilder;
        for (const auto& shardId : shardIds) {
            actualBuilder << shardId;
        }

        ASSERT_BSONOBJ_EQ(expectedBuilder.arr(), actualBuilder.arr());
    }
","    void runQueryTest(const BSONObj& shardKey,
                      std::unique_ptr<CollatorInterface> defaultCollator,
                      bool unique,
                      const std::vector<BSONObj>& splitPoints,
                      const BSONObj& query,
                      const BSONObj& queryCollation,
                      const std::set<ShardId> expectedShardIds) {
        const ShardKeyPattern shardKeyPattern(shardKey);
        auto chunkManager =
            makeChunkManager(shardKeyPattern, std::move(defaultCollator), false, splitPoints);

        std::set<ShardId> shardIds;
        chunkManager->getShardIdsForQuery(operationContext(), query, queryCollation, &shardIds);

        BSONArrayBuilder expectedBuilder;
        for (const auto& shardId : expectedShardIds) {
            expectedBuilder << shardId;
        }

        BSONArrayBuilder actualBuilder;
        for (const auto& shardId : shardIds) {
            actualBuilder << shardId;
        }

","    }
",25
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,-            ASSERT(version.epoch().isSet());,-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,-            ASSERT(version.epoch() == epoch);,-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,-            ASSERT(chunk[ChunkType::shard()].String() == _shardId.toString());,-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,-        ASSERT_OK(status);,-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"+        ASSERT_BSONOBJ_EQ(expectedBuilder.arr(), actualBuilder.arr());",+
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-        ASSERT_EQ(version.epoch(), manager.getVersion().epoch());",-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-        ASSERT_EQ(numChunks - 1, manager.getVersion().minorVersion());",-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-        ASSERT_EQ(numChunks, static_cast<int>(manager.getChunkMap().size()));",-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-        ASSERT_EQ(numChunks, static_cast<int>(manager.getChunkMap().size()));",-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,"-        ASSERT_EQ(laterVersion.toString(), newManager.getVersion().toString());",-
"SERVER-28030 Remove writes from ChunkManager

Also moves the 'chunks' tests from dbtests into the ChunkManager
unit-tests.",src/mongo/s/chunk_manager_test.cpp,-        ASSERT_OK(status);,-
SERVER-28030 Remove writes from Chunk,src/mongo/db/s/balancer/balancer.cpp,"+        log() << ""Marking chunk "" << redact(chunk->toString()) << "" as jumbo."";",+,"void Balancer::_splitOrMarkJumbo(OperationContext* txn,
                                 const NamespaceString& nss,
                                 const BSONObj& minKey) {
    auto scopedCM = uassertStatusOK(ScopedChunkManager::refreshAndGet(txn, nss));
    const auto cm = scopedCM.cm().get();

    auto chunk = cm->findIntersectingChunkWithSimpleCollation(txn, minKey);

    try {
        const auto splitPoints = uassertStatusOK(shardutil::selectChunkSplitPoints(
            txn,
            chunk->getShardId(),
            nss,
            cm->getShardKeyPattern(),
            ChunkRange(chunk->getMin(), chunk->getMax()),
            Grid::get(txn)->getBalancerConfiguration()->getMaxChunkSizeBytes(),
            boost::none));

        uassert(ErrorCodes::CannotSplit, ""No split points found"", !splitPoints.empty());

        uassertStatusOK(
            shardutil::splitChunkAtMultiplePoints(txn,
                                                  chunk->getShardId(),
                                                  nss,
                                                  cm->getShardKeyPattern(),
                                                  cm->getVersion(),
                                                  ChunkRange(chunk->getMin(), chunk->getMax()),
                                                  splitPoints));
    } catch (const DBException& ex) {
        log() << ""Marking chunk "" << redact(chunk->toString()) << "" as jumbo."";

        chunk->markAsJumbo();

        const std::string chunkName = ChunkType::genID(nss.ns(), chunk->getMin());

        auto status = Grid::get(txn)->catalogClient(txn)->updateConfigDocument(
            txn,
            ChunkType::ConfigNS,
            BSON(ChunkType::name(chunkName)),
            BSON(""$set"" << BSON(ChunkType::jumbo(true))),
            false,
            ShardingCatalogClient::kMajorityWriteConcern);
        if (!status.isOK()) {
            log() << ""Couldn't set jumbo for chunk: "" << redact(chunkName)
                  << causedBy(redact(status.getStatus()));
        }
    }
}
","void Balancer::_splitOrMarkJumbo(OperationContext* txn,
                                 const NamespaceString& nss,
                                 const BSONObj& minKey) {
    auto scopedCM = uassertStatusOK(ScopedChunkManager::refreshAndGet(txn, nss));
    const auto cm = scopedCM.cm().get();

    auto chunk = cm->findIntersectingChunkWithSimpleCollation(txn, minKey);

    try {
        const auto splitPoints = uassertStatusOK(shardutil::selectChunkSplitPoints(
            txn,
            chunk->getShardId(),
            nss,
            cm->getShardKeyPattern(),
            ChunkRange(chunk->getMin(), chunk->getMax()),
            Grid::get(txn)->getBalancerConfiguration()->getMaxChunkSizeBytes(),
            boost::none));

        uassert(ErrorCodes::CannotSplit, ""No split points found"", !splitPoints.empty());

        uassertStatusOK(
            shardutil::splitChunkAtMultiplePoints(txn,
                                                  chunk->getShardId(),
                                                  nss,
                                                  cm->getShardKeyPattern(),
                                                  cm->getVersion(),
                                                  ChunkRange(chunk->getMin(), chunk->getMax()),
                                                  splitPoints));
    } catch (const DBException& ex) {
        log() << ""Marking chunk "" << redact(chunk->toString()) << "" as jumbo."";
","        chunk->markAsJumbo();

        const std::string chunkName = ChunkType::genID(nss.ns(), chunk->getMin());

        auto status = Grid::get(txn)->catalogClient(txn)->updateConfigDocument(
            txn,
            ChunkType::ConfigNS,
            BSON(ChunkType::name(chunkName)),
            BSON(""$set"" << BSON(ChunkType::jumbo(true))),
            false,
            ShardingCatalogClient::kMajorityWriteConcern);
        if (!status.isOK()) {
            log() << ""Couldn't set jumbo for chunk: "" << redact(chunkName)
                  << causedBy(redact(status.getStatus()));
        }
    }
}
",31
SERVER-28030 Remove writes from Chunk,src/mongo/db/s/balancer/balancer.cpp,+        auto status = Grid::get(txn)->catalogClient(txn)->updateConfigDocument(,+,"void Balancer::_splitOrMarkJumbo(OperationContext* txn,
                                 const NamespaceString& nss,
                                 const BSONObj& minKey) {
    auto scopedCM = uassertStatusOK(ScopedChunkManager::refreshAndGet(txn, nss));
    const auto cm = scopedCM.cm().get();

    auto chunk = cm->findIntersectingChunkWithSimpleCollation(txn, minKey);

    try {
        const auto splitPoints = uassertStatusOK(shardutil::selectChunkSplitPoints(
            txn,
            chunk->getShardId(),
            nss,
            cm->getShardKeyPattern(),
            ChunkRange(chunk->getMin(), chunk->getMax()),
            Grid::get(txn)->getBalancerConfiguration()->getMaxChunkSizeBytes(),
            boost::none));

        uassert(ErrorCodes::CannotSplit, ""No split points found"", !splitPoints.empty());

        uassertStatusOK(
            shardutil::splitChunkAtMultiplePoints(txn,
                                                  chunk->getShardId(),
                                                  nss,
                                                  cm->getShardKeyPattern(),
                                                  cm->getVersion(),
                                                  ChunkRange(chunk->getMin(), chunk->getMax()),
                                                  splitPoints));
    } catch (const DBException& ex) {
        log() << ""Marking chunk "" << redact(chunk->toString()) << "" as jumbo."";

        chunk->markAsJumbo();

        const std::string chunkName = ChunkType::genID(nss.ns(), chunk->getMin());

        auto status = Grid::get(txn)->catalogClient(txn)->updateConfigDocument(
            txn,
            ChunkType::ConfigNS,
            BSON(ChunkType::name(chunkName)),
            BSON(""$set"" << BSON(ChunkType::jumbo(true))),
            false,
            ShardingCatalogClient::kMajorityWriteConcern);
        if (!status.isOK()) {
            log() << ""Couldn't set jumbo for chunk: "" << redact(chunkName)
                  << causedBy(redact(status.getStatus()));
        }
    }
}
","void Balancer::_splitOrMarkJumbo(OperationContext* txn,
                                 const NamespaceString& nss,
                                 const BSONObj& minKey) {
    auto scopedCM = uassertStatusOK(ScopedChunkManager::refreshAndGet(txn, nss));
    const auto cm = scopedCM.cm().get();

    auto chunk = cm->findIntersectingChunkWithSimpleCollation(txn, minKey);

    try {
        const auto splitPoints = uassertStatusOK(shardutil::selectChunkSplitPoints(
            txn,
            chunk->getShardId(),
            nss,
            cm->getShardKeyPattern(),
            ChunkRange(chunk->getMin(), chunk->getMax()),
            Grid::get(txn)->getBalancerConfiguration()->getMaxChunkSizeBytes(),
            boost::none));

        uassert(ErrorCodes::CannotSplit, ""No split points found"", !splitPoints.empty());

        uassertStatusOK(
            shardutil::splitChunkAtMultiplePoints(txn,
                                                  chunk->getShardId(),
                                                  nss,
                                                  cm->getShardKeyPattern(),
                                                  cm->getVersion(),
                                                  ChunkRange(chunk->getMin(), chunk->getMax()),
                                                  splitPoints));
    } catch (const DBException& ex) {
        log() << ""Marking chunk "" << redact(chunk->toString()) << "" as jumbo."";

        chunk->markAsJumbo();

        const std::string chunkName = ChunkType::genID(nss.ns(), chunk->getMin());

        auto status = Grid::get(txn)->catalogClient(txn)->updateConfigDocument(
","            ChunkType::ConfigNS,
            BSON(ChunkType::name(chunkName)),
            BSON(""$set"" << BSON(ChunkType::jumbo(true))),
            false,
            ShardingCatalogClient::kMajorityWriteConcern);
        if (!status.isOK()) {
            log() << ""Couldn't set jumbo for chunk: "" << redact(chunkName)
                  << causedBy(redact(status.getStatus()));
        }
    }
}
",37
SERVER-28030 Remove writes from Chunk,src/mongo/db/s/balancer/balancer.cpp,"+            log() << ""Couldn't set jumbo for chunk: "" << redact(chunkName)",+,"void Balancer::_splitOrMarkJumbo(OperationContext* txn,
                                 const NamespaceString& nss,
                                 const BSONObj& minKey) {
    auto scopedCM = uassertStatusOK(ScopedChunkManager::refreshAndGet(txn, nss));
    const auto cm = scopedCM.cm().get();

    auto chunk = cm->findIntersectingChunkWithSimpleCollation(txn, minKey);

    try {
        const auto splitPoints = uassertStatusOK(shardutil::selectChunkSplitPoints(
            txn,
            chunk->getShardId(),
            nss,
            cm->getShardKeyPattern(),
            ChunkRange(chunk->getMin(), chunk->getMax()),
            Grid::get(txn)->getBalancerConfiguration()->getMaxChunkSizeBytes(),
            boost::none));

        uassert(ErrorCodes::CannotSplit, ""No split points found"", !splitPoints.empty());

        uassertStatusOK(
            shardutil::splitChunkAtMultiplePoints(txn,
                                                  chunk->getShardId(),
                                                  nss,
                                                  cm->getShardKeyPattern(),
                                                  cm->getVersion(),
                                                  ChunkRange(chunk->getMin(), chunk->getMax()),
                                                  splitPoints));
    } catch (const DBException& ex) {
        log() << ""Marking chunk "" << redact(chunk->toString()) << "" as jumbo."";

        chunk->markAsJumbo();

        const std::string chunkName = ChunkType::genID(nss.ns(), chunk->getMin());

        auto status = Grid::get(txn)->catalogClient(txn)->updateConfigDocument(
            txn,
            ChunkType::ConfigNS,
            BSON(ChunkType::name(chunkName)),
            BSON(""$set"" << BSON(ChunkType::jumbo(true))),
            false,
            ShardingCatalogClient::kMajorityWriteConcern);
        if (!status.isOK()) {
            log() << ""Couldn't set jumbo for chunk: "" << redact(chunkName)
                  << causedBy(redact(status.getStatus()));
        }
    }
}
","void Balancer::_splitOrMarkJumbo(OperationContext* txn,
                                 const NamespaceString& nss,
                                 const BSONObj& minKey) {
    auto scopedCM = uassertStatusOK(ScopedChunkManager::refreshAndGet(txn, nss));
    const auto cm = scopedCM.cm().get();

    auto chunk = cm->findIntersectingChunkWithSimpleCollation(txn, minKey);

    try {
        const auto splitPoints = uassertStatusOK(shardutil::selectChunkSplitPoints(
            txn,
            chunk->getShardId(),
            nss,
            cm->getShardKeyPattern(),
            ChunkRange(chunk->getMin(), chunk->getMax()),
            Grid::get(txn)->getBalancerConfiguration()->getMaxChunkSizeBytes(),
            boost::none));

        uassert(ErrorCodes::CannotSplit, ""No split points found"", !splitPoints.empty());

        uassertStatusOK(
            shardutil::splitChunkAtMultiplePoints(txn,
                                                  chunk->getShardId(),
                                                  nss,
                                                  cm->getShardKeyPattern(),
                                                  cm->getVersion(),
                                                  ChunkRange(chunk->getMin(), chunk->getMax()),
                                                  splitPoints));
    } catch (const DBException& ex) {
        log() << ""Marking chunk "" << redact(chunk->toString()) << "" as jumbo."";

        chunk->markAsJumbo();

        const std::string chunkName = ChunkType::genID(nss.ns(), chunk->getMin());

        auto status = Grid::get(txn)->catalogClient(txn)->updateConfigDocument(
            txn,
            ChunkType::ConfigNS,
            BSON(ChunkType::name(chunkName)),
            BSON(""$set"" << BSON(ChunkType::jumbo(true))),
            false,
            ShardingCatalogClient::kMajorityWriteConcern);
        if (!status.isOK()) {
            log() << ""Couldn't set jumbo for chunk: "" << redact(chunkName)
","        }
    }
}
",45
SERVER-28030 Remove writes from Chunk,src/mongo/s/chunk.cpp,"-    log() << ""Marking chunk "" << toString() << "" as jumbo."";",-,"std::string Chunk::toString() const {
    return str::stream() << ChunkType::shard() << "": "" << _shardId << "", ""
                         << ChunkType::DEPRECATED_lastmod() << "": "" << _lastmod.toString() << "", ""
                         << _range.toString();
}
",,"    return str::stream() << ChunkType::shard() << "": "" << _shardId << "", ""
                         << ChunkType::DEPRECATED_lastmod() << "": "" << _lastmod.toString() << "", ""
                         << _range.toString();
}
",1
SERVER-28030 Remove writes from Chunk,src/mongo/s/chunk.cpp,-    auto status = Grid::get(txn)->catalogClient(txn)->updateConfigDocument(,-
"SERVER-28030 Move catalog_cache.h/.cpp to mongo/s/

There is no need for the CatalogCache and the cache entry classes to be in
the same directory as the catalog manager.",src/mongo/s/chunk_manager.cpp,-    dassert(all);,-,"void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
                _shardVersions = std::move(shardVersions);
                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
","void ChunkManager::loadExistingRanges(OperationContext* txn, const ChunkManager* oldManager) {
    invariant(!_version.isSet());

    int tries = 3;

    while (tries--) {
        ChunkMap chunkMap =
            SimpleBSONObjComparator::kInstance.makeBSONObjIndexedMap<std::shared_ptr<Chunk>>();
        set<ShardId> shardIds;
        ShardVersionMap shardVersions;

        Timer t;

        log() << ""ChunkManager loading chunks for "" << _ns << "" sequenceNumber: "" << _sequenceNumber
              << "" based on: "" << (oldManager ? oldManager->getVersion().toString() : ""(empty)"");

        if (_load(txn, chunkMap, shardIds, &shardVersions, oldManager)) {
            // TODO: Merge into diff code above, so we validate in one place
            if (isChunkMapValid(chunkMap)) {
                _chunkMap = std::move(chunkMap);
                _shardIds = std::move(shardIds);
","                _chunkRangeMap = _constructRanges(_chunkMap);

                log() << ""ChunkManager load took "" << t.millis() << "" ms and found version ""
                      << _version;

                return;
            }
        }

        warning() << ""ChunkManager load failed after "" << t.millis()
                  << "" ms and will be retried up to "" << tries << "" more times"";

        sleepmillis(10 * (3 - tries));
    }

    // This will abort construction so we should never have a reference to an invalid config
    msgasserted(13282,
                str::stream() << ""Couldn't load a valid config for "" << _ns
                              << "" after 3 attempts. Please try again."");
}
",22
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list.cpp,"+Status EgressMetadataHookList::writeRequestMetadata(OperationContext* txn,",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list.cpp,"+        auto status = hook->writeRequestMetadata(txn, requestDestination, metadataBob);",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    Status writeRequestMetadata(OperationContext* txn,",+,"    Status writeRequestMetadata(OperationContext* txn,
                                const HostAndPort& requestDestination,
                                BSONObjBuilder* metadataBob) override {
        metadataBob->append(_fieldName, requestDestination.toString());
        return Status::OK();
    }
",,"                                const HostAndPort& requestDestination,
                                BSONObjBuilder* metadataBob) override {
        metadataBob->append(_fieldName, requestDestination.toString());
        return Status::OK();
    }
",1
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    Status writeRequestMetadata(OperationContext* txn,",+,"    Status writeRequestMetadata(OperationContext* txn,
                                const HostAndPort& requestDestination,
                                BSONObjBuilder* metadataBob) override {
        return _toRet;
    }
",,"                                const HostAndPort& requestDestination,
                                BSONObjBuilder* metadataBob) override {
        return _toRet;
    }
",1
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_OK(hookList.writeRequestMetadata(nullptr, emptyHost, nullptr));",+,"TEST(EgressMetadataHookListTest, EmptyHookShouldNotFail) {
    EgressMetadataHookList hookList;
    HostAndPort emptyHost;
    ASSERT_OK(hookList.writeRequestMetadata(nullptr, emptyHost, nullptr));

    BSONObj emptyObj;
    ASSERT_OK(hookList.readReplyMetadata(emptyHost, emptyObj));
}
","TEST(EgressMetadataHookListTest, EmptyHookShouldNotFail) {
    EgressMetadataHookList hookList;
    HostAndPort emptyHost;
","
    BSONObj emptyObj;
    ASSERT_OK(hookList.readReplyMetadata(emptyHost, emptyObj));
}
",4
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_OK(hookList.readReplyMetadata(emptyHost, emptyObj));",+,"TEST(EgressMetadataHookListTest, EmptyHookShouldNotFail) {
    EgressMetadataHookList hookList;
    HostAndPort emptyHost;
    ASSERT_OK(hookList.writeRequestMetadata(nullptr, emptyHost, nullptr));

    BSONObj emptyObj;
    ASSERT_OK(hookList.readReplyMetadata(emptyHost, emptyObj));
}
","TEST(EgressMetadataHookListTest, EmptyHookShouldNotFail) {
    EgressMetadataHookList hookList;
    HostAndPort emptyHost;
    ASSERT_OK(hookList.writeRequestMetadata(nullptr, emptyHost, nullptr));

    BSONObj emptyObj;
","}
",7
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_OK(hookList.writeRequestMetadata(nullptr, HostAndPort(""a:123""), &builder));",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_BSONOBJ_EQ(BSON(""h1""",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_OK(hookList.readReplyMetadata(testHost, testObj));",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_EQ(testHost, hook1Args.replySource);",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_BSONOBJ_EQ(testObj, hook1Args.metadataObj);",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_OK(hookList.writeRequestMetadata(nullptr, HostAndPort(""a:123""), &builder));",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_BSONOBJ_EQ(BSON(""foo""",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_OK(hookList.readReplyMetadata(testHost, testObj));",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_EQ(testHost, hook1Args.replySource);",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_BSONOBJ_EQ(testObj, hook1Args.metadataObj);",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_EQ(testHost, hook2Args.replySource);",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_BSONOBJ_EQ(testObj, hook2Args.metadataObj);",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_NOT_OK(hookList.writeRequestMetadata(nullptr, HostAndPort(""a:123""), &builder));",+
"SERVER-27855 Attach all NetworkInterface instances with EgressHooks

with the exception of:
- NetworkInterfaceCollectionRangeDeleter-TaskExecutor (doesn't really use network)
- AddShard-TaskExecutor (destination shard is still not part of cluster)",src/mongo/rpc/metadata/egress_metadata_hook_list_test.cpp,"+    ASSERT_NOT_OK(hookList.readReplyMetadata(HostAndPort(""b:456""), BSON(""x"" << 1)));",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/plan_cache_test.cpp,+    assertPlanCacheRecoversSolution(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_array_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,+    assertNumSolutions(3U);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,+    assertNumSolutions(3U);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,+    assertNumSolutions(1U);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_geo_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(2);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(3);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(3);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(3);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(3);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(6);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(4);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertNumSolutions(6);,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,+    assertSolutionExists(,+
SERVER-13732 Index access plan for contained OR should consider top-level predicates,src/mongo/db/query/query_planner_test.cpp,"+    assertSolutionExists(""{cscan: {dir: 1}}}}"");",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/config.c,"+				fprintf(stderr,",+,"int
config_opt_file(WTPERF *wtperf, const char *filename)
{
	FILE *fp;
	size_t linelen, optionpos;
	int linenum, ret;
	bool contline;
	char line[4 * 1024], option[4 * 1024];
	char *comment, *ltrim, *rtrim;

	ret = 0;

	if ((fp = fopen(filename, ""r"")) == NULL) {
		fprintf(stderr, ""wtperf: %s: %s\n"", filename, strerror(errno));
		return (errno);
	}

	optionpos = 0;
	linenum = 0;
	while (fgets(line, sizeof(line), fp) != NULL) {
		linenum++;

		/* Skip leading space. */
		for (ltrim = line; *ltrim && isspace((u_char)*ltrim);
		     ltrim++)
			;

		/*
		 * Find the end of the line; if there's no trailing newline, the
		 * the line is too long for the buffer or the file was corrupted
		 * (there's no terminating newline in the file).
		 */
		for (rtrim = line; *rtrim && *rtrim != '\n'; rtrim++)
			;
		if (*rtrim != '\n') {
			fprintf(stderr,
			    ""wtperf: %s: %d: configuration line too long\n"",
			    filename, linenum);
			ret = EINVAL;
			break;
		}

		/* Skip trailing space. */
		while (rtrim > ltrim && isspace((u_char)rtrim[-1]))
			rtrim--;

		/*
		 * If the last non-space character in the line is an escape, the
		 * line will be continued. Checked early because the line might
		 * otherwise be empty.
		 */
		contline = rtrim > ltrim && rtrim[-1] == '\\';
		if (contline)
			rtrim--;

		/*
		 * Discard anything after the first hash character. Check after
		 * the escape character, the escape can appear after a comment.
		 */
		if ((comment = strchr(ltrim, '#')) != NULL)
			rtrim = comment;

		/* Skip trailing space again. */
		while (rtrim > ltrim && isspace((u_char)rtrim[-1]))
			rtrim--;

		/*
		 * Check for empty lines: note that the right-hand boundary can
		 * cross over the left-hand boundary, less-than or equal to is
		 * the correct test.
		 */
		if (rtrim <= ltrim) {
			/*
			 * If we're continuing from this line, or we haven't
			 * started building an option, ignore this line.
			 */
			if (contline || optionpos == 0)
				continue;

			/*
			 * An empty line terminating an option we're building;
			 * clean things up so we can proceed.
			 */
			linelen = 0;
		} else
			linelen = (size_t)(rtrim - ltrim);
		ltrim[linelen] = '\0';

		if (linelen + optionpos + 1 > sizeof(option)) {
			fprintf(stderr,
			    ""wtperf: %s: %d: option value overflow\n"",
			    filename, linenum);
			ret = EINVAL;
			break;
		}

		memcpy(&option[optionpos], ltrim, linelen);
		option[optionpos + linelen] = '\0';
		if (contline)
			optionpos += linelen;
		else {
			if ((ret = config_opt_str(wtperf, option)) != 0) {
				fprintf(stderr, ""wtperf: %s: %d: parse error\n"",
				    filename, linenum);
				break;
			}
			optionpos = 0;
		}
	}
	if (ret == 0) {
		if (ferror(fp)) {
			fprintf(stderr, ""wtperf: %s: read error\n"", filename);
			ret = errno;
		}
		if (optionpos > 0) {
			fprintf(stderr, ""wtperf: %s: %d: last line continues\n"",
			    filename, linenum);
			ret = EINVAL;
		}
	}

	(void)fclose(fp);
	return (ret);
}

/*
 * config_opt_str --
 *	Parse a single line of config options.  Continued lines have already
 * been joined.
 */
int
config_opt_str(WTPERF *wtperf, const char *optstr)
{
	CONFIG_OPTS *opts;
	CONFIG_QUEUE_ENTRY *config_line;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *scan;
	size_t len;
	int ret, t_ret;

	opts = wtperf->opts;

	len = strlen(optstr);
	if ((ret = wiredtiger_config_parser_open(
	    NULL, optstr, len, &scan)) != 0) {
		lprintf(wtperf, ret, 0, ""Error in config_scan_begin"");
		return (ret);
	}

	while (ret == 0) {
		size_t pos;

		if ((ret = scan->next(scan, &k, &v)) != 0) {
			/* Any parse error has already been reported. */
			if (ret == WT_NOTFOUND)
				ret = 0;
			break;
		}
		ret = config_opt(wtperf, &k, &v);

		/*
		 * Append the key-value pair to our copy of the config.
		 * The config is stored in the order it is processed, so added
		 * options will be after any parsed from the original config.
		 */
		config_line = dcalloc(sizeof(CONFIG_QUEUE_ENTRY), 1);
		/*
		 * If key or value is a string, consider extra space for the
		 * quotes. Add 2 to the required space for '=' and the ending
		 * null character in ""key=value"".
		 */
		config_line->string = dcalloc(
		    k.len + (k.type == WT_CONFIG_ITEM_STRING ? 2 : 0) +
		    v.len + (v.type == WT_CONFIG_ITEM_STRING ? 2 : 0) + 2, 1);
		pos = 0;
		if (k.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		strncpy(config_line->string + pos, k.str, k.len);
		pos += k.len;
		if (k.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		config_line->string[pos] = '=';
		pos++;
		if (v.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		strncpy(config_line->string + pos, v.str, v.len);
		pos += v.len;
		if (v.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		config_line->string[pos] = '\0';
		TAILQ_INSERT_TAIL(&opts->config_head, config_line, q);
	}
	if ((t_ret = scan->close(scan)) != 0) {
		lprintf(wtperf, ret, 0, ""Error in config_scan_end"");
		if (ret == 0)
			ret = t_ret;
	}

	return (ret);
}

/*
 * config_opt_name_value --
 *	Set a name/value configuration pair.
 */
int
config_opt_name_value(WTPERF *wtperf, const char *name, const char *value)
{
	size_t len;
	int ret;
	char *optstr;
							/* name=""value"" */
	len = strlen(name) + strlen(value) + 4;
	optstr = dmalloc(len);
	snprintf(optstr, len, ""%s=\""%s\"""", name, value);
	ret = config_opt_str(wtperf, optstr);
	free(optstr);
	return (ret);
}

/*
 * config_sanity --
 *	Configuration sanity checks.
 */
int
config_sanity(WTPERF *wtperf)
{
	CONFIG_OPTS *opts;
	WORKLOAD *workp;
	u_int i;

	opts = wtperf->opts;

	/* Various intervals should be less than the run-time. */
	if (opts->run_time > 0 &&
	    ((opts->checkpoint_threads != 0 &&
	    opts->checkpoint_interval > opts->run_time) ||
	    opts->report_interval > opts->run_time ||
	    opts->sample_interval > opts->run_time)) {
		fprintf(stderr, ""interval value longer than the run-time\n"");
		return (EINVAL);
	}
	/* The maximum is here to keep file name construction simple. */
	if (opts->table_count < 1 || opts->table_count > 99999) {
		fprintf(stderr,
		    ""invalid table count, less than 1 or greater than 99999\n"");
		return (EINVAL);
	}
	if (opts->database_count < 1 || opts->database_count > 99) {
		fprintf(stderr,
		    ""invalid database count, less than 1 or greater than 99\n"");
		return (EINVAL);
	}

	if (opts->pareto > 100) {
		fprintf(stderr,
		    ""Invalid pareto distribution - should be a percentage\n"");
		return (EINVAL);
	}

	if (opts->value_sz_max < opts->value_sz) {
		if (F_ISSET(wtperf, CFG_GROW)) {
			fprintf(stderr, ""value_sz_max %"" PRIu32
			    "" must be greater than or equal to value_sz %""
			    PRIu32 ""\n"", opts->value_sz_max, opts->value_sz);
			return (EINVAL);
		} else
			opts->value_sz_max = opts->value_sz;
	}
	if (opts->value_sz_min > opts->value_sz) {
		if (F_ISSET(wtperf, CFG_SHRINK)) {
			fprintf(stderr, ""value_sz_min %"" PRIu32
			    "" must be less than or equal to value_sz %""
			    PRIu32 ""\n"", opts->value_sz_min, opts->value_sz);
			return (EINVAL);
		} else
			opts->value_sz_min = opts->value_sz;
	}

	if (wtperf->workload != NULL)
		for (i = 0, workp = wtperf->workload;
		    i < wtperf->workload_cnt; ++i, ++workp) {
			if (opts->readonly &&
			    (workp->insert != 0 || workp->update != 0 ||
			    workp->truncate != 0)) {
				fprintf(stderr,
				    ""Invalid workload: insert, update or ""
				    ""truncate specified with readonly\n"");
				return (EINVAL);
			}
			if (workp->insert != 0 &&
			    workp->table_index != INT32_MAX) {
				fprintf(stderr,
				    ""Invalid workload: Cannot insert into ""
				    ""specific table only\n"");
				return (EINVAL);
			}
			if (workp->table_index != INT32_MAX &&
			    workp->table_index >= (int32_t)opts->table_count) {
				fprintf(stderr,
				    ""Workload table index %"" PRId32
				    "" is larger than table count %"" PRId32,
				    workp->table_index, opts->table_count);
				return (EINVAL);
			}
		}
	return (0);
}

/*
 * config_consolidate --
 *	Consolidate repeated configuration settings so that it only appears
 *	once in the configuration output file.
 */
static void
config_consolidate(CONFIG_OPTS *opts)
{
	CONFIG_QUEUE_ENTRY *conf_line, *test_line, *tmp;
	char *string_key;

	/*
	 * This loop iterates over the config queue and for each entry checks if
	 * a later queue entry has the same key. If there's a match, and key is
	 * ""conn_config"" or ""table_config"", the later queue entry is replaced
	 * with a concatenated entry of the two queue entries, the current queue
	 * entry is removed. For any other key, if there is a match, the current
	 * queue entry is removed.
	 */
	conf_line = TAILQ_FIRST(&opts->config_head);
	while (conf_line != NULL) {
		string_key = strchr(conf_line->string, '=');
		tmp = test_line = TAILQ_NEXT(conf_line, q);
		while (test_line != NULL) {
			/*
			 * The + 1 here forces the '=' sign to be matched
			 * ensuring we don't match keys that have a common
			 * prefix such as ""table_count"" and ""table_count_idle""
			 * as being the same key.
			 */
			if (strncmp(conf_line->string, test_line->string,
			    (size_t)((string_key - conf_line->string) + 1))
			    == 0) {
				if ((strncmp(""conn_config="", conf_line->string,
				    (size_t)((string_key - conf_line->string) +
				    1)) == 0) ||
				    (strncmp(""table_config="", conf_line->string,
				    (size_t)((string_key - conf_line->string) +
				    1)) == 0)) {
					char *concat_str, *val_pointer;

					/*
					 * To concatenate the two config
					 * strings, copy the first string to a
					 * new one, replace the ending '""' with
					 * a ',' and then concatenate the second
					 * string's value after its starting '""'
					 */
					val_pointer =
					    strchr(test_line->string, '=') + 2;
					concat_str =
					    dmalloc(strlen(conf_line->string) +
					    strlen(val_pointer) + 1);
					strcpy(concat_str, conf_line->string);
					concat_str[strlen(concat_str) - 1] =
					    ',';
					strcat(concat_str, val_pointer);
					free(test_line->string);
					test_line->string = concat_str;
				}

				TAILQ_REMOVE(&opts->config_head, conf_line, q);
				free(conf_line->string);
				free(conf_line);
				break;
			}
			test_line = TAILQ_NEXT(test_line, q);
		}
		conf_line = tmp;
	}
}

/*
 * config_opt_log --
 *	Write the final config used in this execution to a file.
 */
void
config_opt_log(CONFIG_OPTS *opts, const char *path)
{
	CONFIG_QUEUE_ENTRY *config_line;
	FILE *fp;

	testutil_checkfmt(((fp = fopen(path, ""w"")) == NULL), ""%s"", path);

	config_consolidate(opts);

	fprintf(fp,""# Warning: This config includes ""
	    ""unwritten, implicit configuration defaults.\n""
	    ""# Changes to those values may cause differences in behavior.\n"");
	TAILQ_FOREACH(config_line, &opts->config_head, q)
		fprintf(fp, ""%s\n"", config_line->string);
	testutil_check(fclose(fp));
}

/*
 * config_opt_print --
 *	Print out the configuration in verbose mode.
 */
void
config_opt_print(WTPERF *wtperf)
{
	CONFIG_OPTS *opts;
	WORKLOAD *workp;
	u_int i;

	opts = wtperf->opts;

	printf(""Workload configuration:\n"");
	printf(""\t"" ""Home: %s\n"", wtperf->home);
	printf(""\t"" ""Table name: %s\n"", opts->table_name);
	printf(""\t"" ""Connection configuration: %s\n"", opts->conn_config);
	if (opts->sess_config != NULL)
		printf(""\t"" ""Session configuration: %s\n"", opts->sess_config);

	printf(""\t%s table: %s\n"",
	    opts->create ? ""Creating new"" : ""Using existing"",
	    opts->table_config);
	printf(""\t"" ""Key size: %"" PRIu32 "", value size: %"" PRIu32 ""\n"",
	    opts->key_sz, opts->value_sz);
	if (opts->create)
		printf(""\t"" ""Populate threads: %"" PRIu32 "", inserting %"" PRIu32
		    "" rows\n"",
		    opts->populate_threads, opts->icount);

	printf(""\t"" ""Workload seconds, operations: %"" PRIu32 "", %"" PRIu32 ""\n"",
	    opts->run_time, opts->run_ops);
	if (wtperf->workload != NULL) {
		printf(""\t"" ""Workload configuration(s):\n"");
		for (i = 0, workp = wtperf->workload;
		    i < wtperf->workload_cnt; ++i, ++workp)
			printf(""\t\t%"" PRId64 "" threads (inserts=%"" PRId64
			    "", reads=%"" PRId64 "", updates=%"" PRId64
			    "", truncates=% "" PRId64 "")\n"",
			    workp->threads,
			    workp->insert, workp->read,
			    workp->update, workp->truncate);
	}

	printf(""\t"" ""Checkpoint threads, interval: %"" PRIu32 "", %"" PRIu32 ""\n"",
	    opts->checkpoint_threads, opts->checkpoint_interval);
	printf(""\t"" ""Reporting interval: %"" PRIu32 ""\n"", opts->report_interval);
	printf(""\t"" ""Sampling interval: %"" PRIu32 ""\n"", opts->sample_interval);

	printf(""\t"" ""Verbosity: %"" PRIu32 ""\n"", opts->verbose);
}

/*
 * pretty_print --
 *	Print out lines of text for a 80 character window.
 */
static void
pretty_print(const char *p, const char *indent)
{
	const char *t;

	for (;; p = t + 1) {
		if (strlen(p) <= 70)
			break;
		for (t = p + 70; t > p && *t != ' '; --t)
			;
		if (t == p)			/* No spaces? */
			break;
		printf(""%s%.*s\n"",
		    indent == NULL ? """" : indent, (int)(t - p), p);
	}
	if (*p != '\0')
		printf(""%s%s\n"", indent == NULL ? """" : indent, p);
}

/*
 * config_opt_usage --
 *	Configuration usage error message.
 */
void
config_opt_usage(void)
{
	size_t i;
	const char *defaultval, *typestr;

	pretty_print(
	    ""The following are options settable using -o or -O, showing the ""
	    ""type and default value.\n"", NULL);
	pretty_print(
	    ""String values must be enclosed in \"" quotes, boolean values must ""
	    ""be either true or false.\n"", NULL);

	for (i = 0; i < WT_ELEMENTS(config_opts_desc); i++) {
		defaultval = config_opts_desc[i].defaultval;
		typestr = ""string"";
		switch (config_opts_desc[i].type) {
		case BOOL_TYPE:
			typestr = ""boolean"";
			if (strcmp(defaultval, ""0"") == 0)
				defaultval = ""false"";
			else
				defaultval = ""true"";
			break;
		case CONFIG_STRING_TYPE:
		case STRING_TYPE:
			break;
		case INT_TYPE:
			typestr = ""int"";
			break;
		case UINT32_TYPE:
			typestr = ""unsigned int"";
			break;
		}
		printf(""%s (%s, default=%s)\n"",
		    config_opts_desc[i].name, typestr, defaultval);
		pretty_print(config_opts_desc[i].description, ""\t"");
	}
}
","int
config_opt_file(WTPERF *wtperf, const char *filename)
{
	FILE *fp;
	size_t linelen, optionpos;
	int linenum, ret;
	bool contline;
	char line[4 * 1024], option[4 * 1024];
	char *comment, *ltrim, *rtrim;

	ret = 0;

	if ((fp = fopen(filename, ""r"")) == NULL) {
		fprintf(stderr, ""wtperf: %s: %s\n"", filename, strerror(errno));
		return (errno);
	}

	optionpos = 0;
	linenum = 0;
	while (fgets(line, sizeof(line), fp) != NULL) {
		linenum++;

		/* Skip leading space. */
		for (ltrim = line; *ltrim && isspace((u_char)*ltrim);
		     ltrim++)
			;

		/*
		 * Find the end of the line; if there's no trailing newline, the
		 * the line is too long for the buffer or the file was corrupted
		 * (there's no terminating newline in the file).
		 */
		for (rtrim = line; *rtrim && *rtrim != '\n'; rtrim++)
			;
		if (*rtrim != '\n') {
			fprintf(stderr,
			    ""wtperf: %s: %d: configuration line too long\n"",
			    filename, linenum);
			ret = EINVAL;
			break;
		}

		/* Skip trailing space. */
		while (rtrim > ltrim && isspace((u_char)rtrim[-1]))
			rtrim--;

		/*
		 * If the last non-space character in the line is an escape, the
		 * line will be continued. Checked early because the line might
		 * otherwise be empty.
		 */
		contline = rtrim > ltrim && rtrim[-1] == '\\';
		if (contline)
			rtrim--;

		/*
		 * Discard anything after the first hash character. Check after
		 * the escape character, the escape can appear after a comment.
		 */
		if ((comment = strchr(ltrim, '#')) != NULL)
			rtrim = comment;

		/* Skip trailing space again. */
		while (rtrim > ltrim && isspace((u_char)rtrim[-1]))
			rtrim--;

		/*
		 * Check for empty lines: note that the right-hand boundary can
		 * cross over the left-hand boundary, less-than or equal to is
		 * the correct test.
		 */
		if (rtrim <= ltrim) {
			/*
			 * If we're continuing from this line, or we haven't
			 * started building an option, ignore this line.
			 */
			if (contline || optionpos == 0)
				continue;

			/*
			 * An empty line terminating an option we're building;
			 * clean things up so we can proceed.
			 */
			linelen = 0;
		} else
			linelen = (size_t)(rtrim - ltrim);
		ltrim[linelen] = '\0';

		if (linelen + optionpos + 1 > sizeof(option)) {
			fprintf(stderr,
			    ""wtperf: %s: %d: option value overflow\n"",
			    filename, linenum);
			ret = EINVAL;
			break;
		}

		memcpy(&option[optionpos], ltrim, linelen);
		option[optionpos + linelen] = '\0';
		if (contline)
			optionpos += linelen;
		else {
			if ((ret = config_opt_str(wtperf, option)) != 0) {
				fprintf(stderr, ""wtperf: %s: %d: parse error\n"",
				    filename, linenum);
				break;
			}
			optionpos = 0;
		}
	}
	if (ret == 0) {
		if (ferror(fp)) {
			fprintf(stderr, ""wtperf: %s: read error\n"", filename);
			ret = errno;
		}
		if (optionpos > 0) {
			fprintf(stderr, ""wtperf: %s: %d: last line continues\n"",
			    filename, linenum);
			ret = EINVAL;
		}
	}

	(void)fclose(fp);
	return (ret);
}

/*
 * config_opt_str --
 *	Parse a single line of config options.  Continued lines have already
 * been joined.
 */
int
config_opt_str(WTPERF *wtperf, const char *optstr)
{
	CONFIG_OPTS *opts;
	CONFIG_QUEUE_ENTRY *config_line;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *scan;
	size_t len;
	int ret, t_ret;

	opts = wtperf->opts;

	len = strlen(optstr);
	if ((ret = wiredtiger_config_parser_open(
	    NULL, optstr, len, &scan)) != 0) {
		lprintf(wtperf, ret, 0, ""Error in config_scan_begin"");
		return (ret);
	}

	while (ret == 0) {
		size_t pos;

		if ((ret = scan->next(scan, &k, &v)) != 0) {
			/* Any parse error has already been reported. */
			if (ret == WT_NOTFOUND)
				ret = 0;
			break;
		}
		ret = config_opt(wtperf, &k, &v);

		/*
		 * Append the key-value pair to our copy of the config.
		 * The config is stored in the order it is processed, so added
		 * options will be after any parsed from the original config.
		 */
		config_line = dcalloc(sizeof(CONFIG_QUEUE_ENTRY), 1);
		/*
		 * If key or value is a string, consider extra space for the
		 * quotes. Add 2 to the required space for '=' and the ending
		 * null character in ""key=value"".
		 */
		config_line->string = dcalloc(
		    k.len + (k.type == WT_CONFIG_ITEM_STRING ? 2 : 0) +
		    v.len + (v.type == WT_CONFIG_ITEM_STRING ? 2 : 0) + 2, 1);
		pos = 0;
		if (k.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		strncpy(config_line->string + pos, k.str, k.len);
		pos += k.len;
		if (k.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		config_line->string[pos] = '=';
		pos++;
		if (v.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		strncpy(config_line->string + pos, v.str, v.len);
		pos += v.len;
		if (v.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		config_line->string[pos] = '\0';
		TAILQ_INSERT_TAIL(&opts->config_head, config_line, q);
	}
	if ((t_ret = scan->close(scan)) != 0) {
		lprintf(wtperf, ret, 0, ""Error in config_scan_end"");
		if (ret == 0)
			ret = t_ret;
	}

	return (ret);
}

/*
 * config_opt_name_value --
 *	Set a name/value configuration pair.
 */
int
config_opt_name_value(WTPERF *wtperf, const char *name, const char *value)
{
	size_t len;
	int ret;
	char *optstr;
							/* name=""value"" */
	len = strlen(name) + strlen(value) + 4;
	optstr = dmalloc(len);
	snprintf(optstr, len, ""%s=\""%s\"""", name, value);
	ret = config_opt_str(wtperf, optstr);
	free(optstr);
	return (ret);
}

/*
 * config_sanity --
 *	Configuration sanity checks.
 */
int
config_sanity(WTPERF *wtperf)
{
	CONFIG_OPTS *opts;
	WORKLOAD *workp;
	u_int i;

	opts = wtperf->opts;

	/* Various intervals should be less than the run-time. */
	if (opts->run_time > 0 &&
	    ((opts->checkpoint_threads != 0 &&
	    opts->checkpoint_interval > opts->run_time) ||
	    opts->report_interval > opts->run_time ||
	    opts->sample_interval > opts->run_time)) {
		fprintf(stderr, ""interval value longer than the run-time\n"");
		return (EINVAL);
	}
	/* The maximum is here to keep file name construction simple. */
	if (opts->table_count < 1 || opts->table_count > 99999) {
		fprintf(stderr,
		    ""invalid table count, less than 1 or greater than 99999\n"");
		return (EINVAL);
	}
	if (opts->database_count < 1 || opts->database_count > 99) {
		fprintf(stderr,
		    ""invalid database count, less than 1 or greater than 99\n"");
		return (EINVAL);
	}

	if (opts->pareto > 100) {
		fprintf(stderr,
		    ""Invalid pareto distribution - should be a percentage\n"");
		return (EINVAL);
	}

	if (opts->value_sz_max < opts->value_sz) {
		if (F_ISSET(wtperf, CFG_GROW)) {
			fprintf(stderr, ""value_sz_max %"" PRIu32
			    "" must be greater than or equal to value_sz %""
			    PRIu32 ""\n"", opts->value_sz_max, opts->value_sz);
			return (EINVAL);
		} else
			opts->value_sz_max = opts->value_sz;
	}
	if (opts->value_sz_min > opts->value_sz) {
		if (F_ISSET(wtperf, CFG_SHRINK)) {
			fprintf(stderr, ""value_sz_min %"" PRIu32
			    "" must be less than or equal to value_sz %""
			    PRIu32 ""\n"", opts->value_sz_min, opts->value_sz);
			return (EINVAL);
		} else
			opts->value_sz_min = opts->value_sz;
	}

	if (wtperf->workload != NULL)
		for (i = 0, workp = wtperf->workload;
		    i < wtperf->workload_cnt; ++i, ++workp) {
			if (opts->readonly &&
			    (workp->insert != 0 || workp->update != 0 ||
			    workp->truncate != 0)) {
				fprintf(stderr,
				    ""Invalid workload: insert, update or ""
				    ""truncate specified with readonly\n"");
				return (EINVAL);
			}
			if (workp->insert != 0 &&
			    workp->table_index != INT32_MAX) {
				fprintf(stderr,
				    ""Invalid workload: Cannot insert into ""
				    ""specific table only\n"");
				return (EINVAL);
			}
			if (workp->table_index != INT32_MAX &&
			    workp->table_index >= (int32_t)opts->table_count) {
				fprintf(stderr,
				    ""Workload table index %"" PRId32
				    "" is larger than table count %"" PRId32,
				    workp->table_index, opts->table_count);
				return (EINVAL);
			}
		}
	return (0);
}

/*
 * config_consolidate --
 *	Consolidate repeated configuration settings so that it only appears
 *	once in the configuration output file.
 */
static void
config_consolidate(CONFIG_OPTS *opts)
{
	CONFIG_QUEUE_ENTRY *conf_line, *test_line, *tmp;
	char *string_key;

	/*
	 * This loop iterates over the config queue and for each entry checks if
	 * a later queue entry has the same key. If there's a match, and key is
	 * ""conn_config"" or ""table_config"", the later queue entry is replaced
	 * with a concatenated entry of the two queue entries, the current queue
	 * entry is removed. For any other key, if there is a match, the current
	 * queue entry is removed.
	 */
	conf_line = TAILQ_FIRST(&opts->config_head);
	while (conf_line != NULL) {
		string_key = strchr(conf_line->string, '=');
		tmp = test_line = TAILQ_NEXT(conf_line, q);
		while (test_line != NULL) {
","			 * The + 1 here forces the '=' sign to be matched
			 * ensuring we don't match keys that have a common
			 * prefix such as ""table_count"" and ""table_count_idle""
			 * as being the same key.
			 */
			if (strncmp(conf_line->string, test_line->string,
			    (size_t)((string_key - conf_line->string) + 1))
			    == 0) {
				if ((strncmp(""conn_config="", conf_line->string,
				    (size_t)((string_key - conf_line->string) +
				    1)) == 0) ||
				    (strncmp(""table_config="", conf_line->string,
				    (size_t)((string_key - conf_line->string) +
				    1)) == 0)) {
					char *concat_str, *val_pointer;

					/*
					 * To concatenate the two config
					 * strings, copy the first string to a
					 * new one, replace the ending '""' with
					 * a ',' and then concatenate the second
					 * string's value after its starting '""'
					 */
					val_pointer =
					    strchr(test_line->string, '=') + 2;
					concat_str =
					    dmalloc(strlen(conf_line->string) +
					    strlen(val_pointer) + 1);
					strcpy(concat_str, conf_line->string);
					concat_str[strlen(concat_str) - 1] =
					    ',';
					strcat(concat_str, val_pointer);
					free(test_line->string);
					test_line->string = concat_str;
				}

				TAILQ_REMOVE(&opts->config_head, conf_line, q);
				free(conf_line->string);
				free(conf_line);
				break;
			}
			test_line = TAILQ_NEXT(test_line, q);
		}
		conf_line = tmp;
	}
}

/*
 * config_opt_log --
 *	Write the final config used in this execution to a file.
 */
void
config_opt_log(CONFIG_OPTS *opts, const char *path)
{
	CONFIG_QUEUE_ENTRY *config_line;
	FILE *fp;

	testutil_checkfmt(((fp = fopen(path, ""w"")) == NULL), ""%s"", path);

	config_consolidate(opts);

	fprintf(fp,""# Warning: This config includes ""
	    ""unwritten, implicit configuration defaults.\n""
	    ""# Changes to those values may cause differences in behavior.\n"");
	TAILQ_FOREACH(config_line, &opts->config_head, q)
		fprintf(fp, ""%s\n"", config_line->string);
	testutil_check(fclose(fp));
}

/*
 * config_opt_print --
 *	Print out the configuration in verbose mode.
 */
void
config_opt_print(WTPERF *wtperf)
{
	CONFIG_OPTS *opts;
	WORKLOAD *workp;
	u_int i;

	opts = wtperf->opts;

	printf(""Workload configuration:\n"");
	printf(""\t"" ""Home: %s\n"", wtperf->home);
	printf(""\t"" ""Table name: %s\n"", opts->table_name);
	printf(""\t"" ""Connection configuration: %s\n"", opts->conn_config);
	if (opts->sess_config != NULL)
		printf(""\t"" ""Session configuration: %s\n"", opts->sess_config);

	printf(""\t%s table: %s\n"",
	    opts->create ? ""Creating new"" : ""Using existing"",
	    opts->table_config);
	printf(""\t"" ""Key size: %"" PRIu32 "", value size: %"" PRIu32 ""\n"",
	    opts->key_sz, opts->value_sz);
	if (opts->create)
		printf(""\t"" ""Populate threads: %"" PRIu32 "", inserting %"" PRIu32
		    "" rows\n"",
		    opts->populate_threads, opts->icount);

	printf(""\t"" ""Workload seconds, operations: %"" PRIu32 "", %"" PRIu32 ""\n"",
	    opts->run_time, opts->run_ops);
	if (wtperf->workload != NULL) {
		printf(""\t"" ""Workload configuration(s):\n"");
		for (i = 0, workp = wtperf->workload;
		    i < wtperf->workload_cnt; ++i, ++workp)
			printf(""\t\t%"" PRId64 "" threads (inserts=%"" PRId64
			    "", reads=%"" PRId64 "", updates=%"" PRId64
			    "", truncates=% "" PRId64 "")\n"",
			    workp->threads,
			    workp->insert, workp->read,
			    workp->update, workp->truncate);
	}

	printf(""\t"" ""Checkpoint threads, interval: %"" PRIu32 "", %"" PRIu32 ""\n"",
	    opts->checkpoint_threads, opts->checkpoint_interval);
	printf(""\t"" ""Reporting interval: %"" PRIu32 ""\n"", opts->report_interval);
	printf(""\t"" ""Sampling interval: %"" PRIu32 ""\n"", opts->sample_interval);

	printf(""\t"" ""Verbosity: %"" PRIu32 ""\n"", opts->verbose);
}

/*
 * pretty_print --
 *	Print out lines of text for a 80 character window.
 */
static void
pretty_print(const char *p, const char *indent)
{
	const char *t;

	for (;; p = t + 1) {
		if (strlen(p) <= 70)
			break;
		for (t = p + 70; t > p && *t != ' '; --t)
			;
		if (t == p)			/* No spaces? */
			break;
		printf(""%s%.*s\n"",
		    indent == NULL ? """" : indent, (int)(t - p), p);
	}
	if (*p != '\0')
		printf(""%s%s\n"", indent == NULL ? """" : indent, p);
}

/*
 * config_opt_usage --
 *	Configuration usage error message.
 */
void
config_opt_usage(void)
{
	size_t i;
	const char *defaultval, *typestr;

	pretty_print(
	    ""The following are options settable using -o or -O, showing the ""
	    ""type and default value.\n"", NULL);
	pretty_print(
	    ""String values must be enclosed in \"" quotes, boolean values must ""
	    ""be either true or false.\n"", NULL);

	for (i = 0; i < WT_ELEMENTS(config_opts_desc); i++) {
		defaultval = config_opts_desc[i].defaultval;
		typestr = ""string"";
		switch (config_opts_desc[i].type) {
		case BOOL_TYPE:
			typestr = ""boolean"";
			if (strcmp(defaultval, ""0"") == 0)
				defaultval = ""false"";
			else
				defaultval = ""true"";
			break;
		case CONFIG_STRING_TYPE:
		case STRING_TYPE:
			break;
		case INT_TYPE:
			typestr = ""int"";
			break;
		case UINT32_TYPE:
			typestr = ""unsigned int"";
			break;
		}
		printf(""%s (%s, default=%s)\n"",
		    config_opts_desc[i].name, typestr, defaultval);
		pretty_print(config_opts_desc[i].description, ""\t"");
	}
}
",342
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/config.c,"+				fprintf(stderr,",+,"int
config_opt_file(WTPERF *wtperf, const char *filename)
{
	FILE *fp;
	size_t linelen, optionpos;
	int linenum, ret;
	bool contline;
	char line[4 * 1024], option[4 * 1024];
	char *comment, *ltrim, *rtrim;

	ret = 0;

	if ((fp = fopen(filename, ""r"")) == NULL) {
		fprintf(stderr, ""wtperf: %s: %s\n"", filename, strerror(errno));
		return (errno);
	}

	optionpos = 0;
	linenum = 0;
	while (fgets(line, sizeof(line), fp) != NULL) {
		linenum++;

		/* Skip leading space. */
		for (ltrim = line; *ltrim && isspace((u_char)*ltrim);
		     ltrim++)
			;

		/*
		 * Find the end of the line; if there's no trailing newline, the
		 * the line is too long for the buffer or the file was corrupted
		 * (there's no terminating newline in the file).
		 */
		for (rtrim = line; *rtrim && *rtrim != '\n'; rtrim++)
			;
		if (*rtrim != '\n') {
			fprintf(stderr,
			    ""wtperf: %s: %d: configuration line too long\n"",
			    filename, linenum);
			ret = EINVAL;
			break;
		}

		/* Skip trailing space. */
		while (rtrim > ltrim && isspace((u_char)rtrim[-1]))
			rtrim--;

		/*
		 * If the last non-space character in the line is an escape, the
		 * line will be continued. Checked early because the line might
		 * otherwise be empty.
		 */
		contline = rtrim > ltrim && rtrim[-1] == '\\';
		if (contline)
			rtrim--;

		/*
		 * Discard anything after the first hash character. Check after
		 * the escape character, the escape can appear after a comment.
		 */
		if ((comment = strchr(ltrim, '#')) != NULL)
			rtrim = comment;

		/* Skip trailing space again. */
		while (rtrim > ltrim && isspace((u_char)rtrim[-1]))
			rtrim--;

		/*
		 * Check for empty lines: note that the right-hand boundary can
		 * cross over the left-hand boundary, less-than or equal to is
		 * the correct test.
		 */
		if (rtrim <= ltrim) {
			/*
			 * If we're continuing from this line, or we haven't
			 * started building an option, ignore this line.
			 */
			if (contline || optionpos == 0)
				continue;

			/*
			 * An empty line terminating an option we're building;
			 * clean things up so we can proceed.
			 */
			linelen = 0;
		} else
			linelen = (size_t)(rtrim - ltrim);
		ltrim[linelen] = '\0';

		if (linelen + optionpos + 1 > sizeof(option)) {
			fprintf(stderr,
			    ""wtperf: %s: %d: option value overflow\n"",
			    filename, linenum);
			ret = EINVAL;
			break;
		}

		memcpy(&option[optionpos], ltrim, linelen);
		option[optionpos + linelen] = '\0';
		if (contline)
			optionpos += linelen;
		else {
			if ((ret = config_opt_str(wtperf, option)) != 0) {
				fprintf(stderr, ""wtperf: %s: %d: parse error\n"",
				    filename, linenum);
				break;
			}
			optionpos = 0;
		}
	}
	if (ret == 0) {
		if (ferror(fp)) {
			fprintf(stderr, ""wtperf: %s: read error\n"", filename);
			ret = errno;
		}
		if (optionpos > 0) {
			fprintf(stderr, ""wtperf: %s: %d: last line continues\n"",
			    filename, linenum);
			ret = EINVAL;
		}
	}

	(void)fclose(fp);
	return (ret);
}

/*
 * config_opt_str --
 *	Parse a single line of config options.  Continued lines have already
 * been joined.
 */
int
config_opt_str(WTPERF *wtperf, const char *optstr)
{
	CONFIG_OPTS *opts;
	CONFIG_QUEUE_ENTRY *config_line;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *scan;
	size_t len;
	int ret, t_ret;

	opts = wtperf->opts;

	len = strlen(optstr);
	if ((ret = wiredtiger_config_parser_open(
	    NULL, optstr, len, &scan)) != 0) {
		lprintf(wtperf, ret, 0, ""Error in config_scan_begin"");
		return (ret);
	}

	while (ret == 0) {
		size_t pos;

		if ((ret = scan->next(scan, &k, &v)) != 0) {
			/* Any parse error has already been reported. */
			if (ret == WT_NOTFOUND)
				ret = 0;
			break;
		}
		ret = config_opt(wtperf, &k, &v);

		/*
		 * Append the key-value pair to our copy of the config.
		 * The config is stored in the order it is processed, so added
		 * options will be after any parsed from the original config.
		 */
		config_line = dcalloc(sizeof(CONFIG_QUEUE_ENTRY), 1);
		/*
		 * If key or value is a string, consider extra space for the
		 * quotes. Add 2 to the required space for '=' and the ending
		 * null character in ""key=value"".
		 */
		config_line->string = dcalloc(
		    k.len + (k.type == WT_CONFIG_ITEM_STRING ? 2 : 0) +
		    v.len + (v.type == WT_CONFIG_ITEM_STRING ? 2 : 0) + 2, 1);
		pos = 0;
		if (k.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		strncpy(config_line->string + pos, k.str, k.len);
		pos += k.len;
		if (k.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		config_line->string[pos] = '=';
		pos++;
		if (v.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		strncpy(config_line->string + pos, v.str, v.len);
		pos += v.len;
		if (v.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		config_line->string[pos] = '\0';
		TAILQ_INSERT_TAIL(&opts->config_head, config_line, q);
	}
	if ((t_ret = scan->close(scan)) != 0) {
		lprintf(wtperf, ret, 0, ""Error in config_scan_end"");
		if (ret == 0)
			ret = t_ret;
	}

	return (ret);
}

/*
 * config_opt_name_value --
 *	Set a name/value configuration pair.
 */
int
config_opt_name_value(WTPERF *wtperf, const char *name, const char *value)
{
	size_t len;
	int ret;
	char *optstr;
							/* name=""value"" */
	len = strlen(name) + strlen(value) + 4;
	optstr = dmalloc(len);
	snprintf(optstr, len, ""%s=\""%s\"""", name, value);
	ret = config_opt_str(wtperf, optstr);
	free(optstr);
	return (ret);
}

/*
 * config_sanity --
 *	Configuration sanity checks.
 */
int
config_sanity(WTPERF *wtperf)
{
	CONFIG_OPTS *opts;
	WORKLOAD *workp;
	u_int i;

	opts = wtperf->opts;

	/* Various intervals should be less than the run-time. */
	if (opts->run_time > 0 &&
	    ((opts->checkpoint_threads != 0 &&
	    opts->checkpoint_interval > opts->run_time) ||
	    opts->report_interval > opts->run_time ||
	    opts->sample_interval > opts->run_time)) {
		fprintf(stderr, ""interval value longer than the run-time\n"");
		return (EINVAL);
	}
	/* The maximum is here to keep file name construction simple. */
	if (opts->table_count < 1 || opts->table_count > 99999) {
		fprintf(stderr,
		    ""invalid table count, less than 1 or greater than 99999\n"");
		return (EINVAL);
	}
	if (opts->database_count < 1 || opts->database_count > 99) {
		fprintf(stderr,
		    ""invalid database count, less than 1 or greater than 99\n"");
		return (EINVAL);
	}

	if (opts->pareto > 100) {
		fprintf(stderr,
		    ""Invalid pareto distribution - should be a percentage\n"");
		return (EINVAL);
	}

	if (opts->value_sz_max < opts->value_sz) {
		if (F_ISSET(wtperf, CFG_GROW)) {
			fprintf(stderr, ""value_sz_max %"" PRIu32
			    "" must be greater than or equal to value_sz %""
			    PRIu32 ""\n"", opts->value_sz_max, opts->value_sz);
			return (EINVAL);
		} else
			opts->value_sz_max = opts->value_sz;
	}
	if (opts->value_sz_min > opts->value_sz) {
		if (F_ISSET(wtperf, CFG_SHRINK)) {
			fprintf(stderr, ""value_sz_min %"" PRIu32
			    "" must be less than or equal to value_sz %""
			    PRIu32 ""\n"", opts->value_sz_min, opts->value_sz);
			return (EINVAL);
		} else
			opts->value_sz_min = opts->value_sz;
	}

	if (wtperf->workload != NULL)
		for (i = 0, workp = wtperf->workload;
		    i < wtperf->workload_cnt; ++i, ++workp) {
			if (opts->readonly &&
			    (workp->insert != 0 || workp->update != 0 ||
			    workp->truncate != 0)) {
				fprintf(stderr,
				    ""Invalid workload: insert, update or ""
				    ""truncate specified with readonly\n"");
				return (EINVAL);
			}
			if (workp->insert != 0 &&
			    workp->table_index != INT32_MAX) {
				fprintf(stderr,
				    ""Invalid workload: Cannot insert into ""
				    ""specific table only\n"");
				return (EINVAL);
			}
			if (workp->table_index != INT32_MAX &&
			    workp->table_index >= (int32_t)opts->table_count) {
				fprintf(stderr,
				    ""Workload table index %"" PRId32
				    "" is larger than table count %"" PRId32,
				    workp->table_index, opts->table_count);
				return (EINVAL);
			}
		}
	return (0);
}

/*
 * config_consolidate --
 *	Consolidate repeated configuration settings so that it only appears
 *	once in the configuration output file.
 */
static void
config_consolidate(CONFIG_OPTS *opts)
{
	CONFIG_QUEUE_ENTRY *conf_line, *test_line, *tmp;
	char *string_key;

	/*
	 * This loop iterates over the config queue and for each entry checks if
	 * a later queue entry has the same key. If there's a match, and key is
	 * ""conn_config"" or ""table_config"", the later queue entry is replaced
	 * with a concatenated entry of the two queue entries, the current queue
	 * entry is removed. For any other key, if there is a match, the current
	 * queue entry is removed.
	 */
	conf_line = TAILQ_FIRST(&opts->config_head);
	while (conf_line != NULL) {
		string_key = strchr(conf_line->string, '=');
		tmp = test_line = TAILQ_NEXT(conf_line, q);
		while (test_line != NULL) {
			/*
			 * The + 1 here forces the '=' sign to be matched
			 * ensuring we don't match keys that have a common
			 * prefix such as ""table_count"" and ""table_count_idle""
			 * as being the same key.
			 */
			if (strncmp(conf_line->string, test_line->string,
			    (size_t)((string_key - conf_line->string) + 1))
			    == 0) {
				if ((strncmp(""conn_config="", conf_line->string,
				    (size_t)((string_key - conf_line->string) +
				    1)) == 0) ||
				    (strncmp(""table_config="", conf_line->string,
				    (size_t)((string_key - conf_line->string) +
				    1)) == 0)) {
					char *concat_str, *val_pointer;

					/*
					 * To concatenate the two config
					 * strings, copy the first string to a
					 * new one, replace the ending '""' with
					 * a ',' and then concatenate the second
					 * string's value after its starting '""'
					 */
					val_pointer =
					    strchr(test_line->string, '=') + 2;
					concat_str =
					    dmalloc(strlen(conf_line->string) +
					    strlen(val_pointer) + 1);
					strcpy(concat_str, conf_line->string);
					concat_str[strlen(concat_str) - 1] =
					    ',';
					strcat(concat_str, val_pointer);
					free(test_line->string);
					test_line->string = concat_str;
				}

				TAILQ_REMOVE(&opts->config_head, conf_line, q);
				free(conf_line->string);
				free(conf_line);
				break;
			}
			test_line = TAILQ_NEXT(test_line, q);
		}
		conf_line = tmp;
	}
}

/*
 * config_opt_log --
 *	Write the final config used in this execution to a file.
 */
void
config_opt_log(CONFIG_OPTS *opts, const char *path)
{
	CONFIG_QUEUE_ENTRY *config_line;
	FILE *fp;

	testutil_checkfmt(((fp = fopen(path, ""w"")) == NULL), ""%s"", path);

	config_consolidate(opts);

	fprintf(fp,""# Warning: This config includes ""
	    ""unwritten, implicit configuration defaults.\n""
	    ""# Changes to those values may cause differences in behavior.\n"");
	TAILQ_FOREACH(config_line, &opts->config_head, q)
		fprintf(fp, ""%s\n"", config_line->string);
	testutil_check(fclose(fp));
}

/*
 * config_opt_print --
 *	Print out the configuration in verbose mode.
 */
void
config_opt_print(WTPERF *wtperf)
{
	CONFIG_OPTS *opts;
	WORKLOAD *workp;
	u_int i;

	opts = wtperf->opts;

	printf(""Workload configuration:\n"");
	printf(""\t"" ""Home: %s\n"", wtperf->home);
	printf(""\t"" ""Table name: %s\n"", opts->table_name);
	printf(""\t"" ""Connection configuration: %s\n"", opts->conn_config);
	if (opts->sess_config != NULL)
		printf(""\t"" ""Session configuration: %s\n"", opts->sess_config);

	printf(""\t%s table: %s\n"",
	    opts->create ? ""Creating new"" : ""Using existing"",
	    opts->table_config);
	printf(""\t"" ""Key size: %"" PRIu32 "", value size: %"" PRIu32 ""\n"",
	    opts->key_sz, opts->value_sz);
	if (opts->create)
		printf(""\t"" ""Populate threads: %"" PRIu32 "", inserting %"" PRIu32
		    "" rows\n"",
		    opts->populate_threads, opts->icount);

	printf(""\t"" ""Workload seconds, operations: %"" PRIu32 "", %"" PRIu32 ""\n"",
	    opts->run_time, opts->run_ops);
	if (wtperf->workload != NULL) {
		printf(""\t"" ""Workload configuration(s):\n"");
		for (i = 0, workp = wtperf->workload;
		    i < wtperf->workload_cnt; ++i, ++workp)
			printf(""\t\t%"" PRId64 "" threads (inserts=%"" PRId64
			    "", reads=%"" PRId64 "", updates=%"" PRId64
			    "", truncates=% "" PRId64 "")\n"",
			    workp->threads,
			    workp->insert, workp->read,
			    workp->update, workp->truncate);
	}

	printf(""\t"" ""Checkpoint threads, interval: %"" PRIu32 "", %"" PRIu32 ""\n"",
	    opts->checkpoint_threads, opts->checkpoint_interval);
	printf(""\t"" ""Reporting interval: %"" PRIu32 ""\n"", opts->report_interval);
	printf(""\t"" ""Sampling interval: %"" PRIu32 ""\n"", opts->sample_interval);

	printf(""\t"" ""Verbosity: %"" PRIu32 ""\n"", opts->verbose);
}

/*
 * pretty_print --
 *	Print out lines of text for a 80 character window.
 */
static void
pretty_print(const char *p, const char *indent)
{
	const char *t;

	for (;; p = t + 1) {
		if (strlen(p) <= 70)
			break;
		for (t = p + 70; t > p && *t != ' '; --t)
			;
		if (t == p)			/* No spaces? */
			break;
		printf(""%s%.*s\n"",
		    indent == NULL ? """" : indent, (int)(t - p), p);
	}
	if (*p != '\0')
		printf(""%s%s\n"", indent == NULL ? """" : indent, p);
}

/*
 * config_opt_usage --
 *	Configuration usage error message.
 */
void
config_opt_usage(void)
{
	size_t i;
	const char *defaultval, *typestr;

	pretty_print(
	    ""The following are options settable using -o or -O, showing the ""
	    ""type and default value.\n"", NULL);
	pretty_print(
	    ""String values must be enclosed in \"" quotes, boolean values must ""
	    ""be either true or false.\n"", NULL);

	for (i = 0; i < WT_ELEMENTS(config_opts_desc); i++) {
		defaultval = config_opts_desc[i].defaultval;
		typestr = ""string"";
		switch (config_opts_desc[i].type) {
		case BOOL_TYPE:
			typestr = ""boolean"";
			if (strcmp(defaultval, ""0"") == 0)
				defaultval = ""false"";
			else
				defaultval = ""true"";
			break;
		case CONFIG_STRING_TYPE:
		case STRING_TYPE:
			break;
		case INT_TYPE:
			typestr = ""int"";
			break;
		case UINT32_TYPE:
			typestr = ""unsigned int"";
			break;
		}
		printf(""%s (%s, default=%s)\n"",
		    config_opts_desc[i].name, typestr, defaultval);
		pretty_print(config_opts_desc[i].description, ""\t"");
	}
}
","int
config_opt_file(WTPERF *wtperf, const char *filename)
{
	FILE *fp;
	size_t linelen, optionpos;
	int linenum, ret;
	bool contline;
	char line[4 * 1024], option[4 * 1024];
	char *comment, *ltrim, *rtrim;

	ret = 0;

	if ((fp = fopen(filename, ""r"")) == NULL) {
		fprintf(stderr, ""wtperf: %s: %s\n"", filename, strerror(errno));
		return (errno);
	}

	optionpos = 0;
	linenum = 0;
	while (fgets(line, sizeof(line), fp) != NULL) {
		linenum++;

		/* Skip leading space. */
		for (ltrim = line; *ltrim && isspace((u_char)*ltrim);
		     ltrim++)
			;

		/*
		 * Find the end of the line; if there's no trailing newline, the
		 * the line is too long for the buffer or the file was corrupted
		 * (there's no terminating newline in the file).
		 */
		for (rtrim = line; *rtrim && *rtrim != '\n'; rtrim++)
			;
		if (*rtrim != '\n') {
			fprintf(stderr,
			    ""wtperf: %s: %d: configuration line too long\n"",
			    filename, linenum);
			ret = EINVAL;
			break;
		}

		/* Skip trailing space. */
		while (rtrim > ltrim && isspace((u_char)rtrim[-1]))
			rtrim--;

		/*
		 * If the last non-space character in the line is an escape, the
		 * line will be continued. Checked early because the line might
		 * otherwise be empty.
		 */
		contline = rtrim > ltrim && rtrim[-1] == '\\';
		if (contline)
			rtrim--;

		/*
		 * Discard anything after the first hash character. Check after
		 * the escape character, the escape can appear after a comment.
		 */
		if ((comment = strchr(ltrim, '#')) != NULL)
			rtrim = comment;

		/* Skip trailing space again. */
		while (rtrim > ltrim && isspace((u_char)rtrim[-1]))
			rtrim--;

		/*
		 * Check for empty lines: note that the right-hand boundary can
		 * cross over the left-hand boundary, less-than or equal to is
		 * the correct test.
		 */
		if (rtrim <= ltrim) {
			/*
			 * If we're continuing from this line, or we haven't
			 * started building an option, ignore this line.
			 */
			if (contline || optionpos == 0)
				continue;

			/*
			 * An empty line terminating an option we're building;
			 * clean things up so we can proceed.
			 */
			linelen = 0;
		} else
			linelen = (size_t)(rtrim - ltrim);
		ltrim[linelen] = '\0';

		if (linelen + optionpos + 1 > sizeof(option)) {
			fprintf(stderr,
			    ""wtperf: %s: %d: option value overflow\n"",
			    filename, linenum);
			ret = EINVAL;
			break;
		}

		memcpy(&option[optionpos], ltrim, linelen);
		option[optionpos + linelen] = '\0';
		if (contline)
			optionpos += linelen;
		else {
			if ((ret = config_opt_str(wtperf, option)) != 0) {
				fprintf(stderr, ""wtperf: %s: %d: parse error\n"",
				    filename, linenum);
				break;
			}
			optionpos = 0;
		}
	}
	if (ret == 0) {
		if (ferror(fp)) {
			fprintf(stderr, ""wtperf: %s: read error\n"", filename);
			ret = errno;
		}
		if (optionpos > 0) {
			fprintf(stderr, ""wtperf: %s: %d: last line continues\n"",
			    filename, linenum);
			ret = EINVAL;
		}
	}

	(void)fclose(fp);
	return (ret);
}

/*
 * config_opt_str --
 *	Parse a single line of config options.  Continued lines have already
 * been joined.
 */
int
config_opt_str(WTPERF *wtperf, const char *optstr)
{
	CONFIG_OPTS *opts;
	CONFIG_QUEUE_ENTRY *config_line;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *scan;
	size_t len;
	int ret, t_ret;

	opts = wtperf->opts;

	len = strlen(optstr);
	if ((ret = wiredtiger_config_parser_open(
	    NULL, optstr, len, &scan)) != 0) {
		lprintf(wtperf, ret, 0, ""Error in config_scan_begin"");
		return (ret);
	}

	while (ret == 0) {
		size_t pos;

		if ((ret = scan->next(scan, &k, &v)) != 0) {
			/* Any parse error has already been reported. */
			if (ret == WT_NOTFOUND)
				ret = 0;
			break;
		}
		ret = config_opt(wtperf, &k, &v);

		/*
		 * Append the key-value pair to our copy of the config.
		 * The config is stored in the order it is processed, so added
		 * options will be after any parsed from the original config.
		 */
		config_line = dcalloc(sizeof(CONFIG_QUEUE_ENTRY), 1);
		/*
		 * If key or value is a string, consider extra space for the
		 * quotes. Add 2 to the required space for '=' and the ending
		 * null character in ""key=value"".
		 */
		config_line->string = dcalloc(
		    k.len + (k.type == WT_CONFIG_ITEM_STRING ? 2 : 0) +
		    v.len + (v.type == WT_CONFIG_ITEM_STRING ? 2 : 0) + 2, 1);
		pos = 0;
		if (k.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		strncpy(config_line->string + pos, k.str, k.len);
		pos += k.len;
		if (k.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		config_line->string[pos] = '=';
		pos++;
		if (v.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		strncpy(config_line->string + pos, v.str, v.len);
		pos += v.len;
		if (v.type == WT_CONFIG_ITEM_STRING) {
			config_line->string[pos] = '""';
			pos++;
		}
		config_line->string[pos] = '\0';
		TAILQ_INSERT_TAIL(&opts->config_head, config_line, q);
	}
	if ((t_ret = scan->close(scan)) != 0) {
		lprintf(wtperf, ret, 0, ""Error in config_scan_end"");
		if (ret == 0)
			ret = t_ret;
	}

	return (ret);
}

/*
 * config_opt_name_value --
 *	Set a name/value configuration pair.
 */
int
config_opt_name_value(WTPERF *wtperf, const char *name, const char *value)
{
	size_t len;
	int ret;
	char *optstr;
							/* name=""value"" */
	len = strlen(name) + strlen(value) + 4;
	optstr = dmalloc(len);
	snprintf(optstr, len, ""%s=\""%s\"""", name, value);
	ret = config_opt_str(wtperf, optstr);
	free(optstr);
	return (ret);
}

/*
 * config_sanity --
 *	Configuration sanity checks.
 */
int
config_sanity(WTPERF *wtperf)
{
	CONFIG_OPTS *opts;
	WORKLOAD *workp;
	u_int i;

	opts = wtperf->opts;

	/* Various intervals should be less than the run-time. */
	if (opts->run_time > 0 &&
	    ((opts->checkpoint_threads != 0 &&
	    opts->checkpoint_interval > opts->run_time) ||
	    opts->report_interval > opts->run_time ||
	    opts->sample_interval > opts->run_time)) {
		fprintf(stderr, ""interval value longer than the run-time\n"");
		return (EINVAL);
	}
	/* The maximum is here to keep file name construction simple. */
	if (opts->table_count < 1 || opts->table_count > 99999) {
		fprintf(stderr,
		    ""invalid table count, less than 1 or greater than 99999\n"");
		return (EINVAL);
	}
	if (opts->database_count < 1 || opts->database_count > 99) {
		fprintf(stderr,
		    ""invalid database count, less than 1 or greater than 99\n"");
		return (EINVAL);
	}

	if (opts->pareto > 100) {
		fprintf(stderr,
		    ""Invalid pareto distribution - should be a percentage\n"");
		return (EINVAL);
	}

	if (opts->value_sz_max < opts->value_sz) {
		if (F_ISSET(wtperf, CFG_GROW)) {
			fprintf(stderr, ""value_sz_max %"" PRIu32
			    "" must be greater than or equal to value_sz %""
			    PRIu32 ""\n"", opts->value_sz_max, opts->value_sz);
			return (EINVAL);
		} else
			opts->value_sz_max = opts->value_sz;
	}
	if (opts->value_sz_min > opts->value_sz) {
		if (F_ISSET(wtperf, CFG_SHRINK)) {
			fprintf(stderr, ""value_sz_min %"" PRIu32
			    "" must be less than or equal to value_sz %""
			    PRIu32 ""\n"", opts->value_sz_min, opts->value_sz);
			return (EINVAL);
		} else
			opts->value_sz_min = opts->value_sz;
	}

	if (wtperf->workload != NULL)
		for (i = 0, workp = wtperf->workload;
		    i < wtperf->workload_cnt; ++i, ++workp) {
			if (opts->readonly &&
			    (workp->insert != 0 || workp->update != 0 ||
			    workp->truncate != 0)) {
				fprintf(stderr,
				    ""Invalid workload: insert, update or ""
				    ""truncate specified with readonly\n"");
				return (EINVAL);
			}
			if (workp->insert != 0 &&
			    workp->table_index != INT32_MAX) {
				fprintf(stderr,
				    ""Invalid workload: Cannot insert into ""
				    ""specific table only\n"");
				return (EINVAL);
			}
			if (workp->table_index != INT32_MAX &&
			    workp->table_index >= (int32_t)opts->table_count) {
				fprintf(stderr,
				    ""Workload table index %"" PRId32
				    "" is larger than table count %"" PRId32,
				    workp->table_index, opts->table_count);
				return (EINVAL);
			}
		}
	return (0);
}

/*
 * config_consolidate --
 *	Consolidate repeated configuration settings so that it only appears
 *	once in the configuration output file.
 */
static void
config_consolidate(CONFIG_OPTS *opts)
{
	CONFIG_QUEUE_ENTRY *conf_line, *test_line, *tmp;
	char *string_key;

	/*
	 * This loop iterates over the config queue and for each entry checks if
	 * a later queue entry has the same key. If there's a match, and key is
	 * ""conn_config"" or ""table_config"", the later queue entry is replaced
	 * with a concatenated entry of the two queue entries, the current queue
	 * entry is removed. For any other key, if there is a match, the current
	 * queue entry is removed.
	 */
	conf_line = TAILQ_FIRST(&opts->config_head);
	while (conf_line != NULL) {
		string_key = strchr(conf_line->string, '=');
		tmp = test_line = TAILQ_NEXT(conf_line, q);
		while (test_line != NULL) {
			/*
			 * The + 1 here forces the '=' sign to be matched
			 * ensuring we don't match keys that have a common
			 * prefix such as ""table_count"" and ""table_count_idle""
			 * as being the same key.
			 */
			if (strncmp(conf_line->string, test_line->string,
","			    == 0) {
				if ((strncmp(""conn_config="", conf_line->string,
				    (size_t)((string_key - conf_line->string) +
				    1)) == 0) ||
				    (strncmp(""table_config="", conf_line->string,
				    (size_t)((string_key - conf_line->string) +
				    1)) == 0)) {
					char *concat_str, *val_pointer;

					/*
					 * To concatenate the two config
					 * strings, copy the first string to a
					 * new one, replace the ending '""' with
					 * a ',' and then concatenate the second
					 * string's value after its starting '""'
					 */
					val_pointer =
					    strchr(test_line->string, '=') + 2;
					concat_str =
					    dmalloc(strlen(conf_line->string) +
					    strlen(val_pointer) + 1);
					strcpy(concat_str, conf_line->string);
					concat_str[strlen(concat_str) - 1] =
					    ',';
					strcat(concat_str, val_pointer);
					free(test_line->string);
					test_line->string = concat_str;
				}

				TAILQ_REMOVE(&opts->config_head, conf_line, q);
				free(conf_line->string);
				free(conf_line);
				break;
			}
			test_line = TAILQ_NEXT(test_line, q);
		}
		conf_line = tmp;
	}
}

/*
 * config_opt_log --
 *	Write the final config used in this execution to a file.
 */
void
config_opt_log(CONFIG_OPTS *opts, const char *path)
{
	CONFIG_QUEUE_ENTRY *config_line;
	FILE *fp;

	testutil_checkfmt(((fp = fopen(path, ""w"")) == NULL), ""%s"", path);

	config_consolidate(opts);

	fprintf(fp,""# Warning: This config includes ""
	    ""unwritten, implicit configuration defaults.\n""
	    ""# Changes to those values may cause differences in behavior.\n"");
	TAILQ_FOREACH(config_line, &opts->config_head, q)
		fprintf(fp, ""%s\n"", config_line->string);
	testutil_check(fclose(fp));
}

/*
 * config_opt_print --
 *	Print out the configuration in verbose mode.
 */
void
config_opt_print(WTPERF *wtperf)
{
	CONFIG_OPTS *opts;
	WORKLOAD *workp;
	u_int i;

	opts = wtperf->opts;

	printf(""Workload configuration:\n"");
	printf(""\t"" ""Home: %s\n"", wtperf->home);
	printf(""\t"" ""Table name: %s\n"", opts->table_name);
	printf(""\t"" ""Connection configuration: %s\n"", opts->conn_config);
	if (opts->sess_config != NULL)
		printf(""\t"" ""Session configuration: %s\n"", opts->sess_config);

	printf(""\t%s table: %s\n"",
	    opts->create ? ""Creating new"" : ""Using existing"",
	    opts->table_config);
	printf(""\t"" ""Key size: %"" PRIu32 "", value size: %"" PRIu32 ""\n"",
	    opts->key_sz, opts->value_sz);
	if (opts->create)
		printf(""\t"" ""Populate threads: %"" PRIu32 "", inserting %"" PRIu32
		    "" rows\n"",
		    opts->populate_threads, opts->icount);

	printf(""\t"" ""Workload seconds, operations: %"" PRIu32 "", %"" PRIu32 ""\n"",
	    opts->run_time, opts->run_ops);
	if (wtperf->workload != NULL) {
		printf(""\t"" ""Workload configuration(s):\n"");
		for (i = 0, workp = wtperf->workload;
		    i < wtperf->workload_cnt; ++i, ++workp)
			printf(""\t\t%"" PRId64 "" threads (inserts=%"" PRId64
			    "", reads=%"" PRId64 "", updates=%"" PRId64
			    "", truncates=% "" PRId64 "")\n"",
			    workp->threads,
			    workp->insert, workp->read,
			    workp->update, workp->truncate);
	}

	printf(""\t"" ""Checkpoint threads, interval: %"" PRIu32 "", %"" PRIu32 ""\n"",
	    opts->checkpoint_threads, opts->checkpoint_interval);
	printf(""\t"" ""Reporting interval: %"" PRIu32 ""\n"", opts->report_interval);
	printf(""\t"" ""Sampling interval: %"" PRIu32 ""\n"", opts->sample_interval);

	printf(""\t"" ""Verbosity: %"" PRIu32 ""\n"", opts->verbose);
}

/*
 * pretty_print --
 *	Print out lines of text for a 80 character window.
 */
static void
pretty_print(const char *p, const char *indent)
{
	const char *t;

	for (;; p = t + 1) {
		if (strlen(p) <= 70)
			break;
		for (t = p + 70; t > p && *t != ' '; --t)
			;
		if (t == p)			/* No spaces? */
			break;
		printf(""%s%.*s\n"",
		    indent == NULL ? """" : indent, (int)(t - p), p);
	}
	if (*p != '\0')
		printf(""%s%s\n"", indent == NULL ? """" : indent, p);
}

/*
 * config_opt_usage --
 *	Configuration usage error message.
 */
void
config_opt_usage(void)
{
	size_t i;
	const char *defaultval, *typestr;

	pretty_print(
	    ""The following are options settable using -o or -O, showing the ""
	    ""type and default value.\n"", NULL);
	pretty_print(
	    ""String values must be enclosed in \"" quotes, boolean values must ""
	    ""be either true or false.\n"", NULL);

	for (i = 0; i < WT_ELEMENTS(config_opts_desc); i++) {
		defaultval = config_opts_desc[i].defaultval;
		typestr = ""string"";
		switch (config_opts_desc[i].type) {
		case BOOL_TYPE:
			typestr = ""boolean"";
			if (strcmp(defaultval, ""0"") == 0)
				defaultval = ""false"";
			else
				defaultval = ""true"";
			break;
		case CONFIG_STRING_TYPE:
		case STRING_TYPE:
			break;
		case INT_TYPE:
			typestr = ""int"";
			break;
		case UINT32_TYPE:
			typestr = ""unsigned int"";
			break;
		}
		printf(""%s (%s, default=%s)\n"",
		    config_opts_desc[i].name, typestr, defaultval);
		pretty_print(config_opts_desc[i].description, ""\t"");
	}
}
",349
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");",+,"static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
","static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
","	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
",9
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+			lprintf(wtperf, ret, 0,",+,"static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
","static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
","	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
",15
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+err:		lprintf(wtperf, ret, 0, ""Pre-workload traverse error"");",+,"static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
","static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
","	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
",29
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+			lprintf(wtperf, ret, 0,",+,"static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
","static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
","				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
",181
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+				lprintf(wtperf, ret, 0,",+,"static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
				 * next key is in the correct order.
				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
","static void *
worker(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WORKLOAD *workload;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_CONNECTION *conn;
	WT_CURSOR **cursors, *cursor, *log_table_cursor, *tmp_cursor;
	WT_SESSION *session;
	size_t i;
	int64_t ops, ops_per_txn;
	uint64_t log_id, next_val, usecs;
	uint8_t *op, *op_end;
	int measure_latency, ret, truncated;
	char *value_buf, *key_buf, *value;
	char buf[512];

	thread = (WTPERF_THREAD *)arg;
	workload = thread->workload;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	cursors = NULL;
	cursor = log_table_cursor = NULL;	/* -Wconditional-initialized */
	ops = 0;
	ops_per_txn = workload->ops_per_txn;
	session = NULL;
	trk = NULL;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""worker: WT_CONNECTION.open_session"");
		goto err;
	}
	for (i = 0; i < opts->table_count_idle; i++) {
		snprintf(buf, 512, ""%s_idle%05d"", wtperf->uris[0], (int)i);
		if ((ret = session->open_cursor(
		    session, buf, NULL, NULL, &tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error opening idle table %s"", buf);
			goto err;
		}
		if ((ret = tmp_cursor->close(tmp_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""Error closing idle table %s"", buf);
			goto err;
		}
	}
	if (workload->table_index != INT32_MAX) {
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, NULL, &cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
		if ((ret = session->open_cursor(session,
		    wtperf->uris[workload->table_index],
		    NULL, ""next_random=true"", &thread->rand_cursor)) != 0) {
			lprintf(wtperf, ret, 0,
			    ""worker: WT_SESSION.open_cursor: random %s"",
			    wtperf->uris[workload->table_index]);
			goto err;
		}
	} else {
		cursors = dcalloc(opts->table_count, sizeof(WT_CURSOR *));
		for (i = 0; i < opts->table_count; i++) {
			if ((ret = session->open_cursor(session,
			    wtperf->uris[i], NULL, NULL, &cursors[i])) != 0) {
				lprintf(wtperf, ret, 0,
				    ""worker: WT_SESSION.open_cursor: %s"",
				    wtperf->uris[i]);
				goto err;
			}
		}
	}
	if (opts->log_like_table && (ret = session->open_cursor(session,
	    wtperf->log_table_uri, NULL, NULL, &log_table_cursor)) != 0) {
		lprintf(wtperf, ret, 0,
		    ""worker: WT_SESSION.open_cursor: %s"",
		    wtperf->log_table_uri);
		goto err;
	}

	/* Setup the timer for throttling. */
	if (workload->throttle != 0)
		setup_throttle(thread);

	/* Setup for truncate */
	if (workload->truncate != 0)
		if ((ret = setup_truncate(wtperf, thread, session)) != 0)
			goto err;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	op = workload->ops;
	op_end = op + sizeof(workload->ops);

	if ((ops_per_txn != 0 || opts->log_like_table) &&
		(ret = session->begin_transaction(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""First transaction begin failed"");
		goto err;
	}

	while (!wtperf->stop) {
		if (workload->pause != 0)
			(void)sleep((unsigned int)workload->pause);
		/*
		 * Generate the next key and setup operation specific
		 * statistics tracking objects.
		 */
		switch (*op) {
		case WORKER_INSERT:
		case WORKER_INSERT_RMW:
			trk = &thread->insert;
			if (opts->random_range)
				next_val = wtperf_rand(thread);
			else
				next_val = opts->icount + get_next_incr(wtperf);
			break;
		case WORKER_READ:
			trk = &thread->read;
			/* FALLTHROUGH */
		case WORKER_UPDATE:
			if (*op == WORKER_UPDATE)
				trk = &thread->update;
			next_val = wtperf_rand(thread);

			/*
			 * If the workload is started without a populate phase
			 * we rely on at least one insert to get a valid item
			 * id.
			 */
			if (wtperf_value_range(wtperf) < next_val)
				continue;
			break;
		case WORKER_TRUNCATE:
			/* Required but not used. */
			next_val = wtperf_rand(thread);
			break;
		default:
			goto err;		/* can't happen */
		}

		generate_key(opts, key_buf, next_val);

		if (workload->table_index == INT32_MAX)
			/*
			 * Spread the data out around the multiple databases.
			 */
			cursor = cursors[
			    map_key_to_table(wtperf->opts, next_val)];

		/*
		 * Skip the first time we do an operation, when trk->ops
		 * is 0, to avoid first time latency spikes.
		 */
		measure_latency =
		    opts->sample_interval != 0 && trk != NULL &&
		    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
		if (measure_latency)
			__wt_epoch(NULL, &start);

		cursor->set_key(cursor, key_buf);

		switch (*op) {
		case WORKER_READ:
			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			ret = cursor->search(cursor);
			if (ret == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in read."");
					goto err;
				}
				/*
				 * If we want to read a range, then call next
				 * for several operations, confirming that the
","				 */
				ret = do_range_reads(wtperf,
				    cursor, workload->read_range);
			}

			if (ret == 0 || ret == WT_NOTFOUND)
				break;
			goto op_err;
		case WORKER_INSERT_RMW:
			if ((ret = cursor->search(cursor)) != WT_NOTFOUND)
				goto op_err;

			/* The error return reset the cursor's key. */
			cursor->set_key(cursor, key_buf);

			/* FALLTHROUGH */
		case WORKER_INSERT:
			if (opts->random_value)
				randomize_value(thread, value_buf);
			cursor->set_value(cursor, value_buf);
			if ((ret = cursor->insert(cursor)) == 0)
				break;
			goto op_err;
		case WORKER_TRUNCATE:
			if ((ret = run_truncate(wtperf,
			    thread, cursor, session, &truncated)) == 0) {
				if (truncated)
					trk = &thread->truncate;
				else
					trk = &thread->truncate_sleep;
				/* Pause between truncate attempts */
				(void)usleep(1000);
				break;
			}
			goto op_err;
		case WORKER_UPDATE:
			if ((ret = cursor->search(cursor)) == 0) {
				if ((ret = cursor->get_value(
				    cursor, &value)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""get_value in update."");
					goto err;
				}
				/*
				 * Copy as much of the previous value as is
				 * safe, and be sure to NUL-terminate.
				 */
				strncpy(value_buf,
				    value, opts->value_sz_max - 1);
				if (workload->update_delta != 0)
					update_value_delta(thread);
				if (value_buf[0] == 'a')
					value_buf[0] = 'b';
				else
					value_buf[0] = 'a';
				if (opts->random_value)
					randomize_value(thread, value_buf);
				cursor->set_value(cursor, value_buf);
				if ((ret = cursor->update(cursor)) == 0)
					break;
				goto op_err;
			}

			/*
			 * Reads can fail with WT_NOTFOUND: we may be searching
			 * in a random range, or an insert thread might have
			 * updated the last record in the table but not yet
			 * finished the actual insert.  Count failed search in
			 * a random range as a ""read"".
			 */
			if (ret == WT_NOTFOUND)
				break;

op_err:			if (ret == WT_ROLLBACK && ops_per_txn != 0) {
				/*
				 * If we are running with explicit transactions
				 * configured and we hit a WT_ROLLBACK, then we
				 * should rollback the current transaction and
				 * attempt to continue.
				 * This does break the guarantee of insertion
				 * order in cases of ordered inserts, as we
				 * aren't retrying here.
				 */
				lprintf(wtperf, ret, 1,
				    ""%s for: %s, range: %""PRIu64, op_name(op),
				    key_buf, wtperf_value_range(wtperf));
				if ((ret = session->rollback_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					     ""Failed rollback_transaction"");
					goto err;
				}
				if ((ret = session->begin_transaction(
				    session, NULL)) != 0) {
					lprintf(wtperf, ret, 0,
					    ""Worker begin transaction failed"");
					goto err;
				}
				break;
			}
			lprintf(wtperf, ret, 0,
			    ""%s failed for: %s, range: %""PRIu64,
			    op_name(op), key_buf, wtperf_value_range(wtperf));
			goto err;
		default:
			goto err;		/* can't happen */
		}

		/* Update the log-like table. */
		if (opts->log_like_table &&
		    (*op != WORKER_READ && *op != WORKER_TRUNCATE)) {
			log_id =
			    __wt_atomic_add64(&wtperf->log_like_table_key, 1);
			log_table_cursor->set_key(log_table_cursor, log_id);
			log_table_cursor->set_value(
			    log_table_cursor, value_buf);
			if ((ret =
			    log_table_cursor->insert(log_table_cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor insert failed"");
				goto err;
			}
		}

		/* Release the cursor, if we have multiple tables. */
		if (opts->table_count > 1 && ret == 0 &&
		    *op != WORKER_INSERT && *op != WORKER_INSERT_RMW) {
			if ((ret = cursor->reset(cursor)) != 0) {
				lprintf(wtperf, ret, 0, ""Cursor reset failed"");
				goto err;
			}
		}

		/* Gather statistics */
		if (!wtperf->in_warmup) {
			if (measure_latency) {
				__wt_epoch(NULL, &stop);
				++trk->latency_ops;
				usecs = WT_TIMEDIFF_US(stop, start);
				track_operation(trk, usecs);
			}
			/* Increment operation count */
			++trk->ops;
		}

		/*
		 * Commit the transaction if grouping operations together
		 * or tracking changes in our log table.
		 */
		if ((opts->log_like_table && ops_per_txn == 0) ||
		    (ops_per_txn != 0 && ops++ % ops_per_txn == 0)) {
			if ((ret = session->commit_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker transaction commit failed"");
				goto err;
			}
			if ((ret = session->begin_transaction(
			    session, NULL)) != 0) {
				lprintf(wtperf, ret, 0,
				    ""Worker begin transaction failed"");
				goto err;
			}
		}

		/* Schedule the next operation */
		if (++op == op_end)
			op = workload->ops;

		/*
		 * Decrement throttle ops and check if we should sleep
		 * and then get more work to perform.
		 */
		if (--thread->throttle_cfg.ops_count == 0)
			worker_throttle(thread);

	}

	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Session close in worker failed"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	free(cursors);

	return (NULL);
}
",191
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"-		lprintf(wtperf, EINVAL, 0, ""no operations scheduled"");",-,"static void *
populate_async(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_ASYNC_OP *asyncop;
	WT_CONNECTION *conn;
	WT_SESSION *session;
	uint64_t op, usecs;
	int measure_latency, ret;
	char *value_buf, *key_buf;

	thread = (WTPERF_THREAD *)arg;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	session = NULL;
	ret = 0;
	trk = &thread->insert;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""populate: WT_CONNECTION.open_session"");
		goto err;
	}

	/*
	 * Measuring latency of one async op is not meaningful.  We
	 * will measure the time it takes to do all of them, including
	 * the time to process by workers.
	 */
	measure_latency =
	    opts->sample_interval != 0 &&
	    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
	if (measure_latency)
		__wt_epoch(NULL, &start);

	/* Populate the databases. */
	for (;;) {
		op = get_next_incr(wtperf);
		if (op > opts->icount)
			break;
		/*
		 * Allocate an async op for whichever table.
		 */
		while ((ret = conn->async_new_op(
		    conn, wtperf->uris[map_key_to_table(wtperf->opts, op)],
		    NULL, &cb, &asyncop)) == EBUSY)
			(void)usleep(10000);
		if (ret != 0)
			goto err;

		asyncop->app_private = thread;
		generate_key(opts, key_buf, op);
		asyncop->set_key(asyncop, key_buf);
		if (opts->random_value)
			randomize_value(thread, value_buf);
		asyncop->set_value(asyncop, value_buf);
		if ((ret = asyncop->insert(asyncop)) != 0) {
			lprintf(wtperf, ret, 0, ""Failed inserting"");
			goto err;
		}
	}

	/*
	 * Gather statistics.
	 * We measure the latency of inserting a single key.  If there
	 * are multiple tables, it is the time for insertion into all
	 * of them.  Note that currently every populate thread will call
	 * async_flush and those calls will convoy.  That is not the
	 * most efficient way, but we want to flush before measuring latency.
	 */
	if (conn->async_flush(conn) != 0)
		goto err;
	if (measure_latency) {
		__wt_epoch(NULL, &stop);
		++trk->latency_ops;
		usecs = WT_TIMEDIFF_US(stop, start);
		track_operation(trk, usecs);
	}
	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Error closing session in populate"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	return (NULL);
}
","static void *
populate_async(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_ASYNC_OP *asyncop;
	WT_CONNECTION *conn;
	WT_SESSION *session;
	uint64_t op, usecs;
	int measure_latency, ret;
	char *value_buf, *key_buf;

	thread = (WTPERF_THREAD *)arg;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	session = NULL;
	ret = 0;
	trk = &thread->insert;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;
","	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""populate: WT_CONNECTION.open_session"");
		goto err;
	}

	/*
	 * Measuring latency of one async op is not meaningful.  We
	 * will measure the time it takes to do all of them, including
	 * the time to process by workers.
	 */
	measure_latency =
	    opts->sample_interval != 0 &&
	    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
	if (measure_latency)
		__wt_epoch(NULL, &start);

	/* Populate the databases. */
	for (;;) {
		op = get_next_incr(wtperf);
		if (op > opts->icount)
			break;
		/*
		 * Allocate an async op for whichever table.
		 */
		while ((ret = conn->async_new_op(
		    conn, wtperf->uris[map_key_to_table(wtperf->opts, op)],
		    NULL, &cb, &asyncop)) == EBUSY)
			(void)usleep(10000);
		if (ret != 0)
			goto err;

		asyncop->app_private = thread;
		generate_key(opts, key_buf, op);
		asyncop->set_key(asyncop, key_buf);
		if (opts->random_value)
			randomize_value(thread, value_buf);
		asyncop->set_value(asyncop, value_buf);
		if ((ret = asyncop->insert(asyncop)) != 0) {
			lprintf(wtperf, ret, 0, ""Failed inserting"");
			goto err;
		}
	}

	/*
	 * Gather statistics.
	 * We measure the latency of inserting a single key.  If there
	 * are multiple tables, it is the time for insertion into all
	 * of them.  Note that currently every populate thread will call
	 * async_flush and those calls will convoy.  That is not the
	 * most efficient way, but we want to flush before measuring latency.
	 */
	if (conn->async_flush(conn) != 0)
		goto err;
	if (measure_latency) {
		__wt_epoch(NULL, &stop);
		++trk->latency_ops;
		usecs = WT_TIMEDIFF_US(stop, start);
		track_operation(trk, usecs);
	}
	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Error closing session in populate"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	return (NULL);
}
",26
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+		lprintf(wtperf, EINVAL, 0, ""no operations scheduled"");",+,"static void *
populate_async(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_ASYNC_OP *asyncop;
	WT_CONNECTION *conn;
	WT_SESSION *session;
	uint64_t op, usecs;
	int measure_latency, ret;
	char *value_buf, *key_buf;

	thread = (WTPERF_THREAD *)arg;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	session = NULL;
	ret = 0;
	trk = &thread->insert;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""populate: WT_CONNECTION.open_session"");
		goto err;
	}

	/*
	 * Measuring latency of one async op is not meaningful.  We
	 * will measure the time it takes to do all of them, including
	 * the time to process by workers.
	 */
	measure_latency =
	    opts->sample_interval != 0 &&
	    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
	if (measure_latency)
		__wt_epoch(NULL, &start);

	/* Populate the databases. */
	for (;;) {
		op = get_next_incr(wtperf);
		if (op > opts->icount)
			break;
		/*
		 * Allocate an async op for whichever table.
		 */
		while ((ret = conn->async_new_op(
		    conn, wtperf->uris[map_key_to_table(wtperf->opts, op)],
		    NULL, &cb, &asyncop)) == EBUSY)
			(void)usleep(10000);
		if (ret != 0)
			goto err;

		asyncop->app_private = thread;
		generate_key(opts, key_buf, op);
		asyncop->set_key(asyncop, key_buf);
		if (opts->random_value)
			randomize_value(thread, value_buf);
		asyncop->set_value(asyncop, value_buf);
		if ((ret = asyncop->insert(asyncop)) != 0) {
			lprintf(wtperf, ret, 0, ""Failed inserting"");
			goto err;
		}
	}

	/*
	 * Gather statistics.
	 * We measure the latency of inserting a single key.  If there
	 * are multiple tables, it is the time for insertion into all
	 * of them.  Note that currently every populate thread will call
	 * async_flush and those calls will convoy.  That is not the
	 * most efficient way, but we want to flush before measuring latency.
	 */
	if (conn->async_flush(conn) != 0)
		goto err;
	if (measure_latency) {
		__wt_epoch(NULL, &stop);
		++trk->latency_ops;
		usecs = WT_TIMEDIFF_US(stop, start);
		track_operation(trk, usecs);
	}
	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Error closing session in populate"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	return (NULL);
}
","static void *
populate_async(void *arg)
{
	struct timespec start, stop;
	CONFIG_OPTS *opts;
	TRACK *trk;
	WTPERF *wtperf;
	WTPERF_THREAD *thread;
	WT_ASYNC_OP *asyncop;
	WT_CONNECTION *conn;
	WT_SESSION *session;
	uint64_t op, usecs;
	int measure_latency, ret;
	char *value_buf, *key_buf;

	thread = (WTPERF_THREAD *)arg;
	wtperf = thread->wtperf;
	opts = wtperf->opts;
	conn = wtperf->conn;
	session = NULL;
	ret = 0;
	trk = &thread->insert;

	key_buf = thread->key_buf;
	value_buf = thread->value_buf;

	if ((ret = conn->open_session(
	    conn, NULL, opts->sess_config, &session)) != 0) {
		lprintf(wtperf, ret, 0, ""populate: WT_CONNECTION.open_session"");
		goto err;
	}

	/*
	 * Measuring latency of one async op is not meaningful.  We
	 * will measure the time it takes to do all of them, including
	 * the time to process by workers.
	 */
	measure_latency =
	    opts->sample_interval != 0 &&
	    trk->ops != 0 && (trk->ops % opts->sample_rate == 0);
	if (measure_latency)
		__wt_epoch(NULL, &start);

	/* Populate the databases. */
	for (;;) {
		op = get_next_incr(wtperf);
		if (op > opts->icount)
			break;
		/*
		 * Allocate an async op for whichever table.
		 */
		while ((ret = conn->async_new_op(
		    conn, wtperf->uris[map_key_to_table(wtperf->opts, op)],
","			(void)usleep(10000);
		if (ret != 0)
			goto err;

		asyncop->app_private = thread;
		generate_key(opts, key_buf, op);
		asyncop->set_key(asyncop, key_buf);
		if (opts->random_value)
			randomize_value(thread, value_buf);
		asyncop->set_value(asyncop, value_buf);
		if ((ret = asyncop->insert(asyncop)) != 0) {
			lprintf(wtperf, ret, 0, ""Failed inserting"");
			goto err;
		}
	}

	/*
	 * Gather statistics.
	 * We measure the latency of inserting a single key.  If there
	 * are multiple tables, it is the time for insertion into all
	 * of them.  Note that currently every populate thread will call
	 * async_flush and those calls will convoy.  That is not the
	 * most efficient way, but we want to flush before measuring latency.
	 */
	if (conn->async_flush(conn) != 0)
		goto err;
	if (measure_latency) {
		__wt_epoch(NULL, &stop);
		++trk->latency_ops;
		usecs = WT_TIMEDIFF_US(stop, start);
		track_operation(trk, usecs);
	}
	if ((ret = session->close(session, NULL)) != 0) {
		lprintf(wtperf, ret, 0, ""Error closing session in populate"");
		goto err;
	}

	/* Notify our caller we failed and shut the system down. */
	if (0) {
err:		wtperf->error = wtperf->stop = true;
	}
	return (NULL);
}
",54
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+			lprintf(wtperf, ret, 0, ""worker: rand next failed"");",+,"int
main(int argc, char *argv[])
{
	CONFIG_OPTS *opts;
	WTPERF *wtperf, _wtperf;
	size_t pos, req_len, sreq_len;
	bool monitor_set;
	int ch, ret;
	const char *cmdflags = ""C:h:m:O:o:T:"";
	const char *append_comma, *config_opts;
	char *cc_buf, *path, *sess_cfg, *tc_buf, *user_cconfig, *user_tconfig;

	/* The first WTPERF structure (from which all others are derived). */
	wtperf = &_wtperf;
	memset(wtperf, 0, sizeof(*wtperf));
	wtperf->home = dstrdup(DEFAULT_HOME);
	wtperf->monitor_dir = dstrdup(DEFAULT_MONITOR_DIR);
	TAILQ_INIT(&wtperf->stone_head);
	config_opt_init(&wtperf->opts);

	opts = wtperf->opts;
	monitor_set = false;
	ret = 0;
	config_opts = NULL;
	cc_buf = sess_cfg = tc_buf = user_cconfig = user_tconfig = NULL;

	/* Do a basic validation of options, and home is needed before open. */
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'C':
			if (user_cconfig == NULL)
				user_cconfig = dstrdup(__wt_optarg);
			else {
				user_cconfig = drealloc(user_cconfig,
				    strlen(user_cconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_cconfig, "","");
				strcat(user_cconfig, __wt_optarg);
			}
			break;
		case 'h':
			free(wtperf->home);
			wtperf->home = dstrdup(__wt_optarg);
			break;
		case 'm':
			free(wtperf->monitor_dir);
			wtperf->monitor_dir = dstrdup(__wt_optarg);
			monitor_set = true;
			break;
		case 'O':
			config_opts = __wt_optarg;
			break;
		case 'T':
			if (user_tconfig == NULL)
				user_tconfig = dstrdup(__wt_optarg);
			else {
				user_tconfig = drealloc(user_tconfig,
				    strlen(user_tconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_tconfig, "","");
				strcat(user_tconfig, __wt_optarg);
			}
			break;
		case '?':
			usage();
			goto einval;
		}

	/*
	 * If the user did not specify a monitor directory then set the
	 * monitor directory to the home dir.
	 */
	if (!monitor_set) {
		free(wtperf->monitor_dir);
		wtperf->monitor_dir = dstrdup(wtperf->home);
	}

	/* Parse configuration settings from configuration file. */
	if (config_opts != NULL && config_opt_file(wtperf, config_opts) != 0)
		goto einval;

	/* Parse options that override values set via a configuration file. */
	__wt_optreset = __wt_optind = 1;
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'o':
			/* Allow -o key=value */
			if (config_opt_str(wtperf, __wt_optarg) != 0)
				goto einval;
			break;
		}

	if (opts->populate_threads == 0 && opts->icount != 0) {
		lprintf(wtperf, 1, 0,
		    ""Cannot have 0 populate threads when icount is set\n"");
		goto err;
	}

	wtperf->async_config = NULL;
	/*
	 * If the user specified async_threads we use async for all ops.
	 * If the user wants compaction, then we also enable async for
	 * the compact operation, but not for the workloads.
	 */
	if (opts->async_threads > 0) {
		if (F_ISSET(wtperf, CFG_TRUNCATE)) {
			lprintf(wtperf,
			    1, 0, ""Cannot run truncate and async\n"");
			goto err;
		}
		wtperf->use_asyncops = true;
	}
	if (opts->compact && opts->async_threads == 0)
		opts->async_threads = 2;
	if (opts->async_threads > 0) {
		/*
		 * The maximum number of async threads is two digits, so just
		 * use that to compute the space we need.  Assume the default
		 * of 1024 for the max ops.  Although we could bump that up
		 * to 4096 if needed.
		 */
		req_len = strlen("",async=(enabled=true,threads=)"") + 4;
		wtperf->async_config = dmalloc(req_len);
		snprintf(wtperf->async_config, req_len,
		    "",async=(enabled=true,threads=%"" PRIu32 "")"",
		    opts->async_threads);
	}
	if ((ret = config_compress(wtperf)) != 0)
		goto err;

	/* You can't have truncate on a random collection. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->random_range) {
		lprintf(wtperf, 1, 0, ""Cannot run truncate and random_range\n"");
		goto err;
	}

	/* We can't run truncate with more than one table. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->table_count > 1) {
		lprintf(wtperf, 1, 0, ""Cannot truncate more than 1 table\n"");
		goto err;
	}

	/* Make stdout line buffered, so verbose output appears quickly. */
	__wt_stream_set_line_buffer(stdout);

	/* Concatenate non-default configuration strings. */
	if ((opts->verbose > 1 && strlen(debug_cconfig) != 0) ||
	     user_cconfig != NULL || opts->session_count_idle > 0 ||
	     wtperf->compress_ext != NULL || wtperf->async_config != NULL) {
		req_len = 20;
		req_len += wtperf->async_config != NULL ?
		    strlen(wtperf->async_config) : 0;
		req_len += wtperf->compress_ext != NULL ?
		    strlen(wtperf->compress_ext) : 0;
		if (opts->session_count_idle > 0) {
			sreq_len = strlen(""session_max="") + 6;
			req_len += sreq_len;
			sess_cfg = dmalloc(sreq_len);
			snprintf(sess_cfg, sreq_len,
			    ""session_max=%"" PRIu32,
			    opts->session_count_idle +
			    wtperf->workers_cnt + opts->populate_threads + 10);
		}
		req_len += user_cconfig != NULL ? strlen(user_cconfig) : 0;
		req_len += debug_cconfig != NULL ? strlen(debug_cconfig) : 0;
		cc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->async_config != NULL &&
		    strlen(wtperf->async_config) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->async_config);
			append_comma = "","";
		}
		if (wtperf->compress_ext != NULL &&
		    strlen(wtperf->compress_ext) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_ext);
			append_comma = "","";
		}
		if (sess_cfg != NULL && strlen(sess_cfg) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, sess_cfg);
			append_comma = "","";
		}
		if (user_cconfig != NULL && strlen(user_cconfig) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_cconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_cconfig) != 0)
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_cconfig);

		if (strlen(cc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""conn_config"", cc_buf)) != 0)
			goto err;
	}
	if ((opts->verbose > 1 && strlen(debug_tconfig) != 0) || opts->index ||
	    user_tconfig != NULL || wtperf->compress_table != NULL) {
		req_len = 20;
		req_len += wtperf->compress_table != NULL ?
		    strlen(wtperf->compress_table) : 0;
		req_len += opts->index ? strlen(INDEX_COL_NAMES) : 0;
		req_len += user_tconfig != NULL ? strlen(user_tconfig) : 0;
		req_len += debug_tconfig != NULL ? strlen(debug_tconfig) : 0;
		tc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->compress_table != NULL &&
		    strlen(wtperf->compress_table) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_table);
			append_comma = "","";
		}
		if (opts->index) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, INDEX_COL_NAMES);
			append_comma = "","";
		}
		if (user_tconfig != NULL && strlen(user_tconfig) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_tconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_tconfig) != 0)
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_tconfig);

		if (strlen(tc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""table_config"", tc_buf)) != 0)
			goto err;
	}
	if (opts->log_partial && opts->table_count > 1) {
		req_len = strlen(opts->table_config) +
		    strlen(LOG_PARTIAL_CONFIG) + 1;
		wtperf->partial_config = dmalloc(req_len);
		snprintf(wtperf->partial_config, req_len, ""%s%s"",
		    opts->table_config, LOG_PARTIAL_CONFIG);
	}
	/*
	 * Set the config for reopen.  If readonly add in that string.
	 * If not readonly then just copy the original conn_config.
	 */
	if (opts->readonly)
		req_len = strlen(opts->conn_config) +
		    strlen(READONLY_CONFIG) + 1;
	else
		req_len = strlen(opts->conn_config) + 1;
	wtperf->reopen_config = dmalloc(req_len);
	if (opts->readonly)
		snprintf(wtperf->reopen_config, req_len, ""%s%s"",
		    opts->conn_config, READONLY_CONFIG);
	else
		snprintf(wtperf->reopen_config,
		    req_len, ""%s"", opts->conn_config);

	/* Sanity-check the configuration. */
	if ((ret = config_sanity(wtperf)) != 0)
		goto err;

	/* If creating, remove and re-create the home directory. */
	if (opts->create != 0)
		recreate_dir(wtperf->home);

	/* Write a copy of the config. */
	req_len = strlen(wtperf->home) + strlen(""/CONFIG.wtperf"") + 1;
	path = dmalloc(req_len);
	snprintf(path, req_len, ""%s/CONFIG.wtperf"", wtperf->home);
	config_opt_log(opts, path);
	free(path);

	/* Display the configuration. */
	if (opts->verbose > 1)
		config_opt_print(wtperf);

	if ((ret = start_all_runs(wtperf)) != 0)
		goto err;

	if (0) {
einval:		ret = EINVAL;
	}

err:	wtperf_free(wtperf);
	config_opt_cleanup(opts);

	free(cc_buf);
	free(sess_cfg);
	free(tc_buf);
	free(user_cconfig);
	free(user_tconfig);

	return (ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
","int
main(int argc, char *argv[])
{
	CONFIG_OPTS *opts;
	WTPERF *wtperf, _wtperf;
	size_t pos, req_len, sreq_len;
	bool monitor_set;
	int ch, ret;
	const char *cmdflags = ""C:h:m:O:o:T:"";
	const char *append_comma, *config_opts;
	char *cc_buf, *path, *sess_cfg, *tc_buf, *user_cconfig, *user_tconfig;

	/* The first WTPERF structure (from which all others are derived). */
	wtperf = &_wtperf;
	memset(wtperf, 0, sizeof(*wtperf));
	wtperf->home = dstrdup(DEFAULT_HOME);
	wtperf->monitor_dir = dstrdup(DEFAULT_MONITOR_DIR);
	TAILQ_INIT(&wtperf->stone_head);
	config_opt_init(&wtperf->opts);

	opts = wtperf->opts;
	monitor_set = false;
	ret = 0;
	config_opts = NULL;
	cc_buf = sess_cfg = tc_buf = user_cconfig = user_tconfig = NULL;

	/* Do a basic validation of options, and home is needed before open. */
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'C':
			if (user_cconfig == NULL)
				user_cconfig = dstrdup(__wt_optarg);
			else {
				user_cconfig = drealloc(user_cconfig,
				    strlen(user_cconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_cconfig, "","");
				strcat(user_cconfig, __wt_optarg);
			}
			break;
		case 'h':
			free(wtperf->home);
			wtperf->home = dstrdup(__wt_optarg);
			break;
		case 'm':
			free(wtperf->monitor_dir);
			wtperf->monitor_dir = dstrdup(__wt_optarg);
			monitor_set = true;
			break;
		case 'O':
			config_opts = __wt_optarg;
			break;
		case 'T':
			if (user_tconfig == NULL)
				user_tconfig = dstrdup(__wt_optarg);
			else {
				user_tconfig = drealloc(user_tconfig,
				    strlen(user_tconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_tconfig, "","");
				strcat(user_tconfig, __wt_optarg);
			}
			break;
		case '?':
			usage();
			goto einval;
		}

	/*
	 * If the user did not specify a monitor directory then set the
	 * monitor directory to the home dir.
	 */
	if (!monitor_set) {
		free(wtperf->monitor_dir);
		wtperf->monitor_dir = dstrdup(wtperf->home);
	}

	/* Parse configuration settings from configuration file. */
	if (config_opts != NULL && config_opt_file(wtperf, config_opts) != 0)
		goto einval;

	/* Parse options that override values set via a configuration file. */
	__wt_optreset = __wt_optind = 1;
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'o':
			/* Allow -o key=value */
			if (config_opt_str(wtperf, __wt_optarg) != 0)
				goto einval;
			break;
		}

	if (opts->populate_threads == 0 && opts->icount != 0) {
		lprintf(wtperf, 1, 0,
		    ""Cannot have 0 populate threads when icount is set\n"");
		goto err;
	}

	wtperf->async_config = NULL;
	/*
	 * If the user specified async_threads we use async for all ops.
	 * If the user wants compaction, then we also enable async for
	 * the compact operation, but not for the workloads.
	 */
	if (opts->async_threads > 0) {
		if (F_ISSET(wtperf, CFG_TRUNCATE)) {
			lprintf(wtperf,
			    1, 0, ""Cannot run truncate and async\n"");
			goto err;
		}
		wtperf->use_asyncops = true;
	}
	if (opts->compact && opts->async_threads == 0)
		opts->async_threads = 2;
	if (opts->async_threads > 0) {
		/*
		 * The maximum number of async threads is two digits, so just
		 * use that to compute the space we need.  Assume the default
		 * of 1024 for the max ops.  Although we could bump that up
		 * to 4096 if needed.
		 */
		req_len = strlen("",async=(enabled=true,threads=)"") + 4;
		wtperf->async_config = dmalloc(req_len);
		snprintf(wtperf->async_config, req_len,
		    "",async=(enabled=true,threads=%"" PRIu32 "")"",
		    opts->async_threads);
	}
	if ((ret = config_compress(wtperf)) != 0)
		goto err;

	/* You can't have truncate on a random collection. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->random_range) {
		lprintf(wtperf, 1, 0, ""Cannot run truncate and random_range\n"");
		goto err;
	}

	/* We can't run truncate with more than one table. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->table_count > 1) {
		lprintf(wtperf, 1, 0, ""Cannot truncate more than 1 table\n"");
		goto err;
	}

	/* Make stdout line buffered, so verbose output appears quickly. */
	__wt_stream_set_line_buffer(stdout);

	/* Concatenate non-default configuration strings. */
	if ((opts->verbose > 1 && strlen(debug_cconfig) != 0) ||
	     user_cconfig != NULL || opts->session_count_idle > 0 ||
	     wtperf->compress_ext != NULL || wtperf->async_config != NULL) {
		req_len = 20;
		req_len += wtperf->async_config != NULL ?
		    strlen(wtperf->async_config) : 0;
		req_len += wtperf->compress_ext != NULL ?
		    strlen(wtperf->compress_ext) : 0;
		if (opts->session_count_idle > 0) {
			sreq_len = strlen(""session_max="") + 6;
			req_len += sreq_len;
			sess_cfg = dmalloc(sreq_len);
			snprintf(sess_cfg, sreq_len,
			    ""session_max=%"" PRIu32,
			    opts->session_count_idle +
			    wtperf->workers_cnt + opts->populate_threads + 10);
		}
		req_len += user_cconfig != NULL ? strlen(user_cconfig) : 0;
		req_len += debug_cconfig != NULL ? strlen(debug_cconfig) : 0;
		cc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->async_config != NULL &&
		    strlen(wtperf->async_config) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->async_config);
			append_comma = "","";
		}
		if (wtperf->compress_ext != NULL &&
		    strlen(wtperf->compress_ext) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
","			append_comma = "","";
		}
		if (sess_cfg != NULL && strlen(sess_cfg) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, sess_cfg);
			append_comma = "","";
		}
		if (user_cconfig != NULL && strlen(user_cconfig) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_cconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_cconfig) != 0)
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_cconfig);

		if (strlen(cc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""conn_config"", cc_buf)) != 0)
			goto err;
	}
	if ((opts->verbose > 1 && strlen(debug_tconfig) != 0) || opts->index ||
	    user_tconfig != NULL || wtperf->compress_table != NULL) {
		req_len = 20;
		req_len += wtperf->compress_table != NULL ?
		    strlen(wtperf->compress_table) : 0;
		req_len += opts->index ? strlen(INDEX_COL_NAMES) : 0;
		req_len += user_tconfig != NULL ? strlen(user_tconfig) : 0;
		req_len += debug_tconfig != NULL ? strlen(debug_tconfig) : 0;
		tc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->compress_table != NULL &&
		    strlen(wtperf->compress_table) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_table);
			append_comma = "","";
		}
		if (opts->index) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, INDEX_COL_NAMES);
			append_comma = "","";
		}
		if (user_tconfig != NULL && strlen(user_tconfig) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_tconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_tconfig) != 0)
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_tconfig);

		if (strlen(tc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""table_config"", tc_buf)) != 0)
			goto err;
	}
	if (opts->log_partial && opts->table_count > 1) {
		req_len = strlen(opts->table_config) +
		    strlen(LOG_PARTIAL_CONFIG) + 1;
		wtperf->partial_config = dmalloc(req_len);
		snprintf(wtperf->partial_config, req_len, ""%s%s"",
		    opts->table_config, LOG_PARTIAL_CONFIG);
	}
	/*
	 * Set the config for reopen.  If readonly add in that string.
	 * If not readonly then just copy the original conn_config.
	 */
	if (opts->readonly)
		req_len = strlen(opts->conn_config) +
		    strlen(READONLY_CONFIG) + 1;
	else
		req_len = strlen(opts->conn_config) + 1;
	wtperf->reopen_config = dmalloc(req_len);
	if (opts->readonly)
		snprintf(wtperf->reopen_config, req_len, ""%s%s"",
		    opts->conn_config, READONLY_CONFIG);
	else
		snprintf(wtperf->reopen_config,
		    req_len, ""%s"", opts->conn_config);

	/* Sanity-check the configuration. */
	if ((ret = config_sanity(wtperf)) != 0)
		goto err;

	/* If creating, remove and re-create the home directory. */
	if (opts->create != 0)
		recreate_dir(wtperf->home);

	/* Write a copy of the config. */
	req_len = strlen(wtperf->home) + strlen(""/CONFIG.wtperf"") + 1;
	path = dmalloc(req_len);
	snprintf(path, req_len, ""%s/CONFIG.wtperf"", wtperf->home);
	config_opt_log(opts, path);
	free(path);

	/* Display the configuration. */
	if (opts->verbose > 1)
		config_opt_print(wtperf);

	if ((ret = start_all_runs(wtperf)) != 0)
		goto err;

	if (0) {
einval:		ret = EINVAL;
	}

err:	wtperf_free(wtperf);
	config_opt_cleanup(opts);

	free(cc_buf);
	free(sess_cfg);
	free(tc_buf);
	free(user_cconfig);
	free(user_tconfig);

	return (ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
",181
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+			lprintf(wtperf, ret, 0,",+,"int
main(int argc, char *argv[])
{
	CONFIG_OPTS *opts;
	WTPERF *wtperf, _wtperf;
	size_t pos, req_len, sreq_len;
	bool monitor_set;
	int ch, ret;
	const char *cmdflags = ""C:h:m:O:o:T:"";
	const char *append_comma, *config_opts;
	char *cc_buf, *path, *sess_cfg, *tc_buf, *user_cconfig, *user_tconfig;

	/* The first WTPERF structure (from which all others are derived). */
	wtperf = &_wtperf;
	memset(wtperf, 0, sizeof(*wtperf));
	wtperf->home = dstrdup(DEFAULT_HOME);
	wtperf->monitor_dir = dstrdup(DEFAULT_MONITOR_DIR);
	TAILQ_INIT(&wtperf->stone_head);
	config_opt_init(&wtperf->opts);

	opts = wtperf->opts;
	monitor_set = false;
	ret = 0;
	config_opts = NULL;
	cc_buf = sess_cfg = tc_buf = user_cconfig = user_tconfig = NULL;

	/* Do a basic validation of options, and home is needed before open. */
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'C':
			if (user_cconfig == NULL)
				user_cconfig = dstrdup(__wt_optarg);
			else {
				user_cconfig = drealloc(user_cconfig,
				    strlen(user_cconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_cconfig, "","");
				strcat(user_cconfig, __wt_optarg);
			}
			break;
		case 'h':
			free(wtperf->home);
			wtperf->home = dstrdup(__wt_optarg);
			break;
		case 'm':
			free(wtperf->monitor_dir);
			wtperf->monitor_dir = dstrdup(__wt_optarg);
			monitor_set = true;
			break;
		case 'O':
			config_opts = __wt_optarg;
			break;
		case 'T':
			if (user_tconfig == NULL)
				user_tconfig = dstrdup(__wt_optarg);
			else {
				user_tconfig = drealloc(user_tconfig,
				    strlen(user_tconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_tconfig, "","");
				strcat(user_tconfig, __wt_optarg);
			}
			break;
		case '?':
			usage();
			goto einval;
		}

	/*
	 * If the user did not specify a monitor directory then set the
	 * monitor directory to the home dir.
	 */
	if (!monitor_set) {
		free(wtperf->monitor_dir);
		wtperf->monitor_dir = dstrdup(wtperf->home);
	}

	/* Parse configuration settings from configuration file. */
	if (config_opts != NULL && config_opt_file(wtperf, config_opts) != 0)
		goto einval;

	/* Parse options that override values set via a configuration file. */
	__wt_optreset = __wt_optind = 1;
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'o':
			/* Allow -o key=value */
			if (config_opt_str(wtperf, __wt_optarg) != 0)
				goto einval;
			break;
		}

	if (opts->populate_threads == 0 && opts->icount != 0) {
		lprintf(wtperf, 1, 0,
		    ""Cannot have 0 populate threads when icount is set\n"");
		goto err;
	}

	wtperf->async_config = NULL;
	/*
	 * If the user specified async_threads we use async for all ops.
	 * If the user wants compaction, then we also enable async for
	 * the compact operation, but not for the workloads.
	 */
	if (opts->async_threads > 0) {
		if (F_ISSET(wtperf, CFG_TRUNCATE)) {
			lprintf(wtperf,
			    1, 0, ""Cannot run truncate and async\n"");
			goto err;
		}
		wtperf->use_asyncops = true;
	}
	if (opts->compact && opts->async_threads == 0)
		opts->async_threads = 2;
	if (opts->async_threads > 0) {
		/*
		 * The maximum number of async threads is two digits, so just
		 * use that to compute the space we need.  Assume the default
		 * of 1024 for the max ops.  Although we could bump that up
		 * to 4096 if needed.
		 */
		req_len = strlen("",async=(enabled=true,threads=)"") + 4;
		wtperf->async_config = dmalloc(req_len);
		snprintf(wtperf->async_config, req_len,
		    "",async=(enabled=true,threads=%"" PRIu32 "")"",
		    opts->async_threads);
	}
	if ((ret = config_compress(wtperf)) != 0)
		goto err;

	/* You can't have truncate on a random collection. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->random_range) {
		lprintf(wtperf, 1, 0, ""Cannot run truncate and random_range\n"");
		goto err;
	}

	/* We can't run truncate with more than one table. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->table_count > 1) {
		lprintf(wtperf, 1, 0, ""Cannot truncate more than 1 table\n"");
		goto err;
	}

	/* Make stdout line buffered, so verbose output appears quickly. */
	__wt_stream_set_line_buffer(stdout);

	/* Concatenate non-default configuration strings. */
	if ((opts->verbose > 1 && strlen(debug_cconfig) != 0) ||
	     user_cconfig != NULL || opts->session_count_idle > 0 ||
	     wtperf->compress_ext != NULL || wtperf->async_config != NULL) {
		req_len = 20;
		req_len += wtperf->async_config != NULL ?
		    strlen(wtperf->async_config) : 0;
		req_len += wtperf->compress_ext != NULL ?
		    strlen(wtperf->compress_ext) : 0;
		if (opts->session_count_idle > 0) {
			sreq_len = strlen(""session_max="") + 6;
			req_len += sreq_len;
			sess_cfg = dmalloc(sreq_len);
			snprintf(sess_cfg, sreq_len,
			    ""session_max=%"" PRIu32,
			    opts->session_count_idle +
			    wtperf->workers_cnt + opts->populate_threads + 10);
		}
		req_len += user_cconfig != NULL ? strlen(user_cconfig) : 0;
		req_len += debug_cconfig != NULL ? strlen(debug_cconfig) : 0;
		cc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->async_config != NULL &&
		    strlen(wtperf->async_config) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->async_config);
			append_comma = "","";
		}
		if (wtperf->compress_ext != NULL &&
		    strlen(wtperf->compress_ext) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_ext);
			append_comma = "","";
		}
		if (sess_cfg != NULL && strlen(sess_cfg) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, sess_cfg);
			append_comma = "","";
		}
		if (user_cconfig != NULL && strlen(user_cconfig) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_cconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_cconfig) != 0)
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_cconfig);

		if (strlen(cc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""conn_config"", cc_buf)) != 0)
			goto err;
	}
	if ((opts->verbose > 1 && strlen(debug_tconfig) != 0) || opts->index ||
	    user_tconfig != NULL || wtperf->compress_table != NULL) {
		req_len = 20;
		req_len += wtperf->compress_table != NULL ?
		    strlen(wtperf->compress_table) : 0;
		req_len += opts->index ? strlen(INDEX_COL_NAMES) : 0;
		req_len += user_tconfig != NULL ? strlen(user_tconfig) : 0;
		req_len += debug_tconfig != NULL ? strlen(debug_tconfig) : 0;
		tc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->compress_table != NULL &&
		    strlen(wtperf->compress_table) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_table);
			append_comma = "","";
		}
		if (opts->index) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, INDEX_COL_NAMES);
			append_comma = "","";
		}
		if (user_tconfig != NULL && strlen(user_tconfig) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_tconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_tconfig) != 0)
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_tconfig);

		if (strlen(tc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""table_config"", tc_buf)) != 0)
			goto err;
	}
	if (opts->log_partial && opts->table_count > 1) {
		req_len = strlen(opts->table_config) +
		    strlen(LOG_PARTIAL_CONFIG) + 1;
		wtperf->partial_config = dmalloc(req_len);
		snprintf(wtperf->partial_config, req_len, ""%s%s"",
		    opts->table_config, LOG_PARTIAL_CONFIG);
	}
	/*
	 * Set the config for reopen.  If readonly add in that string.
	 * If not readonly then just copy the original conn_config.
	 */
	if (opts->readonly)
		req_len = strlen(opts->conn_config) +
		    strlen(READONLY_CONFIG) + 1;
	else
		req_len = strlen(opts->conn_config) + 1;
	wtperf->reopen_config = dmalloc(req_len);
	if (opts->readonly)
		snprintf(wtperf->reopen_config, req_len, ""%s%s"",
		    opts->conn_config, READONLY_CONFIG);
	else
		snprintf(wtperf->reopen_config,
		    req_len, ""%s"", opts->conn_config);

	/* Sanity-check the configuration. */
	if ((ret = config_sanity(wtperf)) != 0)
		goto err;

	/* If creating, remove and re-create the home directory. */
	if (opts->create != 0)
		recreate_dir(wtperf->home);

	/* Write a copy of the config. */
	req_len = strlen(wtperf->home) + strlen(""/CONFIG.wtperf"") + 1;
	path = dmalloc(req_len);
	snprintf(path, req_len, ""%s/CONFIG.wtperf"", wtperf->home);
	config_opt_log(opts, path);
	free(path);

	/* Display the configuration. */
	if (opts->verbose > 1)
		config_opt_print(wtperf);

	if ((ret = start_all_runs(wtperf)) != 0)
		goto err;

	if (0) {
einval:		ret = EINVAL;
	}

err:	wtperf_free(wtperf);
	config_opt_cleanup(opts);

	free(cc_buf);
	free(sess_cfg);
	free(tc_buf);
	free(user_cconfig);
	free(user_tconfig);

	return (ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
","int
main(int argc, char *argv[])
{
	CONFIG_OPTS *opts;
	WTPERF *wtperf, _wtperf;
	size_t pos, req_len, sreq_len;
	bool monitor_set;
	int ch, ret;
	const char *cmdflags = ""C:h:m:O:o:T:"";
	const char *append_comma, *config_opts;
	char *cc_buf, *path, *sess_cfg, *tc_buf, *user_cconfig, *user_tconfig;

	/* The first WTPERF structure (from which all others are derived). */
	wtperf = &_wtperf;
	memset(wtperf, 0, sizeof(*wtperf));
	wtperf->home = dstrdup(DEFAULT_HOME);
	wtperf->monitor_dir = dstrdup(DEFAULT_MONITOR_DIR);
	TAILQ_INIT(&wtperf->stone_head);
	config_opt_init(&wtperf->opts);

	opts = wtperf->opts;
	monitor_set = false;
	ret = 0;
	config_opts = NULL;
	cc_buf = sess_cfg = tc_buf = user_cconfig = user_tconfig = NULL;

	/* Do a basic validation of options, and home is needed before open. */
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'C':
			if (user_cconfig == NULL)
				user_cconfig = dstrdup(__wt_optarg);
			else {
				user_cconfig = drealloc(user_cconfig,
				    strlen(user_cconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_cconfig, "","");
				strcat(user_cconfig, __wt_optarg);
			}
			break;
		case 'h':
			free(wtperf->home);
			wtperf->home = dstrdup(__wt_optarg);
			break;
		case 'm':
			free(wtperf->monitor_dir);
			wtperf->monitor_dir = dstrdup(__wt_optarg);
			monitor_set = true;
			break;
		case 'O':
			config_opts = __wt_optarg;
			break;
		case 'T':
			if (user_tconfig == NULL)
				user_tconfig = dstrdup(__wt_optarg);
			else {
				user_tconfig = drealloc(user_tconfig,
				    strlen(user_tconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_tconfig, "","");
				strcat(user_tconfig, __wt_optarg);
			}
			break;
		case '?':
			usage();
			goto einval;
		}

	/*
	 * If the user did not specify a monitor directory then set the
	 * monitor directory to the home dir.
	 */
	if (!monitor_set) {
		free(wtperf->monitor_dir);
		wtperf->monitor_dir = dstrdup(wtperf->home);
	}

	/* Parse configuration settings from configuration file. */
	if (config_opts != NULL && config_opt_file(wtperf, config_opts) != 0)
		goto einval;

	/* Parse options that override values set via a configuration file. */
	__wt_optreset = __wt_optind = 1;
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'o':
			/* Allow -o key=value */
			if (config_opt_str(wtperf, __wt_optarg) != 0)
				goto einval;
			break;
		}

	if (opts->populate_threads == 0 && opts->icount != 0) {
		lprintf(wtperf, 1, 0,
		    ""Cannot have 0 populate threads when icount is set\n"");
		goto err;
	}

	wtperf->async_config = NULL;
	/*
	 * If the user specified async_threads we use async for all ops.
	 * If the user wants compaction, then we also enable async for
	 * the compact operation, but not for the workloads.
	 */
	if (opts->async_threads > 0) {
		if (F_ISSET(wtperf, CFG_TRUNCATE)) {
			lprintf(wtperf,
			    1, 0, ""Cannot run truncate and async\n"");
			goto err;
		}
		wtperf->use_asyncops = true;
	}
	if (opts->compact && opts->async_threads == 0)
		opts->async_threads = 2;
	if (opts->async_threads > 0) {
		/*
		 * The maximum number of async threads is two digits, so just
		 * use that to compute the space we need.  Assume the default
		 * of 1024 for the max ops.  Although we could bump that up
		 * to 4096 if needed.
		 */
		req_len = strlen("",async=(enabled=true,threads=)"") + 4;
		wtperf->async_config = dmalloc(req_len);
		snprintf(wtperf->async_config, req_len,
		    "",async=(enabled=true,threads=%"" PRIu32 "")"",
		    opts->async_threads);
	}
	if ((ret = config_compress(wtperf)) != 0)
		goto err;

	/* You can't have truncate on a random collection. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->random_range) {
		lprintf(wtperf, 1, 0, ""Cannot run truncate and random_range\n"");
		goto err;
	}

	/* We can't run truncate with more than one table. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->table_count > 1) {
		lprintf(wtperf, 1, 0, ""Cannot truncate more than 1 table\n"");
		goto err;
	}

	/* Make stdout line buffered, so verbose output appears quickly. */
	__wt_stream_set_line_buffer(stdout);

	/* Concatenate non-default configuration strings. */
	if ((opts->verbose > 1 && strlen(debug_cconfig) != 0) ||
	     user_cconfig != NULL || opts->session_count_idle > 0 ||
	     wtperf->compress_ext != NULL || wtperf->async_config != NULL) {
		req_len = 20;
		req_len += wtperf->async_config != NULL ?
		    strlen(wtperf->async_config) : 0;
		req_len += wtperf->compress_ext != NULL ?
		    strlen(wtperf->compress_ext) : 0;
		if (opts->session_count_idle > 0) {
			sreq_len = strlen(""session_max="") + 6;
			req_len += sreq_len;
			sess_cfg = dmalloc(sreq_len);
			snprintf(sess_cfg, sreq_len,
			    ""session_max=%"" PRIu32,
			    opts->session_count_idle +
			    wtperf->workers_cnt + opts->populate_threads + 10);
		}
		req_len += user_cconfig != NULL ? strlen(user_cconfig) : 0;
		req_len += debug_cconfig != NULL ? strlen(debug_cconfig) : 0;
		cc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->async_config != NULL &&
		    strlen(wtperf->async_config) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->async_config);
			append_comma = "","";
		}
		if (wtperf->compress_ext != NULL &&
		    strlen(wtperf->compress_ext) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_ext);
			append_comma = "","";
		}
		if (sess_cfg != NULL && strlen(sess_cfg) != 0) {
			pos += (size_t)snprintf(
","			    append_comma, sess_cfg);
			append_comma = "","";
		}
		if (user_cconfig != NULL && strlen(user_cconfig) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_cconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_cconfig) != 0)
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_cconfig);

		if (strlen(cc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""conn_config"", cc_buf)) != 0)
			goto err;
	}
	if ((opts->verbose > 1 && strlen(debug_tconfig) != 0) || opts->index ||
	    user_tconfig != NULL || wtperf->compress_table != NULL) {
		req_len = 20;
		req_len += wtperf->compress_table != NULL ?
		    strlen(wtperf->compress_table) : 0;
		req_len += opts->index ? strlen(INDEX_COL_NAMES) : 0;
		req_len += user_tconfig != NULL ? strlen(user_tconfig) : 0;
		req_len += debug_tconfig != NULL ? strlen(debug_tconfig) : 0;
		tc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->compress_table != NULL &&
		    strlen(wtperf->compress_table) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_table);
			append_comma = "","";
		}
		if (opts->index) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, INDEX_COL_NAMES);
			append_comma = "","";
		}
		if (user_tconfig != NULL && strlen(user_tconfig) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_tconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_tconfig) != 0)
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_tconfig);

		if (strlen(tc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""table_config"", tc_buf)) != 0)
			goto err;
	}
	if (opts->log_partial && opts->table_count > 1) {
		req_len = strlen(opts->table_config) +
		    strlen(LOG_PARTIAL_CONFIG) + 1;
		wtperf->partial_config = dmalloc(req_len);
		snprintf(wtperf->partial_config, req_len, ""%s%s"",
		    opts->table_config, LOG_PARTIAL_CONFIG);
	}
	/*
	 * Set the config for reopen.  If readonly add in that string.
	 * If not readonly then just copy the original conn_config.
	 */
	if (opts->readonly)
		req_len = strlen(opts->conn_config) +
		    strlen(READONLY_CONFIG) + 1;
	else
		req_len = strlen(opts->conn_config) + 1;
	wtperf->reopen_config = dmalloc(req_len);
	if (opts->readonly)
		snprintf(wtperf->reopen_config, req_len, ""%s%s"",
		    opts->conn_config, READONLY_CONFIG);
	else
		snprintf(wtperf->reopen_config,
		    req_len, ""%s"", opts->conn_config);

	/* Sanity-check the configuration. */
	if ((ret = config_sanity(wtperf)) != 0)
		goto err;

	/* If creating, remove and re-create the home directory. */
	if (opts->create != 0)
		recreate_dir(wtperf->home);

	/* Write a copy of the config. */
	req_len = strlen(wtperf->home) + strlen(""/CONFIG.wtperf"") + 1;
	path = dmalloc(req_len);
	snprintf(path, req_len, ""%s/CONFIG.wtperf"", wtperf->home);
	config_opt_log(opts, path);
	free(path);

	/* Display the configuration. */
	if (opts->verbose > 1)
		config_opt_print(wtperf);

	if ((ret = start_all_runs(wtperf)) != 0)
		goto err;

	if (0) {
einval:		ret = EINVAL;
	}

err:	wtperf_free(wtperf);
	config_opt_cleanup(opts);

	free(cc_buf);
	free(sess_cfg);
	free(tc_buf);
	free(user_cconfig);
	free(user_tconfig);

	return (ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
",186
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/bench/wtperf/wtperf.c,"+			lprintf(wtperf, ret, 0,",+,"int
main(int argc, char *argv[])
{
	CONFIG_OPTS *opts;
	WTPERF *wtperf, _wtperf;
	size_t pos, req_len, sreq_len;
	bool monitor_set;
	int ch, ret;
	const char *cmdflags = ""C:h:m:O:o:T:"";
	const char *append_comma, *config_opts;
	char *cc_buf, *path, *sess_cfg, *tc_buf, *user_cconfig, *user_tconfig;

	/* The first WTPERF structure (from which all others are derived). */
	wtperf = &_wtperf;
	memset(wtperf, 0, sizeof(*wtperf));
	wtperf->home = dstrdup(DEFAULT_HOME);
	wtperf->monitor_dir = dstrdup(DEFAULT_MONITOR_DIR);
	TAILQ_INIT(&wtperf->stone_head);
	config_opt_init(&wtperf->opts);

	opts = wtperf->opts;
	monitor_set = false;
	ret = 0;
	config_opts = NULL;
	cc_buf = sess_cfg = tc_buf = user_cconfig = user_tconfig = NULL;

	/* Do a basic validation of options, and home is needed before open. */
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'C':
			if (user_cconfig == NULL)
				user_cconfig = dstrdup(__wt_optarg);
			else {
				user_cconfig = drealloc(user_cconfig,
				    strlen(user_cconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_cconfig, "","");
				strcat(user_cconfig, __wt_optarg);
			}
			break;
		case 'h':
			free(wtperf->home);
			wtperf->home = dstrdup(__wt_optarg);
			break;
		case 'm':
			free(wtperf->monitor_dir);
			wtperf->monitor_dir = dstrdup(__wt_optarg);
			monitor_set = true;
			break;
		case 'O':
			config_opts = __wt_optarg;
			break;
		case 'T':
			if (user_tconfig == NULL)
				user_tconfig = dstrdup(__wt_optarg);
			else {
				user_tconfig = drealloc(user_tconfig,
				    strlen(user_tconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_tconfig, "","");
				strcat(user_tconfig, __wt_optarg);
			}
			break;
		case '?':
			usage();
			goto einval;
		}

	/*
	 * If the user did not specify a monitor directory then set the
	 * monitor directory to the home dir.
	 */
	if (!monitor_set) {
		free(wtperf->monitor_dir);
		wtperf->monitor_dir = dstrdup(wtperf->home);
	}

	/* Parse configuration settings from configuration file. */
	if (config_opts != NULL && config_opt_file(wtperf, config_opts) != 0)
		goto einval;

	/* Parse options that override values set via a configuration file. */
	__wt_optreset = __wt_optind = 1;
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'o':
			/* Allow -o key=value */
			if (config_opt_str(wtperf, __wt_optarg) != 0)
				goto einval;
			break;
		}

	if (opts->populate_threads == 0 && opts->icount != 0) {
		lprintf(wtperf, 1, 0,
		    ""Cannot have 0 populate threads when icount is set\n"");
		goto err;
	}

	wtperf->async_config = NULL;
	/*
	 * If the user specified async_threads we use async for all ops.
	 * If the user wants compaction, then we also enable async for
	 * the compact operation, but not for the workloads.
	 */
	if (opts->async_threads > 0) {
		if (F_ISSET(wtperf, CFG_TRUNCATE)) {
			lprintf(wtperf,
			    1, 0, ""Cannot run truncate and async\n"");
			goto err;
		}
		wtperf->use_asyncops = true;
	}
	if (opts->compact && opts->async_threads == 0)
		opts->async_threads = 2;
	if (opts->async_threads > 0) {
		/*
		 * The maximum number of async threads is two digits, so just
		 * use that to compute the space we need.  Assume the default
		 * of 1024 for the max ops.  Although we could bump that up
		 * to 4096 if needed.
		 */
		req_len = strlen("",async=(enabled=true,threads=)"") + 4;
		wtperf->async_config = dmalloc(req_len);
		snprintf(wtperf->async_config, req_len,
		    "",async=(enabled=true,threads=%"" PRIu32 "")"",
		    opts->async_threads);
	}
	if ((ret = config_compress(wtperf)) != 0)
		goto err;

	/* You can't have truncate on a random collection. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->random_range) {
		lprintf(wtperf, 1, 0, ""Cannot run truncate and random_range\n"");
		goto err;
	}

	/* We can't run truncate with more than one table. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->table_count > 1) {
		lprintf(wtperf, 1, 0, ""Cannot truncate more than 1 table\n"");
		goto err;
	}

	/* Make stdout line buffered, so verbose output appears quickly. */
	__wt_stream_set_line_buffer(stdout);

	/* Concatenate non-default configuration strings. */
	if ((opts->verbose > 1 && strlen(debug_cconfig) != 0) ||
	     user_cconfig != NULL || opts->session_count_idle > 0 ||
	     wtperf->compress_ext != NULL || wtperf->async_config != NULL) {
		req_len = 20;
		req_len += wtperf->async_config != NULL ?
		    strlen(wtperf->async_config) : 0;
		req_len += wtperf->compress_ext != NULL ?
		    strlen(wtperf->compress_ext) : 0;
		if (opts->session_count_idle > 0) {
			sreq_len = strlen(""session_max="") + 6;
			req_len += sreq_len;
			sess_cfg = dmalloc(sreq_len);
			snprintf(sess_cfg, sreq_len,
			    ""session_max=%"" PRIu32,
			    opts->session_count_idle +
			    wtperf->workers_cnt + opts->populate_threads + 10);
		}
		req_len += user_cconfig != NULL ? strlen(user_cconfig) : 0;
		req_len += debug_cconfig != NULL ? strlen(debug_cconfig) : 0;
		cc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->async_config != NULL &&
		    strlen(wtperf->async_config) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->async_config);
			append_comma = "","";
		}
		if (wtperf->compress_ext != NULL &&
		    strlen(wtperf->compress_ext) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_ext);
			append_comma = "","";
		}
		if (sess_cfg != NULL && strlen(sess_cfg) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, sess_cfg);
			append_comma = "","";
		}
		if (user_cconfig != NULL && strlen(user_cconfig) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_cconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_cconfig) != 0)
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_cconfig);

		if (strlen(cc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""conn_config"", cc_buf)) != 0)
			goto err;
	}
	if ((opts->verbose > 1 && strlen(debug_tconfig) != 0) || opts->index ||
	    user_tconfig != NULL || wtperf->compress_table != NULL) {
		req_len = 20;
		req_len += wtperf->compress_table != NULL ?
		    strlen(wtperf->compress_table) : 0;
		req_len += opts->index ? strlen(INDEX_COL_NAMES) : 0;
		req_len += user_tconfig != NULL ? strlen(user_tconfig) : 0;
		req_len += debug_tconfig != NULL ? strlen(debug_tconfig) : 0;
		tc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->compress_table != NULL &&
		    strlen(wtperf->compress_table) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_table);
			append_comma = "","";
		}
		if (opts->index) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, INDEX_COL_NAMES);
			append_comma = "","";
		}
		if (user_tconfig != NULL && strlen(user_tconfig) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_tconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_tconfig) != 0)
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_tconfig);

		if (strlen(tc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""table_config"", tc_buf)) != 0)
			goto err;
	}
	if (opts->log_partial && opts->table_count > 1) {
		req_len = strlen(opts->table_config) +
		    strlen(LOG_PARTIAL_CONFIG) + 1;
		wtperf->partial_config = dmalloc(req_len);
		snprintf(wtperf->partial_config, req_len, ""%s%s"",
		    opts->table_config, LOG_PARTIAL_CONFIG);
	}
	/*
	 * Set the config for reopen.  If readonly add in that string.
	 * If not readonly then just copy the original conn_config.
	 */
	if (opts->readonly)
		req_len = strlen(opts->conn_config) +
		    strlen(READONLY_CONFIG) + 1;
	else
		req_len = strlen(opts->conn_config) + 1;
	wtperf->reopen_config = dmalloc(req_len);
	if (opts->readonly)
		snprintf(wtperf->reopen_config, req_len, ""%s%s"",
		    opts->conn_config, READONLY_CONFIG);
	else
		snprintf(wtperf->reopen_config,
		    req_len, ""%s"", opts->conn_config);

	/* Sanity-check the configuration. */
	if ((ret = config_sanity(wtperf)) != 0)
		goto err;

	/* If creating, remove and re-create the home directory. */
	if (opts->create != 0)
		recreate_dir(wtperf->home);

	/* Write a copy of the config. */
	req_len = strlen(wtperf->home) + strlen(""/CONFIG.wtperf"") + 1;
	path = dmalloc(req_len);
	snprintf(path, req_len, ""%s/CONFIG.wtperf"", wtperf->home);
	config_opt_log(opts, path);
	free(path);

	/* Display the configuration. */
	if (opts->verbose > 1)
		config_opt_print(wtperf);

	if ((ret = start_all_runs(wtperf)) != 0)
		goto err;

	if (0) {
einval:		ret = EINVAL;
	}

err:	wtperf_free(wtperf);
	config_opt_cleanup(opts);

	free(cc_buf);
	free(sess_cfg);
	free(tc_buf);
	free(user_cconfig);
	free(user_tconfig);

	return (ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
","int
main(int argc, char *argv[])
{
	CONFIG_OPTS *opts;
	WTPERF *wtperf, _wtperf;
	size_t pos, req_len, sreq_len;
	bool monitor_set;
	int ch, ret;
	const char *cmdflags = ""C:h:m:O:o:T:"";
	const char *append_comma, *config_opts;
	char *cc_buf, *path, *sess_cfg, *tc_buf, *user_cconfig, *user_tconfig;

	/* The first WTPERF structure (from which all others are derived). */
	wtperf = &_wtperf;
	memset(wtperf, 0, sizeof(*wtperf));
	wtperf->home = dstrdup(DEFAULT_HOME);
	wtperf->monitor_dir = dstrdup(DEFAULT_MONITOR_DIR);
	TAILQ_INIT(&wtperf->stone_head);
	config_opt_init(&wtperf->opts);

	opts = wtperf->opts;
	monitor_set = false;
	ret = 0;
	config_opts = NULL;
	cc_buf = sess_cfg = tc_buf = user_cconfig = user_tconfig = NULL;

	/* Do a basic validation of options, and home is needed before open. */
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'C':
			if (user_cconfig == NULL)
				user_cconfig = dstrdup(__wt_optarg);
			else {
				user_cconfig = drealloc(user_cconfig,
				    strlen(user_cconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_cconfig, "","");
				strcat(user_cconfig, __wt_optarg);
			}
			break;
		case 'h':
			free(wtperf->home);
			wtperf->home = dstrdup(__wt_optarg);
			break;
		case 'm':
			free(wtperf->monitor_dir);
			wtperf->monitor_dir = dstrdup(__wt_optarg);
			monitor_set = true;
			break;
		case 'O':
			config_opts = __wt_optarg;
			break;
		case 'T':
			if (user_tconfig == NULL)
				user_tconfig = dstrdup(__wt_optarg);
			else {
				user_tconfig = drealloc(user_tconfig,
				    strlen(user_tconfig) +
				    strlen(__wt_optarg) + 2);
				strcat(user_tconfig, "","");
				strcat(user_tconfig, __wt_optarg);
			}
			break;
		case '?':
			usage();
			goto einval;
		}

	/*
	 * If the user did not specify a monitor directory then set the
	 * monitor directory to the home dir.
	 */
	if (!monitor_set) {
		free(wtperf->monitor_dir);
		wtperf->monitor_dir = dstrdup(wtperf->home);
	}

	/* Parse configuration settings from configuration file. */
	if (config_opts != NULL && config_opt_file(wtperf, config_opts) != 0)
		goto einval;

	/* Parse options that override values set via a configuration file. */
	__wt_optreset = __wt_optind = 1;
	while ((ch = __wt_getopt(""wtperf"", argc, argv, cmdflags)) != EOF)
		switch (ch) {
		case 'o':
			/* Allow -o key=value */
			if (config_opt_str(wtperf, __wt_optarg) != 0)
				goto einval;
			break;
		}

	if (opts->populate_threads == 0 && opts->icount != 0) {
		lprintf(wtperf, 1, 0,
		    ""Cannot have 0 populate threads when icount is set\n"");
		goto err;
	}

	wtperf->async_config = NULL;
	/*
	 * If the user specified async_threads we use async for all ops.
	 * If the user wants compaction, then we also enable async for
	 * the compact operation, but not for the workloads.
	 */
	if (opts->async_threads > 0) {
		if (F_ISSET(wtperf, CFG_TRUNCATE)) {
			lprintf(wtperf,
			    1, 0, ""Cannot run truncate and async\n"");
			goto err;
		}
		wtperf->use_asyncops = true;
	}
	if (opts->compact && opts->async_threads == 0)
		opts->async_threads = 2;
	if (opts->async_threads > 0) {
		/*
		 * The maximum number of async threads is two digits, so just
		 * use that to compute the space we need.  Assume the default
		 * of 1024 for the max ops.  Although we could bump that up
		 * to 4096 if needed.
		 */
		req_len = strlen("",async=(enabled=true,threads=)"") + 4;
		wtperf->async_config = dmalloc(req_len);
		snprintf(wtperf->async_config, req_len,
		    "",async=(enabled=true,threads=%"" PRIu32 "")"",
		    opts->async_threads);
	}
	if ((ret = config_compress(wtperf)) != 0)
		goto err;

	/* You can't have truncate on a random collection. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->random_range) {
		lprintf(wtperf, 1, 0, ""Cannot run truncate and random_range\n"");
		goto err;
	}

	/* We can't run truncate with more than one table. */
	if (F_ISSET(wtperf, CFG_TRUNCATE) && opts->table_count > 1) {
		lprintf(wtperf, 1, 0, ""Cannot truncate more than 1 table\n"");
		goto err;
	}

	/* Make stdout line buffered, so verbose output appears quickly. */
	__wt_stream_set_line_buffer(stdout);

	/* Concatenate non-default configuration strings. */
	if ((opts->verbose > 1 && strlen(debug_cconfig) != 0) ||
	     user_cconfig != NULL || opts->session_count_idle > 0 ||
	     wtperf->compress_ext != NULL || wtperf->async_config != NULL) {
		req_len = 20;
		req_len += wtperf->async_config != NULL ?
		    strlen(wtperf->async_config) : 0;
		req_len += wtperf->compress_ext != NULL ?
		    strlen(wtperf->compress_ext) : 0;
		if (opts->session_count_idle > 0) {
			sreq_len = strlen(""session_max="") + 6;
			req_len += sreq_len;
			sess_cfg = dmalloc(sreq_len);
			snprintf(sess_cfg, sreq_len,
			    ""session_max=%"" PRIu32,
			    opts->session_count_idle +
			    wtperf->workers_cnt + opts->populate_threads + 10);
		}
		req_len += user_cconfig != NULL ? strlen(user_cconfig) : 0;
		req_len += debug_cconfig != NULL ? strlen(debug_cconfig) : 0;
		cc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->async_config != NULL &&
		    strlen(wtperf->async_config) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->async_config);
			append_comma = "","";
		}
		if (wtperf->compress_ext != NULL &&
		    strlen(wtperf->compress_ext) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_ext);
			append_comma = "","";
		}
		if (sess_cfg != NULL && strlen(sess_cfg) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, sess_cfg);
			append_comma = "","";
		}
		if (user_cconfig != NULL && strlen(user_cconfig) != 0) {
			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_cconfig);
			append_comma = "","";
		}
","			pos += (size_t)snprintf(
			    cc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_cconfig);

		if (strlen(cc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""conn_config"", cc_buf)) != 0)
			goto err;
	}
	if ((opts->verbose > 1 && strlen(debug_tconfig) != 0) || opts->index ||
	    user_tconfig != NULL || wtperf->compress_table != NULL) {
		req_len = 20;
		req_len += wtperf->compress_table != NULL ?
		    strlen(wtperf->compress_table) : 0;
		req_len += opts->index ? strlen(INDEX_COL_NAMES) : 0;
		req_len += user_tconfig != NULL ? strlen(user_tconfig) : 0;
		req_len += debug_tconfig != NULL ? strlen(debug_tconfig) : 0;
		tc_buf = dmalloc(req_len);

		pos = 0;
		append_comma = """";
		if (wtperf->compress_table != NULL &&
		    strlen(wtperf->compress_table) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, wtperf->compress_table);
			append_comma = "","";
		}
		if (opts->index) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, INDEX_COL_NAMES);
			append_comma = "","";
		}
		if (user_tconfig != NULL && strlen(user_tconfig) != 0) {
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, user_tconfig);
			append_comma = "","";
		}
		if (opts->verbose > 1 && strlen(debug_tconfig) != 0)
			pos += (size_t)snprintf(
			    tc_buf + pos, req_len - pos, ""%s%s"",
			    append_comma, debug_tconfig);

		if (strlen(tc_buf) != 0 && (ret =
		    config_opt_name_value(wtperf, ""table_config"", tc_buf)) != 0)
			goto err;
	}
	if (opts->log_partial && opts->table_count > 1) {
		req_len = strlen(opts->table_config) +
		    strlen(LOG_PARTIAL_CONFIG) + 1;
		wtperf->partial_config = dmalloc(req_len);
		snprintf(wtperf->partial_config, req_len, ""%s%s"",
		    opts->table_config, LOG_PARTIAL_CONFIG);
	}
	/*
	 * Set the config for reopen.  If readonly add in that string.
	 * If not readonly then just copy the original conn_config.
	 */
	if (opts->readonly)
		req_len = strlen(opts->conn_config) +
		    strlen(READONLY_CONFIG) + 1;
	else
		req_len = strlen(opts->conn_config) + 1;
	wtperf->reopen_config = dmalloc(req_len);
	if (opts->readonly)
		snprintf(wtperf->reopen_config, req_len, ""%s%s"",
		    opts->conn_config, READONLY_CONFIG);
	else
		snprintf(wtperf->reopen_config,
		    req_len, ""%s"", opts->conn_config);

	/* Sanity-check the configuration. */
	if ((ret = config_sanity(wtperf)) != 0)
		goto err;

	/* If creating, remove and re-create the home directory. */
	if (opts->create != 0)
		recreate_dir(wtperf->home);

	/* Write a copy of the config. */
	req_len = strlen(wtperf->home) + strlen(""/CONFIG.wtperf"") + 1;
	path = dmalloc(req_len);
	snprintf(path, req_len, ""%s/CONFIG.wtperf"", wtperf->home);
	config_opt_log(opts, path);
	free(path);

	/* Display the configuration. */
	if (opts->verbose > 1)
		config_opt_print(wtperf);

	if ((ret = start_all_runs(wtperf)) != 0)
		goto err;

	if (0) {
einval:		ret = EINVAL;
	}

err:	wtperf_free(wtperf);
	config_opt_cleanup(opts);

	free(cc_buf);
	free(sess_cfg);
	free(tc_buf);
	free(user_cconfig);
	free(user_tconfig);

	return (ret == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
",196
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,+static int fail_file_write(,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+	assert(pthread_rwlock_init(lockp, NULL) == 0);",+,"static void
fail_fs_allocate_lock(pthread_rwlock_t *lockp)
{
	assert(pthread_rwlock_init(lockp, NULL) == 0);
}
","static void
fail_fs_allocate_lock(pthread_rwlock_t *lockp)
{
","}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,+	assert(pthread_rwlock_destroy(lockp) == 0);,+,"static void
fail_fs_destroy_lock(pthread_rwlock_t *lockp)
{
	assert(pthread_rwlock_destroy(lockp) == 0);
}
","static void
fail_fs_destroy_lock(pthread_rwlock_t *lockp)
{
","}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,+	assert(pthread_rwlock_wrlock(lockp) == 0);,+,"static void
fail_fs_lock(pthread_rwlock_t *lockp)
{
	assert(pthread_rwlock_wrlock(lockp) == 0);
}
","static void
fail_fs_lock(pthread_rwlock_t *lockp)
{
","}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,+	assert(pthread_rwlock_unlock(lockp) == 0);,+,"static void
fail_fs_unlock(pthread_rwlock_t *lockp)
{
	assert(pthread_rwlock_unlock(lockp) == 0);
}
","static void
fail_fs_unlock(pthread_rwlock_t *lockp)
{
","}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+			(void)wtext->err_printf(wtext, session,",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+			    wtext->strerror(wtext, NULL, errno));",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+fail_file_write(WT_FILE_HANDLE *file_handle, WT_SESSION *session,",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		if ((nr = pwrite(fail_fh->fd, addr, chunk, offset)) <= 0) {",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+			(void)wtext->err_printf(wtext, session,",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+			    wtext->strerror(wtext, NULL, errno));",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		(void)wtext->msg_printf(wtext, session, ""fail_fs: open: %s"",",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		(void)wtext->msg_printf(wtext, session,",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+				(void)wtext->msg_printf(wtext, session, ""  %s"",",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		(void)wtext->err_printf(wtext, NULL,",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
","		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",15
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		    wtext->strerror(wtext, NULL, ENOMEM));",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
","		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",17
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		(void)wtext->err_printf(wtext, NULL,",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
","		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",26
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		    wtext->strerror(wtext, NULL, ret));",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
","		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",28
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		(void)wtext->err_printf(wtext, NULL,",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

","		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",45
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		    wtext->strerror(wtext, NULL, ret));",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
","		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",49
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		(void)wtext->err_printf(wtext, NULL,",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
","		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",53
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		    wtext->strerror(wtext, NULL, ret));",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
","		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",55
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		(void)wtext->err_printf(wtext, NULL,",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
","		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",59
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		    wtext->strerror(wtext, NULL, ret));",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
","		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",61
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		(void)wtext->err_printf(wtext, NULL,",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
","		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",78
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/ext/test/fail_fs/fail_fs.c,"+		    wtext->strerror(wtext, NULL, ret));",+,"int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
","int
wiredtiger_extension_init(WT_CONNECTION *conn, WT_CONFIG_ARG *config)
{
	FAIL_FILE_SYSTEM *fail_fs;
	WT_CONFIG_ITEM k, v;
	WT_CONFIG_PARSER *config_parser;
	WT_EXTENSION_API *wtext;
	WT_FILE_SYSTEM *file_system;
	int64_t argval;
	int ret;

	ret = 0;
	wtext = conn->get_extension_api(conn);
	if ((fail_fs = calloc(1, sizeof(FAIL_FILE_SYSTEM))) == NULL) {
		(void)wtext->err_printf(wtext, NULL,
		    ""fail_file_system extension_init: %s"",
		    wtext->strerror(wtext, NULL, ENOMEM));
		return (ENOMEM);
	}
	fail_fs->wtext = wtext;
	file_system = (WT_FILE_SYSTEM *)fail_fs;

	/* Get any configuration values. */
	if ((ret = wtext->config_parser_open_arg(
	    wtext, NULL, config, &config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_EXTENSION_API.config_parser_open: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	while ((ret = config_parser->next(config_parser, &k, &v)) == 0) {
		if (fail_fs_arg(""environment"", &k, &v, &argval)) {
			fail_fs->use_environment = (argval != 0);
			continue;
		} else if (fail_fs_arg(""verbose"", &k, &v, &argval)) {
			fail_fs->verbose = (argval != 0);
			continue;
		} else if (fail_fs_arg(""allow_writes"", &k, &v,
		    &fail_fs->allow_writes))
			continue;
		else if (fail_fs_arg(""allow_reads"", &k, &v,
		    &fail_fs->allow_reads))
			continue;

		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: unexpected configuration ""
		    ""information: %.*s=%.*s: %s"",
		    (int)k.len, k.str, (int)v.len, v.str,
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (ret != WT_NOTFOUND) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.next: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if ((ret = config_parser->close(config_parser)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONFIG_PARSER.close: config: %s"",
		    wtext->strerror(wtext, NULL, ret));
		goto err;
	}
	if (fail_fs->allow_writes != 0 || fail_fs->allow_reads != 0)
		fail_fs->fail_enabled = true;

	fail_fs_allocate_lock(&fail_fs->lock);
	/* Initialize the in-memory jump table. */
	file_system->fs_directory_list = fail_fs_directory_list;
	file_system->fs_directory_list_free = fail_fs_directory_list_free;
	file_system->fs_exist = fail_fs_exist;
	file_system->fs_open_file = fail_fs_open;
	file_system->fs_remove = fail_fs_remove;
	file_system->fs_rename = fail_fs_rename;
	file_system->fs_size = fail_fs_size;
	file_system->terminate = fail_fs_terminate;
	if ((ret = conn->set_file_system(conn, file_system, NULL)) != 0) {
		(void)wtext->err_printf(wtext, NULL,
		    ""WT_CONNECTION.set_file_system: %s"",
","		goto err;
	}
	return (0);

err:    free(fail_fs);
	return (ret);
}
",80
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/btree/bt_split.c,-	WT_WRITE_BARRIER();,-,"static int
__split_root(WT_SESSION_IMPL *session, WT_PAGE *root)
{
	WT_BTREE *btree;
	WT_DECL_RET;
	WT_PAGE *child;
	WT_PAGE_INDEX *alloc_index, *child_pindex, *pindex;
	WT_REF **alloc_refp;
	WT_REF **child_refp, *ref, **root_refp;
	WT_SPLIT_ERROR_PHASE complete;
	size_t child_incr, root_decr, root_incr, size;
	uint64_t split_gen;
	uint32_t children, chunk, i, j, remain;
	uint32_t slots;
	void *p;

	WT_STAT_CONN_INCR(session, cache_eviction_deepen);
	WT_STAT_DATA_INCR(session, cache_eviction_deepen);
	WT_STAT_CONN_INCR(session, cache_eviction_split_internal);
	WT_STAT_DATA_INCR(session, cache_eviction_split_internal);

	btree = S2BT(session);
	alloc_index = NULL;
	root_decr = root_incr = 0;
	complete = WT_ERR_RETURN;

	/* The root page will be marked dirty, make sure that will succeed. */
	WT_RET(__wt_page_modify_init(session, root));

	/*
	 * Our caller is holding the root page locked to single-thread splits,
	 * which means we can safely look at the page's index without setting a
	 * split generation.
	 */
	pindex = WT_INTL_INDEX_GET_SAFE(root);

	/*
	 * Decide how many child pages to create, then calculate the standard
	 * chunk and whatever remains. Sanity check the number of children:
	 * the decision to split matched to the deepen-per-child configuration
	 * might get it wrong.
	 */
	children = pindex->entries / btree->split_deepen_per_child;
	if (children < 10) {
		if (pindex->entries < 100)
			return (EBUSY);
		children = 10;
	}
	chunk = pindex->entries / children;
	remain = pindex->entries - chunk * (children - 1);

	__wt_verbose(session, WT_VERB_SPLIT,
	    ""%p: %"" PRIu32 "" root page elements, splitting into %"" PRIu32
	    "" children"",
	    (void *)root, pindex->entries, children);

	/*
	 * Allocate a new WT_PAGE_INDEX and set of WT_REF objects to be inserted
	 * into the root page, replacing the root's page-index.
	 */
	size = sizeof(WT_PAGE_INDEX) + children * sizeof(WT_REF *);
	WT_ERR(__wt_calloc(session, 1, size, &alloc_index));
	root_incr += size;
	alloc_index->index = (WT_REF **)(alloc_index + 1);
	alloc_index->entries = children;
	alloc_refp = alloc_index->index;
	for (i = 0; i < children; alloc_refp++, ++i)
		WT_ERR(__wt_calloc_one(session, alloc_refp));
	root_incr += children * sizeof(WT_REF);

	/* Allocate child pages, and connect them into the new page index. */
	for (root_refp = pindex->index,
	    alloc_refp = alloc_index->index, i = 0; i < children; ++i) {
		slots = i == children - 1 ? remain : chunk;

		WT_ERR(__wt_page_alloc(
		    session, root->type, slots, false, &child));

		/*
		 * Initialize the page's child reference; we need a copy of the
		 * page's key.
		 */
		ref = *alloc_refp++;
		ref->home = root;
		ref->page = child;
		ref->addr = NULL;
		if (root->type == WT_PAGE_ROW_INT) {
			__wt_ref_key(root, *root_refp, &p, &size);
			WT_ERR(__wt_row_ikey(session, 0, p, size, ref));
			root_incr += sizeof(WT_IKEY) + size;
		} else
			ref->ref_recno = (*root_refp)->ref_recno;
		ref->state = WT_REF_MEM;

		/* Initialize the child page. */
		child->pg_intl_parent_ref = ref;

		/* Mark it dirty. */
		WT_ERR(__wt_page_modify_init(session, child));
		__wt_page_modify_set(session, child);

		/*
		 * The newly allocated child's page index references the same
		 * structures as the root.  (We cannot move WT_REF structures,
		 * threads may be underneath us right now changing the structure
		 * state.)  However, if the WT_REF structures reference on-page
		 * information, we have to fix that, because the disk image for
		 * the page that has a page index entry for the WT_REF is about
		 * to change.
		 */
		child_pindex = WT_INTL_INDEX_GET_SAFE(child);
		child_incr = 0;
		for (child_refp = child_pindex->index,
		    j = 0; j < slots; ++child_refp, ++root_refp, ++j)
			WT_ERR(__split_ref_move(session, root,
			    root_refp, &root_decr, child_refp, &child_incr));

		__wt_cache_page_inmem_incr(session, child, child_incr);
	}
	WT_ASSERT(session,
	    alloc_refp - alloc_index->index == (ptrdiff_t)alloc_index->entries);
	WT_ASSERT(session,
	    root_refp - pindex->index == (ptrdiff_t)pindex->entries);

	/* Start making real changes to the tree, errors are fatal. */
	complete = WT_ERR_PANIC;

	/* Get a generation for this split, mark the root page. */
	split_gen = __wt_atomic_addv64(&S2C(session)->split_gen, 1);
	root->pg_intl_split_gen = split_gen;

	/* Prepare the WT_REFs for the move. */
	__split_ref_prepare(session, alloc_index, split_gen, false);

	/*
	 * Confirm the root page's index hasn't moved, then update it, which
	 * makes the split visible to threads descending the tree.
	 */
	WT_ASSERT(session, WT_INTL_INDEX_GET_SAFE(root) == pindex);
	WT_INTL_INDEX_SET(root, alloc_index);
	alloc_index = NULL;

#ifdef HAVE_DIAGNOSTIC
	WT_WITH_PAGE_INDEX(session,
	    ret = __split_verify_root(session, root));
	WT_ERR(ret);
#endif

	/* The split is complete and verified, ignore benign errors. */
	complete = WT_ERR_IGNORE;

	/*
	 * We can't free the previous root's index, there may be threads using
	 * it.  Add to the session's discard list, to be freed once we know no
	 * threads can still be using it.
	 *
	 * This change requires care with error handling: we have already
	 * updated the page with a new index.  Even if stashing the old value
	 * fails, we don't roll back that change, because threads may already
	 * be using the new index.
	 */
	size = sizeof(WT_PAGE_INDEX) + pindex->entries * sizeof(WT_REF *);
	WT_TRET(__split_safe_free(session, split_gen, false, pindex, size));
	root_decr += size;

	/* Adjust the root's memory footprint and mark it dirty. */
	__wt_cache_page_inmem_incr(session, root, root_incr);
	__wt_cache_page_inmem_decr(session, root, root_decr);
	__wt_page_modify_set(session, root);

err:	switch (complete) {
	case WT_ERR_RETURN:
		__wt_free_ref_index(session, root, alloc_index, true);
		break;
	case WT_ERR_PANIC:
		__wt_err(session, ret,
		    ""fatal error during root page split to deepen the tree"");
		ret = WT_PANIC;
		break;
	case WT_ERR_IGNORE:
		if (ret != 0 && ret != WT_PANIC) {
			__wt_err(session, ret,
			    ""ignoring not-fatal error during root page split ""
			    ""to deepen the tree"");
			ret = 0;
		}
		break;
	}
	return (ret);
}
","static int
__split_root(WT_SESSION_IMPL *session, WT_PAGE *root)
{
	WT_BTREE *btree;
	WT_DECL_RET;
	WT_PAGE *child;
	WT_PAGE_INDEX *alloc_index, *child_pindex, *pindex;
	WT_REF **alloc_refp;
	WT_REF **child_refp, *ref, **root_refp;
	WT_SPLIT_ERROR_PHASE complete;
	size_t child_incr, root_decr, root_incr, size;
	uint64_t split_gen;
	uint32_t children, chunk, i, j, remain;
	uint32_t slots;
	void *p;

	WT_STAT_CONN_INCR(session, cache_eviction_deepen);
	WT_STAT_DATA_INCR(session, cache_eviction_deepen);
	WT_STAT_CONN_INCR(session, cache_eviction_split_internal);
	WT_STAT_DATA_INCR(session, cache_eviction_split_internal);

	btree = S2BT(session);
	alloc_index = NULL;
	root_decr = root_incr = 0;
	complete = WT_ERR_RETURN;

	/* The root page will be marked dirty, make sure that will succeed. */
	WT_RET(__wt_page_modify_init(session, root));

	/*
	 * Our caller is holding the root page locked to single-thread splits,
	 * which means we can safely look at the page's index without setting a
	 * split generation.
	 */
	pindex = WT_INTL_INDEX_GET_SAFE(root);

	/*
	 * Decide how many child pages to create, then calculate the standard
	 * chunk and whatever remains. Sanity check the number of children:
	 * the decision to split matched to the deepen-per-child configuration
	 * might get it wrong.
	 */
	children = pindex->entries / btree->split_deepen_per_child;
	if (children < 10) {
		if (pindex->entries < 100)
			return (EBUSY);
		children = 10;
	}
	chunk = pindex->entries / children;
	remain = pindex->entries - chunk * (children - 1);

	__wt_verbose(session, WT_VERB_SPLIT,
	    ""%p: %"" PRIu32 "" root page elements, splitting into %"" PRIu32
	    "" children"",
	    (void *)root, pindex->entries, children);

	/*
	 * Allocate a new WT_PAGE_INDEX and set of WT_REF objects to be inserted
	 * into the root page, replacing the root's page-index.
	 */
	size = sizeof(WT_PAGE_INDEX) + children * sizeof(WT_REF *);
	WT_ERR(__wt_calloc(session, 1, size, &alloc_index));
	root_incr += size;
	alloc_index->index = (WT_REF **)(alloc_index + 1);
	alloc_index->entries = children;
	alloc_refp = alloc_index->index;
	for (i = 0; i < children; alloc_refp++, ++i)
		WT_ERR(__wt_calloc_one(session, alloc_refp));
	root_incr += children * sizeof(WT_REF);

	/* Allocate child pages, and connect them into the new page index. */
	for (root_refp = pindex->index,
	    alloc_refp = alloc_index->index, i = 0; i < children; ++i) {
		slots = i == children - 1 ? remain : chunk;

		WT_ERR(__wt_page_alloc(
		    session, root->type, slots, false, &child));

		/*
		 * Initialize the page's child reference; we need a copy of the
		 * page's key.
		 */
		ref = *alloc_refp++;
		ref->home = root;
		ref->page = child;
		ref->addr = NULL;
		if (root->type == WT_PAGE_ROW_INT) {
			__wt_ref_key(root, *root_refp, &p, &size);
			WT_ERR(__wt_row_ikey(session, 0, p, size, ref));
			root_incr += sizeof(WT_IKEY) + size;
		} else
			ref->ref_recno = (*root_refp)->ref_recno;
		ref->state = WT_REF_MEM;

		/* Initialize the child page. */
		child->pg_intl_parent_ref = ref;

		/* Mark it dirty. */
		WT_ERR(__wt_page_modify_init(session, child));
		__wt_page_modify_set(session, child);

		/*
		 * The newly allocated child's page index references the same
		 * structures as the root.  (We cannot move WT_REF structures,
		 * threads may be underneath us right now changing the structure
		 * state.)  However, if the WT_REF structures reference on-page
		 * information, we have to fix that, because the disk image for
		 * the page that has a page index entry for the WT_REF is about
		 * to change.
		 */
		child_pindex = WT_INTL_INDEX_GET_SAFE(child);
		child_incr = 0;
		for (child_refp = child_pindex->index,
		    j = 0; j < slots; ++child_refp, ++root_refp, ++j)
			WT_ERR(__split_ref_move(session, root,
			    root_refp, &root_decr, child_refp, &child_incr));

		__wt_cache_page_inmem_incr(session, child, child_incr);
	}
	WT_ASSERT(session,
	    alloc_refp - alloc_index->index == (ptrdiff_t)alloc_index->entries);
	WT_ASSERT(session,
	    root_refp - pindex->index == (ptrdiff_t)pindex->entries);

	/* Start making real changes to the tree, errors are fatal. */
	complete = WT_ERR_PANIC;

	/* Get a generation for this split, mark the root page. */
	split_gen = __wt_atomic_addv64(&S2C(session)->split_gen, 1);
	root->pg_intl_split_gen = split_gen;

	/* Prepare the WT_REFs for the move. */
	__split_ref_prepare(session, alloc_index, split_gen, false);

	/*
	 * Confirm the root page's index hasn't moved, then update it, which
	 * makes the split visible to threads descending the tree.
	 */
	WT_ASSERT(session, WT_INTL_INDEX_GET_SAFE(root) == pindex);
	WT_INTL_INDEX_SET(root, alloc_index);
	alloc_index = NULL;

#ifdef HAVE_DIAGNOSTIC
	WT_WITH_PAGE_INDEX(session,
	    ret = __split_verify_root(session, root));
","#endif

	/* The split is complete and verified, ignore benign errors. */
	complete = WT_ERR_IGNORE;

	/*
	 * We can't free the previous root's index, there may be threads using
	 * it.  Add to the session's discard list, to be freed once we know no
	 * threads can still be using it.
	 *
	 * This change requires care with error handling: we have already
	 * updated the page with a new index.  Even if stashing the old value
	 * fails, we don't roll back that change, because threads may already
	 * be using the new index.
	 */
	size = sizeof(WT_PAGE_INDEX) + pindex->entries * sizeof(WT_REF *);
	WT_TRET(__split_safe_free(session, split_gen, false, pindex, size));
	root_decr += size;

	/* Adjust the root's memory footprint and mark it dirty. */
	__wt_cache_page_inmem_incr(session, root, root_incr);
	__wt_cache_page_inmem_decr(session, root, root_decr);
	__wt_page_modify_set(session, root);

err:	switch (complete) {
	case WT_ERR_RETURN:
		__wt_free_ref_index(session, root, alloc_index, true);
		break;
	case WT_ERR_PANIC:
		__wt_err(session, ret,
		    ""fatal error during root page split to deepen the tree"");
		ret = WT_PANIC;
		break;
	case WT_ERR_IGNORE:
		if (ret != 0 && ret != WT_PANIC) {
			__wt_err(session, ret,
			    ""ignoring not-fatal error during root page split ""
			    ""to deepen the tree"");
			ret = 0;
		}
		break;
	}
	return (ret);
}
",146
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_dhandle.c,"-	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));",-,"int
__wt_conn_btree_sync_and_close(WT_SESSION_IMPL *session, bool final, bool force)
{
	WT_BM *bm;
	WT_BTREE *btree;
	WT_DATA_HANDLE *dhandle;
	WT_DECL_RET;
	bool marked_dead, no_schema_lock;

	btree = S2BT(session);
	bm = btree->bm;
	dhandle = session->dhandle;
	marked_dead = false;

	if (!F_ISSET(dhandle, WT_DHANDLE_OPEN))
		return (0);

	/* Turn off eviction. */
	WT_RET(__wt_evict_file_exclusive_on(session));

	/*
	 * If we don't already have the schema lock, make it an error to try
	 * to acquire it.  The problem is that we are holding an exclusive
	 * lock on the handle, and if we attempt to acquire the schema lock
	 * we might deadlock with a thread that has the schema lock and wants
	 * a handle lock (specifically, checkpoint).
	 */
	no_schema_lock = false;
	if (!F_ISSET(session, WT_SESSION_LOCKED_SCHEMA)) {
		no_schema_lock = true;
		F_SET(session, WT_SESSION_NO_SCHEMA_LOCK);
	}

	/*
	 * We may not be holding the schema lock, and threads may be walking
	 * the list of open handles (for example, checkpoint).  Acquire the
	 * handle's close lock. We don't have the sweep server acquire the
	 * handle's rwlock so we have to prevent races through the close code.
	 */
	__wt_spin_lock(session, &dhandle->close_lock);

	/*
	 * The close can fail if an update cannot be written, return the EBUSY
	 * error to our caller for eventual retry.
	 *
	 * If we are forcing the close, just mark the handle dead and the tree
	 * will be discarded later.  Don't do this for memory-mapped trees: we
	 * have to close the file handle to allow the file to be removed, but
	 * memory mapped trees contain pointers into memory that will become
	 * invalid if the mapping is closed.
	 */
	if (!F_ISSET(btree,
	    WT_BTREE_SALVAGE | WT_BTREE_UPGRADE | WT_BTREE_VERIFY)) {
		if (force && (bm == NULL || !bm->is_mapped(bm, session))) {
			F_SET(session->dhandle, WT_DHANDLE_DEAD);
			marked_dead = true;

			/* Reset the tree's eviction priority (if any). */
			__wt_evict_priority_clear(session);
		}
		if (!marked_dead || final)
			WT_ERR(__wt_checkpoint_close(session, final));
	}

	WT_TRET(__wt_btree_close(session));

	/*
	 * If we marked a handle dead it will be closed by sweep, via
	 * another call to sync and close.
	 */
	if (!marked_dead) {
		F_CLR(dhandle, WT_DHANDLE_OPEN);
		if (dhandle->checkpoint == NULL)
			--S2C(session)->open_btree_count;
	}
	WT_ASSERT(session,
	    F_ISSET(dhandle, WT_DHANDLE_DEAD) ||
	    !F_ISSET(dhandle, WT_DHANDLE_OPEN));

err:	__wt_spin_unlock(session, &dhandle->close_lock);

	if (no_schema_lock)
		F_CLR(session, WT_SESSION_NO_SCHEMA_LOCK);

	__wt_evict_file_exclusive_off(session);

	return (ret);
}
","int
__wt_conn_btree_sync_and_close(WT_SESSION_IMPL *session, bool final, bool force)
{
	WT_BM *bm;
	WT_BTREE *btree;
	WT_DATA_HANDLE *dhandle;
	WT_DECL_RET;
	bool marked_dead, no_schema_lock;

	btree = S2BT(session);
	bm = btree->bm;
	dhandle = session->dhandle;
	marked_dead = false;

	if (!F_ISSET(dhandle, WT_DHANDLE_OPEN))
		return (0);

	/* Turn off eviction. */
	WT_RET(__wt_evict_file_exclusive_on(session));

	/*
	 * If we don't already have the schema lock, make it an error to try
	 * to acquire it.  The problem is that we are holding an exclusive
	 * lock on the handle, and if we attempt to acquire the schema lock
	 * we might deadlock with a thread that has the schema lock and wants
	 * a handle lock (specifically, checkpoint).
	 */
	no_schema_lock = false;
	if (!F_ISSET(session, WT_SESSION_LOCKED_SCHEMA)) {
		no_schema_lock = true;
		F_SET(session, WT_SESSION_NO_SCHEMA_LOCK);
	}

	/*
	 * We may not be holding the schema lock, and threads may be walking
	 * the list of open handles (for example, checkpoint).  Acquire the
	 * handle's close lock. We don't have the sweep server acquire the
	 * handle's rwlock so we have to prevent races through the close code.
	 */
	__wt_spin_lock(session, &dhandle->close_lock);

	/*
	 * The close can fail if an update cannot be written, return the EBUSY
	 * error to our caller for eventual retry.
	 *
","	 * will be discarded later.  Don't do this for memory-mapped trees: we
	 * have to close the file handle to allow the file to be removed, but
	 * memory mapped trees contain pointers into memory that will become
	 * invalid if the mapping is closed.
	 */
	if (!F_ISSET(btree,
	    WT_BTREE_SALVAGE | WT_BTREE_UPGRADE | WT_BTREE_VERIFY)) {
		if (force && (bm == NULL || !bm->is_mapped(bm, session))) {
			F_SET(session->dhandle, WT_DHANDLE_DEAD);
			marked_dead = true;

			/* Reset the tree's eviction priority (if any). */
			__wt_evict_priority_clear(session);
		}
		if (!marked_dead || final)
			WT_ERR(__wt_checkpoint_close(session, final));
	}

	WT_TRET(__wt_btree_close(session));

	/*
	 * If we marked a handle dead it will be closed by sweep, via
	 * another call to sync and close.
	 */
	if (!marked_dead) {
		F_CLR(dhandle, WT_DHANDLE_OPEN);
		if (dhandle->checkpoint == NULL)
			--S2C(session)->open_btree_count;
	}
	WT_ASSERT(session,
	    F_ISSET(dhandle, WT_DHANDLE_DEAD) ||
	    !F_ISSET(dhandle, WT_DHANDLE_OPEN));

err:	__wt_spin_unlock(session, &dhandle->close_lock);

	if (no_schema_lock)
		F_CLR(session, WT_SESSION_NO_SCHEMA_LOCK);

	__wt_evict_file_exclusive_off(session);

	return (ret);
}
",46
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_dhandle.c,"-	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));",-,"static void
__conn_btree_config_clear(WT_SESSION_IMPL *session)
{
	WT_DATA_HANDLE *dhandle;
	const char **a;

	dhandle = session->dhandle;

	if (dhandle->cfg == NULL)
		return;
	for (a = dhandle->cfg; *a != NULL; ++a)
		__wt_free(session, *a);
	__wt_free(session, dhandle->cfg);
}
","static void
__conn_btree_config_clear(WT_SESSION_IMPL *session)
{
	WT_DATA_HANDLE *dhandle;
	const char **a;

	dhandle = session->dhandle;

	if (dhandle->cfg == NULL)
		return;
	for (a = dhandle->cfg; *a != NULL; ++a)
","	__wt_free(session, dhandle->cfg);
}
",12
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_dhandle.c,"+	WT_ASSERT(session,",+,"static void
__conn_btree_config_clear(WT_SESSION_IMPL *session)
{
	WT_DATA_HANDLE *dhandle;
	const char **a;

	dhandle = session->dhandle;

	if (dhandle->cfg == NULL)
		return;
	for (a = dhandle->cfg; *a != NULL; ++a)
		__wt_free(session, *a);
	__wt_free(session, dhandle->cfg);
}
","static void
__conn_btree_config_clear(WT_SESSION_IMPL *session)
{
	WT_DATA_HANDLE *dhandle;
	const char **a;

	dhandle = session->dhandle;

	if (dhandle->cfg == NULL)
		return;
	for (a = dhandle->cfg; *a != NULL; ++a)
		__wt_free(session, *a);
","}
",13
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_dhandle.c,"-	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));",-,"static int
__conn_btree_config_set(WT_SESSION_IMPL *session)
{
	WT_DATA_HANDLE *dhandle;
	WT_DECL_RET;
	char *metaconf;

	dhandle = session->dhandle;

	/*
	 * Read the object's entry from the metadata file, we're done if we
	 * don't find one.
	 */
	if ((ret =
	    __wt_metadata_search(session, dhandle->name, &metaconf)) != 0) {
		if (ret == WT_NOTFOUND)
			ret = ENOENT;
		WT_RET(ret);
	}

	/*
	 * The defaults are included because underlying objects have persistent
	 * configuration information stored in the metadata file.  If defaults
	 * are included in the configuration, we can add new configuration
	 * strings without upgrading the metadata file or writing special code
	 * in case a configuration string isn't initialized, as long as the new
	 * configuration string has an appropriate default value.
	 *
	 * The error handling is a little odd, but be careful: we're holding a
	 * chunk of allocated memory in metaconf.  If we fail before we copy a
	 * reference to it into the object's configuration array, we must free
	 * it, after the copy, we don't want to free it.
	 */
	WT_ERR(__wt_calloc_def(session, 3, &dhandle->cfg));
	WT_ERR(__wt_strdup(
	    session, WT_CONFIG_BASE(session, file_meta), &dhandle->cfg[0]));
	dhandle->cfg[1] = metaconf;
	return (0);

err:	__wt_free(session, metaconf);
	return (ret);
}
","static int
__conn_btree_config_set(WT_SESSION_IMPL *session)
","	WT_DATA_HANDLE *dhandle;
	WT_DECL_RET;
	char *metaconf;

	dhandle = session->dhandle;

	/*
	 * Read the object's entry from the metadata file, we're done if we
	 * don't find one.
	 */
	if ((ret =
	    __wt_metadata_search(session, dhandle->name, &metaconf)) != 0) {
		if (ret == WT_NOTFOUND)
			ret = ENOENT;
		WT_RET(ret);
	}

	/*
	 * The defaults are included because underlying objects have persistent
	 * configuration information stored in the metadata file.  If defaults
	 * are included in the configuration, we can add new configuration
	 * strings without upgrading the metadata file or writing special code
	 * in case a configuration string isn't initialized, as long as the new
	 * configuration string has an appropriate default value.
	 *
	 * The error handling is a little odd, but be careful: we're holding a
	 * chunk of allocated memory in metaconf.  If we fail before we copy a
	 * reference to it into the object's configuration array, we must free
	 * it, after the copy, we don't want to free it.
	 */
	WT_ERR(__wt_calloc_def(session, 3, &dhandle->cfg));
	WT_ERR(__wt_strdup(
	    session, WT_CONFIG_BASE(session, file_meta), &dhandle->cfg[0]));
	dhandle->cfg[1] = metaconf;
	return (0);

err:	__wt_free(session, metaconf);
	return (ret);
}
",3
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_dhandle.c,"+	WT_ASSERT(session,",+,"static int
__conn_btree_config_set(WT_SESSION_IMPL *session)
{
	WT_DATA_HANDLE *dhandle;
	WT_DECL_RET;
	char *metaconf;

	dhandle = session->dhandle;

	/*
	 * Read the object's entry from the metadata file, we're done if we
	 * don't find one.
	 */
	if ((ret =
	    __wt_metadata_search(session, dhandle->name, &metaconf)) != 0) {
		if (ret == WT_NOTFOUND)
			ret = ENOENT;
		WT_RET(ret);
	}

	/*
	 * The defaults are included because underlying objects have persistent
	 * configuration information stored in the metadata file.  If defaults
	 * are included in the configuration, we can add new configuration
	 * strings without upgrading the metadata file or writing special code
	 * in case a configuration string isn't initialized, as long as the new
	 * configuration string has an appropriate default value.
	 *
	 * The error handling is a little odd, but be careful: we're holding a
	 * chunk of allocated memory in metaconf.  If we fail before we copy a
	 * reference to it into the object's configuration array, we must free
	 * it, after the copy, we don't want to free it.
	 */
	WT_ERR(__wt_calloc_def(session, 3, &dhandle->cfg));
	WT_ERR(__wt_strdup(
	    session, WT_CONFIG_BASE(session, file_meta), &dhandle->cfg[0]));
	dhandle->cfg[1] = metaconf;
	return (0);

err:	__wt_free(session, metaconf);
	return (ret);
}
","static int
__conn_btree_config_set(WT_SESSION_IMPL *session)
{
","	WT_DECL_RET;
	char *metaconf;

	dhandle = session->dhandle;

	/*
	 * Read the object's entry from the metadata file, we're done if we
	 * don't find one.
	 */
	if ((ret =
	    __wt_metadata_search(session, dhandle->name, &metaconf)) != 0) {
		if (ret == WT_NOTFOUND)
			ret = ENOENT;
		WT_RET(ret);
	}

	/*
	 * The defaults are included because underlying objects have persistent
	 * configuration information stored in the metadata file.  If defaults
	 * are included in the configuration, we can add new configuration
	 * strings without upgrading the metadata file or writing special code
	 * in case a configuration string isn't initialized, as long as the new
	 * configuration string has an appropriate default value.
	 *
	 * The error handling is a little odd, but be careful: we're holding a
	 * chunk of allocated memory in metaconf.  If we fail before we copy a
	 * reference to it into the object's configuration array, we must free
	 * it, after the copy, we don't want to free it.
	 */
	WT_ERR(__wt_calloc_def(session, 3, &dhandle->cfg));
	WT_ERR(__wt_strdup(
	    session, WT_CONFIG_BASE(session, file_meta), &dhandle->cfg[0]));
	dhandle->cfg[1] = metaconf;
	return (0);

err:	__wt_free(session, metaconf);
	return (ret);
}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_dhandle.c,"+	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"static int
__conn_btree_config_set(WT_SESSION_IMPL *session)
{
	WT_DATA_HANDLE *dhandle;
	WT_DECL_RET;
	char *metaconf;

	dhandle = session->dhandle;

	/*
	 * Read the object's entry from the metadata file, we're done if we
	 * don't find one.
	 */
	if ((ret =
	    __wt_metadata_search(session, dhandle->name, &metaconf)) != 0) {
		if (ret == WT_NOTFOUND)
			ret = ENOENT;
		WT_RET(ret);
	}

	/*
	 * The defaults are included because underlying objects have persistent
	 * configuration information stored in the metadata file.  If defaults
	 * are included in the configuration, we can add new configuration
	 * strings without upgrading the metadata file or writing special code
	 * in case a configuration string isn't initialized, as long as the new
	 * configuration string has an appropriate default value.
	 *
	 * The error handling is a little odd, but be careful: we're holding a
	 * chunk of allocated memory in metaconf.  If we fail before we copy a
	 * reference to it into the object's configuration array, we must free
	 * it, after the copy, we don't want to free it.
	 */
	WT_ERR(__wt_calloc_def(session, 3, &dhandle->cfg));
	WT_ERR(__wt_strdup(
	    session, WT_CONFIG_BASE(session, file_meta), &dhandle->cfg[0]));
	dhandle->cfg[1] = metaconf;
	return (0);

err:	__wt_free(session, metaconf);
	return (ret);
}
","static int
__conn_btree_config_set(WT_SESSION_IMPL *session)
{
	WT_DATA_HANDLE *dhandle;
	WT_DECL_RET;
	char *metaconf;

	dhandle = session->dhandle;

	/*
	 * Read the object's entry from the metadata file, we're done if we
	 * don't find one.
	 */
","	    __wt_metadata_search(session, dhandle->name, &metaconf)) != 0) {
		if (ret == WT_NOTFOUND)
			ret = ENOENT;
		WT_RET(ret);
	}

	/*
	 * The defaults are included because underlying objects have persistent
	 * configuration information stored in the metadata file.  If defaults
	 * are included in the configuration, we can add new configuration
	 * strings without upgrading the metadata file or writing special code
	 * in case a configuration string isn't initialized, as long as the new
	 * configuration string has an appropriate default value.
	 *
	 * The error handling is a little odd, but be careful: we're holding a
	 * chunk of allocated memory in metaconf.  If we fail before we copy a
	 * reference to it into the object's configuration array, we must free
	 * it, after the copy, we don't want to free it.
	 */
	WT_ERR(__wt_calloc_def(session, 3, &dhandle->cfg));
	WT_ERR(__wt_strdup(
	    session, WT_CONFIG_BASE(session, file_meta), &dhandle->cfg[0]));
	dhandle->cfg[1] = metaconf;
	return (0);

err:	__wt_free(session, metaconf);
	return (ret);
}
",14
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_stat.c,+__statlog_server_run_chk(WT_SESSION_IMPL *session),+,"static WT_THREAD_RET
__statlog_server(void *arg)
{
	WT_CONNECTION_IMPL *conn;
	WT_DECL_RET;
	WT_ITEM path, tmp;
	WT_SESSION_IMPL *session;

	session = arg;
	conn = S2C(session);

	WT_CLEAR(path);
	WT_CLEAR(tmp);

	/*
	 * We need a temporary place to build a path and an entry prefix.
	 * The length of the path plus 128 should be more than enough.
	 *
	 * We also need a place to store the current path, because that's
	 * how we know when to close/re-open the file.
	 */
	WT_ERR(__wt_buf_init(session, &path, strlen(conn->stat_path) + 128));
	WT_ERR(__wt_buf_init(session, &tmp, strlen(conn->stat_path) + 128));

	for (;;) {
		/* Wait until the next event. */
		__wt_cond_wait(session, conn->stat_cond,
		    conn->stat_usecs, __statlog_server_run_chk);

		/* Check if we're quitting or being reconfigured. */
		if (!__statlog_server_run_chk(session))
			break;

		if (WT_STAT_ENABLED(session))
			WT_ERR(__statlog_log_one(session, &path, &tmp));
	}

	if (0) {
err:		WT_PANIC_MSG(session, ret, ""statistics log server error"");
	}
	__wt_buf_free(session, &path);
	__wt_buf_free(session, &tmp);
	return (WT_THREAD_RET_VALUE);
}
","static WT_THREAD_RET
__statlog_server(void *arg)
{
	WT_CONNECTION_IMPL *conn;
	WT_DECL_RET;
	WT_ITEM path, tmp;
	WT_SESSION_IMPL *session;

	session = arg;
	conn = S2C(session);

	WT_CLEAR(path);
	WT_CLEAR(tmp);

	/*
	 * We need a temporary place to build a path and an entry prefix.
	 * The length of the path plus 128 should be more than enough.
	 *
	 * We also need a place to store the current path, because that's
	 * how we know when to close/re-open the file.
	 */
	WT_ERR(__wt_buf_init(session, &path, strlen(conn->stat_path) + 128));
	WT_ERR(__wt_buf_init(session, &tmp, strlen(conn->stat_path) + 128));

","		/* Wait until the next event. */
		__wt_cond_wait(session, conn->stat_cond,
		    conn->stat_usecs, __statlog_server_run_chk);

		/* Check if we're quitting or being reconfigured. */
		if (!__statlog_server_run_chk(session))
			break;

		if (WT_STAT_ENABLED(session))
			WT_ERR(__statlog_log_one(session, &path, &tmp));
	}

	if (0) {
err:		WT_PANIC_MSG(session, ret, ""statistics log server error"");
	}
	__wt_buf_free(session, &path);
	__wt_buf_free(session, &tmp);
	return (WT_THREAD_RET_VALUE);
}
",25
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_stat.c,+		if (!__statlog_server_run_chk(session)),+,"static int
__statlog_start(WT_CONNECTION_IMPL *conn)
{
	WT_SESSION_IMPL *session;

	/* Nothing to do if the server is already running. */
	if (conn->stat_session != NULL)
		return (0);

	F_SET(conn, WT_CONN_SERVER_STATISTICS);

	/* The statistics log server gets its own session. */
	WT_RET(__wt_open_internal_session(
	    conn, ""statlog-server"", true, 0, &conn->stat_session));
	session = conn->stat_session;

	WT_RET(__wt_cond_alloc(
	    session, ""statistics log server"", &conn->stat_cond));

	/*
	 * Start the thread.
	 *
	 * Statistics logging creates a thread per database, rather than using
	 * a single thread to do logging for all of the databases. If we ever
	 * see lots of databases at a time, doing statistics logging, and we
	 * want to reduce the number of threads, there's no reason we have to
	 * have more than one thread, I just didn't feel like writing the code
	 * to figure out the scheduling.
	 */
	WT_RET(__wt_thread_create(
	    session, &conn->stat_tid, __statlog_server, session));
	conn->stat_tid_set = true;

	return (0);
}
","static int
__statlog_start(WT_CONNECTION_IMPL *conn)
{
	WT_SESSION_IMPL *session;

	/* Nothing to do if the server is already running. */
	if (conn->stat_session != NULL)
		return (0);

	F_SET(conn, WT_CONN_SERVER_STATISTICS);

	/* The statistics log server gets its own session. */
	WT_RET(__wt_open_internal_session(
	    conn, ""statlog-server"", true, 0, &conn->stat_session));
	session = conn->stat_session;

	WT_RET(__wt_cond_alloc(
	    session, ""statistics log server"", &conn->stat_cond));

	/*
	 * Start the thread.
	 *
	 * Statistics logging creates a thread per database, rather than using
	 * a single thread to do logging for all of the databases. If we ever
	 * see lots of databases at a time, doing statistics logging, and we
	 * want to reduce the number of threads, there's no reason we have to
	 * have more than one thread, I just didn't feel like writing the code
	 * to figure out the scheduling.
	 */
	WT_RET(__wt_thread_create(
	    session, &conn->stat_tid, __statlog_server, session));
	conn->stat_tid_set = true;

	return (0);
",,35
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/conn/conn_sweep.c,"+		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"static int
__sweep_remove_handles(WT_SESSION_IMPL *session)
{
	WT_CONNECTION_IMPL *conn;
	WT_DATA_HANDLE *dhandle, *dhandle_next;
	WT_DECL_RET;

	conn = S2C(session);

	for (dhandle = TAILQ_FIRST(&conn->dhqh);
	    dhandle != NULL;
	    dhandle = dhandle_next) {
		dhandle_next = TAILQ_NEXT(dhandle, q);
		if (WT_IS_METADATA(dhandle))
			continue;
		if (!WT_DHANDLE_CAN_DISCARD(dhandle))
			continue;

		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __sweep_remove_one(session, dhandle));
		if (ret == 0)
			WT_STAT_CONN_INCR(session, dh_sweep_remove);
		else
			WT_STAT_CONN_INCR(session, dh_sweep_ref);
		WT_RET_BUSY_OK(ret);
	}

	return (ret == EBUSY ? 0 : ret);
}
","static int
__sweep_remove_handles(WT_SESSION_IMPL *session)
{
	WT_CONNECTION_IMPL *conn;
	WT_DATA_HANDLE *dhandle, *dhandle_next;
	WT_DECL_RET;

	conn = S2C(session);

	for (dhandle = TAILQ_FIRST(&conn->dhqh);
	    dhandle != NULL;
	    dhandle = dhandle_next) {
		dhandle_next = TAILQ_NEXT(dhandle, q);
		if (WT_IS_METADATA(dhandle))
			continue;
		if (!WT_DHANDLE_CAN_DISCARD(dhandle))
			continue;

		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
","		if (ret == 0)
			WT_STAT_CONN_INCR(session, dh_sweep_remove);
		else
			WT_STAT_CONN_INCR(session, dh_sweep_ref);
		WT_RET_BUSY_OK(ret);
	}

	return (ret == EBUSY ? 0 : ret);
}
",20
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-	WT_ASSERT(session,",-,"static inline uint64_t
__evict_entry_priority(WT_SESSION_IMPL *session, WT_REF *ref)
{
	WT_BTREE *btree;
	WT_PAGE *page;
	uint64_t read_gen;

	btree = S2BT(session);
	page = ref->page;

	/* Any page set to the oldest generation should be discarded. */
	if (page->read_gen == WT_READGEN_OLDEST)
		return (WT_READGEN_OLDEST);

	/*
	 * Any leaf page from a dead tree is a great choice (not internal pages,
	 * they may have children and are not yet evictable).
	 */
	if (!WT_PAGE_IS_INTERNAL(page) &&
	    F_ISSET(btree->dhandle, WT_DHANDLE_DEAD))
		return (WT_READGEN_OLDEST);

	/* Any empty page (leaf or internal), is a good choice. */
	if (__wt_page_is_empty(page))
		return (WT_READGEN_OLDEST);

	/* Any large page in memory is likewise a good choice. */
	if (page->memory_footprint > btree->splitmempage)
		return (WT_READGEN_OLDEST);

	/*
	 * The base read-generation is skewed by the eviction priority.
	 * Internal pages are also adjusted, we prefer to evict leaf pages.
	 */
	if (page->modify != NULL &&
	    F_ISSET(S2C(session)->cache, WT_CACHE_EVICT_DIRTY) &&
	    !F_ISSET(S2C(session)->cache, WT_CACHE_EVICT_CLEAN))
		read_gen = page->modify->update_txn;
	else
		read_gen = page->read_gen;

	read_gen += btree->evict_priority;
	if (WT_PAGE_IS_INTERNAL(page))
		read_gen += WT_EVICT_INT_SKEW;

	return (read_gen);
}
","static inline uint64_t
__evict_entry_priority(WT_SESSION_IMPL *session, WT_REF *ref)
{
	WT_BTREE *btree;
	WT_PAGE *page;
	uint64_t read_gen;
","	btree = S2BT(session);
	page = ref->page;

	/* Any page set to the oldest generation should be discarded. */
	if (page->read_gen == WT_READGEN_OLDEST)
		return (WT_READGEN_OLDEST);

	/*
	 * Any leaf page from a dead tree is a great choice (not internal pages,
	 * they may have children and are not yet evictable).
	 */
	if (!WT_PAGE_IS_INTERNAL(page) &&
	    F_ISSET(btree->dhandle, WT_DHANDLE_DEAD))
		return (WT_READGEN_OLDEST);

	/* Any empty page (leaf or internal), is a good choice. */
	if (__wt_page_is_empty(page))
		return (WT_READGEN_OLDEST);

	/* Any large page in memory is likewise a good choice. */
	if (page->memory_footprint > btree->splitmempage)
		return (WT_READGEN_OLDEST);

	/*
	 * The base read-generation is skewed by the eviction priority.
	 * Internal pages are also adjusted, we prefer to evict leaf pages.
	 */
	if (page->modify != NULL &&
	    F_ISSET(S2C(session)->cache, WT_CACHE_EVICT_DIRTY) &&
	    !F_ISSET(S2C(session)->cache, WT_CACHE_EVICT_CLEAN))
		read_gen = page->modify->update_txn;
	else
		read_gen = page->read_gen;

	read_gen += btree->evict_priority;
	if (WT_PAGE_IS_INTERNAL(page))
		read_gen += WT_EVICT_INT_SKEW;

	return (read_gen);
}
",7
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"+	WT_ASSERT(session, !F_ISSET_ATOMIC(ref->page, WT_PAGE_EVICT_LRU));",+,"static inline uint64_t
__evict_entry_priority(WT_SESSION_IMPL *session, WT_REF *ref)
{
	WT_BTREE *btree;
	WT_PAGE *page;
	uint64_t read_gen;

	btree = S2BT(session);
	page = ref->page;

	/* Any page set to the oldest generation should be discarded. */
	if (page->read_gen == WT_READGEN_OLDEST)
		return (WT_READGEN_OLDEST);

	/*
	 * Any leaf page from a dead tree is a great choice (not internal pages,
	 * they may have children and are not yet evictable).
	 */
	if (!WT_PAGE_IS_INTERNAL(page) &&
	    F_ISSET(btree->dhandle, WT_DHANDLE_DEAD))
		return (WT_READGEN_OLDEST);

	/* Any empty page (leaf or internal), is a good choice. */
	if (__wt_page_is_empty(page))
		return (WT_READGEN_OLDEST);

	/* Any large page in memory is likewise a good choice. */
	if (page->memory_footprint > btree->splitmempage)
		return (WT_READGEN_OLDEST);

	/*
	 * The base read-generation is skewed by the eviction priority.
	 * Internal pages are also adjusted, we prefer to evict leaf pages.
	 */
	if (page->modify != NULL &&
	    F_ISSET(S2C(session)->cache, WT_CACHE_EVICT_DIRTY) &&
	    !F_ISSET(S2C(session)->cache, WT_CACHE_EVICT_CLEAN))
		read_gen = page->modify->update_txn;
	else
		read_gen = page->read_gen;

	read_gen += btree->evict_priority;
	if (WT_PAGE_IS_INTERNAL(page))
		read_gen += WT_EVICT_INT_SKEW;

	return (read_gen);
}
","static inline uint64_t
__evict_entry_priority(WT_SESSION_IMPL *session, WT_REF *ref)
{
	WT_BTREE *btree;
	WT_PAGE *page;
	uint64_t read_gen;

	btree = S2BT(session);
","
	/* Any page set to the oldest generation should be discarded. */
	if (page->read_gen == WT_READGEN_OLDEST)
		return (WT_READGEN_OLDEST);

	/*
	 * Any leaf page from a dead tree is a great choice (not internal pages,
	 * they may have children and are not yet evictable).
	 */
	if (!WT_PAGE_IS_INTERNAL(page) &&
	    F_ISSET(btree->dhandle, WT_DHANDLE_DEAD))
		return (WT_READGEN_OLDEST);

	/* Any empty page (leaf or internal), is a good choice. */
	if (__wt_page_is_empty(page))
		return (WT_READGEN_OLDEST);

	/* Any large page in memory is likewise a good choice. */
	if (page->memory_footprint > btree->splitmempage)
		return (WT_READGEN_OLDEST);

	/*
	 * The base read-generation is skewed by the eviction priority.
	 * Internal pages are also adjusted, we prefer to evict leaf pages.
	 */
	if (page->modify != NULL &&
	    F_ISSET(S2C(session)->cache, WT_CACHE_EVICT_DIRTY) &&
	    !F_ISSET(S2C(session)->cache, WT_CACHE_EVICT_CLEAN))
		read_gen = page->modify->update_txn;
	else
		read_gen = page->read_gen;

	read_gen += btree->evict_priority;
	if (WT_PAGE_IS_INTERNAL(page))
		read_gen += WT_EVICT_INT_SKEW;

	return (read_gen);
}
",9
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-	if (fprintf(fp, ""==========\n"" ""transaction state dump\n"") < 0)",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-	if (fprintf(fp,",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-	if (fprintf(fp,",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-	if (fprintf(fp, ""Dumping transaction state of active sessions\n"") < 0)",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-		if (fprintf(fp,",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-	if (fprintf(fp, ""==========\n"" ""cache dump\n"") < 0)",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-			if (fprintf(fp,",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-			if (fprintf(fp, ""%s(checkpoint=%s): \n"",",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-			if (fprintf(fp,",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-			if (fprintf(fp,",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-	if (fprintf(fp,",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/evict/evict_lru.c,"-	if (fprintf(fp, ""==========\n"") < 0)",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"-	return (__wt_write(session, slot->slot_fh, offset, len, buf));",-,"void
__wt_log_ckpt(WT_SESSION_IMPL *session, WT_LSN *ckp_lsn)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;

	conn = S2C(session);
	log = conn->log;
	log->ckpt_lsn = *ckp_lsn;
	if (conn->log_cond != NULL)
		__wt_cond_signal(session, conn->log_cond);
}
","void
","{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;

	conn = S2C(session);
	log = conn->log;
	log->ckpt_lsn = *ckp_lsn;
	if (conn->log_cond != NULL)
		__wt_cond_signal(session, conn->log_cond);
}
",2
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"+	if ((ret = __wt_write(session, slot->slot_fh, offset, len, buf)) != 0)",+,"void
__wt_log_ckpt(WT_SESSION_IMPL *session, WT_LSN *ckp_lsn)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;

	conn = S2C(session);
	log = conn->log;
	log->ckpt_lsn = *ckp_lsn;
	if (conn->log_cond != NULL)
		__wt_cond_signal(session, conn->log_cond);
}
","void
__wt_log_ckpt(WT_SESSION_IMPL *session, WT_LSN *ckp_lsn)
","	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;

	conn = S2C(session);
	log = conn->log;
	log->ckpt_lsn = *ckp_lsn;
	if (conn->log_cond != NULL)
		__wt_cond_signal(session, conn->log_cond);
}
",3
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"-	__wt_log_slot_join(session, rdup_len, flags, &myslot);",-,"int
__wt_log_acquire(WT_SESSION_IMPL *session, uint64_t recsize, WT_LOGSLOT *slot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	bool created_log;

	conn = S2C(session);
	log = conn->log;
	created_log = true;
	/*
	 * Add recsize to alloc_lsn.  Save our starting LSN
	 * where the previous allocation finished for the release LSN.
	 * That way when log files switch, we're waiting for the correct LSN
	 * from outstanding writes.
	 */
	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	/*
	 * We need to set the release LSN earlier, before a log file change.
	 */
	slot->slot_release_lsn = log->alloc_lsn;
	/*
	 * Make sure that the size can fit in the file.  Proactively switch
	 * if it cannot.  This reduces, but does not eliminate, log files
	 * that exceed the maximum file size.  We want to minimize the risk
	 * of an error due to no space.
	 */
	if (!__log_size_fit(session, &log->alloc_lsn, recsize)) {
		WT_RET(__log_newfile(session, false, &created_log));
		if (log->log_close_fh != NULL)
			F_SET(slot, WT_SLOT_CLOSEFH);
	}

	/*
	 * Pre-allocate on the first real write into the log file, if it
	 * was just created (i.e. not pre-allocated).
	 */
	if (log->alloc_lsn.l.offset == WT_LOG_FIRST_RECORD && created_log)
		WT_RET(__log_prealloc(session, log->log_fh));
	/*
	 * Initialize the slot for activation.
	 */
	__wt_log_slot_activate(session, slot);

	return (0);
}
","int
__wt_log_acquire(WT_SESSION_IMPL *session, uint64_t recsize, WT_LOGSLOT *slot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	bool created_log;

	conn = S2C(session);
	log = conn->log;
	created_log = true;
	/*
	 * Add recsize to alloc_lsn.  Save our starting LSN
	 * where the previous allocation finished for the release LSN.
	 * That way when log files switch, we're waiting for the correct LSN
	 * from outstanding writes.
	 */
	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	/*
	 * We need to set the release LSN earlier, before a log file change.
	 */
	slot->slot_release_lsn = log->alloc_lsn;
	/*
	 * Make sure that the size can fit in the file.  Proactively switch
","	 * that exceed the maximum file size.  We want to minimize the risk
	 * of an error due to no space.
	 */
	if (!__log_size_fit(session, &log->alloc_lsn, recsize)) {
		WT_RET(__log_newfile(session, false, &created_log));
		if (log->log_close_fh != NULL)
			F_SET(slot, WT_SLOT_CLOSEFH);
	}

	/*
	 * Pre-allocate on the first real write into the log file, if it
	 * was just created (i.e. not pre-allocated).
	 */
	if (log->alloc_lsn.l.offset == WT_LOG_FIRST_RECORD && created_log)
		WT_RET(__log_prealloc(session, log->log_fh));
	/*
	 * Initialize the slot for activation.
	 */
	__wt_log_slot_activate(session, slot);

	return (0);
}
",24
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"+	WT_ERR(__wt_log_slot_join(session, rdup_len, flags, &myslot));",+,"int
__wt_log_scan(WT_SESSION_IMPL *session, WT_LSN *lsnp, uint32_t flags,
    int (*func)(WT_SESSION_IMPL *session,
    WT_ITEM *record, WT_LSN *lsnp, WT_LSN *next_lsnp,
    void *cookie, int firstrecord), void *cookie)
{
	WT_CONNECTION_IMPL *conn;
	WT_DECL_ITEM(buf);
	WT_DECL_ITEM(decryptitem);
	WT_DECL_ITEM(uncitem);
	WT_DECL_RET;
	WT_FH *log_fh;
	WT_ITEM *cbbuf;
	WT_LOG *log;
	WT_LOG_RECORD *logrec;
	WT_LSN end_lsn, next_lsn, rd_lsn, start_lsn;
	wt_off_t log_size;
	uint32_t allocsize, firstlog, lastlog, lognum, rdup_len, reclen;
	uint32_t checksum_calculate, checksum_tmp;
	u_int i, logcount;
	int firstrecord;
	bool eol, partial_record;
	char **logfiles;

	conn = S2C(session);
	log = conn->log;
	log_fh = NULL;
	logcount = 0;
	logfiles = NULL;
	eol = false;
	firstrecord = 1;

	/*
	 * If the caller did not give us a callback function there is nothing
	 * to do.
	 */
	if (func == NULL)
		return (0);

	if (LF_ISSET(WT_LOGSCAN_RECOVER))
		__wt_verbose(session, WT_VERB_LOG,
		    ""__wt_log_scan truncating to %"" PRIu32 ""/%"" PRIu32,
		    log->trunc_lsn.l.file, log->trunc_lsn.l.offset);

	if (log != NULL) {
		allocsize = log->allocsize;

		if (lsnp == NULL) {
			if (LF_ISSET(WT_LOGSCAN_FIRST))
				start_lsn = log->first_lsn;
			else if (LF_ISSET(WT_LOGSCAN_FROM_CKP))
				start_lsn = log->ckpt_lsn;
			else
				return (WT_ERROR);	/* Illegal usage */
		} else {
			if (LF_ISSET(WT_LOGSCAN_FIRST|WT_LOGSCAN_FROM_CKP))
				WT_RET_MSG(session, WT_ERROR,
			    ""choose either a start LSN or a start flag"");

			/* Offsets must be on allocation boundaries. */
			if (lsnp->l.offset % allocsize != 0 ||
			    lsnp->l.file > log->fileid)
				return (WT_NOTFOUND);

			/*
			 * Log cursors may not know the starting LSN.  If an
			 * LSN is passed in that it is equal to the smallest
			 * LSN, start from the beginning of the log.
			 */
			start_lsn = *lsnp;
			if (WT_IS_INIT_LSN(&start_lsn))
				start_lsn = log->first_lsn;
		}
		end_lsn = log->alloc_lsn;
	} else {
		/*
		 * If logging is not configured, we can still print out the log
		 * if log files exist.  We just need to set the LSNs from what
		 * is in the files versus what is in the live connection.
		 */
		/*
		 * Set allocsize to the minimum alignment it could be.  Larger
		 * records and larger allocation boundaries should always be
		 * a multiple of this.
		 */
		allocsize = WT_LOG_ALIGN;
		lastlog = 0;
		firstlog = UINT32_MAX;
		WT_RET(__log_get_files(session,
		    WT_LOG_FILENAME, &logfiles, &logcount));
		if (logcount == 0)
			WT_RET_MSG(session, ENOTSUP, ""no log files found"");
		for (i = 0; i < logcount; i++) {
			WT_ERR(__wt_log_extract_lognum(session, logfiles[i],
			    &lognum));
			lastlog = WT_MAX(lastlog, lognum);
			firstlog = WT_MIN(firstlog, lognum);
		}
		WT_SET_LSN(&start_lsn, firstlog, 0);
		WT_SET_LSN(&end_lsn, lastlog, 0);
		WT_ERR(
		    __wt_fs_directory_list_free(session, &logfiles, logcount));
	}
	WT_ERR(__log_openfile(session,
	    &log_fh, WT_LOG_FILENAME, start_lsn.l.file, WT_LOG_OPEN_VERIFY));
	WT_ERR(__wt_filesize(session, log_fh, &log_size));
	rd_lsn = start_lsn;
	if (LF_ISSET(WT_LOGSCAN_RECOVER))
		__wt_verbose(session, WT_VERB_RECOVERY_PROGRESS,
		    ""Recovering log %"" PRIu32 "" through %"" PRIu32,
		    rd_lsn.l.file, end_lsn.l.file);

	WT_ERR(__wt_scr_alloc(session, WT_LOG_ALIGN, &buf));
	WT_ERR(__wt_scr_alloc(session, 0, &decryptitem));
	WT_ERR(__wt_scr_alloc(session, 0, &uncitem));
	for (;;) {
		if (rd_lsn.l.offset + allocsize > log_size) {
advance:
			if (rd_lsn.l.offset == log_size)
				partial_record = false;
			else
				/*
				 * See if there is anything non-zero at the
				 * end of this log file.
				 */
				WT_ERR(__log_has_hole(
				    session, log_fh, log_size,
				    rd_lsn.l.offset, &partial_record));
			/*
			 * If we read the last record, go to the next file.
			 */
			WT_ERR(__wt_close(session, &log_fh));
			log_fh = NULL;
			eol = true;
			/*
			 * Truncate this log file before we move to the next.
			 */
			if (LF_ISSET(WT_LOGSCAN_RECOVER))
				WT_ERR(__log_truncate(session,
				    &rd_lsn, WT_LOG_FILENAME, 1));
			/*
			 * If we had a partial record, we'll want to break
			 * now after closing and truncating.  Although for now
			 * log_truncate does not modify the LSN passed in,
			 * this code does not assume it is unmodified after that
			 * call which is why it uses the boolean set earlier.
			 */
			if (partial_record)
				break;
			WT_SET_LSN(&rd_lsn, rd_lsn.l.file + 1, 0);
			/*
			 * Avoid an error message when we reach end of log
			 * by checking here.
			 */
			if (rd_lsn.l.file > end_lsn.l.file)
				break;
			WT_ERR(__log_openfile(session,
			    &log_fh, WT_LOG_FILENAME,
			    rd_lsn.l.file, WT_LOG_OPEN_VERIFY));
			if (LF_ISSET(WT_LOGSCAN_RECOVER))
				__wt_verbose(session, WT_VERB_RECOVERY_PROGRESS,
				    ""Recovering log %"" PRIu32
				    "" through %"" PRIu32,
				    rd_lsn.l.file, end_lsn.l.file);
			WT_ERR(__wt_filesize(session, log_fh, &log_size));
			eol = false;
			continue;
		}
		/*
		 * Read the minimum allocation size a record could be.
		 */
		WT_ASSERT(session, buf->memsize >= allocsize);
		WT_ERR(__wt_read(session,
		    log_fh, rd_lsn.l.offset, (size_t)allocsize, buf->mem));
		/*
		 * See if we need to read more than the allocation size. We
		 * expect that we rarely will have to read more. Most log
		 * records will be fairly small.
		 */
		reclen = ((WT_LOG_RECORD *)buf->mem)->len;
#ifdef WORDS_BIGENDIAN
		reclen = __wt_bswap32(reclen);
#endif
		/*
		 * Log files are pre-allocated.  We need to detect the
		 * difference between a hole in the file (where this location
		 * would be considered the end of log) and the last record
		 * in the log and we're at the zeroed part of the file.
		 * If we find a zeroed record, scan forward in the log looking
		 * for any data.  If we detect any we have a hole and stop.
		 * Otherwise if the rest is all zeroes advance to the next file.
		 * When recovery finds the end of the log, truncate the file
		 * and remove any later log files that may exist.
		 */
		if (reclen == 0) {
			WT_ERR(__log_has_hole(
			    session, log_fh, log_size, rd_lsn.l.offset, &eol));
			if (eol)
				/* Found a hole. This LSN is the end. */
				break;
			else
				/* Last record in log.  Look for more. */
				goto advance;
		}
		rdup_len = __wt_rduppo2(reclen, allocsize);
		if (reclen > allocsize) {
			/*
			 * The log file end could be the middle of this
			 * log record.  If we have a partially written record
			 * then this is considered the end of the log.
			 */
			if (rd_lsn.l.offset + rdup_len > log_size) {
				eol = true;
				break;
			}
			/*
			 * We need to round up and read in the full padded
			 * record, especially for direct I/O.
			 */
			WT_ERR(__wt_buf_grow(session, buf, rdup_len));
			WT_ERR(__wt_read(session, log_fh,
			    rd_lsn.l.offset, (size_t)rdup_len, buf->mem));
			WT_STAT_CONN_INCR(session, log_scan_rereads);
		}
		/*
		 * We read in the record, verify checksum.
		 *
		 * Handle little- and big-endian objects. Objects are written
		 * in little-endian format: save the header checksum, and
		 * calculate the checksum for the header in its little-endian
		 * form. Then, restore the header's checksum, and byte-swap
		 * the whole thing as necessary, leaving us with a calculated
		 * checksum that should match the checksum in the header.
		 */
		buf->size = reclen;
		logrec = (WT_LOG_RECORD *)buf->mem;
		checksum_tmp = logrec->checksum;
		logrec->checksum = 0;
		checksum_calculate = __wt_checksum(logrec, reclen);
		logrec->checksum = checksum_tmp;
		__wt_log_record_byteswap(logrec);
		if (logrec->checksum != checksum_calculate) {
			/*
			 * A checksum mismatch means we have reached the end of
			 * the useful part of the log.  This should be found on
			 * the first pass through recovery.  In the second pass
			 * where we truncate the log, this is where it should
			 * end.
			 */
			if (log != NULL)
				log->trunc_lsn = rd_lsn;
			/*
			 * If the user asked for a specific LSN and it is not
			 * a valid LSN, return WT_NOTFOUND.
			 */
			if (LF_ISSET(WT_LOGSCAN_ONE))
				ret = WT_NOTFOUND;
			break;
		}

		/*
		 * We have a valid log record.  If it is not the log file
		 * header, invoke the callback.
		 */
		WT_STAT_CONN_INCR(session, log_scan_records);
		next_lsn = rd_lsn;
		next_lsn.l.offset += rdup_len;
		if (rd_lsn.l.offset != 0) {
			/*
			 * We need to manage the different buffers here.
			 * Buf is the buffer this function uses to read from
			 * the disk.  The callback buffer may change based
			 * on whether encryption and compression are used.
			 *
			 * We want to free any buffers from compression and
			 * encryption but keep the one we use for reading.
			 */
			cbbuf = buf;
			if (F_ISSET(logrec, WT_LOG_RECORD_ENCRYPTED)) {
				WT_ERR(__log_decrypt(
				    session, cbbuf, decryptitem));
				cbbuf = decryptitem;
			}
			if (F_ISSET(logrec, WT_LOG_RECORD_COMPRESSED)) {
				WT_ERR(__log_decompress(
				    session, cbbuf, uncitem));
				cbbuf = uncitem;
			}
			WT_ERR((*func)(session,
			    cbbuf, &rd_lsn, &next_lsn, cookie, firstrecord));

			firstrecord = 0;

			if (LF_ISSET(WT_LOGSCAN_ONE))
				break;
		}
		rd_lsn = next_lsn;
	}

	/* Truncate if we're in recovery. */
	if (LF_ISSET(WT_LOGSCAN_RECOVER) &&
	    __wt_log_cmp(&rd_lsn, &log->trunc_lsn) < 0)
		WT_ERR(__log_truncate(session,
		    &rd_lsn, WT_LOG_FILENAME, 0));

err:	WT_STAT_CONN_INCR(session, log_scans);
	/*
	 * If the first attempt to read a log record results in
	 * an error recovery is likely going to fail.  Try to provide
	 * a helpful failure message.
	 */
	if (ret != 0 && firstrecord) {
		__wt_errx(session,
		    ""WiredTiger is unable to read the recovery log."");
		__wt_errx(session, ""This may be due to the log""
		    "" files being encrypted, being from an older""
		    "" version or due to corruption on disk"");
		__wt_errx(session, ""You should confirm that you have""
		    "" opened the database with the correct options including""
		    "" all encryption and compression options"");
	}

	WT_TRET(__wt_fs_directory_list_free(session, &logfiles, logcount));

	__wt_scr_free(session, &buf);
	__wt_scr_free(session, &decryptitem);
	__wt_scr_free(session, &uncitem);

	/*
	 * If the caller wants one record and it is at the end of log,
	 * return WT_NOTFOUND.
	 */
	if (LF_ISSET(WT_LOGSCAN_ONE) && eol && ret == 0)
		ret = WT_NOTFOUND;
	WT_TRET(__wt_close(session, &log_fh));
	return (ret);
}
","int
__wt_log_scan(WT_SESSION_IMPL *session, WT_LSN *lsnp, uint32_t flags,
","    WT_ITEM *record, WT_LSN *lsnp, WT_LSN *next_lsnp,
    void *cookie, int firstrecord), void *cookie)
{
	WT_CONNECTION_IMPL *conn;
	WT_DECL_ITEM(buf);
	WT_DECL_ITEM(decryptitem);
	WT_DECL_ITEM(uncitem);
	WT_DECL_RET;
	WT_FH *log_fh;
	WT_ITEM *cbbuf;
	WT_LOG *log;
	WT_LOG_RECORD *logrec;
	WT_LSN end_lsn, next_lsn, rd_lsn, start_lsn;
	wt_off_t log_size;
	uint32_t allocsize, firstlog, lastlog, lognum, rdup_len, reclen;
	uint32_t checksum_calculate, checksum_tmp;
	u_int i, logcount;
	int firstrecord;
	bool eol, partial_record;
	char **logfiles;

	conn = S2C(session);
	log = conn->log;
	log_fh = NULL;
	logcount = 0;
	logfiles = NULL;
	eol = false;
	firstrecord = 1;

	/*
	 * If the caller did not give us a callback function there is nothing
	 * to do.
	 */
	if (func == NULL)
		return (0);

	if (LF_ISSET(WT_LOGSCAN_RECOVER))
		__wt_verbose(session, WT_VERB_LOG,
		    ""__wt_log_scan truncating to %"" PRIu32 ""/%"" PRIu32,
		    log->trunc_lsn.l.file, log->trunc_lsn.l.offset);

	if (log != NULL) {
		allocsize = log->allocsize;

		if (lsnp == NULL) {
			if (LF_ISSET(WT_LOGSCAN_FIRST))
				start_lsn = log->first_lsn;
			else if (LF_ISSET(WT_LOGSCAN_FROM_CKP))
				start_lsn = log->ckpt_lsn;
			else
				return (WT_ERROR);	/* Illegal usage */
		} else {
			if (LF_ISSET(WT_LOGSCAN_FIRST|WT_LOGSCAN_FROM_CKP))
				WT_RET_MSG(session, WT_ERROR,
			    ""choose either a start LSN or a start flag"");

			/* Offsets must be on allocation boundaries. */
			if (lsnp->l.offset % allocsize != 0 ||
			    lsnp->l.file > log->fileid)
				return (WT_NOTFOUND);

			/*
			 * Log cursors may not know the starting LSN.  If an
			 * LSN is passed in that it is equal to the smallest
			 * LSN, start from the beginning of the log.
			 */
			start_lsn = *lsnp;
			if (WT_IS_INIT_LSN(&start_lsn))
				start_lsn = log->first_lsn;
		}
		end_lsn = log->alloc_lsn;
	} else {
		/*
		 * If logging is not configured, we can still print out the log
		 * if log files exist.  We just need to set the LSNs from what
		 * is in the files versus what is in the live connection.
		 */
		/*
		 * Set allocsize to the minimum alignment it could be.  Larger
		 * records and larger allocation boundaries should always be
		 * a multiple of this.
		 */
		allocsize = WT_LOG_ALIGN;
		lastlog = 0;
		firstlog = UINT32_MAX;
		WT_RET(__log_get_files(session,
		    WT_LOG_FILENAME, &logfiles, &logcount));
		if (logcount == 0)
			WT_RET_MSG(session, ENOTSUP, ""no log files found"");
		for (i = 0; i < logcount; i++) {
			WT_ERR(__wt_log_extract_lognum(session, logfiles[i],
			    &lognum));
			lastlog = WT_MAX(lastlog, lognum);
			firstlog = WT_MIN(firstlog, lognum);
		}
		WT_SET_LSN(&start_lsn, firstlog, 0);
		WT_SET_LSN(&end_lsn, lastlog, 0);
		WT_ERR(
		    __wt_fs_directory_list_free(session, &logfiles, logcount));
	}
	WT_ERR(__log_openfile(session,
	    &log_fh, WT_LOG_FILENAME, start_lsn.l.file, WT_LOG_OPEN_VERIFY));
	WT_ERR(__wt_filesize(session, log_fh, &log_size));
	rd_lsn = start_lsn;
	if (LF_ISSET(WT_LOGSCAN_RECOVER))
		__wt_verbose(session, WT_VERB_RECOVERY_PROGRESS,
		    ""Recovering log %"" PRIu32 "" through %"" PRIu32,
		    rd_lsn.l.file, end_lsn.l.file);

	WT_ERR(__wt_scr_alloc(session, WT_LOG_ALIGN, &buf));
	WT_ERR(__wt_scr_alloc(session, 0, &decryptitem));
	WT_ERR(__wt_scr_alloc(session, 0, &uncitem));
	for (;;) {
		if (rd_lsn.l.offset + allocsize > log_size) {
advance:
			if (rd_lsn.l.offset == log_size)
				partial_record = false;
			else
				/*
				 * See if there is anything non-zero at the
				 * end of this log file.
				 */
				WT_ERR(__log_has_hole(
				    session, log_fh, log_size,
				    rd_lsn.l.offset, &partial_record));
			/*
			 * If we read the last record, go to the next file.
			 */
			WT_ERR(__wt_close(session, &log_fh));
			log_fh = NULL;
			eol = true;
			/*
			 * Truncate this log file before we move to the next.
			 */
			if (LF_ISSET(WT_LOGSCAN_RECOVER))
				WT_ERR(__log_truncate(session,
				    &rd_lsn, WT_LOG_FILENAME, 1));
			/*
			 * If we had a partial record, we'll want to break
			 * now after closing and truncating.  Although for now
			 * log_truncate does not modify the LSN passed in,
			 * this code does not assume it is unmodified after that
			 * call which is why it uses the boolean set earlier.
			 */
			if (partial_record)
				break;
			WT_SET_LSN(&rd_lsn, rd_lsn.l.file + 1, 0);
			/*
			 * Avoid an error message when we reach end of log
			 * by checking here.
			 */
			if (rd_lsn.l.file > end_lsn.l.file)
				break;
			WT_ERR(__log_openfile(session,
			    &log_fh, WT_LOG_FILENAME,
			    rd_lsn.l.file, WT_LOG_OPEN_VERIFY));
			if (LF_ISSET(WT_LOGSCAN_RECOVER))
				__wt_verbose(session, WT_VERB_RECOVERY_PROGRESS,
				    ""Recovering log %"" PRIu32
				    "" through %"" PRIu32,
				    rd_lsn.l.file, end_lsn.l.file);
			WT_ERR(__wt_filesize(session, log_fh, &log_size));
			eol = false;
			continue;
		}
		/*
		 * Read the minimum allocation size a record could be.
		 */
		WT_ASSERT(session, buf->memsize >= allocsize);
		WT_ERR(__wt_read(session,
		    log_fh, rd_lsn.l.offset, (size_t)allocsize, buf->mem));
		/*
		 * See if we need to read more than the allocation size. We
		 * expect that we rarely will have to read more. Most log
		 * records will be fairly small.
		 */
		reclen = ((WT_LOG_RECORD *)buf->mem)->len;
#ifdef WORDS_BIGENDIAN
		reclen = __wt_bswap32(reclen);
#endif
		/*
		 * Log files are pre-allocated.  We need to detect the
		 * difference between a hole in the file (where this location
		 * would be considered the end of log) and the last record
		 * in the log and we're at the zeroed part of the file.
		 * If we find a zeroed record, scan forward in the log looking
		 * for any data.  If we detect any we have a hole and stop.
		 * Otherwise if the rest is all zeroes advance to the next file.
		 * When recovery finds the end of the log, truncate the file
		 * and remove any later log files that may exist.
		 */
		if (reclen == 0) {
			WT_ERR(__log_has_hole(
			    session, log_fh, log_size, rd_lsn.l.offset, &eol));
			if (eol)
				/* Found a hole. This LSN is the end. */
				break;
			else
				/* Last record in log.  Look for more. */
				goto advance;
		}
		rdup_len = __wt_rduppo2(reclen, allocsize);
		if (reclen > allocsize) {
			/*
			 * The log file end could be the middle of this
			 * log record.  If we have a partially written record
			 * then this is considered the end of the log.
			 */
			if (rd_lsn.l.offset + rdup_len > log_size) {
				eol = true;
				break;
			}
			/*
			 * We need to round up and read in the full padded
			 * record, especially for direct I/O.
			 */
			WT_ERR(__wt_buf_grow(session, buf, rdup_len));
			WT_ERR(__wt_read(session, log_fh,
			    rd_lsn.l.offset, (size_t)rdup_len, buf->mem));
			WT_STAT_CONN_INCR(session, log_scan_rereads);
		}
		/*
		 * We read in the record, verify checksum.
		 *
		 * Handle little- and big-endian objects. Objects are written
		 * in little-endian format: save the header checksum, and
		 * calculate the checksum for the header in its little-endian
		 * form. Then, restore the header's checksum, and byte-swap
		 * the whole thing as necessary, leaving us with a calculated
		 * checksum that should match the checksum in the header.
		 */
		buf->size = reclen;
		logrec = (WT_LOG_RECORD *)buf->mem;
		checksum_tmp = logrec->checksum;
		logrec->checksum = 0;
		checksum_calculate = __wt_checksum(logrec, reclen);
		logrec->checksum = checksum_tmp;
		__wt_log_record_byteswap(logrec);
		if (logrec->checksum != checksum_calculate) {
			/*
			 * A checksum mismatch means we have reached the end of
			 * the useful part of the log.  This should be found on
			 * the first pass through recovery.  In the second pass
			 * where we truncate the log, this is where it should
			 * end.
			 */
			if (log != NULL)
				log->trunc_lsn = rd_lsn;
			/*
			 * If the user asked for a specific LSN and it is not
			 * a valid LSN, return WT_NOTFOUND.
			 */
			if (LF_ISSET(WT_LOGSCAN_ONE))
				ret = WT_NOTFOUND;
			break;
		}

		/*
		 * We have a valid log record.  If it is not the log file
		 * header, invoke the callback.
		 */
		WT_STAT_CONN_INCR(session, log_scan_records);
		next_lsn = rd_lsn;
		next_lsn.l.offset += rdup_len;
		if (rd_lsn.l.offset != 0) {
			/*
			 * We need to manage the different buffers here.
			 * Buf is the buffer this function uses to read from
			 * the disk.  The callback buffer may change based
			 * on whether encryption and compression are used.
			 *
			 * We want to free any buffers from compression and
			 * encryption but keep the one we use for reading.
			 */
			cbbuf = buf;
			if (F_ISSET(logrec, WT_LOG_RECORD_ENCRYPTED)) {
				WT_ERR(__log_decrypt(
				    session, cbbuf, decryptitem));
				cbbuf = decryptitem;
			}
			if (F_ISSET(logrec, WT_LOG_RECORD_COMPRESSED)) {
				WT_ERR(__log_decompress(
				    session, cbbuf, uncitem));
				cbbuf = uncitem;
			}
			WT_ERR((*func)(session,
			    cbbuf, &rd_lsn, &next_lsn, cookie, firstrecord));

			firstrecord = 0;

			if (LF_ISSET(WT_LOGSCAN_ONE))
				break;
		}
		rd_lsn = next_lsn;
	}

	/* Truncate if we're in recovery. */
	if (LF_ISSET(WT_LOGSCAN_RECOVER) &&
	    __wt_log_cmp(&rd_lsn, &log->trunc_lsn) < 0)
		WT_ERR(__log_truncate(session,
		    &rd_lsn, WT_LOG_FILENAME, 0));

err:	WT_STAT_CONN_INCR(session, log_scans);
	/*
	 * If the first attempt to read a log record results in
	 * an error recovery is likely going to fail.  Try to provide
	 * a helpful failure message.
	 */
	if (ret != 0 && firstrecord) {
		__wt_errx(session,
		    ""WiredTiger is unable to read the recovery log."");
		__wt_errx(session, ""This may be due to the log""
		    "" files being encrypted, being from an older""
		    "" version or due to corruption on disk"");
		__wt_errx(session, ""You should confirm that you have""
		    "" opened the database with the correct options including""
		    "" all encryption and compression options"");
	}

	WT_TRET(__wt_fs_directory_list_free(session, &logfiles, logcount));

	__wt_scr_free(session, &buf);
	__wt_scr_free(session, &decryptitem);
	__wt_scr_free(session, &uncitem);

	/*
	 * If the caller wants one record and it is at the end of log,
	 * return WT_NOTFOUND.
	 */
	if (LF_ISSET(WT_LOGSCAN_ONE) && eol && ret == 0)
		ret = WT_NOTFOUND;
	WT_TRET(__wt_close(session, &log_fh));
	return (ret);
}
",3
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"-	WT_ASSERT(session, !LF_ISSET(WT_LOG_FLUSH) ||",-,"int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
","int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
","	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
",19
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"+	WT_ASSERT(session, ret != 0 || !LF_ISSET(WT_LOG_FLUSH) ||",+,"int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
","int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
","	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
",20
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"-	WT_ASSERT(session,",-,"int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
","int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
","	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
",22
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"-	    !LF_ISSET(WT_LOG_FSYNC) || __wt_log_cmp(&log->sync_lsn, &lsn) >= 0);",-,"int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
","int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
","	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
",23
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"+	WT_ASSERT(session, ret != 0 || !LF_ISSET(WT_LOG_FSYNC) ||",+,"int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
","int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
","		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
",24
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log.c,"+	    __wt_log_cmp(&log->sync_lsn, &lsn) >= 0);",+,"int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
		last_lsn = log->log_close_lsn;

	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
","int
__wt_log_flush(WT_SESSION_IMPL *session, uint32_t flags)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LSN last_lsn, lsn;

	conn = S2C(session);
	WT_ASSERT(session, FLD_ISSET(conn->log_flags, WT_CONN_LOG_ENABLED));
	log = conn->log;
	/*
	 * We need to flush out the current slot first to get the real
	 * end of log LSN in log->alloc_lsn.
	 */
	WT_RET(__wt_log_flush_lsn(session, &lsn, false));
	last_lsn = log->alloc_lsn;

	/*
	 * If the last write caused a switch to a new log file, we should only
	 * wait for the last write to be flushed.  Otherwise, if the workload
	 * is single-threaded we could wait here forever because the write LSN
	 * doesn't switch into the new file until it contains a record.
	 */
	if (last_lsn.l.offset == WT_LOG_FIRST_RECORD)
","
	/*
	 * Wait until all current outstanding writes have been written
	 * to the file system.
	 */
	while (__wt_log_cmp(&last_lsn, &lsn) > 0)
		WT_RET(__wt_log_flush_lsn(session, &lsn, false));

	__wt_verbose(session, WT_VERB_LOG,
	    ""log_flush: flags %#"" PRIx32 "" LSN %"" PRIu32 ""/%"" PRIu32,
	    flags, lsn.l.file, lsn.l.offset);
	/*
	 * If the user wants write-no-sync, there is nothing more to do.
	 * If the user wants background sync, set the LSN and we're done.
	 * If the user wants sync, force it now.
	 */
	if (LF_ISSET(WT_LOG_BACKGROUND))
		__wt_log_background(session, &lsn);
	else if (LF_ISSET(WT_LOG_FSYNC))
		WT_RET(__wt_log_force_sync(session, &lsn));
	return (0);
}
",25
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+__log_slot_dump(WT_SESSION_IMPL *session),+,"static void
__log_slot_dump(WT_SESSION_IMPL *session)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int earliest, i;

	conn = S2C(session);
	log = conn->log;
	earliest = 0;
	for (i = 0; i < WT_SLOT_POOL; i++) {
		slot = &log->slot_pool[i];
		if (__wt_log_cmp(&slot->slot_release_lsn,
		    &log->slot_pool[earliest].slot_release_lsn) < 0)
			earliest = i;
		__wt_errx(session, ""Slot %d:"", i);
		__wt_errx(session, ""    State: %"" PRIx64 "" Flags: %"" PRIx32,
		    slot->slot_state, slot->flags);
		__wt_errx(session, ""    Start LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_start_lsn.l.file, slot->slot_start_lsn.l.offset);
		__wt_errx(session, ""    End  LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_end_lsn.l.file, slot->slot_end_lsn.l.offset);
		__wt_errx(session, ""    Release LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_release_lsn.l.file,
		    slot->slot_release_lsn.l.offset);
		__wt_errx(session, ""    Offset: start: %"" PRIuMAX
		    "" last:%"" PRIuMAX, (uintmax_t)slot->slot_start_offset,
		    (uintmax_t)slot->slot_last_offset);
		__wt_errx(session, ""    Unbuffered: %"" PRId64
		    "" error: %"" PRId32, slot->slot_unbuffered,
		    slot->slot_error);
	}
	__wt_errx(session, ""Earliest slot: %d"", earliest);

}
","static void
","{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int earliest, i;

	conn = S2C(session);
	log = conn->log;
	earliest = 0;
	for (i = 0; i < WT_SLOT_POOL; i++) {
		slot = &log->slot_pool[i];
		if (__wt_log_cmp(&slot->slot_release_lsn,
		    &log->slot_pool[earliest].slot_release_lsn) < 0)
			earliest = i;
		__wt_errx(session, ""Slot %d:"", i);
		__wt_errx(session, ""    State: %"" PRIx64 "" Flags: %"" PRIx32,
		    slot->slot_state, slot->flags);
		__wt_errx(session, ""    Start LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_start_lsn.l.file, slot->slot_start_lsn.l.offset);
		__wt_errx(session, ""    End  LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_end_lsn.l.file, slot->slot_end_lsn.l.offset);
		__wt_errx(session, ""    Release LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_release_lsn.l.file,
		    slot->slot_release_lsn.l.offset);
		__wt_errx(session, ""    Offset: start: %"" PRIuMAX
		    "" last:%"" PRIuMAX, (uintmax_t)slot->slot_start_offset,
		    (uintmax_t)slot->slot_last_offset);
		__wt_errx(session, ""    Unbuffered: %"" PRId64
		    "" error: %"" PRId32, slot->slot_unbuffered,
		    slot->slot_error);
	}
	__wt_errx(session, ""Earliest slot: %d"", earliest);

}
",2
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,"+		if (__wt_log_cmp(&slot->slot_release_lsn,",+,"static void
__log_slot_dump(WT_SESSION_IMPL *session)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int earliest, i;

	conn = S2C(session);
	log = conn->log;
	earliest = 0;
	for (i = 0; i < WT_SLOT_POOL; i++) {
		slot = &log->slot_pool[i];
		if (__wt_log_cmp(&slot->slot_release_lsn,
		    &log->slot_pool[earliest].slot_release_lsn) < 0)
			earliest = i;
		__wt_errx(session, ""Slot %d:"", i);
		__wt_errx(session, ""    State: %"" PRIx64 "" Flags: %"" PRIx32,
		    slot->slot_state, slot->flags);
		__wt_errx(session, ""    Start LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_start_lsn.l.file, slot->slot_start_lsn.l.offset);
		__wt_errx(session, ""    End  LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_end_lsn.l.file, slot->slot_end_lsn.l.offset);
		__wt_errx(session, ""    Release LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_release_lsn.l.file,
		    slot->slot_release_lsn.l.offset);
		__wt_errx(session, ""    Offset: start: %"" PRIuMAX
		    "" last:%"" PRIuMAX, (uintmax_t)slot->slot_start_offset,
		    (uintmax_t)slot->slot_last_offset);
		__wt_errx(session, ""    Unbuffered: %"" PRId64
		    "" error: %"" PRId32, slot->slot_unbuffered,
		    slot->slot_error);
	}
	__wt_errx(session, ""Earliest slot: %d"", earliest);

}
","static void
__log_slot_dump(WT_SESSION_IMPL *session)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int earliest, i;

	conn = S2C(session);
	log = conn->log;
	earliest = 0;
	for (i = 0; i < WT_SLOT_POOL; i++) {
		slot = &log->slot_pool[i];
","		    &log->slot_pool[earliest].slot_release_lsn) < 0)
			earliest = i;
		__wt_errx(session, ""Slot %d:"", i);
		__wt_errx(session, ""    State: %"" PRIx64 "" Flags: %"" PRIx32,
		    slot->slot_state, slot->flags);
		__wt_errx(session, ""    Start LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_start_lsn.l.file, slot->slot_start_lsn.l.offset);
		__wt_errx(session, ""    End  LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_end_lsn.l.file, slot->slot_end_lsn.l.offset);
		__wt_errx(session, ""    Release LSN: %"" PRIu32 ""/%"" PRIu32,
		    slot->slot_release_lsn.l.file,
		    slot->slot_release_lsn.l.offset);
		__wt_errx(session, ""    Offset: start: %"" PRIuMAX
		    "" last:%"" PRIuMAX, (uintmax_t)slot->slot_start_offset,
		    (uintmax_t)slot->slot_last_offset);
		__wt_errx(session, ""    Unbuffered: %"" PRId64
		    "" error: %"" PRId32, slot->slot_unbuffered,
		    slot->slot_error);
	}
	__wt_errx(session, ""Earliest slot: %d"", earliest);

}
",14
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,-	while (WT_LOG_SLOT_UNBUFFERED_ISSET(old_state) &&,-,"static int
__log_slot_switch_internal(
    WT_SESSION_IMPL *session, WT_MYSLOT *myslot, bool forced)
{
	WT_DECL_RET;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	bool free_slot, release;

	log = S2C(session)->log;
	release = false;
	slot = myslot->slot;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_SLOT));

	/*
	 * If someone else raced us to closing this specific slot, we're
	 * done here.
	 */
	if (slot != log->active_slot)
		return (0);

	/*
	 * We may come through here multiple times if we were able to close
	 * a slot but could not set up a new one.  If we closed it already,
	 * don't try to do it again but still set up the new slot.
	 */
	if (!F_ISSET(myslot, WT_MYSLOT_CLOSE)) {
		ret = __log_slot_close(session, slot, &release, forced);
		/*
		 * If close returns WT_NOTFOUND it means that someone else
		 * is processing the slot change.
		 */
		if (ret == WT_NOTFOUND)
			return (0);
		WT_RET(ret);
		if (release) {
			WT_RET(__wt_log_release(session, slot, &free_slot));
			if (free_slot)
				__wt_log_slot_free(session, slot);
		}
	}
	/*
	 * Set that we have closed this slot because we may call in here
	 * multiple times if we retry creating a new slot.
	 */
	F_SET(myslot, WT_MYSLOT_CLOSE);
	WT_RET(__wt_log_slot_new(session));
	F_CLR(myslot, WT_MYSLOT_CLOSE);
	return (0);
}
","static int
__log_slot_switch_internal(
    WT_SESSION_IMPL *session, WT_MYSLOT *myslot, bool forced)
{
	WT_DECL_RET;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	bool free_slot, release;

	log = S2C(session)->log;
	release = false;
	slot = myslot->slot;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_SLOT));

	/*
	 * If someone else raced us to closing this specific slot, we're
	 * done here.
	 */
	if (slot != log->active_slot)
		return (0);

	/*
	 * We may come through here multiple times if we were able to close
	 * a slot but could not set up a new one.  If we closed it already,
	 * don't try to do it again but still set up the new slot.
	 */
	if (!F_ISSET(myslot, WT_MYSLOT_CLOSE)) {
		ret = __log_slot_close(session, slot, &release, forced);
		/*
		 * If close returns WT_NOTFOUND it means that someone else
		 * is processing the slot change.
		 */
		if (ret == WT_NOTFOUND)
			return (0);
		WT_RET(ret);
		if (release) {
			WT_RET(__wt_log_release(session, slot, &free_slot));
			if (free_slot)
				__wt_log_slot_free(session, slot);
		}
	}
	/*
	 * Set that we have closed this slot because we may call in here
	 * multiple times if we retry creating a new slot.
	 */
","	WT_RET(__wt_log_slot_new(session));
	F_CLR(myslot, WT_MYSLOT_CLOSE);
	return (0);
}
",47
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+	if (WT_LOG_SLOT_UNBUFFERED_ISSET(old_state)) {,+,"static int
__log_slot_close(
    WT_SESSION_IMPL *session, WT_LOGSLOT *slot, bool *releasep, bool forced)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	int64_t end_offset, new_state, old_state;
#ifdef	HAVE_DIAGNOSTIC
	struct timespec begin, now;
	int count;
#endif

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, releasep != NULL);
	conn = S2C(session);
	log = conn->log;
	*releasep = 0;
	if (slot == NULL)
		return (WT_NOTFOUND);
retry:
	old_state = slot->slot_state;
	/*
	 * If this close is coming from a forced close and a thread is in
	 * the middle of using the slot, return EBUSY.  The caller can
	 * decide if retrying is necessary or not.
	 */
	if (forced && WT_LOG_SLOT_INPROGRESS(old_state))
		return (EBUSY);
	/*
	 * If someone else is switching out this slot we lost.  Nothing to
	 * do but return.  Return WT_NOTFOUND anytime the given slot was
	 * processed by another closing thread.  Only return 0 when we
	 * actually closed the slot.
	 */
	if (WT_LOG_SLOT_CLOSED(old_state))
		return (WT_NOTFOUND);
	/*
	 * If someone completely processed this slot, we're done.
	 */
	if (FLD64_ISSET((uint64_t)slot->slot_state, WT_LOG_SLOT_RESERVED))
		return (WT_NOTFOUND);
	new_state = (old_state | WT_LOG_SLOT_CLOSE);
	/*
	 * Close this slot.  If we lose the race retry.
	 */
	if (!__wt_atomic_casiv64(&slot->slot_state, old_state, new_state))
		goto retry;
	/*
	 * We own the slot now.  No one else can join.
	 * Set the end LSN.
	 */
	WT_STAT_CONN_INCR(session, log_slot_closes);
	if (WT_LOG_SLOT_DONE(new_state))
		*releasep = 1;
	slot->slot_end_lsn = slot->slot_start_lsn;
	/*
	 * A thread setting the unbuffered flag sets the unbuffered size after
	 * setting the flag.  There could be a delay between a thread setting
	 * the flag, a thread closing the slot, and the original thread setting
	 * that value.  If the state is unbuffered, wait for the unbuffered
	 * size to be set.
	 */
#ifdef	HAVE_DIAGNOSTIC
	count = 0;
	__wt_epoch(session, &begin);
#endif
	if (WT_LOG_SLOT_UNBUFFERED_ISSET(old_state)) {
		while (slot->slot_unbuffered == 0) {
			WT_RET(WT_SESSION_CHECK_PANIC(session));
			__wt_yield();
#ifdef	HAVE_DIAGNOSTIC
			++count;
			if (count > WT_MILLION) {
				__wt_epoch(session, &now);
				if (WT_TIMEDIFF_SEC(now, begin) > 10) {
					__wt_errx(session, ""SLOT_CLOSE: Slot %""
					PRIu32 "" Timeout unbuffered, state 0x%""
					PRIx64 "" unbuffered %"" PRIu64,
					(uint32_t)(slot - &log->slot_pool[0]),
					slot->slot_state,
					slot->slot_unbuffered);
					__log_slot_dump(session);
					__wt_abort(session);
				}
				count = 0;
			}
#endif
		}
	}

	end_offset =
	    WT_LOG_SLOT_JOINED_BUFFERED(old_state) + slot->slot_unbuffered;
	slot->slot_end_lsn.l.offset += (uint32_t)end_offset;
	WT_STAT_CONN_INCRV(session, log_slot_consolidated, end_offset);
	/*
	 * XXX Would like to change so one piece of code advances the LSN.
	 */
	log->alloc_lsn = slot->slot_end_lsn;
	WT_ASSERT(session, log->alloc_lsn.l.file >= log->write_lsn.l.file);
	return (0);
}
","static int
__log_slot_close(
    WT_SESSION_IMPL *session, WT_LOGSLOT *slot, bool *releasep, bool forced)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	int64_t end_offset, new_state, old_state;
#ifdef	HAVE_DIAGNOSTIC
	struct timespec begin, now;
	int count;
#endif

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, releasep != NULL);
	conn = S2C(session);
	log = conn->log;
	*releasep = 0;
	if (slot == NULL)
		return (WT_NOTFOUND);
retry:
	old_state = slot->slot_state;
	/*
	 * If this close is coming from a forced close and a thread is in
	 * the middle of using the slot, return EBUSY.  The caller can
	 * decide if retrying is necessary or not.
	 */
	if (forced && WT_LOG_SLOT_INPROGRESS(old_state))
		return (EBUSY);
	/*
	 * If someone else is switching out this slot we lost.  Nothing to
	 * do but return.  Return WT_NOTFOUND anytime the given slot was
	 * processed by another closing thread.  Only return 0 when we
	 * actually closed the slot.
	 */
	if (WT_LOG_SLOT_CLOSED(old_state))
		return (WT_NOTFOUND);
	/*
	 * If someone completely processed this slot, we're done.
	 */
	if (FLD64_ISSET((uint64_t)slot->slot_state, WT_LOG_SLOT_RESERVED))
		return (WT_NOTFOUND);
	new_state = (old_state | WT_LOG_SLOT_CLOSE);
	/*
	 * Close this slot.  If we lose the race retry.
	 */
	if (!__wt_atomic_casiv64(&slot->slot_state, old_state, new_state))
		goto retry;
	/*
	 * We own the slot now.  No one else can join.
	 * Set the end LSN.
	 */
	WT_STAT_CONN_INCR(session, log_slot_closes);
	if (WT_LOG_SLOT_DONE(new_state))
		*releasep = 1;
	slot->slot_end_lsn = slot->slot_start_lsn;
	/*
	 * A thread setting the unbuffered flag sets the unbuffered size after
	 * setting the flag.  There could be a delay between a thread setting
	 * the flag, a thread closing the slot, and the original thread setting
	 * that value.  If the state is unbuffered, wait for the unbuffered
	 * size to be set.
	 */
#ifdef	HAVE_DIAGNOSTIC
	count = 0;
	__wt_epoch(session, &begin);
#endif
	if (WT_LOG_SLOT_UNBUFFERED_ISSET(old_state)) {
		while (slot->slot_unbuffered == 0) {
			WT_RET(WT_SESSION_CHECK_PANIC(session));
			__wt_yield();
#ifdef	HAVE_DIAGNOSTIC
			++count;
			if (count > WT_MILLION) {
				__wt_epoch(session, &now);
				if (WT_TIMEDIFF_SEC(now, begin) > 10) {
					__wt_errx(session, ""SLOT_CLOSE: Slot %""
					PRIu32 "" Timeout unbuffered, state 0x%""
","					(uint32_t)(slot - &log->slot_pool[0]),
					slot->slot_state,
					slot->slot_unbuffered);
					__log_slot_dump(session);
					__wt_abort(session);
				}
				count = 0;
			}
#endif
		}
	}

	end_offset =
	    WT_LOG_SLOT_JOINED_BUFFERED(old_state) + slot->slot_unbuffered;
	slot->slot_end_lsn.l.offset += (uint32_t)end_offset;
	WT_STAT_CONN_INCRV(session, log_slot_consolidated, end_offset);
	/*
	 * XXX Would like to change so one piece of code advances the LSN.
	 */
	log->alloc_lsn = slot->slot_end_lsn;
	WT_ASSERT(session, log->alloc_lsn.l.file >= log->write_lsn.l.file);
	return (0);
}
",78
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+					__log_slot_dump(session);,+,"int
__wt_log_slot_switch(
    WT_SESSION_IMPL *session, WT_MYSLOT *myslot, bool retry, bool forced)
{
	WT_DECL_RET;
	WT_LOG *log;

	log = S2C(session)->log;
	/*
	 * !!! Since the WT_WITH_SLOT_LOCK macro is a do-while loop, the
	 * compiler does not like it combined directly with the while loop
	 * here.
	 *
	 * The loop conditional is a bit complex.  We have to retry if we
	 * closed the slot but were unable to set up a new slot.  In that
	 * case the flag indicating we have closed the slot will still be set.
	 * We have to retry in that case regardless of the retry setting
	 * because we are responsible for setting up the new slot.
	 */
	do {
		WT_WITH_SLOT_LOCK(session, log,
		    ret = __log_slot_switch_internal(session, myslot, forced));
		if (ret == EBUSY) {
			WT_STAT_CONN_INCR(session, log_slot_switch_busy);
			__wt_yield();
		}
	} while (F_ISSET(myslot, WT_MYSLOT_CLOSE) || (retry && ret == EBUSY));
	return (ret);
}
","int
__wt_log_slot_switch(
    WT_SESSION_IMPL *session, WT_MYSLOT *myslot, bool retry, bool forced)
{
	WT_DECL_RET;
	WT_LOG *log;

	log = S2C(session)->log;
	/*
	 * !!! Since the WT_WITH_SLOT_LOCK macro is a do-while loop, the
	 * compiler does not like it combined directly with the while loop
	 * here.
","	 * The loop conditional is a bit complex.  We have to retry if we
	 * closed the slot but were unable to set up a new slot.  In that
	 * case the flag indicating we have closed the slot will still be set.
	 * We have to retry in that case regardless of the retry setting
	 * because we are responsible for setting up the new slot.
	 */
	do {
		WT_WITH_SLOT_LOCK(session, log,
		    ret = __log_slot_switch_internal(session, myslot, forced));
		if (ret == EBUSY) {
			WT_STAT_CONN_INCR(session, log_slot_switch_busy);
			__wt_yield();
		}
	} while (F_ISSET(myslot, WT_MYSLOT_CLOSE) || (retry && ret == EBUSY));
	return (ret);
}
",13
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+				__log_slot_dump(session);,+,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
","			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",63
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,"+	WT_ASSERT(session, mysize != 0);",+,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;
","	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",108
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,-		flag_state = WT_LOG_SLOT_FLAGS(old_state);,-,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
","	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",135
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,-		released = WT_LOG_SLOT_RELEASED(old_state);,-,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
","}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",136
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,-		join_offset = WT_LOG_SLOT_JOINED(old_state);,-,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
","
/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",137
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,-		new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(,-,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
","	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",148
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,-		if (WT_LOG_SLOT_OPEN(old_state) &&,-,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
","}
",155
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+		if (WT_LOG_SLOT_OPEN(old_state)) {,+,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
","	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",129
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+			flag_state = WT_LOG_SLOT_FLAGS(old_state);,+,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
","	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",134
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+			released = WT_LOG_SLOT_RELEASED(old_state);,+,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
","	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",135
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+			join_offset = WT_LOG_SLOT_JOINED(old_state);,+,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
","}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",136
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/log/log_slot.c,+			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(,+,"int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
 *	Free a slot back into the pool.
 */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
","int
__wt_log_slot_join(WT_SESSION_IMPL *session, uint64_t mysize,
    uint32_t flags, WT_MYSLOT *myslot)
{
	WT_CONNECTION_IMPL *conn;
	WT_LOG *log;
	WT_LOGSLOT *slot;
	int64_t flag_state, new_state, old_state, released;
	int32_t join_offset, new_join;
	bool unbuffered, yld;

	conn = S2C(session);
	log = conn->log;

	WT_ASSERT(session, !F_ISSET(session, WT_SESSION_LOCKED_SLOT));
	WT_ASSERT(session, mysize != 0);

	/*
	 * There should almost always be a slot open.
	 */
	unbuffered = false;
#ifdef	HAVE_DIAGNOSTIC
	yld = (++log->write_calls % 7) == 0;
	if ((log->write_calls % WT_THOUSAND) == 0 ||
	    mysize > WT_LOG_SLOT_BUF_MAX) {
#else
	yld = false;
	if (mysize > WT_LOG_SLOT_BUF_MAX) {
#endif
		unbuffered = true;
		F_SET(myslot, WT_MYSLOT_UNBUFFERED);
	}
	for (;;) {
		WT_BARRIER();
		WT_RET(WT_SESSION_CHECK_PANIC(session));
		slot = log->active_slot;
		old_state = slot->slot_state;
		if (WT_LOG_SLOT_OPEN(old_state)) {
			/*
			 * Try to join our size into the existing size and
			 * atomically write it back into the state.
			 */
			flag_state = WT_LOG_SLOT_FLAGS(old_state);
			released = WT_LOG_SLOT_RELEASED(old_state);
			join_offset = WT_LOG_SLOT_JOINED(old_state);
			if (unbuffered)
				new_join = join_offset + WT_LOG_SLOT_UNBUFFERED;
			else
				new_join = join_offset + (int32_t)mysize;
			new_state = (int64_t)WT_LOG_SLOT_JOIN_REL(
			    (int64_t)new_join, (int64_t)released,
			    (int64_t)flag_state);

			/*
			 * Braces used due to potential empty body warning.
			 */
			if (yld) {
				WT_DIAGNOSTIC_YIELD;
			}
			/*
			 * Attempt to swap our size into the state.
			 */
			if (__wt_atomic_casiv64(
			    &slot->slot_state, old_state, new_state))
				break;
		}
		/*
		 * The slot is no longer open or we lost the race to
		 * update it.  Yield and try again.
		 */
		WT_STAT_CONN_INCR(session, log_slot_races);
		__wt_yield();
	}
	/*
	 * We joined this slot.  Fill in our information to return to
	 * the caller.
	 */
	WT_STAT_CONN_INCR(session, log_slot_joins);
	if (LF_ISSET(WT_LOG_DSYNC | WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC_DIR);
	if (LF_ISSET(WT_LOG_FLUSH))
		F_SET(slot, WT_SLOT_FLUSH);
	if (LF_ISSET(WT_LOG_FSYNC))
		F_SET(slot, WT_SLOT_SYNC);
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED)) {
		WT_ASSERT(session, slot->slot_unbuffered == 0);
		WT_STAT_CONN_INCR(session, log_slot_unbuffered);
		slot->slot_unbuffered = (int64_t)mysize;
	}
	myslot->slot = slot;
	myslot->offset = join_offset;
	myslot->end_offset = (wt_off_t)((uint64_t)join_offset + mysize);
	return (0);
}

/*
 * __wt_log_slot_release --
 *	Each thread in a consolidated group releases its portion to
 *	signal it has completed copying its piece of the log into
 *	the memory buffer.
 */
int64_t
__wt_log_slot_release(WT_SESSION_IMPL *session, WT_MYSLOT *myslot, int64_t size)
{
	WT_LOGSLOT *slot;
	wt_off_t cur_offset, my_start;
	int64_t my_size, rel_size;

	WT_UNUSED(session);
	slot = myslot->slot;
	my_start = slot->slot_start_offset + myslot->offset;
	/*
	 * We maintain the last starting offset within this slot.
	 * This is used to know the offset of the last record that
	 * was written rather than the beginning record of the slot.
	 */
	while ((cur_offset = slot->slot_last_offset) < my_start) {
		/*
		 * Set our offset if we are larger.
		 */
		if (__wt_atomic_casiv64(
		    &slot->slot_last_offset, cur_offset, my_start))
			break;
		/*
		 * If we raced another thread updating this, try again.
		 */
		WT_BARRIER();
	}
	/*
	 * Add my size into the state and return the new size.
	 */
	rel_size = size;
	if (F_ISSET(myslot, WT_MYSLOT_UNBUFFERED))
		rel_size = WT_LOG_SLOT_UNBUFFERED;
	my_size = (int64_t)WT_LOG_SLOT_JOIN_REL((int64_t)0, rel_size, 0);
	return (__wt_atomic_addiv64(&slot->slot_state, my_size));
}

/*
 * __wt_log_slot_free --
"," */
void
__wt_log_slot_free(WT_SESSION_IMPL *session, WT_LOGSLOT *slot)
{
	/*
	 * Make sure flags don't get retained between uses.
	 * We have to reset them here and not in log_slot_activate because
	 * some flags (such as closing the file handle) may be set before
	 * we initialize the rest of the slot.
	 */
	WT_UNUSED(session);
	slot->flags = WT_SLOT_INIT_FLAGS;
	slot->slot_error = 0;
	slot->slot_state = WT_LOG_SLOT_FREE;
}
",141
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"+	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
","static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;
","	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
",6
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"+			WT_ASSERT(session, lsm_tree->excl_session ==",+,"static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
","static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
","				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
",15
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"-	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));",-,"static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
","static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
","				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
",24
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"+	WT_ASSERT(session,",+,"static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
","static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
","				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
",25
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"-	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));",-,"static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
","static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
","
				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
",34
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"+		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
","static int
__lsm_tree_find(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_LSM_TREE *lsm_tree;

	WT_ASSERT(session, F_ISSET(session, WT_SESSION_LOCKED_HANDLE_LIST));

	/* See if the tree is already open. */
	TAILQ_FOREACH(lsm_tree, &S2C(session)->lsmqh, q)
		if (strcmp(uri, lsm_tree->name) == 0) {
			if (exclusive) {
				/*
				 * Make sure we win the race to switch on the
				 * exclusive flag.
				 */
				if (!__wt_atomic_cas_ptr(
				    &lsm_tree->excl_session, NULL, session))
					return (EBUSY);

				/*
				 * Drain the work queue before checking for
				 * open cursors - otherwise we can generate
				 * spurious busy returns.
				 */
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);
				__lsm_tree_close(session, lsm_tree, false);
				if (lsm_tree->refcnt != 1) {
					__wt_lsm_tree_release(
					    session, lsm_tree);
					return (EBUSY);
				}
			} else {
				(void)__wt_atomic_add32(&lsm_tree->refcnt, 1);

				/*
				 * We got a reference, check if an exclusive
				 * lock beat us to it.
				 */
				if (lsm_tree->excl_session != NULL) {
					WT_ASSERT(session,
					    lsm_tree->refcnt > 0);
","					    session, lsm_tree);
					return (EBUSY);
				}
			}

			*treep = lsm_tree;

			WT_ASSERT(session, lsm_tree->excl_session ==
			     (exclusive ? session : NULL));
			return (0);
		}

	return (WT_NOTFOUND);
}
",43
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"+		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"int
__wt_lsm_tree_get(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_DECL_RET;

	/*
	 * Dropping and re-acquiring the lock is safe here, since the tree open
	 * call checks to see if another thread beat it to opening the tree
	 * before proceeding.
	 */
	if (exclusive)
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_tree_find(session, uri, exclusive, treep));
	else
		WT_WITH_HANDLE_LIST_READ_LOCK(session,
		    ret = __lsm_tree_find(session, uri, exclusive, treep));
	if (ret == WT_NOTFOUND)
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_tree_open(session, uri, exclusive, treep));

	return (ret);
}
","int
__wt_lsm_tree_get(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_DECL_RET;

","	 * Dropping and re-acquiring the lock is safe here, since the tree open
	 * call checks to see if another thread beat it to opening the tree
	 * before proceeding.
	 */
	if (exclusive)
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_tree_find(session, uri, exclusive, treep));
	else
		WT_WITH_HANDLE_LIST_READ_LOCK(session,
		    ret = __lsm_tree_find(session, uri, exclusive, treep));
	if (ret == WT_NOTFOUND)
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_tree_open(session, uri, exclusive, treep));

	return (ret);
}
",7
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"-	WT_ASSERT(session, ret != 0 ||",-,"int
__wt_lsm_tree_get(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_DECL_RET;

	/*
	 * Dropping and re-acquiring the lock is safe here, since the tree open
	 * call checks to see if another thread beat it to opening the tree
	 * before proceeding.
	 */
	if (exclusive)
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_tree_find(session, uri, exclusive, treep));
	else
		WT_WITH_HANDLE_LIST_READ_LOCK(session,
		    ret = __lsm_tree_find(session, uri, exclusive, treep));
	if (ret == WT_NOTFOUND)
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_tree_open(session, uri, exclusive, treep));

	return (ret);
}
","int
__wt_lsm_tree_get(WT_SESSION_IMPL *session,
    const char *uri, bool exclusive, WT_LSM_TREE **treep)
{
	WT_DECL_RET;

	/*
	 * Dropping and re-acquiring the lock is safe here, since the tree open
	 * call checks to see if another thread beat it to opening the tree
","	 */
	if (exclusive)
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_tree_find(session, uri, exclusive, treep));
	else
		WT_WITH_HANDLE_LIST_READ_LOCK(session,
		    ret = __lsm_tree_find(session, uri, exclusive, treep));
	if (ret == WT_NOTFOUND)
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_tree_open(session, uri, exclusive, treep));

	return (ret);
}
",10
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"+	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"int
__wt_lsm_tree_truncate(
    WT_SESSION_IMPL *session, const char *name, const char *cfg[])
{
	WT_DECL_RET;
	WT_LSM_CHUNK *chunk;
	WT_LSM_TREE *lsm_tree;
	int tret;
	bool locked;

	WT_UNUSED(cfg);
	chunk = NULL;
	locked = false;

	/* Get the LSM tree. */
	WT_RET(__wt_lsm_tree_get(session, name, true, &lsm_tree));

	/* Prevent any new opens. */
	__wt_lsm_tree_writelock(session, lsm_tree);
	locked = true;

	/* Create the new chunk. */
	WT_ERR(__wt_calloc_one(session, &chunk));
	chunk->id = __wt_atomic_add32(&lsm_tree->last, 1);
	WT_ERR(__wt_lsm_tree_setup_chunk(session, lsm_tree, chunk));

	/* Mark all chunks old. */
	WT_ERR(__wt_lsm_merge_update_tree(
	    session, lsm_tree, 0, lsm_tree->nchunks, chunk));

	WT_ERR(__wt_lsm_meta_write(session, lsm_tree, NULL));

	locked = false;
	__wt_lsm_tree_writeunlock(session, lsm_tree);
	__wt_lsm_tree_release(session, lsm_tree);

err:	if (locked)
		__wt_lsm_tree_writeunlock(session, lsm_tree);
	if (ret != 0) {
		if (chunk != NULL) {
			WT_TRET(__wt_schema_drop(session, chunk->uri, NULL));
			__wt_free(session, chunk);
		}
		/*
		 * Discard the LSM tree structure on error. This will force the
		 * LSM tree to be re-opened the next time it is accessed and
		 * the last good version of the metadata will be used, resulting
		 * in a valid (not truncated) tree.
		 */
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    tret = __lsm_tree_discard(session, lsm_tree, false));
		WT_TRET(tret);
	}
	return (ret);
}
","int
__wt_lsm_tree_truncate(
    WT_SESSION_IMPL *session, const char *name, const char *cfg[])
{
	WT_DECL_RET;
	WT_LSM_CHUNK *chunk;
	WT_LSM_TREE *lsm_tree;
	int tret;
	bool locked;

	WT_UNUSED(cfg);
	chunk = NULL;
	locked = false;

	/* Get the LSM tree. */
	WT_RET(__wt_lsm_tree_get(session, name, true, &lsm_tree));

	/* Prevent any new opens. */
	__wt_lsm_tree_writelock(session, lsm_tree);
","
	/* Create the new chunk. */
	WT_ERR(__wt_calloc_one(session, &chunk));
	chunk->id = __wt_atomic_add32(&lsm_tree->last, 1);
	WT_ERR(__wt_lsm_tree_setup_chunk(session, lsm_tree, chunk));

	/* Mark all chunks old. */
	WT_ERR(__wt_lsm_merge_update_tree(
	    session, lsm_tree, 0, lsm_tree->nchunks, chunk));

	WT_ERR(__wt_lsm_meta_write(session, lsm_tree, NULL));

	locked = false;
	__wt_lsm_tree_writeunlock(session, lsm_tree);
	__wt_lsm_tree_release(session, lsm_tree);

err:	if (locked)
		__wt_lsm_tree_writeunlock(session, lsm_tree);
	if (ret != 0) {
		if (chunk != NULL) {
			WT_TRET(__wt_schema_drop(session, chunk->uri, NULL));
			__wt_free(session, chunk);
		}
		/*
		 * Discard the LSM tree structure on error. This will force the
		 * LSM tree to be re-opened the next time it is accessed and
		 * the last good version of the metadata will be used, resulting
		 * in a valid (not truncated) tree.
		 */
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    tret = __lsm_tree_discard(session, lsm_tree, false));
		WT_TRET(tret);
	}
	return (ret);
}
",20
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"+	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"void
__wt_lsm_tree_writeunlock(WT_SESSION_IMPL *session, WT_LSM_TREE *lsm_tree)
{
	F_CLR(session, WT_SESSION_NO_EVICTION | WT_SESSION_NO_SCHEMA_LOCK);

	__wt_writeunlock(session, &lsm_tree->rwlock);
}
","void
__wt_lsm_tree_writeunlock(WT_SESSION_IMPL *session, WT_LSM_TREE *lsm_tree)
{
	F_CLR(session, WT_SESSION_NO_EVICTION | WT_SESSION_NO_SCHEMA_LOCK);

	__wt_writeunlock(session, &lsm_tree->rwlock);
",,7
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_tree.c,"+		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"int
__wt_lsm_compact(WT_SESSION_IMPL *session, const char *name, bool *skipp)
{
	WT_DECL_RET;
	WT_LSM_CHUNK *chunk;
	WT_LSM_TREE *lsm_tree;
	uint64_t progress;
	uint32_t i;
	bool compacting, flushing, locked, ref;

	compacting = flushing = locked = ref = false;
	chunk = NULL;
	/*
	 * This function is applied to all matching sources: ignore anything
	 * that is not an LSM tree.
	 */
	if (!WT_PREFIX_MATCH(name, ""lsm:""))
		return (0);

	/* Tell __wt_schema_worker not to look inside the LSM tree. */
	*skipp = true;

	WT_RET(__wt_lsm_tree_get(session, name, false, &lsm_tree));

	if (!F_ISSET(S2C(session), WT_CONN_LSM_MERGE))
		WT_ERR_MSG(session, EINVAL,
		    ""LSM compaction requires active merge threads"");

	/*
	 * There is no work to do if there is only a single chunk in the tree
	 * and it has a bloom filter or is configured to never have a bloom
	 * filter.
	 */
	if (lsm_tree->nchunks == 1 &&
	    (!FLD_ISSET(lsm_tree->bloom, WT_LSM_BLOOM_OLDEST) ||
	    F_ISSET(lsm_tree->chunk[0], WT_LSM_CHUNK_BLOOM))) {
		__wt_lsm_tree_release(session, lsm_tree);
		return (0);
	}

	/*
	 * Compacting has two distinct phases.
	 * 1.  All in-memory chunks up to and including the current
	 * current chunk must be flushed.  Normally, the flush code
	 * does not flush the last, in-use chunk, so we set a force
	 * flag to include that last chunk.  We monitor the state of the
	 * last chunk and periodically push another forced flush work
	 * unit until it is complete.
	 * 2.  After all flushing is done, we move onto the merging
	 * phase for compaction.  Again, we monitor the state and
	 * continue to push merge work units until all merging is done.
	 */

	/* Lock the tree: single-thread compaction. */
	__wt_lsm_tree_writelock(session, lsm_tree);
	locked = true;

	/* Clear any merge throttle: compact throws out that calculation. */
	lsm_tree->merge_throttle = 0;
	lsm_tree->merge_aggressiveness = 0;
	progress = lsm_tree->merge_progressing;

	/* If another thread started a compact on this tree, we're done. */
	if (F_ISSET(lsm_tree, WT_LSM_TREE_COMPACTING))
		goto err;

	/*
	 * Set the switch transaction on the current chunk, if it
	 * hasn't been set before.  This prevents further writes, so it
	 * can be flushed by the checkpoint worker.
	 */
	if (lsm_tree->nchunks > 0 &&
	    (chunk = lsm_tree->chunk[lsm_tree->nchunks - 1]) != NULL) {
		if (chunk->switch_txn == WT_TXN_NONE) {
			/*
			 * Make sure any cursors open on the tree see the
			 * new switch generation before updating.
			 */
			++lsm_tree->dsk_gen;
			WT_FULL_BARRIER();
			chunk->switch_txn = __wt_txn_id_alloc(session, false);
		}
		/*
		 * If we have a chunk, we want to look for it to be on-disk.
		 * So we need to add a reference to keep it available.
		 */
		(void)__wt_atomic_add32(&chunk->refcnt, 1);
		ref = true;
	}

	locked = false;
	__wt_lsm_tree_writeunlock(session, lsm_tree);

	if (chunk != NULL) {
		__wt_verbose(session, WT_VERB_LSM,
		    ""Compact force flush %s flags 0x%"" PRIx32
		    "" chunk %"" PRIu32 "" flags 0x%"" PRIx32,
		    name, lsm_tree->flags, chunk->id, chunk->flags);
		flushing = true;
		/*
		 * Make sure the in-memory chunk gets flushed do not push a
		 * switch, because we don't want to create a new in-memory
		 * chunk if the tree is being used read-only now.
		 */
		WT_ERR(__wt_lsm_manager_push_entry(session,
		    WT_LSM_WORK_FLUSH, WT_LSM_WORK_FORCE, lsm_tree));
	} else {
		/*
		 * If there is no chunk to flush, go straight to the
		 * compacting state.
		 */
		compacting = true;
		progress = lsm_tree->merge_progressing;
		F_SET(lsm_tree, WT_LSM_TREE_COMPACTING);
		__wt_verbose(session, WT_VERB_LSM,
		    ""COMPACT: Start compacting %s"", lsm_tree->name);
	}

	/* Wait for the work unit queues to drain. */
	while (lsm_tree->active) {
		/*
		 * The flush flag is cleared when the chunk has been flushed.
		 * Continue to push forced flushes until the chunk is on disk.
		 * Once it is on disk move to the compacting phase.
		 */
		if (flushing) {
			WT_ASSERT(session, chunk != NULL);
			if (F_ISSET(chunk, WT_LSM_CHUNK_ONDISK)) {
				__wt_verbose(session,
				    WT_VERB_LSM,
				    ""Compact flush done %s chunk %"" PRIu32 "". ""
				    ""Start compacting progress %"" PRIu64,
				    name, chunk->id,
				    lsm_tree->merge_progressing);
				(void)__wt_atomic_sub32(&chunk->refcnt, 1);
				flushing = ref = false;
				compacting = true;
				F_SET(lsm_tree, WT_LSM_TREE_COMPACTING);
				progress = lsm_tree->merge_progressing;
			} else {
				__wt_verbose(session, WT_VERB_LSM,
				    ""Compact flush retry %s chunk %"" PRIu32,
				    name, chunk->id);
				WT_ERR(__wt_lsm_manager_push_entry(session,
				    WT_LSM_WORK_FLUSH, WT_LSM_WORK_FORCE,
				    lsm_tree));
			}
		}

		/*
		 * The compacting flag is cleared when no merges can be done.
		 * Ensure that we push through some aggressive merges before
		 * stopping otherwise we might not do merges that would
		 * span chunks with different generations.
		 */
		if (compacting && !F_ISSET(lsm_tree, WT_LSM_TREE_COMPACTING)) {
			if (lsm_tree->merge_aggressiveness < 10 ||
			    (progress < lsm_tree->merge_progressing) ||
			    lsm_tree->merge_syncing) {
				progress = lsm_tree->merge_progressing;
				F_SET(lsm_tree, WT_LSM_TREE_COMPACTING);
				lsm_tree->merge_aggressiveness = 10;
			} else
				break;
		}
		WT_ERR(__wt_session_compact_check_timeout(session));
		__wt_sleep(1, 0);

		/*
		 * Push merge operations while they are still getting work
		 * done. If we are pushing merges, make sure they are
		 * aggressive, to avoid duplicating effort.
		 */
		if (compacting)
#define	COMPACT_PARALLEL_MERGES	5
			for (i = lsm_tree->queue_ref;
			    i < COMPACT_PARALLEL_MERGES; i++) {
				lsm_tree->merge_aggressiveness = 10;
				WT_ERR(__wt_lsm_manager_push_entry(
				    session, WT_LSM_WORK_MERGE, 0, lsm_tree));
			}
	}
err:
	/* Ensure anything we set is cleared. */
	if (ref)
		(void)__wt_atomic_sub32(&chunk->refcnt, 1);
	if (compacting) {
		F_CLR(lsm_tree, WT_LSM_TREE_COMPACTING);
		lsm_tree->merge_aggressiveness = 0;
	}
	if (locked)
		__wt_lsm_tree_writeunlock(session, lsm_tree);

	__wt_verbose(session, WT_VERB_LSM,
	    ""Compact %s complete, return %d"", name, ret);

	__wt_lsm_tree_release(session, lsm_tree);
	return (ret);
}
","int
__wt_lsm_compact(WT_SESSION_IMPL *session, const char *name, bool *skipp)
{
	WT_DECL_RET;
	WT_LSM_CHUNK *chunk;
	WT_LSM_TREE *lsm_tree;
	uint64_t progress;
	uint32_t i;
	bool compacting, flushing, locked, ref;

	compacting = flushing = locked = ref = false;
	chunk = NULL;
	/*
	 * This function is applied to all matching sources: ignore anything
	 * that is not an LSM tree.
	 */
	if (!WT_PREFIX_MATCH(name, ""lsm:""))
		return (0);

	/* Tell __wt_schema_worker not to look inside the LSM tree. */
	*skipp = true;

	WT_RET(__wt_lsm_tree_get(session, name, false, &lsm_tree));

	if (!F_ISSET(S2C(session), WT_CONN_LSM_MERGE))
		WT_ERR_MSG(session, EINVAL,
		    ""LSM compaction requires active merge threads"");

	/*
	 * There is no work to do if there is only a single chunk in the tree
	 * and it has a bloom filter or is configured to never have a bloom
	 * filter.
	 */
	if (lsm_tree->nchunks == 1 &&
	    (!FLD_ISSET(lsm_tree->bloom, WT_LSM_BLOOM_OLDEST) ||
	    F_ISSET(lsm_tree->chunk[0], WT_LSM_CHUNK_BLOOM))) {
		__wt_lsm_tree_release(session, lsm_tree);
		return (0);
	}

	/*
	 * Compacting has two distinct phases.
	 * 1.  All in-memory chunks up to and including the current
	 * current chunk must be flushed.  Normally, the flush code
	 * does not flush the last, in-use chunk, so we set a force
	 * flag to include that last chunk.  We monitor the state of the
	 * last chunk and periodically push another forced flush work
	 * unit until it is complete.
	 * 2.  After all flushing is done, we move onto the merging
	 * phase for compaction.  Again, we monitor the state and
	 * continue to push merge work units until all merging is done.
	 */

	/* Lock the tree: single-thread compaction. */
	__wt_lsm_tree_writelock(session, lsm_tree);
	locked = true;

	/* Clear any merge throttle: compact throws out that calculation. */
	lsm_tree->merge_throttle = 0;
	lsm_tree->merge_aggressiveness = 0;
	progress = lsm_tree->merge_progressing;

	/* If another thread started a compact on this tree, we're done. */
	if (F_ISSET(lsm_tree, WT_LSM_TREE_COMPACTING))
		goto err;

	/*
	 * Set the switch transaction on the current chunk, if it
	 * hasn't been set before.  This prevents further writes, so it
	 * can be flushed by the checkpoint worker.
	 */
	if (lsm_tree->nchunks > 0 &&
	    (chunk = lsm_tree->chunk[lsm_tree->nchunks - 1]) != NULL) {
","			/*
			 * Make sure any cursors open on the tree see the
			 * new switch generation before updating.
			 */
			++lsm_tree->dsk_gen;
			WT_FULL_BARRIER();
			chunk->switch_txn = __wt_txn_id_alloc(session, false);
		}
		/*
		 * If we have a chunk, we want to look for it to be on-disk.
		 * So we need to add a reference to keep it available.
		 */
		(void)__wt_atomic_add32(&chunk->refcnt, 1);
		ref = true;
	}

	locked = false;
	__wt_lsm_tree_writeunlock(session, lsm_tree);

	if (chunk != NULL) {
		__wt_verbose(session, WT_VERB_LSM,
		    ""Compact force flush %s flags 0x%"" PRIx32
		    "" chunk %"" PRIu32 "" flags 0x%"" PRIx32,
		    name, lsm_tree->flags, chunk->id, chunk->flags);
		flushing = true;
		/*
		 * Make sure the in-memory chunk gets flushed do not push a
		 * switch, because we don't want to create a new in-memory
		 * chunk if the tree is being used read-only now.
		 */
		WT_ERR(__wt_lsm_manager_push_entry(session,
		    WT_LSM_WORK_FLUSH, WT_LSM_WORK_FORCE, lsm_tree));
	} else {
		/*
		 * If there is no chunk to flush, go straight to the
		 * compacting state.
		 */
		compacting = true;
		progress = lsm_tree->merge_progressing;
		F_SET(lsm_tree, WT_LSM_TREE_COMPACTING);
		__wt_verbose(session, WT_VERB_LSM,
		    ""COMPACT: Start compacting %s"", lsm_tree->name);
	}

	/* Wait for the work unit queues to drain. */
	while (lsm_tree->active) {
		/*
		 * The flush flag is cleared when the chunk has been flushed.
		 * Continue to push forced flushes until the chunk is on disk.
		 * Once it is on disk move to the compacting phase.
		 */
		if (flushing) {
			WT_ASSERT(session, chunk != NULL);
			if (F_ISSET(chunk, WT_LSM_CHUNK_ONDISK)) {
				__wt_verbose(session,
				    WT_VERB_LSM,
				    ""Compact flush done %s chunk %"" PRIu32 "". ""
				    ""Start compacting progress %"" PRIu64,
				    name, chunk->id,
				    lsm_tree->merge_progressing);
				(void)__wt_atomic_sub32(&chunk->refcnt, 1);
				flushing = ref = false;
				compacting = true;
				F_SET(lsm_tree, WT_LSM_TREE_COMPACTING);
				progress = lsm_tree->merge_progressing;
			} else {
				__wt_verbose(session, WT_VERB_LSM,
				    ""Compact flush retry %s chunk %"" PRIu32,
				    name, chunk->id);
				WT_ERR(__wt_lsm_manager_push_entry(session,
				    WT_LSM_WORK_FLUSH, WT_LSM_WORK_FORCE,
				    lsm_tree));
			}
		}

		/*
		 * The compacting flag is cleared when no merges can be done.
		 * Ensure that we push through some aggressive merges before
		 * stopping otherwise we might not do merges that would
		 * span chunks with different generations.
		 */
		if (compacting && !F_ISSET(lsm_tree, WT_LSM_TREE_COMPACTING)) {
			if (lsm_tree->merge_aggressiveness < 10 ||
			    (progress < lsm_tree->merge_progressing) ||
			    lsm_tree->merge_syncing) {
				progress = lsm_tree->merge_progressing;
				F_SET(lsm_tree, WT_LSM_TREE_COMPACTING);
				lsm_tree->merge_aggressiveness = 10;
			} else
				break;
		}
		WT_ERR(__wt_session_compact_check_timeout(session));
		__wt_sleep(1, 0);

		/*
		 * Push merge operations while they are still getting work
		 * done. If we are pushing merges, make sure they are
		 * aggressive, to avoid duplicating effort.
		 */
		if (compacting)
#define	COMPACT_PARALLEL_MERGES	5
			for (i = lsm_tree->queue_ref;
			    i < COMPACT_PARALLEL_MERGES; i++) {
				lsm_tree->merge_aggressiveness = 10;
				WT_ERR(__wt_lsm_manager_push_entry(
				    session, WT_LSM_WORK_MERGE, 0, lsm_tree));
			}
	}
err:
	/* Ensure anything we set is cleared. */
	if (ref)
		(void)__wt_atomic_sub32(&chunk->refcnt, 1);
	if (compacting) {
		F_CLR(lsm_tree, WT_LSM_TREE_COMPACTING);
		lsm_tree->merge_aggressiveness = 0;
	}
	if (locked)
		__wt_lsm_tree_writeunlock(session, lsm_tree);

	__wt_verbose(session, WT_VERB_LSM,
	    ""Compact %s complete, return %d"", name, ret);

	__wt_lsm_tree_release(session, lsm_tree);
	return (ret);
}
",74
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_work_unit.c,"+		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"int
__wt_lsm_checkpoint_chunk(WT_SESSION_IMPL *session,
    WT_LSM_TREE *lsm_tree, WT_LSM_CHUNK *chunk)
{
	WT_DECL_RET;
	WT_TXN_ISOLATION saved_isolation;
	bool flush_set;

	flush_set = false;

	/*
	 * If the chunk is already checkpointed, make sure it is also evicted.
	 * Either way, there is no point trying to checkpoint it again.
	 */
	if (F_ISSET(chunk, WT_LSM_CHUNK_ONDISK) &&
	    !F_ISSET(chunk, WT_LSM_CHUNK_STABLE) &&
	    !chunk->evicted) {
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
		    ret = __lsm_discard_handle(session, chunk->uri, NULL));
		if (ret == 0)
			chunk->evicted = 1;
		else if (ret == EBUSY)
			ret = 0;
		else
			WT_RET_MSG(session, ret, ""discard handle"");
	}
	if (F_ISSET(chunk, WT_LSM_CHUNK_ONDISK)) {
		__wt_verbose(session, WT_VERB_LSM,
		    ""LSM worker %s already on disk"",
		    chunk->uri);
		return (0);
	}

	/* Stop if a running transaction needs the chunk. */
	WT_RET(__wt_txn_update_oldest(
	    session, WT_TXN_OLDEST_STRICT | WT_TXN_OLDEST_WAIT));
	if (chunk->switch_txn == WT_TXN_NONE ||
	    !__wt_txn_visible_all(session, chunk->switch_txn)) {
		__wt_verbose(session, WT_VERB_LSM,
		    ""LSM worker %s: running transaction, return"",
		    chunk->uri);
		return (0);
	}

	if (!__wt_atomic_cas8(&chunk->flushing, 0, 1))
		return (0);
	flush_set = true;

	__wt_verbose(session, WT_VERB_LSM, ""LSM worker flushing %s"",
	    chunk->uri);

	/*
	 * Flush the file before checkpointing: this is the expensive part in
	 * terms of I/O.
	 *
	 * !!!
	 * We can wait here for checkpoints and fsyncs to complete, which can
	 * take a long time.
	 */
	if ((ret = __wt_session_get_btree(
	    session, chunk->uri, NULL, NULL, 0)) == 0) {
		/*
		 * Set read-uncommitted: we have already checked that all of the
		 * updates in this chunk are globally visible, use the cheapest
		 * possible check in reconciliation.
		 */
		saved_isolation = session->txn.isolation;
		session->txn.isolation = WT_ISO_READ_UNCOMMITTED;
		ret = __wt_cache_op(session, WT_SYNC_WRITE_LEAVES);
		session->txn.isolation = saved_isolation;
		WT_TRET(__wt_session_release_btree(session));
	}
	WT_ERR(ret);

	__wt_verbose(session, WT_VERB_LSM, ""LSM worker checkpointing %s"",
	    chunk->uri);

	/*
	 * Turn on metadata tracking to ensure the checkpoint gets the
	 * necessary handle locks.
	 *
	 * Ensure that we don't race with a running checkpoint: the checkpoint
	 * lock protects against us racing with an application checkpoint in
	 * this chunk.  Don't wait for it, though: checkpoints can take a long
	 * time, and our checkpoint operation should be very quick.
	 */
	WT_ERR(__wt_meta_track_on(session));
	WT_WITH_CHECKPOINT_LOCK(session,
	    WT_WITH_SCHEMA_LOCK(session,
		ret = __wt_schema_worker(
		session, chunk->uri, __wt_checkpoint, NULL, NULL, 0)));
	WT_TRET(__wt_meta_track_off(session, false, ret != 0));
	if (ret != 0)
		WT_ERR_MSG(session, ret, ""LSM checkpoint"");

	/* Now the file is written, get the chunk size. */
	WT_ERR(__wt_lsm_tree_set_chunk_size(session, chunk));

	/* Update the flush timestamp to help track ongoing progress. */
	__wt_epoch(session, &lsm_tree->last_flush_ts);
	++lsm_tree->chunks_flushed;

	/* Lock the tree, mark the chunk as on disk and update the metadata. */
	__wt_lsm_tree_writelock(session, lsm_tree);
	F_SET(chunk, WT_LSM_CHUNK_ONDISK);
	ret = __wt_lsm_meta_write(session, lsm_tree, NULL);
	++lsm_tree->dsk_gen;

	/* Update the throttle time. */
	__wt_lsm_tree_throttle(session, lsm_tree, true);
	__wt_lsm_tree_writeunlock(session, lsm_tree);
	if (ret != 0)
		WT_ERR_MSG(session, ret, ""LSM metadata write"");

	WT_PUBLISH(chunk->flushing, 0);
	flush_set = false;

	/*
	 * Clear the no-eviction flag so the primary can be evicted and
	 * eventually closed.  Only do this once the checkpoint has succeeded:
	 * otherwise, accessing the leaf page during the checkpoint can trigger
	 * forced eviction.
	 */
	WT_ERR(__wt_session_get_btree(session, chunk->uri, NULL, NULL, 0));
	__wt_btree_lsm_switch_primary(session, false);
	WT_ERR(__wt_session_release_btree(session));

	/* Make sure we aren't pinning a transaction ID. */
	__wt_txn_release_snapshot(session);

	__wt_verbose(session, WT_VERB_LSM, ""LSM worker checkpointed %s"",
	    chunk->uri);

	/* Schedule a bloom filter create for our newly flushed chunk. */
	if (!FLD_ISSET(lsm_tree->bloom, WT_LSM_BLOOM_OFF))
		WT_ERR(__wt_lsm_manager_push_entry(
		    session, WT_LSM_WORK_BLOOM, 0, lsm_tree));
	else
		WT_ERR(__wt_lsm_manager_push_entry(
		    session, WT_LSM_WORK_MERGE, 0, lsm_tree));

err:	if (flush_set)
		WT_PUBLISH(chunk->flushing, 0);

	return (ret);
}
","int
__wt_lsm_checkpoint_chunk(WT_SESSION_IMPL *session,
    WT_LSM_TREE *lsm_tree, WT_LSM_CHUNK *chunk)
{
	WT_DECL_RET;
	WT_TXN_ISOLATION saved_isolation;
	bool flush_set;

	flush_set = false;

	/*
	 * If the chunk is already checkpointed, make sure it is also evicted.
	 * Either way, there is no point trying to checkpoint it again.
	 */
	if (F_ISSET(chunk, WT_LSM_CHUNK_ONDISK) &&
	    !F_ISSET(chunk, WT_LSM_CHUNK_STABLE) &&
	    !chunk->evicted) {
		WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
","		if (ret == 0)
			chunk->evicted = 1;
		else if (ret == EBUSY)
			ret = 0;
		else
			WT_RET_MSG(session, ret, ""discard handle"");
	}
	if (F_ISSET(chunk, WT_LSM_CHUNK_ONDISK)) {
		__wt_verbose(session, WT_VERB_LSM,
		    ""LSM worker %s already on disk"",
		    chunk->uri);
		return (0);
	}

	/* Stop if a running transaction needs the chunk. */
	WT_RET(__wt_txn_update_oldest(
	    session, WT_TXN_OLDEST_STRICT | WT_TXN_OLDEST_WAIT));
	if (chunk->switch_txn == WT_TXN_NONE ||
	    !__wt_txn_visible_all(session, chunk->switch_txn)) {
		__wt_verbose(session, WT_VERB_LSM,
		    ""LSM worker %s: running transaction, return"",
		    chunk->uri);
		return (0);
	}

	if (!__wt_atomic_cas8(&chunk->flushing, 0, 1))
		return (0);
	flush_set = true;

	__wt_verbose(session, WT_VERB_LSM, ""LSM worker flushing %s"",
	    chunk->uri);

	/*
	 * Flush the file before checkpointing: this is the expensive part in
	 * terms of I/O.
	 *
	 * !!!
	 * We can wait here for checkpoints and fsyncs to complete, which can
	 * take a long time.
	 */
	if ((ret = __wt_session_get_btree(
	    session, chunk->uri, NULL, NULL, 0)) == 0) {
		/*
		 * Set read-uncommitted: we have already checked that all of the
		 * updates in this chunk are globally visible, use the cheapest
		 * possible check in reconciliation.
		 */
		saved_isolation = session->txn.isolation;
		session->txn.isolation = WT_ISO_READ_UNCOMMITTED;
		ret = __wt_cache_op(session, WT_SYNC_WRITE_LEAVES);
		session->txn.isolation = saved_isolation;
		WT_TRET(__wt_session_release_btree(session));
	}
	WT_ERR(ret);

	__wt_verbose(session, WT_VERB_LSM, ""LSM worker checkpointing %s"",
	    chunk->uri);

	/*
	 * Turn on metadata tracking to ensure the checkpoint gets the
	 * necessary handle locks.
	 *
	 * Ensure that we don't race with a running checkpoint: the checkpoint
	 * lock protects against us racing with an application checkpoint in
	 * this chunk.  Don't wait for it, though: checkpoints can take a long
	 * time, and our checkpoint operation should be very quick.
	 */
	WT_ERR(__wt_meta_track_on(session));
	WT_WITH_CHECKPOINT_LOCK(session,
	    WT_WITH_SCHEMA_LOCK(session,
		ret = __wt_schema_worker(
		session, chunk->uri, __wt_checkpoint, NULL, NULL, 0)));
	WT_TRET(__wt_meta_track_off(session, false, ret != 0));
	if (ret != 0)
		WT_ERR_MSG(session, ret, ""LSM checkpoint"");

	/* Now the file is written, get the chunk size. */
	WT_ERR(__wt_lsm_tree_set_chunk_size(session, chunk));

	/* Update the flush timestamp to help track ongoing progress. */
	__wt_epoch(session, &lsm_tree->last_flush_ts);
	++lsm_tree->chunks_flushed;

	/* Lock the tree, mark the chunk as on disk and update the metadata. */
	__wt_lsm_tree_writelock(session, lsm_tree);
	F_SET(chunk, WT_LSM_CHUNK_ONDISK);
	ret = __wt_lsm_meta_write(session, lsm_tree, NULL);
	++lsm_tree->dsk_gen;

	/* Update the throttle time. */
	__wt_lsm_tree_throttle(session, lsm_tree, true);
	__wt_lsm_tree_writeunlock(session, lsm_tree);
	if (ret != 0)
		WT_ERR_MSG(session, ret, ""LSM metadata write"");

	WT_PUBLISH(chunk->flushing, 0);
	flush_set = false;

	/*
	 * Clear the no-eviction flag so the primary can be evicted and
	 * eventually closed.  Only do this once the checkpoint has succeeded:
	 * otherwise, accessing the leaf page during the checkpoint can trigger
	 * forced eviction.
	 */
	WT_ERR(__wt_session_get_btree(session, chunk->uri, NULL, NULL, 0));
	__wt_btree_lsm_switch_primary(session, false);
	WT_ERR(__wt_session_release_btree(session));

	/* Make sure we aren't pinning a transaction ID. */
	__wt_txn_release_snapshot(session);

	__wt_verbose(session, WT_VERB_LSM, ""LSM worker checkpointed %s"",
	    chunk->uri);

	/* Schedule a bloom filter create for our newly flushed chunk. */
	if (!FLD_ISSET(lsm_tree->bloom, WT_LSM_BLOOM_OFF))
		WT_ERR(__wt_lsm_manager_push_entry(
		    session, WT_LSM_WORK_BLOOM, 0, lsm_tree));
	else
		WT_ERR(__wt_lsm_manager_push_entry(
		    session, WT_LSM_WORK_MERGE, 0, lsm_tree));

err:	if (flush_set)
		WT_PUBLISH(chunk->flushing, 0);

	return (ret);
}
",19
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/lsm/lsm_work_unit.c,"+	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"static int
__lsm_drop_file(WT_SESSION_IMPL *session, const char *uri)
{
	WT_DECL_RET;
	const char *drop_cfg[] = { WT_CONFIG_BASE(
	    session, WT_SESSION_drop), ""remove_files=false"", NULL };

	/*
	 * We need to grab the schema lock to drop the file, so first try to
	 * make sure there is minimal work to freeing space in the cache.  Only
	 * bother trying to discard the checkpoint handle: the in-memory handle
	 * should have been closed already.
	 *
	 * This will fail with EBUSY if the file is still in use.
	 */
	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
	   ret = __lsm_discard_handle(session, uri, WT_CHECKPOINT));
	WT_RET(ret);

	/*
	 * Take the schema lock for the drop operation.  Since __wt_schema_drop
	 * results in the hot backup lock being taken when it updates the
	 * metadata (which would be too late to prevent our drop).
	 */
	WT_WITH_SCHEMA_LOCK(session,
	    ret = __wt_schema_drop(session, uri, drop_cfg));

	if (ret == 0)
		ret = __wt_fs_remove(session, uri + strlen(""file:""), false);
	__wt_verbose(session, WT_VERB_LSM, ""Dropped %s"", uri);

	if (ret == EBUSY || ret == ENOENT)
		__wt_verbose(session, WT_VERB_LSM,
		    ""LSM worker drop of %s failed with %d"", uri, ret);

	return (ret);
}
","static int
__lsm_drop_file(WT_SESSION_IMPL *session, const char *uri)
{
	WT_DECL_RET;
	const char *drop_cfg[] = { WT_CONFIG_BASE(
	    session, WT_SESSION_drop), ""remove_files=false"", NULL };

	/*
	 * We need to grab the schema lock to drop the file, so first try to
	 * make sure there is minimal work to freeing space in the cache.  Only
	 * bother trying to discard the checkpoint handle: the in-memory handle
	 * should have been closed already.
	 *
	 * This will fail with EBUSY if the file is still in use.
	 */
	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
	   ret = __lsm_discard_handle(session, uri, WT_CHECKPOINT));
	WT_RET(ret);

	/*
	 * Take the schema lock for the drop operation.  Since __wt_schema_drop
	 * results in the hot backup lock being taken when it updates the
	 * metadata (which would be too late to prevent our drop).
	 */
	WT_WITH_SCHEMA_LOCK(session,
","
	if (ret == 0)
		ret = __wt_fs_remove(session, uri + strlen(""file:""), false);
	__wt_verbose(session, WT_VERB_LSM, ""Dropped %s"", uri);

	if (ret == EBUSY || ret == ENOENT)
		__wt_verbose(session, WT_VERB_LSM,
		    ""LSM worker drop of %s failed with %d"", uri, ret);

	return (ret);
}
",26
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/os_posix/os_mtx_cond.c,"+	WT_ASSERT(session, run_func != NULL || usecs <= WT_MILLION);",+,"void
__wt_cond_wait_signal(WT_SESSION_IMPL *session, WT_CONDVAR *cond,
    uint64_t usecs, bool (*run_func)(WT_SESSION_IMPL *), bool *signalled)
{
	struct timespec ts;
	WT_DECL_RET;
	bool locked;

	locked = false;

	/* Fast path if already signalled. */
	*signalled = true;
	if (__wt_atomic_addi32(&cond->waiters, 1) == 0)
		return;

	__wt_verbose(session, WT_VERB_MUTEX, ""wait %s"", cond->name);
	WT_STAT_CONN_INCR(session, cond_wait);

	WT_ERR(pthread_mutex_lock(&cond->mtx));
	locked = true;

	/*
	 * It's possible to race with threads waking us up. That's not a problem
	 * if there are multiple wakeups because the next wakeup will get us, or
	 * if we're only pausing for a short period. It's a problem if there's
	 * only a single wakeup, our waker is likely waiting for us to exit.
	 * After acquiring the mutex (so we're guaranteed to be awakened by any
	 * future wakeup call), optionally check if we're OK to keep running.
	 * This won't ensure our caller won't just loop and call us again, but
	 * at least it's not our fault.
	 *
	 * Assert we're not waiting longer than a second if not checking the
	 * run status.
	 */
	WT_ASSERT(session, run_func != NULL || usecs <= WT_MILLION);
	if (run_func != NULL && !run_func(session))
		goto skipping;

	if (usecs > 0) {
		__wt_epoch(session, &ts);
		ts.tv_sec += (time_t)
		    (((uint64_t)ts.tv_nsec + WT_THOUSAND * usecs) / WT_BILLION);
		ts.tv_nsec = (long)
		    (((uint64_t)ts.tv_nsec + WT_THOUSAND * usecs) % WT_BILLION);
		ret = pthread_cond_timedwait(&cond->cond, &cond->mtx, &ts);
	} else
		ret = pthread_cond_wait(&cond->cond, &cond->mtx);

	/*
	 * Check pthread_cond_wait() return for EINTR, ETIME and
	 * ETIMEDOUT, some systems return these errors.
	 */
	if (ret == EINTR ||
#ifdef ETIME
	    ret == ETIME ||
#endif
	    ret == ETIMEDOUT) {
skipping:	*signalled = false;
		ret = 0;
	}

err:	(void)__wt_atomic_subi32(&cond->waiters, 1);

	if (locked)
		WT_TRET(pthread_mutex_unlock(&cond->mtx));
	if (ret == 0)
		return;

	WT_PANIC_MSG(session, ret, ""pthread_cond_wait: %s"", cond->name);
}
","void
__wt_cond_wait_signal(WT_SESSION_IMPL *session, WT_CONDVAR *cond,
    uint64_t usecs, bool (*run_func)(WT_SESSION_IMPL *), bool *signalled)
{
	struct timespec ts;
	WT_DECL_RET;
	bool locked;

	locked = false;

	/* Fast path if already signalled. */
	*signalled = true;
	if (__wt_atomic_addi32(&cond->waiters, 1) == 0)
		return;

	__wt_verbose(session, WT_VERB_MUTEX, ""wait %s"", cond->name);
	WT_STAT_CONN_INCR(session, cond_wait);

	WT_ERR(pthread_mutex_lock(&cond->mtx));
	locked = true;

	/*
	 * It's possible to race with threads waking us up. That's not a problem
	 * if there are multiple wakeups because the next wakeup will get us, or
	 * if we're only pausing for a short period. It's a problem if there's
	 * only a single wakeup, our waker is likely waiting for us to exit.
	 * After acquiring the mutex (so we're guaranteed to be awakened by any
	 * future wakeup call), optionally check if we're OK to keep running.
	 * This won't ensure our caller won't just loop and call us again, but
	 * at least it's not our fault.
	 *
	 * Assert we're not waiting longer than a second if not checking the
	 * run status.
	 */
	WT_ASSERT(session, run_func != NULL || usecs <= WT_MILLION);
	if (run_func != NULL && !run_func(session))
		goto skipping;

	if (usecs > 0) {
		__wt_epoch(session, &ts);
		ts.tv_sec += (time_t)
		    (((uint64_t)ts.tv_nsec + WT_THOUSAND * usecs) / WT_BILLION);
		ts.tv_nsec = (long)
		    (((uint64_t)ts.tv_nsec + WT_THOUSAND * usecs) % WT_BILLION);
		ret = pthread_cond_timedwait(&cond->cond, &cond->mtx, &ts);
	} else
		ret = pthread_cond_wait(&cond->cond, &cond->mtx);

	/*
	 * Check pthread_cond_wait() return for EINTR, ETIME and
	 * ETIMEDOUT, some systems return these errors.
	 */
	if (ret == EINTR ||
#ifdef ETIME
	    ret == ETIME ||
#endif
	    ret == ETIMEDOUT) {
skipping:	*signalled = false;
		ret = 0;
	}

err:	(void)__wt_atomic_subi32(&cond->waiters, 1);

	if (locked)
","	if (ret == 0)
		return;

	WT_PANIC_MSG(session, ret, ""pthread_cond_wait: %s"", cond->name);
}
",65
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/os_win/os_mtx_cond.c,"+	WT_ASSERT(session, run_func != NULL || usecs <= WT_MILLION);",+,"void
__wt_cond_wait_signal(WT_SESSION_IMPL *session, WT_CONDVAR *cond,
    uint64_t usecs, bool (*run_func)(WT_SESSION_IMPL *), bool *signalled)
{
	BOOL sleepret;
	DWORD milliseconds, windows_error;
	bool locked;
	uint64_t milliseconds64;

	locked = false;

	/* Fast path if already signalled. */
	*signalled = true;
	if (__wt_atomic_addi32(&cond->waiters, 1) == 0)
		return;

	__wt_verbose(session, WT_VERB_MUTEX, ""wait %s"", cond->name);
	WT_STAT_CONN_INCR(session, cond_wait);

	EnterCriticalSection(&cond->mtx);
	locked = true;

	/*
	 * It's possible to race with threads waking us up. That's not a problem
	 * if there are multiple wakeups because the next wakeup will get us, or
	 * if we're only pausing for a short period. It's a problem if there's
	 * only a single wakeup, our waker is likely waiting for us to exit.
	 * After acquiring the mutex (so we're guaranteed to be awakened by any
	 * future wakeup call), optionally check if we're OK to keep running.
	 * This won't ensure our caller won't just loop and call us again, but
	 * at least it's not our fault.
	 *
	 * Assert we're not waiting longer than a second if not checking the
	 * run status.
	 */
	WT_ASSERT(session, run_func != NULL || usecs <= WT_MILLION);

	if (run_func != NULL && !run_func(session))
		goto skipping;

	if (usecs > 0) {
		milliseconds64 = usecs / WT_THOUSAND;

		/*
		 * Check for 32-bit unsigned integer overflow
		 * INFINITE is max unsigned int on Windows
		 */
		if (milliseconds64 >= INFINITE)
			milliseconds64 = INFINITE - 1;
		milliseconds = (DWORD)milliseconds64;

		/*
		 * 0 would mean the CV sleep becomes a TryCV which we do not
		 * want
		 */
		if (milliseconds == 0)
			milliseconds = 1;

		sleepret = SleepConditionVariableCS(
		    &cond->cond, &cond->mtx, milliseconds);
	} else
		sleepret = SleepConditionVariableCS(
		    &cond->cond, &cond->mtx, INFINITE);

	/*
	 * SleepConditionVariableCS returns non-zero on success, 0 on timeout
	 * or failure.
	 */
	if (sleepret == 0) {
		windows_error = __wt_getlasterror();
		if (windows_error == ERROR_TIMEOUT) {
skipping:		*signalled = false;
			sleepret = 1;
		}
	}

	(void)__wt_atomic_subi32(&cond->waiters, 1);

	if (locked)
		LeaveCriticalSection(&cond->mtx);

	if (sleepret != 0)
		return;

	__wt_errx(session, ""SleepConditionVariableCS: %s: %s"",
	    cond->name, __wt_formatmessage(session, windows_error));
	WT_PANIC_MSG(session, __wt_map_windows_error(windows_error),
	    ""SleepConditionVariableCS: %s"", cond->name);
}
","void
__wt_cond_wait_signal(WT_SESSION_IMPL *session, WT_CONDVAR *cond,
    uint64_t usecs, bool (*run_func)(WT_SESSION_IMPL *), bool *signalled)
{
	BOOL sleepret;
	DWORD milliseconds, windows_error;
	bool locked;
	uint64_t milliseconds64;

	locked = false;

	/* Fast path if already signalled. */
	*signalled = true;
	if (__wt_atomic_addi32(&cond->waiters, 1) == 0)
		return;

	__wt_verbose(session, WT_VERB_MUTEX, ""wait %s"", cond->name);
	WT_STAT_CONN_INCR(session, cond_wait);

	EnterCriticalSection(&cond->mtx);
	locked = true;

	/*
	 * It's possible to race with threads waking us up. That's not a problem
	 * if there are multiple wakeups because the next wakeup will get us, or
	 * if we're only pausing for a short period. It's a problem if there's
	 * only a single wakeup, our waker is likely waiting for us to exit.
	 * After acquiring the mutex (so we're guaranteed to be awakened by any
	 * future wakeup call), optionally check if we're OK to keep running.
	 * This won't ensure our caller won't just loop and call us again, but
	 * at least it's not our fault.
	 *
	 * Assert we're not waiting longer than a second if not checking the
	 * run status.
	 */
	WT_ASSERT(session, run_func != NULL || usecs <= WT_MILLION);

	if (run_func != NULL && !run_func(session))
		goto skipping;

	if (usecs > 0) {
		milliseconds64 = usecs / WT_THOUSAND;

		/*
		 * Check for 32-bit unsigned integer overflow
		 * INFINITE is max unsigned int on Windows
		 */
		if (milliseconds64 >= INFINITE)
			milliseconds64 = INFINITE - 1;
		milliseconds = (DWORD)milliseconds64;

		/*
		 * 0 would mean the CV sleep becomes a TryCV which we do not
		 * want
		 */
		if (milliseconds == 0)
			milliseconds = 1;

		sleepret = SleepConditionVariableCS(
		    &cond->cond, &cond->mtx, milliseconds);
	} else
		sleepret = SleepConditionVariableCS(
		    &cond->cond, &cond->mtx, INFINITE);

	/*
","	 * or failure.
	 */
	if (sleepret == 0) {
		windows_error = __wt_getlasterror();
		if (windows_error == ERROR_TIMEOUT) {
skipping:		*signalled = false;
			sleepret = 1;
		}
	}

	(void)__wt_atomic_subi32(&cond->waiters, 1);

	if (locked)
		LeaveCriticalSection(&cond->mtx);

	if (sleepret != 0)
		return;

	__wt_errx(session, ""SleepConditionVariableCS: %s: %s"",
	    cond->name, __wt_formatmessage(session, windows_error));
	WT_PANIC_MSG(session, __wt_map_windows_error(windows_error),
	    ""SleepConditionVariableCS: %s"", cond->name);
}
",66
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/os_win/os_mtx_cond.c,-	WT_WRITE_BARRIER();,-,"void
__wt_cond_signal(WT_SESSION_IMPL *session, WT_CONDVAR *cond)
{
	WT_DECL_RET;

	__wt_verbose(session, WT_VERB_MUTEX, ""signal %s"", cond->name);

	/*
	 * Our callers often set flags to cause a thread to exit. Add a barrier
	 * to ensure exit flags are seen by the sleeping threads, otherwise we
	 * can wake up a thread, it immediately goes back to sleep, and we'll
	 * hang. Use a full barrier (we may not write before waiting on thread
	 * join).
	 */
	WT_FULL_BARRIER();

	/*
	 * Fast path if we are in (or can enter), a state where the next waiter
	 * will return immediately as already signaled.
	 */
	if (cond->waiters == -1 ||
	    (cond->waiters == 0 && __wt_atomic_casi32(&cond->waiters, 0, -1)))
		return;

	EnterCriticalSection(&cond->mtx);
	WakeAllConditionVariable(&cond->cond);
	LeaveCriticalSection(&cond->mtx);
}
","void
__wt_cond_signal(WT_SESSION_IMPL *session, WT_CONDVAR *cond)
{
	WT_DECL_RET;

	__wt_verbose(session, WT_VERB_MUTEX, ""signal %s"", cond->name);

	/*
	 * Our callers often set flags to cause a thread to exit. Add a barrier
	 * to ensure exit flags are seen by the sleeping threads, otherwise we
","	 * hang. Use a full barrier (we may not write before waiting on thread
	 * join).
	 */
	WT_FULL_BARRIER();

	/*
	 * Fast path if we are in (or can enter), a state where the next waiter
	 * will return immediately as already signaled.
	 */
	if (cond->waiters == -1 ||
	    (cond->waiters == 0 && __wt_atomic_casi32(&cond->waiters, 0, -1)))
		return;

	EnterCriticalSection(&cond->mtx);
	WakeAllConditionVariable(&cond->cond);
	LeaveCriticalSection(&cond->mtx);
}
",11
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/schema/schema_drop.c,"+	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"static int
__drop_file(
    WT_SESSION_IMPL *session, const char *uri, bool force, const char *cfg[])
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	bool remove_files;
	const char *filename;

	WT_RET(__wt_config_gets(session, cfg, ""remove_files"", &cval));
	remove_files = cval.val != 0;

	filename = uri;
	if (!WT_PREFIX_SKIP(filename, ""file:""))
		return (__wt_unexpected_object_type(session, uri, ""file:""));

	WT_RET(__wt_schema_backup_check(session, filename));
	/* Close all btree handles associated with this file. */
	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
	    ret = __wt_conn_dhandle_close_all(session, uri, force));
	WT_RET(ret);

	/* Remove the metadata entry (ignore missing items). */
	WT_TRET(__wt_metadata_remove(session, uri));
	if (!remove_files)
		return (ret);

	/*
	 * Schedule the remove of the underlying physical file when the drop
	 * completes.
	 */
	WT_TRET(__wt_meta_track_drop(session, filename));

	return (ret);
}
","static int
__drop_file(
    WT_SESSION_IMPL *session, const char *uri, bool force, const char *cfg[])
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	bool remove_files;
	const char *filename;

	WT_RET(__wt_config_gets(session, cfg, ""remove_files"", &cval));
	remove_files = cval.val != 0;

	filename = uri;
	if (!WT_PREFIX_SKIP(filename, ""file:""))
		return (__wt_unexpected_object_type(session, uri, ""file:""));

	WT_RET(__wt_schema_backup_check(session, filename));
	/* Close all btree handles associated with this file. */
	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
","	WT_RET(ret);

	/* Remove the metadata entry (ignore missing items). */
	WT_TRET(__wt_metadata_remove(session, uri));
	if (!remove_files)
		return (ret);

	/*
	 * Schedule the remove of the underlying physical file when the drop
	 * completes.
	 */
	WT_TRET(__wt_meta_track_drop(session, filename));

	return (ret);
}
",20
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/schema/schema_rename.c,"+	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"static int
__rename_file(
    WT_SESSION_IMPL *session, const char *uri, const char *newuri)
{
	WT_DECL_RET;
	bool exist;
	const char *filename, *newfile;
	char *newvalue, *oldvalue;

	newvalue = oldvalue = NULL;

	filename = uri;
	if (!WT_PREFIX_SKIP(filename, ""file:""))
		return (__wt_unexpected_object_type(session, uri, ""file:""));
	newfile = newuri;
	if (!WT_PREFIX_SKIP(newfile, ""file:""))
		return (__wt_unexpected_object_type(session, newuri, ""file:""));

	WT_RET(__wt_schema_backup_check(session, filename));
	WT_RET(__wt_schema_backup_check(session, newfile));
	/* Close any btree handles in the file. */
	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
	    ret = __wt_conn_dhandle_close_all(session, uri, false));
	WT_ERR(ret);

	/*
	 * First, check if the file being renamed exists in the system.  Doing
	 * this check first matches the table rename behavior because we return
	 * WT_NOTFOUND when the renamed file doesn't exist (subsequently mapped
	 * to ENOENT by the session layer).
	 */
	WT_ERR(__wt_metadata_search(session, uri, &oldvalue));

	/*
	 * Check to see if the proposed name is already in use, in either the
	 * metadata or the filesystem.
	 */
	switch (ret = __wt_metadata_search(session, newuri, &newvalue)) {
	case 0:
		WT_ERR_MSG(session, EEXIST, ""%s"", newuri);
		/* NOTREACHED */
	case WT_NOTFOUND:
		break;
	default:
		WT_ERR(ret);
	}
	WT_ERR(__wt_fs_exist(session, newfile, &exist));
	if (exist)
		WT_ERR_MSG(session, EEXIST, ""%s"", newfile);

	/* Replace the old file entries with new file entries. */
	WT_ERR(__wt_metadata_remove(session, uri));
	WT_ERR(__wt_metadata_insert(session, newuri, oldvalue));

	/* Rename the underlying file. */
	WT_ERR(__wt_fs_rename(session, filename, newfile, false));
	if (WT_META_TRACKING(session))
		WT_ERR(__wt_meta_track_fileop(session, uri, newuri));

err:	__wt_free(session, newvalue);
	__wt_free(session, oldvalue);
	return (ret);
}
","static int
__rename_file(
    WT_SESSION_IMPL *session, const char *uri, const char *newuri)
{
	WT_DECL_RET;
	bool exist;
	const char *filename, *newfile;
	char *newvalue, *oldvalue;

	newvalue = oldvalue = NULL;

	filename = uri;
	if (!WT_PREFIX_SKIP(filename, ""file:""))
		return (__wt_unexpected_object_type(session, uri, ""file:""));
	newfile = newuri;
	if (!WT_PREFIX_SKIP(newfile, ""file:""))
		return (__wt_unexpected_object_type(session, newuri, ""file:""));

	WT_RET(__wt_schema_backup_check(session, filename));
	WT_RET(__wt_schema_backup_check(session, newfile));
	/* Close any btree handles in the file. */
	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
","	WT_ERR(ret);

	/*
	 * First, check if the file being renamed exists in the system.  Doing
	 * this check first matches the table rename behavior because we return
	 * WT_NOTFOUND when the renamed file doesn't exist (subsequently mapped
	 * to ENOENT by the session layer).
	 */
	WT_ERR(__wt_metadata_search(session, uri, &oldvalue));

	/*
	 * Check to see if the proposed name is already in use, in either the
	 * metadata or the filesystem.
	 */
	switch (ret = __wt_metadata_search(session, newuri, &newvalue)) {
	case 0:
		WT_ERR_MSG(session, EEXIST, ""%s"", newuri);
		/* NOTREACHED */
	case WT_NOTFOUND:
		break;
	default:
		WT_ERR(ret);
	}
	WT_ERR(__wt_fs_exist(session, newfile, &exist));
	if (exist)
		WT_ERR_MSG(session, EEXIST, ""%s"", newfile);

	/* Replace the old file entries with new file entries. */
	WT_ERR(__wt_metadata_remove(session, uri));
	WT_ERR(__wt_metadata_insert(session, newuri, oldvalue));

	/* Rename the underlying file. */
	WT_ERR(__wt_fs_rename(session, filename, newfile, false));
	if (WT_META_TRACKING(session))
		WT_ERR(__wt_meta_track_fileop(session, uri, newuri));

err:	__wt_free(session, newvalue);
	__wt_free(session, oldvalue);
	return (ret);
}
",23
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/schema/schema_worker.c,"+				WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"int
__wt_schema_worker(WT_SESSION_IMPL *session,
   const char *uri,
   int (*file_func)(WT_SESSION_IMPL *, const char *[]),
   int (*name_func)(WT_SESSION_IMPL *, const char *, bool *),
   const char *cfg[], uint32_t open_flags)
{
	WT_COLGROUP *colgroup;
	WT_DATA_SOURCE *dsrc;
	WT_DECL_RET;
	WT_INDEX *idx;
	WT_SESSION *wt_session;
	WT_TABLE *table;
	const char *tablename;
	u_int i;
	bool skip;

	table = NULL;
	tablename = uri;

	skip = false;
	if (name_func != NULL)
		WT_ERR(name_func(session, uri, &skip));

	/* If the callback said to skip this object, we're done. */
	if (skip)
		return (0);

	/* Get the btree handle(s) and call the underlying function. */
	if (WT_PREFIX_MATCH(uri, ""file:"")) {
		if (file_func != NULL) {
			/*
			 * If the operation requires exclusive access, close
			 * any open file handles, including checkpoints.
			 */
			if (FLD_ISSET(open_flags, WT_DHANDLE_EXCLUSIVE)) {
				WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
				    ret = __wt_conn_dhandle_close_all(
				    session, uri, false));
				WT_ERR(ret);
			}

			WT_ERR(__wt_session_get_btree_ckpt(
			    session, uri, cfg, open_flags));
			WT_SAVE_DHANDLE(session,
			    ret = file_func(session, cfg));
			WT_TRET(__wt_session_release_btree(session));
			WT_ERR(ret);
		}
	} else if (WT_PREFIX_MATCH(uri, ""colgroup:"")) {
		WT_ERR(__wt_schema_get_colgroup(
		    session, uri, false, NULL, &colgroup));
		WT_ERR(__wt_schema_worker(session,
		    colgroup->source, file_func, name_func, cfg, open_flags));
	} else if (WT_PREFIX_SKIP(tablename, ""index:"")) {
		idx = NULL;
		WT_ERR(__wt_schema_get_index(session, uri, false, NULL, &idx));
		WT_ERR(__wt_schema_worker(session, idx->source,
		    file_func, name_func, cfg, open_flags));
	} else if (WT_PREFIX_MATCH(uri, ""lsm:"")) {
		WT_ERR(__wt_lsm_tree_worker(session,
		    uri, file_func, name_func, cfg, open_flags));
	} else if (WT_PREFIX_SKIP(tablename, ""table:"")) {
		WT_ERR(__wt_schema_get_table(session,
		    tablename, strlen(tablename), false, &table));
		WT_ASSERT(session, session->dhandle == NULL);

		/*
		 * We could make a recursive call for each colgroup or index
		 * URI, but since we have already opened the table, we can take
		 * a short cut and skip straight to the sources.  If we have a
		 * name function, it needs to know about the intermediate URIs.
		 */
		for (i = 0; i < WT_COLGROUPS(table); i++) {
			colgroup = table->cgroups[i];
			skip = false;
			if (name_func != NULL)
				WT_ERR(name_func(
				    session, colgroup->name, &skip));
			if (!skip)
				WT_ERR(__wt_schema_worker(
				    session, colgroup->source,
				    file_func, name_func, cfg, open_flags));
		}

		WT_ERR(__wt_schema_open_indices(session, table));
		for (i = 0; i < table->nindices; i++) {
			idx = table->indices[i];
			skip = false;
			if (name_func != NULL)
				WT_ERR(name_func(session, idx->name, &skip));
			if (!skip)
				WT_ERR(__wt_schema_worker(session, idx->source,
				    file_func, name_func, cfg, open_flags));
		}
	} else if ((dsrc = __wt_schema_get_source(session, uri)) != NULL) {
		wt_session = (WT_SESSION *)session;
		if (file_func == __wt_salvage && dsrc->salvage != NULL)
			WT_ERR(dsrc->salvage(
			   dsrc, wt_session, uri, (WT_CONFIG_ARG *)cfg));
		else if (file_func == __wt_verify && dsrc->verify != NULL)
			WT_ERR(dsrc->verify(
			   dsrc, wt_session, uri, (WT_CONFIG_ARG *)cfg));
		else if (file_func == __wt_checkpoint)
			;
		else if (file_func == __wt_checkpoint_get_handles)
			;
		else if (file_func == __wt_checkpoint_sync)
			;
		else
			WT_ERR(__wt_object_unsupported(session, uri));
	} else
		WT_ERR(__wt_bad_object_type(session, uri));

err:	if (table != NULL)
		__wt_schema_release_table(session, table);
	return (ret);
}
","int
__wt_schema_worker(WT_SESSION_IMPL *session,
   const char *uri,
   int (*file_func)(WT_SESSION_IMPL *, const char *[]),
   int (*name_func)(WT_SESSION_IMPL *, const char *, bool *),
   const char *cfg[], uint32_t open_flags)
{
	WT_COLGROUP *colgroup;
	WT_DATA_SOURCE *dsrc;
	WT_DECL_RET;
	WT_INDEX *idx;
	WT_SESSION *wt_session;
	WT_TABLE *table;
	const char *tablename;
	u_int i;
	bool skip;

	table = NULL;
	tablename = uri;

	skip = false;
	if (name_func != NULL)
		WT_ERR(name_func(session, uri, &skip));

	/* If the callback said to skip this object, we're done. */
	if (skip)
		return (0);

	/* Get the btree handle(s) and call the underlying function. */
	if (WT_PREFIX_MATCH(uri, ""file:"")) {
		if (file_func != NULL) {
			/*
			 * If the operation requires exclusive access, close
			 * any open file handles, including checkpoints.
			 */
			if (FLD_ISSET(open_flags, WT_DHANDLE_EXCLUSIVE)) {
				WT_WITH_HANDLE_LIST_WRITE_LOCK(session,
","				    session, uri, false));
				WT_ERR(ret);
			}

			WT_ERR(__wt_session_get_btree_ckpt(
			    session, uri, cfg, open_flags));
			WT_SAVE_DHANDLE(session,
			    ret = file_func(session, cfg));
			WT_TRET(__wt_session_release_btree(session));
			WT_ERR(ret);
		}
	} else if (WT_PREFIX_MATCH(uri, ""colgroup:"")) {
		WT_ERR(__wt_schema_get_colgroup(
		    session, uri, false, NULL, &colgroup));
		WT_ERR(__wt_schema_worker(session,
		    colgroup->source, file_func, name_func, cfg, open_flags));
	} else if (WT_PREFIX_SKIP(tablename, ""index:"")) {
		idx = NULL;
		WT_ERR(__wt_schema_get_index(session, uri, false, NULL, &idx));
		WT_ERR(__wt_schema_worker(session, idx->source,
		    file_func, name_func, cfg, open_flags));
	} else if (WT_PREFIX_MATCH(uri, ""lsm:"")) {
		WT_ERR(__wt_lsm_tree_worker(session,
		    uri, file_func, name_func, cfg, open_flags));
	} else if (WT_PREFIX_SKIP(tablename, ""table:"")) {
		WT_ERR(__wt_schema_get_table(session,
		    tablename, strlen(tablename), false, &table));
		WT_ASSERT(session, session->dhandle == NULL);

		/*
		 * We could make a recursive call for each colgroup or index
		 * URI, but since we have already opened the table, we can take
		 * a short cut and skip straight to the sources.  If we have a
		 * name function, it needs to know about the intermediate URIs.
		 */
		for (i = 0; i < WT_COLGROUPS(table); i++) {
			colgroup = table->cgroups[i];
			skip = false;
			if (name_func != NULL)
				WT_ERR(name_func(
				    session, colgroup->name, &skip));
			if (!skip)
				WT_ERR(__wt_schema_worker(
				    session, colgroup->source,
				    file_func, name_func, cfg, open_flags));
		}

		WT_ERR(__wt_schema_open_indices(session, table));
		for (i = 0; i < table->nindices; i++) {
			idx = table->indices[i];
			skip = false;
			if (name_func != NULL)
				WT_ERR(name_func(session, idx->name, &skip));
			if (!skip)
				WT_ERR(__wt_schema_worker(session, idx->source,
				    file_func, name_func, cfg, open_flags));
		}
	} else if ((dsrc = __wt_schema_get_source(session, uri)) != NULL) {
		wt_session = (WT_SESSION *)session;
		if (file_func == __wt_salvage && dsrc->salvage != NULL)
			WT_ERR(dsrc->salvage(
			   dsrc, wt_session, uri, (WT_CONFIG_ARG *)cfg));
		else if (file_func == __wt_verify && dsrc->verify != NULL)
			WT_ERR(dsrc->verify(
			   dsrc, wt_session, uri, (WT_CONFIG_ARG *)cfg));
		else if (file_func == __wt_checkpoint)
			;
		else if (file_func == __wt_checkpoint_get_handles)
			;
		else if (file_func == __wt_checkpoint_sync)
			;
		else
			WT_ERR(__wt_object_unsupported(session, uri));
	} else
		WT_ERR(__wt_bad_object_type(session, uri));

err:	if (table != NULL)
		__wt_schema_release_table(session, table);
	return (ret);
}
",38
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/session/session_api.c,"+		WT_WITH_TABLE_WRITE_LOCK(session,",+,"static int
__session_alter(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;

	SESSION_API_CALL(session, alter, config, cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * We replace the default configuration listing with the current
	 * configuration.  Otherwise the defaults for values that can be
	 * altered would override settings used by the user in create.
	 */
	cfg[0] = cfg[1];
	cfg[1] = NULL;
	WT_WITH_CHECKPOINT_LOCK(session,
	    WT_WITH_SCHEMA_LOCK(session,
		WT_WITH_TABLE_WRITE_LOCK(session,
		    ret = __wt_schema_alter(session, uri, cfg))));

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_alter_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_alter_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
","static int
__session_alter(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;

	SESSION_API_CALL(session, alter, config, cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * We replace the default configuration listing with the current
	 * configuration.  Otherwise the defaults for values that can be
	 * altered would override settings used by the user in create.
	 */
	cfg[0] = cfg[1];
	cfg[1] = NULL;
	WT_WITH_CHECKPOINT_LOCK(session,
	    WT_WITH_SCHEMA_LOCK(session,
		WT_WITH_TABLE_WRITE_LOCK(session,
","
err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_alter_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_alter_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
",24
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/session/session_api.c,"+	    WT_WITH_TABLE_WRITE_LOCK(session,",+,"static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
","static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

","	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
",12
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/session/session_api.c,"+		WT_WITH_TABLE_WRITE_LOCK(session,",+,"static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
","static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
","	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
",21
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/session/session_api.c,"+				WT_WITH_TABLE_WRITE_LOCK(session, ret =",+,"static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
","static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
","		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
",30
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/session/session_api.c,"+				WT_WITH_TABLE_WRITE_LOCK_NOWAIT(session, ret,",+,"static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
","static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
","			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
",36
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/session/session_api.c,"+			    WT_WITH_TABLE_WRITE_LOCK(session,",+,"static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
","static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

","		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
",43
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/session/session_api.c,"+			    WT_WITH_TABLE_WRITE_LOCK_NOWAIT(session, ret,",+,"static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
}
","static int
__session_create(WT_SESSION *wt_session, const char *uri, const char *config)
{
	WT_CONFIG_ITEM cval;
	WT_DECL_RET;
	WT_SESSION_IMPL *session;

	session = (WT_SESSION_IMPL *)wt_session;
	SESSION_API_CALL(session, create, config, cfg);
	WT_UNUSED(cfg);

	/* Disallow objects in the WiredTiger name space. */
	WT_ERR(__wt_str_name_check(session, uri));

	/*
	 * Type configuration only applies to tables, column groups and indexes.
	 * We don't want applications to attempt to layer LSM on top of their
	 * extended data-sources, and the fact we allow LSM as a valid URI is an
	 * invitation to that mistake: nip it in the bud.
	 */
	if (!WT_PREFIX_MATCH(uri, ""colgroup:"") &&
	    !WT_PREFIX_MATCH(uri, ""index:"") &&
	    !WT_PREFIX_MATCH(uri, ""table:"")) {
		/*
		 * We can't disallow type entirely, a configuration string might
		 * innocently include it, for example, a dump/load pair.  If the
		 * underlying type is ""file"", it's OK (""file"" is the underlying
		 * type for every type); if the URI type prefix and the type are
		 * the same, let it go.
		 */
		if ((ret =
		    __wt_config_getones(session, config, ""type"", &cval)) == 0 &&
		    !WT_STRING_MATCH(""file"", cval.str, cval.len) &&
		    (strncmp(uri, cval.str, cval.len) != 0 ||
		    uri[cval.len] != ':'))
			WT_ERR_MSG(session, EINVAL,
			    ""%s: unsupported type configuration"", uri);
		WT_ERR_NOTFOUND_OK(ret);
	}

	ret = __wt_session_create(session, uri, config);

err:	if (ret != 0)
		WT_STAT_CONN_INCR(session, session_table_create_fail);
	else
		WT_STAT_CONN_INCR(session, session_table_create_success);
	API_END_RET_NOTFOUND_MAP(session, ret);
",,48
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/session/session_dhandle.c,"+	WT_WITH_HANDLE_LIST_WRITE_LOCK(session,",+,"static int
__session_get_dhandle(
    WT_SESSION_IMPL *session, const char *uri, const char *checkpoint)
{
	WT_DATA_HANDLE_CACHE *dhandle_cache;
	WT_DECL_RET;

	__session_find_dhandle(session, uri, checkpoint, &dhandle_cache);
	if (dhandle_cache != NULL) {
		session->dhandle = dhandle_cache->dhandle;
		return (0);
	}

	/* Sweep the handle list to remove any dead handles. */
	__session_dhandle_sweep(session);

	/*
	 * We didn't find a match in the session cache, search the shared
	 * handle list and cache the handle we find.
	 */
	WT_RET(__session_find_shared_dhandle(session, uri, checkpoint));

	/*
	 * Fixup the reference count on failure (we incremented the reference
	 * count while holding the handle-list lock).
	 */
	if ((ret = __session_add_dhandle(session)) != 0) {
		WT_DHANDLE_RELEASE(session->dhandle);
		session->dhandle = NULL;
	}

	return (ret);
}
","static int
__session_get_dhandle(
    WT_SESSION_IMPL *session, const char *uri, const char *checkpoint)
{
","	WT_DECL_RET;

	__session_find_dhandle(session, uri, checkpoint, &dhandle_cache);
	if (dhandle_cache != NULL) {
		session->dhandle = dhandle_cache->dhandle;
		return (0);
	}

	/* Sweep the handle list to remove any dead handles. */
	__session_dhandle_sweep(session);

	/*
	 * We didn't find a match in the session cache, search the shared
	 * handle list and cache the handle we find.
	 */
	WT_RET(__session_find_shared_dhandle(session, uri, checkpoint));

	/*
	 * Fixup the reference count on failure (we incremented the reference
	 * count while holding the handle-list lock).
	 */
	if ((ret = __session_add_dhandle(session)) != 0) {
		WT_DHANDLE_RELEASE(session->dhandle);
		session->dhandle = NULL;
	}

	return (ret);
}
",5
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/support/cond_auto.c,"-	WT_ASSERT(session, cond->min_wait != 0);",-,"void
__wt_cond_auto_wait(WT_SESSION_IMPL *session,
    WT_CONDVAR *cond, bool progress, bool (*run_func)(WT_SESSION_IMPL *))
{
	bool notused;

	__wt_cond_auto_wait_signal(session, cond, progress, run_func, &notused);
}
","void
__wt_cond_auto_wait(WT_SESSION_IMPL *session,
    WT_CONDVAR *cond, bool progress, bool (*run_func)(WT_SESSION_IMPL *))
","	bool notused;

	__wt_cond_auto_wait_signal(session, cond, progress, run_func, &notused);
}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_compact.c,"-		fprintf(stderr, ""%s: compact(%s): %s\n"",",-,"int
util_compact(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->compact(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.compact: %s"", uri);

	free(uri);
	return (ret);
}
","int
util_compact(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->compact(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.compact: %s"", uri);
","	free(uri);
	return (ret);
}
",26
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_compact.c,"-		    progname, uri, session->strerror(session, ret));",-,"int
util_compact(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->compact(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.compact: %s"", uri);

	free(uri);
	return (ret);
}
","int
util_compact(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->compact(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.compact: %s"", uri);

","	return (ret);
}
",27
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_dump.c,"-			    progname, name, session->strerror(session, ret));",-,"int
util_dump(WT_SESSION *session, int argc, char *argv[])
{
	WT_CURSOR *cursor;
	WT_DECL_RET;
	size_t len;
	int ch, i;
	bool hex, json, reverse;
	char *checkpoint, *config, *p, *simpleuri, *uri;

	hex = json = reverse = false;
	checkpoint = config = simpleuri = uri = NULL;
	cursor = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""c:f:jrx"")) != EOF)
		switch (ch) {
		case 'c':
			checkpoint = __wt_optarg;
			break;
		case 'f':			/* output file */
			if (freopen(__wt_optarg, ""w"", stdout) == NULL)
				return (util_err(
				    session, errno, ""%s: reopen"", __wt_optarg));
			break;
		case 'j':
			json = true;
			break;
		case 'r':
			reverse = true;
			break;
		case 'x':
			hex = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* -j and -x are incompatible. */
	if (hex && json) {
		fprintf(stderr,
		    ""%s: the -j and -x dump options are incompatible\n"",
		    progname);
		goto err;
	}

	/* The remaining argument is the uri. */
	if (argc < 1 || (argc != 1 && !json))
		return (usage());

	if (json &&
	    (dump_json_begin(session) != 0 ||
	    dump_prefix(session, hex, json) != 0))
		goto err;

	for (i = 0; i < argc; i++) {
		if (json && i > 0)
			if (dump_json_separator(session) != 0)
				goto err;
		free(uri);
		free(simpleuri);
		uri = simpleuri = NULL;

		if ((uri = util_uri(session, argv[i], ""table"")) == NULL)
			goto err;

		len =
		    checkpoint == NULL ? 0 : strlen(""checkpoint="") +
		    strlen(checkpoint) + 1;
		len += strlen(json ? ""dump=json"" :
		    (hex ? ""dump=hex"" : ""dump=print""));
		if ((config = malloc(len + 10)) == NULL)
			goto err;
		if (checkpoint == NULL)
			config[0] = '\0';
		else {
			(void)strcpy(config, ""checkpoint="");
			(void)strcat(config, checkpoint);
			(void)strcat(config, "","");
		}
		(void)strcat(config, json ? ""dump=json"" :
		    (hex ? ""dump=hex"" : ""dump=print""));
		if ((ret = session->open_cursor(
		    session, uri, NULL, config, &cursor)) != 0) {
			fprintf(stderr, ""%s: cursor open(%s) failed: %s\n"",
			    progname, uri, session->strerror(session, ret));
			goto err;
		}

		if ((simpleuri = strdup(uri)) == NULL) {
			(void)util_err(session, errno, NULL);
			goto err;
		}
		if ((p = strchr(simpleuri, '(')) != NULL)
			*p = '\0';
		if (dump_config(session, simpleuri, cursor, hex, json) != 0)
			goto err;

		if (dump_record(cursor, reverse, json) != 0)
			goto err;
		if (json && dump_json_table_end(session) != 0)
			goto err;

		ret = cursor->close(cursor);
		cursor = NULL;
		if (ret != 0) {
			(void)util_err(session, ret, NULL);
			goto err;
		}
	}
	if (json && dump_json_end(session) != 0)
		goto err;

	if (0) {
err:		ret = 1;
	}

	free(config);
	free(uri);
	free(simpleuri);
	if (cursor != NULL && (ret = cursor->close(cursor)) != 0) {
		(void)util_err(session, ret, NULL);
		ret = 1;
	}
	return (ret);
}
","int
util_dump(WT_SESSION *session, int argc, char *argv[])
{
	WT_CURSOR *cursor;
	WT_DECL_RET;
	size_t len;
	int ch, i;
	bool hex, json, reverse;
	char *checkpoint, *config, *p, *simpleuri, *uri;

	hex = json = reverse = false;
	checkpoint = config = simpleuri = uri = NULL;
	cursor = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""c:f:jrx"")) != EOF)
		switch (ch) {
		case 'c':
			checkpoint = __wt_optarg;
			break;
		case 'f':			/* output file */
			if (freopen(__wt_optarg, ""w"", stdout) == NULL)
				return (util_err(
				    session, errno, ""%s: reopen"", __wt_optarg));
			break;
		case 'j':
			json = true;
			break;
		case 'r':
			reverse = true;
			break;
		case 'x':
			hex = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* -j and -x are incompatible. */
	if (hex && json) {
		fprintf(stderr,
		    ""%s: the -j and -x dump options are incompatible\n"",
		    progname);
		goto err;
	}

	/* The remaining argument is the uri. */
	if (argc < 1 || (argc != 1 && !json))
		return (usage());

	if (json &&
	    (dump_json_begin(session) != 0 ||
	    dump_prefix(session, hex, json) != 0))
		goto err;

	for (i = 0; i < argc; i++) {
		if (json && i > 0)
			if (dump_json_separator(session) != 0)
				goto err;
		free(uri);
		free(simpleuri);
		uri = simpleuri = NULL;

		if ((uri = util_uri(session, argv[i], ""table"")) == NULL)
			goto err;

		len =
		    checkpoint == NULL ? 0 : strlen(""checkpoint="") +
		    strlen(checkpoint) + 1;
		len += strlen(json ? ""dump=json"" :
		    (hex ? ""dump=hex"" : ""dump=print""));
		if ((config = malloc(len + 10)) == NULL)
			goto err;
		if (checkpoint == NULL)
			config[0] = '\0';
		else {
			(void)strcpy(config, ""checkpoint="");
			(void)strcat(config, checkpoint);
			(void)strcat(config, "","");
		}
		(void)strcat(config, json ? ""dump=json"" :
		    (hex ? ""dump=hex"" : ""dump=print""));
		if ((ret = session->open_cursor(
		    session, uri, NULL, config, &cursor)) != 0) {
			fprintf(stderr, ""%s: cursor open(%s) failed: %s\n"",
			    progname, uri, session->strerror(session, ret));
			goto err;
		}

		if ((simpleuri = strdup(uri)) == NULL) {
			(void)util_err(session, errno, NULL);
			goto err;
		}
		if ((p = strchr(simpleuri, '(')) != NULL)
			*p = '\0';
		if (dump_config(session, simpleuri, cursor, hex, json) != 0)
			goto err;

		if (dump_record(cursor, reverse, json) != 0)
			goto err;
		if (json && dump_json_table_end(session) != 0)
			goto err;

		ret = cursor->close(cursor);
		cursor = NULL;
		if (ret != 0) {
			(void)util_err(session, ret, NULL);
			goto err;
		}
	}
	if (json && dump_json_end(session) != 0)
		goto err;

	if (0) {
err:		ret = 1;
","
	free(config);
	free(uri);
	free(simpleuri);
	if (cursor != NULL && (ret = cursor->close(cursor)) != 0) {
		(void)util_err(session, ret, NULL);
		ret = 1;
	}
	return (ret);
}
",117
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_dump.c,"+			    progname, uri, session->strerror(session, ret));",+,"int
util_dump(WT_SESSION *session, int argc, char *argv[])
{
	WT_CURSOR *cursor;
	WT_DECL_RET;
	size_t len;
	int ch, i;
	bool hex, json, reverse;
	char *checkpoint, *config, *p, *simpleuri, *uri;

	hex = json = reverse = false;
	checkpoint = config = simpleuri = uri = NULL;
	cursor = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""c:f:jrx"")) != EOF)
		switch (ch) {
		case 'c':
			checkpoint = __wt_optarg;
			break;
		case 'f':			/* output file */
			if (freopen(__wt_optarg, ""w"", stdout) == NULL)
				return (util_err(
				    session, errno, ""%s: reopen"", __wt_optarg));
			break;
		case 'j':
			json = true;
			break;
		case 'r':
			reverse = true;
			break;
		case 'x':
			hex = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* -j and -x are incompatible. */
	if (hex && json) {
		fprintf(stderr,
		    ""%s: the -j and -x dump options are incompatible\n"",
		    progname);
		goto err;
	}

	/* The remaining argument is the uri. */
	if (argc < 1 || (argc != 1 && !json))
		return (usage());

	if (json &&
	    (dump_json_begin(session) != 0 ||
	    dump_prefix(session, hex, json) != 0))
		goto err;

	for (i = 0; i < argc; i++) {
		if (json && i > 0)
			if (dump_json_separator(session) != 0)
				goto err;
		free(uri);
		free(simpleuri);
		uri = simpleuri = NULL;

		if ((uri = util_uri(session, argv[i], ""table"")) == NULL)
			goto err;

		len =
		    checkpoint == NULL ? 0 : strlen(""checkpoint="") +
		    strlen(checkpoint) + 1;
		len += strlen(json ? ""dump=json"" :
		    (hex ? ""dump=hex"" : ""dump=print""));
		if ((config = malloc(len + 10)) == NULL)
			goto err;
		if (checkpoint == NULL)
			config[0] = '\0';
		else {
			(void)strcpy(config, ""checkpoint="");
			(void)strcat(config, checkpoint);
			(void)strcat(config, "","");
		}
		(void)strcat(config, json ? ""dump=json"" :
		    (hex ? ""dump=hex"" : ""dump=print""));
		if ((ret = session->open_cursor(
		    session, uri, NULL, config, &cursor)) != 0) {
			fprintf(stderr, ""%s: cursor open(%s) failed: %s\n"",
			    progname, uri, session->strerror(session, ret));
			goto err;
		}

		if ((simpleuri = strdup(uri)) == NULL) {
			(void)util_err(session, errno, NULL);
			goto err;
		}
		if ((p = strchr(simpleuri, '(')) != NULL)
			*p = '\0';
		if (dump_config(session, simpleuri, cursor, hex, json) != 0)
			goto err;

		if (dump_record(cursor, reverse, json) != 0)
			goto err;
		if (json && dump_json_table_end(session) != 0)
			goto err;

		ret = cursor->close(cursor);
		cursor = NULL;
		if (ret != 0) {
			(void)util_err(session, ret, NULL);
			goto err;
		}
	}
	if (json && dump_json_end(session) != 0)
		goto err;

	if (0) {
err:		ret = 1;
	}

	free(config);
	free(uri);
	free(simpleuri);
	if (cursor != NULL && (ret = cursor->close(cursor)) != 0) {
		(void)util_err(session, ret, NULL);
		ret = 1;
	}
	return (ret);
}
","int
util_dump(WT_SESSION *session, int argc, char *argv[])
{
	WT_CURSOR *cursor;
	WT_DECL_RET;
	size_t len;
	int ch, i;
	bool hex, json, reverse;
	char *checkpoint, *config, *p, *simpleuri, *uri;

	hex = json = reverse = false;
	checkpoint = config = simpleuri = uri = NULL;
	cursor = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""c:f:jrx"")) != EOF)
		switch (ch) {
		case 'c':
			checkpoint = __wt_optarg;
			break;
		case 'f':			/* output file */
			if (freopen(__wt_optarg, ""w"", stdout) == NULL)
				return (util_err(
				    session, errno, ""%s: reopen"", __wt_optarg));
			break;
		case 'j':
			json = true;
			break;
		case 'r':
			reverse = true;
			break;
		case 'x':
			hex = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* -j and -x are incompatible. */
	if (hex && json) {
		fprintf(stderr,
		    ""%s: the -j and -x dump options are incompatible\n"",
		    progname);
		goto err;
	}

	/* The remaining argument is the uri. */
	if (argc < 1 || (argc != 1 && !json))
		return (usage());

	if (json &&
	    (dump_json_begin(session) != 0 ||
	    dump_prefix(session, hex, json) != 0))
		goto err;

	for (i = 0; i < argc; i++) {
		if (json && i > 0)
			if (dump_json_separator(session) != 0)
				goto err;
		free(uri);
		free(simpleuri);
		uri = simpleuri = NULL;

		if ((uri = util_uri(session, argv[i], ""table"")) == NULL)
			goto err;

		len =
		    checkpoint == NULL ? 0 : strlen(""checkpoint="") +
		    strlen(checkpoint) + 1;
		len += strlen(json ? ""dump=json"" :
		    (hex ? ""dump=hex"" : ""dump=print""));
		if ((config = malloc(len + 10)) == NULL)
			goto err;
		if (checkpoint == NULL)
			config[0] = '\0';
		else {
			(void)strcpy(config, ""checkpoint="");
			(void)strcat(config, checkpoint);
			(void)strcat(config, "","");
		}
		(void)strcat(config, json ? ""dump=json"" :
		    (hex ? ""dump=hex"" : ""dump=print""));
		if ((ret = session->open_cursor(
		    session, uri, NULL, config, &cursor)) != 0) {
			fprintf(stderr, ""%s: cursor open(%s) failed: %s\n"",
			    progname, uri, session->strerror(session, ret));
			goto err;
		}

		if ((simpleuri = strdup(uri)) == NULL) {
			(void)util_err(session, errno, NULL);
			goto err;
		}
		if ((p = strchr(simpleuri, '(')) != NULL)
			*p = '\0';
		if (dump_config(session, simpleuri, cursor, hex, json) != 0)
			goto err;

		if (dump_record(cursor, reverse, json) != 0)
			goto err;
		if (json && dump_json_table_end(session) != 0)
			goto err;

		ret = cursor->close(cursor);
		cursor = NULL;
		if (ret != 0) {
			(void)util_err(session, ret, NULL);
			goto err;
		}
	}
	if (json && dump_json_end(session) != 0)
		goto err;

	if (0) {
err:		ret = 1;
	}
","	free(config);
	free(uri);
	free(simpleuri);
	if (cursor != NULL && (ret = cursor->close(cursor)) != 0) {
		(void)util_err(session, ret, NULL);
		ret = 1;
	}
	return (ret);
}
",118
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_list.c,"-	ret = list_print(session, name, cflag, vflag);",-,"int
util_list(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	bool cflag, vflag;
	char *uri;

	cflag = vflag = false;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""cv"")) != EOF)
		switch (ch) {
		case 'c':
			cflag = true;
			break;
		case 'v':
			vflag = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	switch (argc) {
	case 0:
		break;
	case 1:
		if ((uri = util_uri(session, *argv, ""table"")) == NULL)
			return (1);
		break;
	default:
		return (usage());
	}

	ret = list_print(session, uri, cflag, vflag);

	free(uri);
	return (ret);
}
","int
util_list(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	bool cflag, vflag;
	char *uri;

	cflag = vflag = false;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""cv"")) != EOF)
		switch (ch) {
		case 'c':
			cflag = true;
			break;
		case 'v':
			vflag = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	switch (argc) {
	case 0:
","	case 1:
		if ((uri = util_uri(session, *argv, ""table"")) == NULL)
			return (1);
		break;
	default:
		return (usage());
	}

	ret = list_print(session, uri, cflag, vflag);

	free(uri);
	return (ret);
}
",28
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_list.c,"+	ret = list_print(session, uri, cflag, vflag);",+,"int
util_list(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	bool cflag, vflag;
	char *uri;

	cflag = vflag = false;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""cv"")) != EOF)
		switch (ch) {
		case 'c':
			cflag = true;
			break;
		case 'v':
			vflag = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	switch (argc) {
	case 0:
		break;
	case 1:
		if ((uri = util_uri(session, *argv, ""table"")) == NULL)
			return (1);
		break;
	default:
		return (usage());
	}

	ret = list_print(session, uri, cflag, vflag);

	free(uri);
	return (ret);
}
","int
util_list(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	bool cflag, vflag;
	char *uri;

	cflag = vflag = false;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""cv"")) != EOF)
		switch (ch) {
		case 'c':
			cflag = true;
			break;
		case 'v':
			vflag = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	switch (argc) {
	case 0:
		break;
	case 1:
		if ((uri = util_uri(session, *argv, ""table"")) == NULL)
","		break;
	default:
		return (usage());
	}

	ret = list_print(session, uri, cflag, vflag);

	free(uri);
	return (ret);
}
",31
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_list.c,"-list_print(WT_SESSION *session, const char *name, bool cflag, bool vflag)",-,"int
util_list(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	bool cflag, vflag;
	char *uri;

	cflag = vflag = false;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""cv"")) != EOF)
		switch (ch) {
		case 'c':
			cflag = true;
			break;
		case 'v':
			vflag = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	switch (argc) {
	case 0:
		break;
	case 1:
		if ((uri = util_uri(session, *argv, ""table"")) == NULL)
			return (1);
		break;
	default:
		return (usage());
	}

	ret = list_print(session, uri, cflag, vflag);

	free(uri);
	return (ret);
}
","int
util_list(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	bool cflag, vflag;
	char *uri;

	cflag = vflag = false;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""cv"")) != EOF)
		switch (ch) {
		case 'c':
			cflag = true;
			break;
		case 'v':
			vflag = true;
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	switch (argc) {
	case 0:
		break;
	case 1:
		if ((uri = util_uri(session, *argv, ""table"")) == NULL)
			return (1);
		break;
	default:
		return (usage());
	}

	ret = list_print(session, uri, cflag, vflag);

	free(uri);
	return (ret);
",,41
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_list.c,"+list_print(WT_SESSION *session, const char *uri, bool cflag, bool vflag)",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_list.c,"-		fprintf(stderr, ""%s: %s: not found\n"", progname, name);",-
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_list.c,"+		fprintf(stderr, ""%s: %s: not found\n"", progname, uri);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_printlog.c,"-	ret = __wt_txn_printlog(session, flags);",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""printlog [-x] [-f output-file]\n"",
	    progname, usage_prefix);
	return (1);
}
","static int
usage(void)
{
	(void)fprintf(stderr,
","	    ""printlog [-x] [-f output-file]\n"",
	    progname, usage_prefix);
	return (1);
}
",5
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_printlog.c,"-		fprintf(stderr, ""%s: printlog failed: %s\n"",",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""printlog [-x] [-f output-file]\n"",
	    progname, usage_prefix);
	return (1);
}
","static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""printlog [-x] [-f output-file]\n"",
	    progname, usage_prefix);
","}
",8
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_printlog.c,"-		    progname, session->strerror(session, ret));",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""printlog [-x] [-f output-file]\n"",
	    progname, usage_prefix);
	return (1);
}
","static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""printlog [-x] [-f output-file]\n"",
	    progname, usage_prefix);
	return (1);
",,9
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_printlog.c,"+	if ((ret = __wt_txn_printlog(session, flags)) != 0)",+,"int
util_printlog(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	uint32_t flags;
	int ch;

	flags = 0;
	while ((ch = __wt_getopt(progname, argc, argv, ""f:x"")) != EOF)
		switch (ch) {
		case 'f':			/* output file */
			if (freopen(__wt_optarg, ""w"", stdout) == NULL) {
				fprintf(stderr, ""%s: %s: reopen: %s\n"",
				    progname, __wt_optarg, strerror(errno));
				return (1);
			}
			break;
		case 'x':			/* hex output */
			LF_SET(WT_TXN_PRINTLOG_HEX);
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* There should not be any more arguments. */
	if (argc != 0)
		return (usage());

	if ((ret = __wt_txn_printlog(session, flags)) != 0)
		(void)util_err(session, ret, ""printlog"");

	return (ret);
}
","int
util_printlog(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	uint32_t flags;
	int ch;

	flags = 0;
	while ((ch = __wt_getopt(progname, argc, argv, ""f:x"")) != EOF)
		switch (ch) {
		case 'f':			/* output file */
			if (freopen(__wt_optarg, ""w"", stdout) == NULL) {
				fprintf(stderr, ""%s: %s: reopen: %s\n"",
				    progname, __wt_optarg, strerror(errno));
				return (1);
			}
			break;
		case 'x':			/* hex output */
			LF_SET(WT_TXN_PRINTLOG_HEX);
			break;
		case '?':
","			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* There should not be any more arguments. */
	if (argc != 0)
		return (usage());

	if ((ret = __wt_txn_printlog(session, flags)) != 0)
		(void)util_err(session, ret, ""printlog"");

	return (ret);
}
",22
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_rebalance.c,"-		fprintf(stderr, ""%s: rebalance(%s): %s\n"",",-,"int
util_rebalance(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->rebalance(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.rebalance: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
	return (ret);
}
","int
util_rebalance(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);
","	if ((ret = session->rebalance(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.rebalance: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
	return (ret);
}
",23
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_rebalance.c,"-		    progname, name, session->strerror(session, ret));",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""rebalance uri\n"",
	    progname, usage_prefix);
	return (1);
}
",,"usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""rebalance uri\n"",
	    progname, usage_prefix);
	return (1);
}
",1
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_rebalance.c,"+			printf(""\n"");",+,"int
util_rebalance(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->rebalance(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.rebalance: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
	return (ret);
}
","int
util_rebalance(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->rebalance(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.rebalance: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}
","	free(uri);
	return (ret);
}
",34
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_rebalance.c,"-		printf(""\n"");",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""rebalance uri\n"",
	    progname, usage_prefix);
	return (1);
}
",,"usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""rebalance uri\n"",
	    progname, usage_prefix);
	return (1);
}
",1
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_rename.c,"-		fprintf(stderr, ""%s: rename %s to %s: %s\n"",",-,"int
util_rename(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri, *newuri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining arguments are the object uri and new name. */
	if (argc != 2)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);
	newuri = argv[1];

	if ((ret = session->rename(session, uri, newuri, NULL)) != 0)
		(void)util_err(
		    session, ret, ""session.rename: %s, %s"", uri, newuri);

	free(uri);
	return (ret);
}
","int
util_rename(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri, *newuri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining arguments are the object uri and new name. */
	if (argc != 2)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);
	newuri = argv[1];

	if ((ret = session->rename(session, uri, newuri, NULL)) != 0)
		(void)util_err(
","
	free(uri);
	return (ret);
}
",27
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_rename.c,"-		    progname, uri, newuri, session->strerror(session, ret));",-,"int
util_rename(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri, *newuri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining arguments are the object uri and new name. */
	if (argc != 2)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);
	newuri = argv[1];

	if ((ret = session->rename(session, uri, newuri, NULL)) != 0)
		(void)util_err(
		    session, ret, ""session.rename: %s, %s"", uri, newuri);

	free(uri);
	return (ret);
}
","int
util_rename(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri, *newuri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining arguments are the object uri and new name. */
	if (argc != 2)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);
	newuri = argv[1];

	if ((ret = session->rename(session, uri, newuri, NULL)) != 0)
		(void)util_err(
		    session, ret, ""session.rename: %s, %s"", uri, newuri);
","	free(uri);
	return (ret);
}
",28
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_salvage.c,"-		fprintf(stderr, ""%s: salvage(%s): %s\n"",",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""salvage [-F] uri\n"",
	    progname, usage_prefix);
	return (1);
}
",,"usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""salvage [-F] uri\n"",
	    progname, usage_prefix);
	return (1);
}
",1
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_salvage.c,"-		    progname, name, session->strerror(session, ret));",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""salvage [-F] uri\n"",
	    progname, usage_prefix);
	return (1);
}
","static int
","{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""salvage [-F] uri\n"",
	    progname, usage_prefix);
	return (1);
}
",2
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_salvage.c,"+			printf(""\n"");",+,"int
util_salvage(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	const char *force;
	char *uri;

	force = NULL;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""F"")) != EOF)
		switch (ch) {
		case 'F':
			force = ""force"";
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the file name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""file"")) == NULL)
		return (1);

	if ((ret = session->salvage(session, uri, force)) != 0)
		(void)util_err(session, ret, ""session.salvage: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
	return (ret);
}
","int
util_salvage(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	const char *force;
	char *uri;

	force = NULL;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""F"")) != EOF)
		switch (ch) {
		case 'F':
			force = ""force"";
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the file name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""file"")) == NULL)
		return (1);

	if ((ret = session->salvage(session, uri, force)) != 0)
		(void)util_err(session, ret, ""session.salvage: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
","			printf(""\n"");
	}

	free(uri);
	return (ret);
}
",36
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_salvage.c,"-		printf(""\n"");",-,"int
util_salvage(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	const char *force;
	char *uri;

	force = NULL;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""F"")) != EOF)
		switch (ch) {
		case 'F':
			force = ""force"";
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the file name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""file"")) == NULL)
		return (1);

	if ((ret = session->salvage(session, uri, force)) != 0)
		(void)util_err(session, ret, ""session.salvage: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
	return (ret);
}
","int
util_salvage(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	const char *force;
	char *uri;

	force = NULL;
	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, ""F"")) != EOF)
		switch (ch) {
		case 'F':
			force = ""force"";
			break;
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the file name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""file"")) == NULL)
		return (1);

	if ((ret = session->salvage(session, uri, force)) != 0)
		(void)util_err(session, ret, ""session.salvage: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
","}
",41
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_upgrade.c,"-		fprintf(stderr, ""%s: upgrade(%s): %s\n"",",-,"int
util_upgrade(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->upgrade(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.upgrade: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
	return (ret);
}
","int
util_upgrade(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);
","	if ((ret = session->upgrade(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.upgrade: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
	return (ret);
}
",23
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_upgrade.c,"-		    progname, name, session->strerror(session, ret));",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""upgrade uri\n"",
	    progname, usage_prefix);
	return (1);
}
",,"usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""upgrade uri\n"",
	    progname, usage_prefix);
	return (1);
}
",1
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_upgrade.c,"+			printf(""\n"");",+,"int
util_upgrade(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->upgrade(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.upgrade: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}

	free(uri);
	return (ret);
}
","int
util_upgrade(WT_SESSION *session, int argc, char *argv[])
{
	WT_DECL_RET;
	int ch;
	char *uri;

	uri = NULL;
	while ((ch = __wt_getopt(progname, argc, argv, """")) != EOF)
		switch (ch) {
		case '?':
		default:
			return (usage());
		}
	argc -= __wt_optind;
	argv += __wt_optind;

	/* The remaining argument is the table name. */
	if (argc != 1)
		return (usage());
	if ((uri = util_uri(session, *argv, ""table"")) == NULL)
		return (1);

	if ((ret = session->upgrade(session, uri, NULL)) != 0)
		(void)util_err(session, ret, ""session.upgrade: %s"", uri);
	else {
		/*
		 * Verbose configures a progress counter, move to the next
		 * line.
		 */
		if (verbose)
			printf(""\n"");
	}
","	free(uri);
	return (ret);
}
",34
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_upgrade.c,"-		printf(""\n"");",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""upgrade uri\n"",
	    progname, usage_prefix);
	return (1);
}
",,"usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""upgrade uri\n"",
	    progname, usage_prefix);
	return (1);
}
",1
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_verify.c,"-		fprintf(stderr, ""%s: verify(%s): %s\n"",",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""verify %s\n"",
	    progname, usage_prefix,
	    ""[-d dump_address | dump_blocks | dump_layout | ""
	    ""dump_offsets=#,# | dump_pages] uri"");
	return (1);
}
","static int
usage(void)
{
","	    ""usage: %s %s ""
	    ""verify %s\n"",
	    progname, usage_prefix,
	    ""[-d dump_address | dump_blocks | dump_layout | ""
	    ""dump_offsets=#,# | dump_pages] uri"");
	return (1);
}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_verify.c,"-		    progname, name, session->strerror(session, ret));",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""verify %s\n"",
	    progname, usage_prefix,
	    ""[-d dump_address | dump_blocks | dump_layout | ""
	    ""dump_offsets=#,# | dump_pages] uri"");
	return (1);
}
","static int
usage(void)
{
	(void)fprintf(stderr,
","	    ""verify %s\n"",
	    progname, usage_prefix,
	    ""[-d dump_address | dump_blocks | dump_layout | ""
	    ""dump_offsets=#,# | dump_pages] uri"");
	return (1);
}
",5
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_verify.c,"+			printf(""\n"");",+,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""verify %s\n"",
	    progname, usage_prefix,
	    ""[-d dump_address | dump_blocks | dump_layout | ""
	    ""dump_offsets=#,# | dump_pages] uri"");
	return (1);
}
",,"usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""verify %s\n"",
	    progname, usage_prefix,
	    ""[-d dump_address | dump_blocks | dump_layout | ""
	    ""dump_offsets=#,# | dump_pages] uri"");
	return (1);
}
",1
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/src/utilities/util_verify.c,"-		printf(""\n"");",-,"static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
	    ""verify %s\n"",
	    progname, usage_prefix,
	    ""[-d dump_address | dump_blocks | dump_layout | ""
	    ""dump_offsets=#,# | dump_pages] uri"");
	return (1);
}
","static int
usage(void)
{
	(void)fprintf(stderr,
	    ""usage: %s %s ""
","	    progname, usage_prefix,
	    ""[-d dump_address | dump_blocks | dump_layout | ""
	    ""dump_offsets=#,# | dump_pages] uri"");
	return (1);
}
",6
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+		testutil_assert(key == key_got);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+		testutil_assert(key == key_got);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+			printf(""checked %"" PRIu64 ""/%"" PRIu64 ""\n"", count,",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""checked %"" PRIu64 ""/%"" PRIu64 ""\n"", count, nrecords);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(count > 0);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(ret == WT_NOTFOUND);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(maincur2->next(maincur2) == WT_NOTFOUND);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(count == idxcount);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(count == idxcount);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(count == idxcount);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(v0 == v0_got);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(v1 == v1_got);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(v2 == v2_got);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	testutil_assert(strcmp(big, big_got) == 0);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(ret == WT_NOTFOUND);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	snprintf(value, sizeof(value), ""%"" PRIu64, allow_writes);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	snprintf(value, sizeof(value), ""%"" PRIu64, allow_reads);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	snprintf(sarg, sizeof(sarg), ""%"" PRIu64, nops);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	snprintf(rarg, sizeof(rarg), ""%"" PRIu64, opts->nrecords);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(narg <= MAX_ARGS);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""running a separate process with %"" PRIu64",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""process exited %d\n"", estatus);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""Determining best range of operations until failure, """,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(mid > 1 && mid < MAX_OP_RANGE - 1);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""Retesting around %"" PRIu64 "" operations.\n"",",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(got_failure);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+	testutil_assert(got_success);,+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""running: "");",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+			printf(""%s "", *arg);",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""\n"");",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);",+,"static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
","static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
","	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
",21
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	testutil_assert(freopen(filename, ""a"", stderr) != NULL);",+,"static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
","static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
","	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
",22
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);",+,"static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
","static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
","	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
",23
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	testutil_assert(freopen(filename, ""a"", stdout) != NULL);",+,"static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
","static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
","	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
",24
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+	snprintf(config, sizeof(config),",+,"static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
	snprintf(config, sizeof(config),
	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
","static int
subtest_main(int argc, char *argv[], bool close_test)
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	char config[1024], filename[1024];
	struct rlimit rlim;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	memset(&rlim, 0, sizeof(rlim));

	/* No core files during fault injection tests. */
	testutil_check(setrlimit(RLIMIT_CORE, &rlim));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	/* Redirect stderr, stdout. */
	sprintf(filename, ""%s/%s"", opts->home, STDERR_FILE);
	testutil_assert(freopen(filename, ""a"", stderr) != NULL);
	sprintf(filename, ""%s/%s"", opts->home, STDOUT_FILE);
	testutil_assert(freopen(filename, ""a"", stdout) != NULL);
","	    ""create,cache_size=250M,log=(enabled),""
	    ""transaction_sync=(enabled,method=none),extensions=(""
	    WT_FAIL_FS_LIB
	    ""=(early_load,config={environment=true,verbose=true})]"");

	testutil_check(wiredtiger_open(opts->home, NULL, config, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(session->create(session, ""table:subtest"",
	    ""key_format=i,value_format=iiiS,""
	    ""columns=(id,v0,v1,v2,big)""));

	testutil_check(session->create(session, ""table:subtest2"",
	    ""key_format=i,value_format=i""));

	testutil_check(session->create(session, ""index:subtest:v0"",
	    ""columns=(v0)""));
	testutil_check(session->create(session, ""index:subtest:v1"",
	    ""columns=(v1)""));
	testutil_check(session->create(session, ""index:subtest:v2"",
	    ""columns=(v2)""));

	testutil_check(session->close(session, NULL));

	subtest_populate(opts, close_test);

	testutil_cleanup(opts);

	return (0);
}
",25
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+			fprintf(stderr, ""  BAD RETURN %d for \""%s\""\n"", \",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+			printf(""  %"" PRIu64 ""/%"" PRIu64 ""\n"",",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+				printf(""checkpoint failed (expected).\n"");",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+			fprintf(stderr, ""exit early.\n"");",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+			fprintf(stderr, ""closing after failure.\n"");",+
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,+			testutil_assert(false);,+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	uint64_t nresults;
	const char *debugger;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	debugger = NULL;

	testutil_check(testutil_parse_opts(argc, argv, opts));
	argc -= __wt_optind;
	argv += __wt_optind;
	if (opts->nrecords == 0)
		opts->nrecords = 50000;

	while (argc > 0) {
		if (strcmp(argv[0], ""subtest"") == 0)
			return (subtest_main(argc, argv, false));
		else if (strcmp(argv[0], ""subtest_close"") == 0)
			return (subtest_main(argc, argv, true));
		else if (strcmp(argv[0], ""gdb"") == 0)
			debugger = ""/usr/bin/gdb"";
		else
			testutil_assert(false);
		argc--;
		argv++;
	}
	if (opts->verbose) {
		printf(""Number of operations until failure: %"" PRIu64
		    ""  (change with -o N)\n"", opts->nops);
		printf(""Number of records: %"" PRIu64
		    ""  (change with -n N)\n"", opts->nrecords);
	}
	if (opts->nops == 0) {
		run_check_subtest_range(opts, debugger, false);
		run_check_subtest_range(opts, debugger, true);
	} else
		run_check_subtest(opts, debugger, opts->nops,
		    opts->nrecords, &nresults);

	testutil_clean_work_dir(opts->home);
	testutil_cleanup(opts);

	return (0);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	uint64_t nresults;
	const char *debugger;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	debugger = NULL;

	testutil_check(testutil_parse_opts(argc, argv, opts));
	argc -= __wt_optind;
	argv += __wt_optind;
	if (opts->nrecords == 0)
		opts->nrecords = 50000;

	while (argc > 0) {
		if (strcmp(argv[0], ""subtest"") == 0)
			return (subtest_main(argc, argv, false));
		else if (strcmp(argv[0], ""subtest_close"") == 0)
			return (subtest_main(argc, argv, true));
		else if (strcmp(argv[0], ""gdb"") == 0)
			debugger = ""/usr/bin/gdb"";
		else
","		argc--;
		argv++;
	}
	if (opts->verbose) {
		printf(""Number of operations until failure: %"" PRIu64
		    ""  (change with -o N)\n"", opts->nops);
		printf(""Number of records: %"" PRIu64
		    ""  (change with -n N)\n"", opts->nrecords);
	}
	if (opts->nops == 0) {
		run_check_subtest_range(opts, debugger, false);
		run_check_subtest_range(opts, debugger, true);
	} else
		run_check_subtest(opts, debugger, opts->nops,
		    opts->nrecords, &nresults);

	testutil_clean_work_dir(opts->home);
	testutil_cleanup(opts);

	return (0);
}
",28
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""Number of operations until failure: %"" PRIu64",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	uint64_t nresults;
	const char *debugger;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	debugger = NULL;

	testutil_check(testutil_parse_opts(argc, argv, opts));
	argc -= __wt_optind;
	argv += __wt_optind;
	if (opts->nrecords == 0)
		opts->nrecords = 50000;

	while (argc > 0) {
		if (strcmp(argv[0], ""subtest"") == 0)
			return (subtest_main(argc, argv, false));
		else if (strcmp(argv[0], ""subtest_close"") == 0)
			return (subtest_main(argc, argv, true));
		else if (strcmp(argv[0], ""gdb"") == 0)
			debugger = ""/usr/bin/gdb"";
		else
			testutil_assert(false);
		argc--;
		argv++;
	}
	if (opts->verbose) {
		printf(""Number of operations until failure: %"" PRIu64
		    ""  (change with -o N)\n"", opts->nops);
		printf(""Number of records: %"" PRIu64
		    ""  (change with -n N)\n"", opts->nrecords);
	}
	if (opts->nops == 0) {
		run_check_subtest_range(opts, debugger, false);
		run_check_subtest_range(opts, debugger, true);
	} else
		run_check_subtest(opts, debugger, opts->nops,
		    opts->nrecords, &nresults);

	testutil_clean_work_dir(opts->home);
	testutil_cleanup(opts);

	return (0);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	uint64_t nresults;
	const char *debugger;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	debugger = NULL;

	testutil_check(testutil_parse_opts(argc, argv, opts));
	argc -= __wt_optind;
	argv += __wt_optind;
	if (opts->nrecords == 0)
		opts->nrecords = 50000;

	while (argc > 0) {
		if (strcmp(argv[0], ""subtest"") == 0)
			return (subtest_main(argc, argv, false));
		else if (strcmp(argv[0], ""subtest_close"") == 0)
			return (subtest_main(argc, argv, true));
		else if (strcmp(argv[0], ""gdb"") == 0)
			debugger = ""/usr/bin/gdb"";
		else
			testutil_assert(false);
		argc--;
		argv++;
	}
	if (opts->verbose) {
","		    ""  (change with -o N)\n"", opts->nops);
		printf(""Number of records: %"" PRIu64
		    ""  (change with -n N)\n"", opts->nrecords);
	}
	if (opts->nops == 0) {
		run_check_subtest_range(opts, debugger, false);
		run_check_subtest_range(opts, debugger, true);
	} else
		run_check_subtest(opts, debugger, opts->nops,
		    opts->nrecords, &nresults);

	testutil_clean_work_dir(opts->home);
	testutil_cleanup(opts);

	return (0);
}
",33
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt2909_checkpoint_integrity/main.c,"+		printf(""Number of records: %"" PRIu64",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	uint64_t nresults;
	const char *debugger;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	debugger = NULL;

	testutil_check(testutil_parse_opts(argc, argv, opts));
	argc -= __wt_optind;
	argv += __wt_optind;
	if (opts->nrecords == 0)
		opts->nrecords = 50000;

	while (argc > 0) {
		if (strcmp(argv[0], ""subtest"") == 0)
			return (subtest_main(argc, argv, false));
		else if (strcmp(argv[0], ""subtest_close"") == 0)
			return (subtest_main(argc, argv, true));
		else if (strcmp(argv[0], ""gdb"") == 0)
			debugger = ""/usr/bin/gdb"";
		else
			testutil_assert(false);
		argc--;
		argv++;
	}
	if (opts->verbose) {
		printf(""Number of operations until failure: %"" PRIu64
		    ""  (change with -o N)\n"", opts->nops);
		printf(""Number of records: %"" PRIu64
		    ""  (change with -n N)\n"", opts->nrecords);
	}
	if (opts->nops == 0) {
		run_check_subtest_range(opts, debugger, false);
		run_check_subtest_range(opts, debugger, true);
	} else
		run_check_subtest(opts, debugger, opts->nops,
		    opts->nrecords, &nresults);

	testutil_clean_work_dir(opts->home);
	testutil_cleanup(opts);

	return (0);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	uint64_t nresults;
	const char *debugger;

	if (testutil_disable_long_tests())
		return (0);
	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	debugger = NULL;

	testutil_check(testutil_parse_opts(argc, argv, opts));
	argc -= __wt_optind;
	argv += __wt_optind;
	if (opts->nrecords == 0)
		opts->nrecords = 50000;

	while (argc > 0) {
		if (strcmp(argv[0], ""subtest"") == 0)
			return (subtest_main(argc, argv, false));
		else if (strcmp(argv[0], ""subtest_close"") == 0)
			return (subtest_main(argc, argv, true));
		else if (strcmp(argv[0], ""gdb"") == 0)
			debugger = ""/usr/bin/gdb"";
		else
			testutil_assert(false);
		argc--;
		argv++;
	}
	if (opts->verbose) {
		printf(""Number of operations until failure: %"" PRIu64
		    ""  (change with -o N)\n"", opts->nops);
","		    ""  (change with -n N)\n"", opts->nrecords);
	}
	if (opts->nops == 0) {
		run_check_subtest_range(opts, debugger, false);
		run_check_subtest_range(opts, debugger, true);
	} else
		run_check_subtest(opts, debugger, opts->nops,
		    opts->nrecords, &nresults);

	testutil_clean_work_dir(opts->home);
	testutil_cleanup(opts);

	return (0);
}
",35
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3120_filesys/main.c,"+	snprintf(buf, sizeof(buf),",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

","	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",15
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3120_filesys/main.c,"+	testutil_assert(strcmp(kstr, ""a"") == 0);",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
","	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",45
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3120_filesys/main.c,"+	testutil_assert(strcmp(vstr, ""0"") == 0);",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
","	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",46
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3120_filesys/main.c,"+	testutil_assert(strcmp(kstr, ""b"") == 0);",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
","	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",50
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3120_filesys/main.c,"+	testutil_assert(strcmp(vstr, ""1"") == 0);",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
","	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",51
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3120_filesys/main.c,+	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);,+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
","	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",52
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3120_filesys/main.c,"+	printf(""Success\n"");",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
	printf(""Success\n"");

	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor;
	WT_SESSION *session;
	char *kstr, *vstr;
	char buf[1024];

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	snprintf(buf, sizeof(buf),
	    ""create,extensions=("" WT_FAIL_FS_LIB ""=(early_load=true))"");
	testutil_check(wiredtiger_open(opts->home, NULL, buf, &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->create(session, opts->uri,
	    ""key_format=S,value_format=S""));

	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	cursor->set_key(cursor, ""a"");
	cursor->set_value(cursor, ""0"");
	testutil_check(cursor->insert(cursor));
	cursor->set_key(cursor, ""b"");
	cursor->set_value(cursor, ""1"");
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));

	/* Force to disk and re-open. */
	testutil_check(opts->conn->close(opts->conn, NULL));
	testutil_check(wiredtiger_open(opts->home, NULL, NULL, &opts->conn));

	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));
	testutil_check(session->open_cursor(session, opts->uri, NULL, NULL,
	    &cursor));
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""a"") == 0);
	testutil_assert(strcmp(vstr, ""0"") == 0);
	testutil_check(cursor->next(cursor));
	testutil_check(cursor->get_key(cursor, &kstr));
	testutil_check(cursor->get_value(cursor, &vstr));
	testutil_assert(strcmp(kstr, ""b"") == 0);
	testutil_assert(strcmp(vstr, ""1"") == 0);
	testutil_assert(cursor->next(cursor) == WT_NOTFOUND);
	testutil_check(cursor->close(cursor));
	testutil_check(session->close(session, NULL));
","
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",55
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,+	testutil_assert(test_index >= 0 && test_index <= 4);,+,"static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

","	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",8
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);",+,"static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
","	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",18
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);",+,"static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
","	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",20
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||",+,"static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
","		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",22
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);",+,"static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
","	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",25
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);",+,"static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
","
	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",27
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,+		testutil_assert(ret == WT_NOTFOUND);,+,"static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
","	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",33
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,+		testutil_assert(ret == 0);,+,"static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_str(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	int exact, ret;
	const char *result;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	cursor->set_key(cursor, test_str);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &result));

	if (test_index == 0)
		testutil_assert(strcmp(result, str_01) == 0 && exact > 0);
	else if (test_index == 1)
		testutil_assert(strcmp(result, str_01) == 0 && exact == 0);
	else if (test_index == 2)
		testutil_assert((strcmp(result, str_0123) == 0 && exact > 0) ||
		    (strcmp(result, str_01) == 0 && exact < 0));
	else if (test_index == 3)
		testutil_assert(strcmp(result, str_0123) == 0 && exact == 0);
	else if (test_index == 4)
		testutil_assert(strcmp(result, str_0123) == 0 && exact < 0);

	cursor->set_key(cursor, test_str);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
","}
",35
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,+	testutil_assert(test_index >= 0 && test_index <= 4);,+,"static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

","	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",9
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert(item_str_equal(&item, str_01) && exact > 0);",+,"static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
","	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",22
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert(item_str_equal(&item, str_01) && exact == 0);",+,"static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
","	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",24
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)",+,"static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
","		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",26
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);",+,"static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
","	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",29
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);",+,"static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
","
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",31
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,+		testutil_assert(ret == WT_NOTFOUND);,+,"static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
","	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
",39
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,+		testutil_assert(ret == 0);,+,"static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
		testutil_assert(ret == 0);
}
","static void
search_using_item(WT_CURSOR *cursor, TEST_SET test_set, int test_index)
{
	WT_ITEM item;
	size_t testlen;
	int exact, ret;
	const char *str_01, *str_0123, *test_str;

	testutil_assert(test_index >= 0 && test_index <= 4);
	str_01 = test_set[1];
	str_0123 = test_set[3];
	test_str = test_set[test_index];

	testlen = strlen(test_str) + 1;
	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	testutil_check(cursor->search_near(cursor, &exact));
	testutil_check(cursor->get_key(cursor, &item));

	if (test_index == 0)
		testutil_assert(item_str_equal(&item, str_01) && exact > 0);
	else if (test_index == 1)
		testutil_assert(item_str_equal(&item, str_01) && exact == 0);
	else if (test_index == 2)
		testutil_assert((item_str_equal(&item, str_0123) && exact > 0)
		    || (item_str_equal(&item, str_01) && exact < 0));
	else if (test_index == 3)
		testutil_assert(item_str_equal(&item, str_0123) && exact == 0);
	else if (test_index == 4)
		testutil_assert(item_str_equal(&item, str_0123) && exact < 0);

	item.data = test_str;
	item.size = testlen;
	cursor->set_key(cursor, &item);
	ret = cursor->search(cursor);

	if (test_index == 0 || test_index == 2 || test_index == 4)
		testutil_assert(ret == WT_NOTFOUND);
	else if (test_index == 1 || test_index == 3)
","}
",41
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3135_search_near_collator/main.c,"+		printf(""test set %"" WT_SIZET_FMT ""\n"", i);",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	size_t i;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	/* Add any collators and extractors used by tests */
	testutil_check(opts->conn->add_collator(opts->conn, ""collator_S"",
	    &collator_S, NULL));
	testutil_check(opts->conn->add_collator(opts->conn, ""collator_u"",
	    &collator_u, NULL));
	testutil_check(opts->conn->add_extractor(opts->conn, ""extractor_u"",
	    &extractor_u, NULL));

	for (i = 0; i < TEST_SET_COUNT; i++) {
		printf(""test set %"" WT_SIZET_FMT ""\n"", i);
		test_one_set(session, test_sets[i]);
	}

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_SESSION *session;
	size_t i;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	/* Add any collators and extractors used by tests */
	testutil_check(opts->conn->add_collator(opts->conn, ""collator_S"",
	    &collator_S, NULL));
	testutil_check(opts->conn->add_collator(opts->conn, ""collator_u"",
	    &collator_u, NULL));
	testutil_check(opts->conn->add_extractor(opts->conn, ""extractor_u"",
	    &extractor_u, NULL));

	for (i = 0; i < TEST_SET_COUNT; i++) {
","		test_one_set(session, test_sets[i]);
	}

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",27
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,+	testutil_assert(item->size == sizeof(int32_t));,+,"static int32_t
item_to_int(WT_ITEM *item)
{
	testutil_assert(item->size == sizeof(int32_t));
	return (*(int32_t *)item->data);
}
","static int32_t
item_to_int(WT_ITEM *item)
{
","	return (*(int32_t *)item->data);
}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,+	testutil_assert(itema->size == sizeof(int32_t));,+,"static int
compare_int_items(WT_ITEM *itema, WT_ITEM *itemb)
{
	testutil_assert(itema->size == sizeof(int32_t));
	testutil_assert(itemb->size == sizeof(int32_t));
	return (compare_int(item_to_int(itema), item_to_int(itemb)));
}
","static int
compare_int_items(WT_ITEM *itema, WT_ITEM *itemb)
{
","	testutil_assert(itemb->size == sizeof(int32_t));
	return (compare_int(item_to_int(itema), item_to_int(itemb)));
}
",4
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,+	testutil_assert(itemb->size == sizeof(int32_t));,+,"static int
compare_int_items(WT_ITEM *itema, WT_ITEM *itemb)
{
	testutil_assert(itema->size == sizeof(int32_t));
	testutil_assert(itemb->size == sizeof(int32_t));
	return (compare_int(item_to_int(itema), item_to_int(itemb)));
}
","static int
compare_int_items(WT_ITEM *itema, WT_ITEM *itemb)
{
	testutil_assert(itema->size == sizeof(int32_t));
","	return (compare_int(item_to_int(itema), item_to_int(itemb)));
}
",5
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+print_int_item(const char *str, const WT_ITEM *item)",+,"static void
print_int_item(const char *str, const WT_ITEM *item)
{
	if (item->size > 0) {
		testutil_assert(item->size == sizeof(int32_t));
		printf(""%s%"" PRId32, str, *(int32_t *)item->data);
	} else
		printf(""%s<empty>"", str);
}
","static void
","{
	if (item->size > 0) {
		testutil_assert(item->size == sizeof(int32_t));
		printf(""%s%"" PRId32, str, *(int32_t *)item->data);
	} else
		printf(""%s<empty>"", str);
}
",2
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,+		testutil_assert(item->size == sizeof(int32_t));,+,"static void
print_int_item(const char *str, const WT_ITEM *item)
{
	if (item->size > 0) {
		testutil_assert(item->size == sizeof(int32_t));
		printf(""%s%"" PRId32, str, *(int32_t *)item->data);
	} else
		printf(""%s<empty>"", str);
}
","static void
print_int_item(const char *str, const WT_ITEM *item)
{
	if (item->size > 0) {
","		printf(""%s%"" PRId32, str, *(int32_t *)item->data);
	} else
		printf(""%s<empty>"", str);
}
",5
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+		printf(""%s%"" PRId32, str, *(int32_t *)item->data);",+,"static void
print_int_item(const char *str, const WT_ITEM *item)
{
	if (item->size > 0) {
		testutil_assert(item->size == sizeof(int32_t));
		printf(""%s%"" PRId32, str, *(int32_t *)item->data);
	} else
		printf(""%s<empty>"", str);
}
","static void
print_int_item(const char *str, const WT_ITEM *item)
{
	if (item->size > 0) {
		testutil_assert(item->size == sizeof(int32_t));
","	} else
		printf(""%s<empty>"", str);
}
",6
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+		printf(""%s<empty>"", str);",+,"static void
print_int_item(const char *str, const WT_ITEM *item)
{
	if (item->size > 0) {
		testutil_assert(item->size == sizeof(int32_t));
		printf(""%s%"" PRId32, str, *(int32_t *)item->data);
	} else
		printf(""%s<empty>"", str);
}
","static void
print_int_item(const char *str, const WT_ITEM *item)
{
	if (item->size > 0) {
		testutil_assert(item->size == sizeof(int32_t));
		printf(""%s%"" PRId32, str, *(int32_t *)item->data);
	} else
","}
",8
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+	print_int_item(""index_compare: index key1 = "", &ikey1);",+,"static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
	print_int_item("", primary key1 = "", &pkey1);
	print_int_item("", index key2 = "", &ikey2);
	print_int_item("", primary key2 = "", &pkey2);
	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
","static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

","	print_int_item("", primary key1 = "", &pkey1);
	print_int_item("", index key2 = "", &ikey2);
	print_int_item("", primary key2 = "", &pkey2);
	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
",13
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+	print_int_item("", primary key1 = "", &pkey1);",+,"static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
	print_int_item("", primary key1 = "", &pkey1);
	print_int_item("", index key2 = "", &ikey2);
	print_int_item("", primary key2 = "", &pkey2);
	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
","static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
","	print_int_item("", index key2 = "", &ikey2);
	print_int_item("", primary key2 = "", &pkey2);
	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
",14
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+	print_int_item("", index key2 = "", &ikey2);",+,"static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
	print_int_item("", primary key1 = "", &pkey1);
	print_int_item("", index key2 = "", &ikey2);
	print_int_item("", primary key2 = "", &pkey2);
	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
","static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
	print_int_item("", primary key1 = "", &pkey1);
","	print_int_item("", primary key2 = "", &pkey2);
	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
",15
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+	print_int_item("", primary key2 = "", &pkey2);",+,"static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
	print_int_item("", primary key1 = "", &pkey1);
	print_int_item("", index key2 = "", &ikey2);
	print_int_item("", primary key2 = "", &pkey2);
	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
","static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
	print_int_item("", primary key1 = "", &pkey1);
	print_int_item("", index key2 = "", &ikey2);
","	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
",16
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+	printf(""\n"");",+,"static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
	print_int_item("", primary key1 = "", &pkey1);
	print_int_item("", index key2 = "", &ikey2);
	print_int_item("", primary key2 = "", &pkey2);
	printf(""\n"");

	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
","static int
index_compare(WT_COLLATOR *collator, WT_SESSION *session,
	      const WT_ITEM *key1, const WT_ITEM *key2, int *cmp)
{
	WT_ITEM ikey1, pkey1, ikey2, pkey2;

	(void)collator;
	testutil_check(wiredtiger_struct_unpack(session,
	    key1->data, key1->size, ""uu"", &ikey1, &pkey1));
	testutil_check(wiredtiger_struct_unpack(session,
	    key2->data, key2->size, ""uu"", &ikey2, &pkey2));

	print_int_item(""index_compare: index key1 = "", &ikey1);
	print_int_item("", primary key1 = "", &pkey1);
	print_int_item("", index key2 = "", &ikey2);
	print_int_item("", primary key2 = "", &pkey2);
","
	if ((*cmp = compare_int_items(&ikey1, &ikey2)) != 0)
		return (0);

	if (pkey1.size != 0 && pkey2.size != 0)
		*cmp = compare_int_items(&pkey1, &pkey2);
	else if (pkey1.size != 0)
		*cmp = 1;
	else if (pkey2.size != 0)
		*cmp = -1;
	else
		*cmp = 0;

	return (0);
}
",17
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+	printf(""adding new record\n"");",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

","	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",28
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+	printf(""positioning index cursor\n"");",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

","
	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",43
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,"+	printf(""duplicating cursor\n"");",+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

","	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",50
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,+	testutil_assert(item_to_int(&got) == 17);,+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
","	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",54
"Import wiredtiger: e1bcc30da91eedd0b17cebb725cc7e607ffa2340 from branch mongodb-3.6

ref: 48a3cbc17f..e1bcc30da9
for: 3.5.4

WT-2790       Fix a text case false positive in test_sweep01
WT-2909       Create automatable test verifying checkpoint integrity after errors
WT-3088       bug: Don't evict a page with refs visible to readers after a split
WT-3097       Race on reconfigure or shutdown can lead to waiting for statistics log server
WT-3111       util_create() doesnt free memory assigned to ""uri""
WT-3113       Add a verbose mode to dump the cache when eviction is stuck
WT-3115       Change the dhandle lock to a read/write lock
WT-3120       Fix ordering problem in connection_close for filesystem loaded in an extension
WT-3135       search_near() for index with custom collator
WT-3137       Hang in __log_slot_join/__log_slot_switch_internal
WT-3139       Enhance wtperf to support periodic table scans
WT-3144       bug fix: random cursor returns not-found when descending to an empty page
WT-3148       Improve eviction efficiency with many small trees
WT-3149       Change eviction to start new walks from a random place in the tree
WT-3150       Reduce impact of checkpoints on eviction server
WT-3152       Convert table lock from a spinlock to a read write lock
WT-3156       Assertion in log_write fires after write failure
WT-3157       checkpoint/transaction integrity issue when writes fail.
WT-3159       Incorrect key for index containing multiple variable sized entries
WT-3161       checkpoint hang after write failure injection.
WT-3164       Ensure all relevant btree fields are reset on checkpoint error
WT-3170       Clear the eviction walk point while populating from a tree
WT-3173       Add runtime detection for s390x CRC32 hardware support
WT-3174       Coverity/lint cleanup
WT-3175       New hang in internal page split
WT-3179       Test bug: clang sanitizer failure in fail_fs
WT-3180       Fault injection tests should only run as ""long"" tests and should not create core files
WT-3184       Problem duplicating index cursor with custom collator
WT-3186       Fix error path and panic detection in logging loops",src/third_party/wiredtiger/test/csuite/wt3184_dup_index_collator/main.c,+	testutil_assert(item_to_int(&got) == 17);,+,"int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
	testutil_assert(item_to_int(&got) == 17);

	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
","int
main(int argc, char *argv[])
{
	TEST_OPTS *opts, _opts;
	WT_CURSOR *cursor, *cursor1;
	WT_ITEM got, k, v;
	WT_SESSION *session;
	int32_t ki, vi;

	opts = &_opts;
	memset(opts, 0, sizeof(*opts));
	testutil_check(testutil_parse_opts(argc, argv, opts));
	testutil_make_work_dir(opts->home);

	testutil_check(wiredtiger_open(opts->home, NULL, ""create"",
	    &opts->conn));
	testutil_check(
	    opts->conn->open_session(opts->conn, NULL, NULL, &session));

	testutil_check(opts->conn->add_collator(opts->conn, ""index_coll"",
	    &index_coll, NULL));

	testutil_check(session->create(session,
	    ""table:main"", ""key_format=u,value_format=u,columns=(k,v)""));
	testutil_check(session->create(session,
	    ""index:main:index"", ""columns=(v),collator=index_coll""));

	printf(""adding new record\n"");
	testutil_check(session->open_cursor(session, ""table:main"", NULL, NULL,
	    &cursor));

	ki = 13;
	vi = 17;

	k.data = &ki; k.size = sizeof(ki);
	v.data = &vi; v.size = sizeof(vi);

	cursor->set_key(cursor, &k);
	cursor->set_value(cursor, &v);
	testutil_check(cursor->insert(cursor));
	testutil_check(cursor->close(cursor));

	printf(""positioning index cursor\n"");

	testutil_check(session->open_cursor(session, ""index:main:index"", NULL,
	    NULL, &cursor));
	cursor->set_key(cursor, &v);
	testutil_check(cursor->search(cursor));

	printf(""duplicating cursor\n"");
	testutil_check(session->open_cursor(session, NULL, cursor, NULL,
	    &cursor1));
	cursor->get_value(cursor, &got);
	testutil_assert(item_to_int(&got) == 17);
	cursor1->get_value(cursor1, &got);
","
	testutil_check(session->close(session, NULL));
	testutil_cleanup(opts);
	return (EXIT_SUCCESS);
}
",56
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/async_results_merger_test.cpp,-    ASSERT(statusWithNext.isOK());,-,"    void scheduleErrorResponse(ResponseStatus rs) {
        invariant(!rs.isOK());
        rs.elapsedMillis = Milliseconds(0);
        executor::NetworkInterfaceMock* net = network();
        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
        net->scheduleResponse(net->getNextReadyRequest(), net->now(), rs);
        net->runReadyNetworkOperations();
        net->exitNetwork();
    }
","    void scheduleErrorResponse(ResponseStatus rs) {
        invariant(!rs.isOK());
        rs.elapsedMillis = Milliseconds(0);
        executor::NetworkInterfaceMock* net = network();
        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
","        net->runReadyNetworkOperations();
        net->exitNetwork();
    }
",7
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/async_results_merger_test.cpp,+    ASSERT(!statusWithNext.isOK());,+,"    void scheduleErrorResponse(ResponseStatus rs) {
        invariant(!rs.isOK());
        rs.elapsedMillis = Milliseconds(0);
        executor::NetworkInterfaceMock* net = network();
        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
        net->scheduleResponse(net->getNextReadyRequest(), net->now(), rs);
        net->runReadyNetworkOperations();
        net->exitNetwork();
    }
","    void scheduleErrorResponse(ResponseStatus rs) {
        invariant(!rs.isOK());
        rs.elapsedMillis = Milliseconds(0);
        executor::NetworkInterfaceMock* net = network();
        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
        net->scheduleResponse(net->getNextReadyRequest(), net->now(), rs);
","        net->exitNetwork();
    }
",8
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/async_results_merger_test.cpp,"+    ASSERT_EQ(statusWithNext.getStatus().code(),",+,"    void scheduleErrorResponse(ResponseStatus rs) {
        invariant(!rs.isOK());
        rs.elapsedMillis = Milliseconds(0);
        executor::NetworkInterfaceMock* net = network();
        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
        net->scheduleResponse(net->getNextReadyRequest(), net->now(), rs);
        net->runReadyNetworkOperations();
        net->exitNetwork();
    }
","    void scheduleErrorResponse(ResponseStatus rs) {
        invariant(!rs.isOK());
        rs.elapsedMillis = Milliseconds(0);
        executor::NetworkInterfaceMock* net = network();
        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
        net->scheduleResponse(net->getNextReadyRequest(), net->now(), rs);
        net->runReadyNetworkOperations();
","    }
",9
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/async_results_merger_test.cpp,-    ASSERT(viewDef);,-,"    void blackHoleNextRequest() {
        executor::NetworkInterfaceMock* net = network();
        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
        net->blackHole(net->getNextReadyRequest());
        net->exitNetwork();
    }
","    void blackHoleNextRequest() {
","        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
        net->blackHole(net->getNextReadyRequest());
        net->exitNetwork();
    }
",2
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/async_results_merger_test.cpp,+    ASSERT(_params->viewDefinition);,+,"    void blackHoleNextRequest() {
        executor::NetworkInterfaceMock* net = network();
        net->enterNetwork();
        ASSERT_TRUE(net->hasReadyRequests());
        net->blackHole(net->getNextReadyRequest());
        net->exitNetwork();
    }
","    void blackHoleNextRequest() {
        executor::NetworkInterfaceMock* net = network();
","        ASSERT_TRUE(net->hasReadyRequests());
        net->blackHole(net->getNextReadyRequest());
        net->exitNetwork();
    }
",3
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/cluster_client_cursor_impl_test.cpp,-    ASSERT_OK(result.getStatus());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/cluster_client_cursor_impl_test.cpp,-    ASSERT(!result.getValue().getResult());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/cluster_client_cursor_impl_test.cpp,-    ASSERT(result.getValue().getViewDefinition());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/cluster_client_cursor_impl_test.cpp,"-    ASSERT_BSONOBJ_EQ(*result.getValue().getViewDefinition(), viewDef);",-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/cluster_find.cpp,+                                << ErrorCodes::errorString(next.getStatus().code())};,+
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/router_stage_limit_test.cpp,-    ASSERT_OK(result.getStatus());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/router_stage_limit_test.cpp,-    ASSERT(!result.getValue().getResult());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/router_stage_limit_test.cpp,-    ASSERT(result.getValue().getViewDefinition());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/router_stage_limit_test.cpp,"-    ASSERT_BSONOBJ_EQ(*result.getValue().getViewDefinition(), viewDef);",-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/router_stage_skip_test.cpp,-    ASSERT_OK(result.getStatus());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/router_stage_skip_test.cpp,-    ASSERT(!result.getValue().getResult());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/router_stage_skip_test.cpp,-    ASSERT(result.getValue().getViewDefinition());,-
SERVER-27973 make ClusterClientCursor own ClusterClientCursorParams and pass the params by reference to RouterStageMerge/ARM,src/mongo/s/query/router_stage_skip_test.cpp,"-    ASSERT_BSONOBJ_EQ(*result.getValue().getViewDefinition(),",-
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/member_config_test.cpp,"+    ASSERT_EQUALS(0.0, mc.getPriority());",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/member_config_test.cpp,"+    ASSERT_EQUALS(1.0, mc.getPriority());",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_OK(zeroConfig.initialize(BSON(""_id""",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_OK(oneConfig.initialize(BSON(""_id""",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_OK(twoConfig.initialize(BSON(""_id""",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_OK(,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_OK(,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_EQUALS(,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_OK(oldConfig.initialize(BSON(""_id""",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_OK(zeroConfig.initialize(BSON(""_id""",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_OK(oneConfig.initialize(BSON(""_id""",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_OK(twoConfig.initialize(BSON(""_id""",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_OK(oldConfig.validate());,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_OK(zeroConfig.validate());,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_OK(oneConfig.validate());,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_OK(twoConfig.validate());,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_OK(validateConfigForReconfig(,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,+    ASSERT_OK(validateConfigForReconfig(,+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_EQUALS(ErrorCodes::InvalidReplicaSetConfig,",+
"SERVER-19491 Require that arbiters have priority 0 or 1.

Configurations with arbiters having priority 1 will be silently changed to 0.
Configurations with arbiters having priority other than 0 or 1 will be
rejected during initiate or reconfigure.",src/mongo/db/repl/replica_set_config_checks_test.cpp,"+    ASSERT_EQUALS(ErrorCodes::InvalidReplicaSetConfig,",+
