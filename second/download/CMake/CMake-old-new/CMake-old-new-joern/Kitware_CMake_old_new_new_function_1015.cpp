bool cmQtAutomoc::RunAutomocQt4()
{
  if (!cmsys::SystemTools::FileExists(this->OutMocCppFilename.c_str())
    || (this->OldMocDefinitionsStr != this->Join(this->MocDefinitions, ' ')))
    {
    this->GenerateAll = true;
    }

  // the program goes through all .cpp files to see which moc files are
  // included. It is not really interesting how the moc file is named, but
  // what file the moc is created from. Once a moc is included the same moc
  // may not be included in the _automoc.cpp file anymore. OTOH if there's a
  // header containing Q_OBJECT where no corresponding moc file is included
  // anywhere a moc_<filename>.cpp file is created and included in
  // the _automoc.cpp file.

  // key = moc source filepath, value = moc output filepath
  std::map<std::string, std::string> includedMocs;
  // key = moc source filepath, value = moc output filename
  std::map<std::string, std::string> notIncludedMocs;


  std::vector<std::string> sourceFiles;
  cmSystemTools::ExpandListArgument(this->Sources, sourceFiles);

  for (std::vector<std::string>::const_iterator it = sourceFiles.begin();
       it != sourceFiles.end();
       ++it)
    {
    const std::string &absFilename = *it;
    if (this->Verbose)
      {
      std::cout << "AUTOMOC: Checking " << absFilename << std::endl;
      }
    this->ParseCppFile(absFilename, includedMocs, notIncludedMocs);
    }

  std::vector<std::string> headerFiles;
  cmSystemTools::ExpandListArgument(this->Headers, headerFiles);
  for (std::vector<std::string>::const_iterator it = headerFiles.begin();
       it != headerFiles.end();
       ++it)
    {
    const std::string &absFilename = *it;
    if (this->Verbose)
      {
      std::cout << "AUTOMOC: Checking " << absFilename << std::endl;
      }
    if (includedMocs.find(absFilename) == includedMocs.end()
              && notIncludedMocs.find(absFilename) == notIncludedMocs.end())
      {
      // if this header is not getting processed yet and is explicitly
      // mentioned for the automoc the moc is run unconditionally on the
      // header and the resulting file is included in the _automoc.cpp file
      // (unless there's a .cpp file later on that includes the moc from
      // this header)
      const std::string currentMoc = "moc_" + cmsys::SystemTools::
                         GetFilenameWithoutLastExtension(absFilename) + ".cpp";
      notIncludedMocs[absFilename] = currentMoc;
      }
    }

  // run moc on all the moc's that are #included in source files
  for(std::map<std::string, std::string>::const_iterator
                                                     it = includedMocs.begin();
      it != includedMocs.end();
      ++it)
    {
    this->GenerateMoc(it->first, it->second);
    }

  std::stringstream outStream(std::stringstream::out);
  outStream << "/* This file is autogenerated, do not edit*/\n";

  bool automocCppChanged = false;
  if (notIncludedMocs.empty())
    {
    outStream << "enum some_compilers { need_more_than_nothing };\n";
    }
  else
    {
    // run moc on the remaining headers and include them in
    // the _automoc.cpp file
    for(std::map<std::string, std::string>::const_iterator
                                                  it = notIncludedMocs.begin();
        it != notIncludedMocs.end();
        ++it)
      {
      bool mocSuccess = this->GenerateMoc(it->first, it->second);
      if (mocSuccess)
        {
        automocCppChanged = true;
        }
      outStream << "#include \"" << it->second << "\"\n";
      }
    }

  if (this->RunMocFailed)
    {
    std::cerr << "returning failed.."<< std::endl;
    return false;
    }
  outStream.flush();
  std::string automocSource = outStream.str();
  if (!automocCppChanged)
    {
    // compare contents of the _automoc.cpp file
    const std::string oldContents = this->ReadAll(this->OutMocCppFilename);
    if (oldContents == automocSource)
      {
      // nothing changed: don't touch the _automoc.cpp file
      return true;
      }
    }

  // source file that includes all remaining moc files (_automoc.cpp file)
  std::fstream outfile;
  outfile.open(this->OutMocCppFilename.c_str(),
               std::ios_base::out | std::ios_base::trunc);
  outfile << automocSource;
  outfile.close();

  return true;
}