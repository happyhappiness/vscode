diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/00-RELEASENOTES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/00-RELEASENOTES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/00-RELEASENOTES	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/00-RELEASENOTES	2017-07-14 19:28:42.000000000 +0800
@@ -1,2215 +1,3673 @@
-Redis 3.2 release notes
+Redis 4.0 release notes
 =======================
 
 --------------------------------------------------------------------------------
 Upgrade urgency levels:
 
 LOW:      No need to upgrade unless there are new features you want to use.
 MODERATE: Program an upgrade of the server, but it's not urgent.
 HIGH:     There is a critical bug that may affect a subset of users. Upgrade!
 CRITICAL: There is a critical bug affecting MOST USERS. Upgrade ASAP.
 --------------------------------------------------------------------------------
 
 ================================================================================
-Redis 3.2.11     Released Thu Sep 21 15:47:53 CEST 2017
+Redis 4.0.0     Released Fri Jul 14 13:04:44 CEST 2017
 ================================================================================
 
-Upgrade urgency HIGH: Potentially critical bugs fixed.
+Upgrade urgency CRITICAL: 4.0.0 GA fixes many important bugs.
 
-AOF flush on SHUTDOWN did not cared to really write the AOF buffers
-(not in the kernel but in the Redis process memory) to disk before exiting.
-Calling SHUTDOWN during traffic resulted into not every operation to be
-persisted on disk.
+Dear Redis users,
 
-Oran Agra (and also Buğra Gedik) in commit 8651e5d5:
- Flush append only buffers before existing.
- 1 file changed, 2 insertions(+), 1 deletion(-)
+this is the first stable version of Redis 4.0. There are a number
+of bug fixes and improvements compared to the previous RC, mainly:
 
-================================================================================
-Redis 3.2.10     Released Fri Jul 28 17:49:07 CEST 2017
-================================================================================
+* Different replication fixes to PSYNC2, the new 4.0 replication engine.
+* Modules thread safe contexts were introduced. They are an experimental API right now, but the API is considered to be stable and usable when needed.
+* SLOWLOG now logs the offending client name and address. Note that this is a backward compatibility breakage in case old code assumes that the slowlog entry is composed of exactly three entries.
+* The modules native data types RDB format changed.
+* The AOF check utility is now able to deal with RDB preambles.
+* GEORADIUS_RO and GEORADIUSBYMEMBER_RO variants, not supporting the STORE option, were added in order to allow read-only scaling of such queries.
+* HSET is now variadic, and HMSET is considered deprecated (but will be supported for years to come). Please use HSET in new code.
+* GEORADIUS huge radius (>= ~6000 km) corner cases fixed, certain elements near the edges were not returned.
+* DEBUG DIGEST modules API added.
+* HyperLogLog commands no longer crash on certain input (non HLL) strings.
+* Fixed SLAVEOF inside MULTI/EXEC blocks.
+* Many other minor bug fixes and improvements.
+
+Note that 4.0 is probably one of the most extreme releases of Redis ever
+made in terms of changes inside the internals: all the aggregated data types
+no longer use Redis Objects structures but directly SDS objects, certain
+deletion operations are now threaded, the replication engine was modified
+in many ways. So please handle this release with care. A few patch-level 
+releases will follow in the next weeks and months fixing the important issues
+discovered by the users.
+
+You can read the new set of features below in this file, there are a lot
+of improvements that can make a real difference in real world use cases.
+Also note that Redis 4.0 is, as usually, almost a perfect superset of Redis
+3.2, so it is very rare that compatibility with the past is broken in terms
+of exported commands.
+
+IMPORTANT: Redis Cluster users, please note that, as specified in the list
+of incompatibilities, Redis 4.0 cluster bus protocol is not compatible with
+Redis 3.2, so in order to upgrade, a mass reboot of the instances is needed
+and rolling upgrades are not possible. This change was needed in order to
+add compatibility for Containers/NAT, where the bus port at a fixed offset
+was not an acceptable design, so we had to change many things, resulting
+in the incompatible protocol.
 
-Upgrade urgency MODERATE: This release contains a number of fixes that are not
-                          critical in the general case, but quite important
-                          in certain use cases. Upgrading is suggested but not
-                          mandatory.
+Have fun with Redis 4.0!
+Salvatore
 
-Dear Redis users,
+antirez in commit c29852ff:
+ Modules: fix thread safe context DB selection.
+ 1 file changed, 3 insertions(+)
 
-while 4.0.1 is already out, this is a maintenance release of Redis 3.2.
-It fixes several bugs, the most interesting ones are the following:
+antirez in commit b73f186a:
+ Modules documentation removed from source.
+ 4 files changed, 2830 deletions(-)
+
+antirez in commit 09d93ec9:
+ Markdown generation of Redis Modules API reference improved.
+ 2 files changed, 83 insertions(+), 74 deletions(-)
+
+antirez in commit 87aabb1a:
+ Fix replication of SLAVEOF inside transaction.
+ 2 files changed, 19 insertions(+), 3 deletions(-)
 
-1. INFO server.stat_net_output_bytes field was computed in a wrong way, now
-   the output is correct.
-2. SET with EX/PX options are now propagated correctly in the AOF, using
-   the absolute times.
-3. CLIENT PAUSE was fixed to prevent eviction of keys, so that master and
-   slave continue to be consistent for the time the pause is active.
-4. GEORADIUS(BYMEMBER)_RO variants for read-only operations added.
-5. HyperLogLog sanity detection fixed in an edge case.
-6. Redis Cluster crash due to mis-handling of hidden node flags fixed.
+antirez in commit 44f89d1d:
+ CLUSTER GETKEYSINSLOT: avoid overallocating.
+ 1 file changed, 5 insertions(+)
 
-If you think you may be affected by the above problems, upgrading is a
-good idea.
+antirez in commit 0df24b68:
+ Fix isHLLObjectOrReply() to handle integer encoded strings.
+ 1 file changed, 1 insertion(+)
 
-Have a nice day,
-Salvatore
+antirez in commit 884ceb69:
+ Clients blocked in modules: free argv/argc later.
+ 2 files changed, 15 insertions(+), 3 deletions(-)
+
+antirez in commit ccbdd762:
+ Event loop: call after sleep() only from top level.
+ 2 files changed, 4 insertions(+), 2 deletions(-)
 
-Full history of commits in this release:
+antirez in commit 10925e46:
+ redis-check-aof: tell users there is a --fix option.
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
-Jan-Erik Rediger in commit bf508753:
- Check that the whole first argument is a number
- 1 file changed, 3 insertions(+), 2 deletions(-)
+Guy Benoish in commit 99bb1c74:
+ Modules: Fix io->bytes calculation in RDB save
+ 1 file changed, 55 insertions(+), 30 deletions(-)
 
-WuYunlong in commit 8774228c:
- fix rewrite config: auto-aof-rewrite-min-size
- 1 file changed, 2 insertions(+), 2 deletions(-)
+antirez in commit cfdcd440:
+ AOF check utility: ability to check files with RDB preamble.
+ 6 files changed, 61 insertions(+), 35 deletions(-)
 
-Byron Grobe in commit ab900303:
- Fixed issue #1996 (Missing '-' in help message for redis-benchmark)
+sunweinan in commit 1cefb1c5:
+ minor fix in listJoin().
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-Jan-Erik Rediger in commit 7fcca9ba:
- Don't use extended Regexp Syntax
- 1 file changed, 6 insertions(+), 6 deletions(-)
+antirez in commit db791a1e:
+ Free IO context if any in RDB loading code.
+ 1 file changed, 4 insertions(+)
 
-Leon Chen in commit 41963fe6:
- fix return wrong value of clusterDelNodeSlots
- 1 file changed, 4 insertions(+), 2 deletions(-)
+antirez in commit 419dacfe:
+ Modules: DEBUG DIGEST interface.
+ 5 files changed, 108 insertions(+), 1 deletion(-)
 
-Leon Chen in commit 97d50344:
- fix mismatch argument
+spinlock in commit 5d03b831:
+ update Makefile for test-sds
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-liangsijian in commit e3984980:
- Fix lua ldb command log
+spinlock in commit ed437b82:
+ Optimize addReplyBulkSds for better performance
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+antirez in commit 4ebfe265:
+ Avoid closing invalid FDs to make Valgrind happier.
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+antirez in commit b6cab88c:
+ Modules: no MULTI/EXEC for commands replicated from async contexts.
+ 1 file changed, 5 insertions(+)
+
+antirez in commit 5c5e8a50:
+ Add symmetrical assertion to track c->reply_buffer infinite growth.
+ 1 file changed, 4 insertions(+)
+
+Dvir Volk in commit c63a97f8:
+ fixed #4100
  1 file changed, 1 insertion(+)
 
-antirez in commit 84a4f202:
- Make representClusterNodeFlags() more robust.
- 1 file changed, 17 insertions(+), 16 deletions(-)
+antirez in commit eeb90571:
+ Fix GEORADIUS edge case with huge radius.
+ 2 files changed, 39 insertions(+), 20 deletions(-)
+
+antirez in commit 670456a7:
+ redis-cli --latency: ability to run non interactively.
+ 1 file changed, 39 insertions(+), 3 deletions(-)
+
+antirez in commit 64db8044:
+ HMSET and MSET implementations unified. HSET now variadic.
+ 2 files changed, 18 insertions(+), 22 deletions(-)
 
-antirez in commit 5aa25250:
- Fix isHLLObjectOrReply() to handle integer encoded strings.
+antirez in commit e43c890e:
+ Aesthetic changes to #4068 PR to conform to Redis coding standard.
+ 1 file changed, 6 insertions(+), 7 deletions(-)
+
+itamar in commit 3f3dc3b8:
+ Sets up fake client to select current db in RM_Call()
  1 file changed, 1 insertion(+)
 
-antirez in commit 7018d27d:
+antirez in commit ba773724:
  Fix abort typo in Lua debugger help screen.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-antirez in commit d557144e:
+antirez in commit bdd6de96:
  Added GEORADIUS(BYMEMBER)_RO variants for read-only operations.
  3 files changed, 32 insertions(+), 11 deletions(-)
 
-Suraj Narkhede in commit a309388d:
- Fix following issues in blocking commands: 1. brpop last key index, thus checking all keys for slots. 2. Memory leak in clusterRedirectBlockedClientIfNeeded. 3. Remove while loop in clusterRedirectBlockedClientIfNeeded.
- 1 file changed, 1 insertion(+)
-
-Suraj Narkhede in commit 55442262:
+Suraj Narkhede in commit de391ff1:
  Fix brpop command table entry and redirect blocked clients.
  2 files changed, 3 insertions(+), 2 deletions(-)
 
-antirez in commit e3641c8d:
- Fix PERSIST expired key resuscitation issue #4048.
- 1 file changed, 4 insertions(+), 7 deletions(-)
+antirez in commit 5af0fc0c:
+ RDB modules values serialization format version 2.
+ 4 files changed, 127 insertions(+), 28 deletions(-)
 
-Antonio Mallia in commit 9ce105ad:
- Removed duplicate 'sys/socket.h'  include
- 1 file changed, 1 deletion(-)
+antirez in commit 6516958e:
+ ARM: Fix stack trace generation on crash.
+ 1 file changed, 5 insertions(+)
 
-Zachary Marquez in commit e084a394:
- Prevent expirations and evictions while paused
- 1 file changed, 10 insertions(+)
+antirez in commit 3669f96e:
+ Issue #4027: unify comment and modify return value in freeMemoryIfNeeded().
+ 2 files changed, 7 insertions(+), 7 deletions(-)
 
-antirez in commit 61c78a52:
- Collect fork() timing info only if fork succeeded.
- 1 file changed, 4 insertions(+), 3 deletions(-)
+Suraj Narkhede in commit 896c4690:
+ Fix following issues in blocking commands: 1. brpop last key index, thus checking all keys for slots. 2. Memory leak in clusterRedirectBlockedClientIfNeeded. 3. Remove while loop in clusterRedirectBlockedClientIfNeeded.
+ 1 file changed, 1 insertion(+)
 
-antirez in commit d067e334:
- Aesthetic changes to #4068 PR to conform to Redis coding standard.
- 1 file changed, 6 insertions(+), 7 deletions(-)
+Zachary Marquez in commit deeb795a:
+ Prevent expirations and evictions while paused
+ 2 files changed, 10 insertions(+)
 
-xuzhou in commit 2b0f03e4:
+antirez in commit a6615423:
+ Upgrade 4.0 changelog with more backward incompatibilities.
+ 1 file changed, 8 insertions(+)
+
+xuzhou in commit 0b367871:
  Optimize set command with ex/px when updating aof.
  1 file changed, 3 insertions(+), 3 deletions(-)
 
-antirez in commit ad949f23:
+antirez in commit 2ae733d9:
  redis-benchmark: add -t hset target.
  1 file changed, 7 insertions(+)
 
-xuzhou in commit 351663bd:
+xuzhou in commit 63e1c9f2:
  Fix set with ex/px option when propagated to aof
  4 files changed, 36 insertions(+), 1 deletion(-)
 
-minghang.zmh in commit d70ac1d1:
+minghang.zmh in commit 0231156f:
  fix server.stat_net_output_bytes calc bug
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-xuchengxuan in commit 8da9a167:
+xuchengxuan in commit e99954e4:
  Fixed comments of slowlog duration
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-cbgbt in commit 13546adc:
+cbgbt in commit d048f972:
  cli: Only print elapsed time on OUTPUT_STANDARD
  1 file changed, 3 insertions(+), 1 deletion(-)
 
-Aric Huang in commit 373facf8:
+Aric Huang in commit b5f22939:
  (fix) Update create-cluster README
  1 file changed, 4 insertions(+), 4 deletions(-)
 
-Salvatore Sanfilippo in commit 29e3ff9b:
- Merge pull request #3926 from QuChen88/3.2
+antirez in commit 0b7ba621:
+ SLOWLOG: log offending client address and name.
+ 4 files changed, 27 insertions(+), 7 deletions(-)
 
-================================================================================
-Redis 3.2.9     Released Mon May 17 17:35:38 CEST 2017
-================================================================================
+Antonio Mallia in commit 1fbc90fe:
+ Removed duplicate 'sys/socket.h'  include
+ 1 file changed, 1 deletion(-)
+
+Antonio Mallia in commit c7a6b711:
+ Fixed comment in clusterMsg version field
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Upgrade urgency LOW: A few rarely harmful bugs were fixed.
+Qu Chen in commit 73d358f7:
+ Implement getKeys procedure for georadius and georadiusbymember commands.
+ 3 files changed, 41 insertions(+), 2 deletions(-)
 
-This release just fixes bugs that are unlikely to cause serious problems
-so there is no need to update ASAP. Please, see the list of commits
-for the details on the bugs fixed and credits:
+antirez in commit c782d189:
+ Fix PERSIST expired key resuscitation issue #4048.
+ 2 files changed, 4 insertions(+), 7 deletions(-)
 
-antirez in commit 3b46cf97:
+antirez in commit cb548bf3:
+ More informative -MISCONF error message.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 8cd6a2bd:
+ Collect fork() timing info only if fork succeeded.
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+antirez in commit a3941aa5:
  redis-cli --bigkeys: show error when TYPE fails.
  1 file changed, 7 insertions(+), 2 deletions(-)
 
-antirez in commit f59b4b93:
+antirez in commit 6b21cebd:
+ Modules TSC: use atomic var for server.unixtime.
+ 3 files changed, 15 insertions(+), 5 deletions(-)
+
+antirez in commit 54bd224f:
+ atomicvar.h: show used API in INFO. Add macro to force __sync builtin.
+ 2 files changed, 13 insertions(+), 6 deletions(-)
+
+antirez in commit a864d25c:
+ zmalloc.c: remove thread safe mode, it's the default way.
+ 3 files changed, 3 insertions(+), 23 deletions(-)
+
+antirez in commit b338f2b9:
+ Modules TSC: Add mutex for server.lruclock.
+ 2 files changed, 2 insertions(+)
+
+antirez in commit 7e9c658d:
+ Modules TSC: Improve inter-thread synchronization.
+ 5 files changed, 75 insertions(+), 20 deletions(-)
+
+antirez in commit e69af32f:
+ Simplify atomicvar.h usage by having the mutex name implicit.
+ 3 files changed, 25 insertions(+), 27 deletions(-)
+
+antirez in commit 26e57f17:
+ Lazyfree: fix lazyfreeGetPendingObjectsCount() race reading counter.
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+antirez in commit 2acf003c:
+ Modules TSC: HELLO.KEYS reply format fixed.
+ 1 file changed, 15 insertions(+), 13 deletions(-)
+
+antirez in commit 12fd298f:
+ Modules TSC: put the client in the pending write list.
+ 1 file changed, 13 insertions(+), 1 deletion(-)
+
+antirez in commit 5b1afa4a:
+ adlist: fix final list count in listJoin().
+ 1 file changed, 1 insertion(+)
+
+antirez in commit 717b2eea:
+ adlist: fix listJoin() to handle empty lists.
+ 1 file changed, 8 insertions(+), 2 deletions(-)
+
+antirez in commit a839036a:
+ Modules: remove unused var in example module.
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+antirez in commit eda5ee5e:
+ Modules TSC: HELLO.KEYS example draft finished.
+ 1 file changed, 35 insertions(+), 6 deletions(-)
+
+antirez in commit fb8734fe:
+ Module: fix RedisModule_Call() "l" specifier to create a raw string.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit c4b88495:
+ Modules TSC: Release the GIL for all the time we are blocked.
+ 6 files changed, 100 insertions(+), 22 deletions(-)
+
+antirez in commit fcd9a07d:
+ Modules TSC: Export symbols of the new API.
+ 2 files changed, 12 insertions(+)
+
+antirez in commit 8affa3e7:
+ Modules TSC: Handling of RM_Reply* functions.
+ 3 files changed, 82 insertions(+), 14 deletions(-)
+
+antirez in commit 31b1f3c1:
+ Modules TSC: Basic TS context creeation and handling.
+ 1 file changed, 60 insertions(+), 1 deletion(-)
+
+antirez in commit 74f3a843:
+ Modules TSC: GIL and cooperative multi tasking setup.
+ 3 files changed, 31 insertions(+), 1 deletion(-)
+
+antirez in commit 5021fda2:
+ Regression test for #3899 fixed.
+ 1 file changed, 36 insertions(+), 19 deletions(-)
+
+antirez in commit 166bdbda:
+ Regression test for PSYNC2 issue #3899 added.
+ 2 files changed, 62 insertions(+)
+
+antirez in commit b506eb74:
+ Check event loop creation return value. Fix #3951.
+ 1 file changed, 6 insertions(+)
+
+antirez in commit 80690562:
+ PSYNC2: fix master cleanup when caching it.
+ 3 files changed, 20 insertions(+), 7 deletions(-)
+
+antirez in commit 8c4b0f41:
+ Defrag: test currently disabled, too many false positives.
+ 1 file changed, 40 insertions(+), 38 deletions(-)
+
+================================================================================
+Redis 4.0-RC3     Released Sat Apr 22 11:19:56 CEST 2017
+================================================================================
+
+Upgrade urgency HIGH: Many bugs fixed and many improvements operated, so who
+                      is using 4.0 RC2 should upgrade if possible, or at least
+                      should carefully read this release notes to understand if
+                      it may be affected by some bug.
+
+Redis 3.9.103 (4.0 RC3 for the friends) is finally out, and the list of commits
+is pretty long, so here is a synopsis of all the major changes operated in this
+release.
+
+Major things:
+
+* Finally the infamous leakage of keys with an expire, in slaves that are
+  configured as writable, is fixed. (Salvatore Sanfilippo)
+* A serious MIGRATE issue forgetting to store the TTL of the key under
+  certain conditions is fixed. (reported by Jinbei Wang, fixed by Jan-Erik
+  Rediger).
+* An in-depth investigation of the ziplist implementation was performed.
+  The final result was:
+  1. An in depth auditing (Salvatore Sanfilippo and Oran Agra).
+  2. The discovery of a bug and its fix (Salvatore Sanfilippo).
+  3. The creation of a new specification to replace ziplists with something
+     better, listpacks: https://gist.github.com/antirez/66ffab20190ece8a7485bd9accfbc175 (Yuval Inbar, Salvatore Sanfilippo, Oran Agra).
+  4. Refactoring and function to dump a ziplist for debugging purposes
+     (Salvatore Sanfilippo).
+* New major feature: Memory de-fragmentation. This feature, contributed by
+  Oran Agra, allows Redis to perform "online defragmentation" of memory
+  if the Jemalloc allocator is used. There is some documentation in the
+  example `redis.conf` file. (Oran Agra)
+* Support for ARM. (Salvatore Sanfilippo)
+* Fix a very important "family of bugs" about PSYNC2, thanks to the help
+  of Kevin McGehee, Siran Yang and Oran Agra.
+* Hash function moved to SipHash 1-2 variant. (Salvatore Sanfilippo)
+* Redis Cluster failure detection improved in different ways, the most
+  important result is to exchange a lot less messages among nodes. (Salvatore
+  Sanfilippo)
+
+All the rest:
+
+* A bug in the modules API ziplist iterator was fixed. (Dvir Volk).
+* The HyperLogLog implementation final cardinality approximation function
+  was improved to use the LogLog-Beta algorithm. (Harish Murthy and
+  Salvatore Sanfilippo).
+* Edge case copy-on-write disaster fix (Oran Agra).
+* Now the Redis ASCII art logo is shown only if logging to stdout and if the
+  stdout is a tty. (Salvatore Sanfilippo because of users request).
+* A new GEO bug fixed (and there is another pending when huge radiuses are
+  used, where elements at the edge may be miss-reported). (Salvatore
+  Sanfilippo). ***IMPORTANT*** See the list of incompatibilities below
+  since the GEO API has some potentially backward incompatible change.
+* ZADD crash on syntax error fixed. (Itamar Haber)
+* Fixed a division by zero but in MEMORY DOCTOR. (Jan-Erik Rediger)
+* More MIGRATE bugs fixed. (Salvatore Sanfilippo)
+* Different file descriptors potential lakes fixed. (multiple authors)
+* Support for Solaris improved. (Salvatore Sanfilippo)
+* Improve memory reclaiming in freeMemoryIfNeeded(). (Oran Agra and
+  Salvatore Sanfilippo)
+* Fixes multiple bugs in the test suite. (Salvatore Sanfilippo)
+* Fix asynchronous commands in modules API. (Dvir Volk and Salvatore Sanfilippo)
+* A new data structure, the radix tree (rax.c) was introduced into Redis in
+  order to fix a major Redis Cluster slowdown. (Salvatore Sanfilippo)
+* Fix `lua-time-limit` config ignored in `redis.conf`. (Salvatore Sanfilippo)
+* Jemalloc downgraded to an apparently safe version, given that recent
+  releases apparently hang under certain conditions. See Redis issue #3799.
+
+For details and full credits, see the list of commits here. However note that
+many information is inside the full commit message, while here only the first
+line is shown.
+
+antirez in commit 6bc6bd4c:
+ PSYNC2: discard pending transactions from cached master.
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+antirez in commit a91cc5bc:
+ Fix PSYNC2 incomplete command bug as described in #3899.
+ 3 files changed, 47 insertions(+), 8 deletions(-)
+
+antirez in commit 278972ce:
+ Fix getKeysUsingCommandTable() in cluster mode.
+ 1 file changed, 14 insertions(+), 1 deletion(-)
+
+张文康 in commit 20285017:
+ update block->free after some diff data are written to the child process
+ 1 file changed, 1 insertion(+)
+
+Jan-Erik Rediger in commit 05ac217f:
+ Reorder to make dict-benchmark compile on Linux
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+antirez in commit 8d44c52a:
+ Fix #3848 by closing the descriptor on error.
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+antirez in commit 5c107c62:
+ Clarify why we save ziplist elements in revserse order.
+ 1 file changed, 13 insertions(+), 7 deletions(-)
+
+spinlock in commit 22996414:
+ rdb: saving skiplist in reversed order to accelerate the deserialisation process
+ 1 file changed, 8 insertions(+), 7 deletions(-)
+
+antirez in commit d98ef35a:
+ Cluster: discard pong times in the future.
+ 1 file changed, 8 insertions(+), 1 deletion(-)
+
+antirez in commit e47c8e3f:
+ Test: fix, hopefully, false PSYNC failure like in issue #2715.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 1e659a04:
+ Cluster: always add PFAIL nodes at end of gossip section.
+ 2 files changed, 71 insertions(+), 23 deletions(-)
+
+antirez in commit 39d34487:
+ Cluster: fix gossip section ping/pong times encoding.
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+antirez in commit 78148d0e:
+ Cluster: add clean-logs command to create-cluster script.
+ 2 files changed, 9 insertions(+), 1 deletion(-)
+
+antirez in commit a5c1c77e:
+ Cluster: decrease ping/pong traffic by trusting other nodes reports.
+ 1 file changed, 13 insertions(+)
+
+antirez in commit 51901396:
+ Cluster: collect more specific bus messages stats.
+ 2 files changed, 82 insertions(+), 31 deletions(-)
+
+antirez in commit f7b91b6c:
+ Add a top comment in crucial functions inside networking.c.
+ 1 file changed, 23 insertions(+), 1 deletion(-)
+
+antirez in commit 6e1489ae:
+ Set lua-time-limit default value at safe place.
+ 2 files changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 5fd841c0:
  Fix preprocessor if/else chain broken in order to fix #3927.
  1 file changed, 3 insertions(+)
 
-antirez in commit dd80fedf:
+antirez in commit 185b361a:
+ Fix typo in feedReplicationBacklog() top comment.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+lorneli in commit b740fc1e:
+ Expire: Update comment of activeExpireCycle function
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 56cafcce:
  Fix zmalloc_get_memory_size() ifdefs to actually use the else branch.
  1 file changed, 2 deletions(-)
 
-antirez in commit 697d3abe:
- Set lua-time-limit default value at safe place.
- 2 files changed, 1 insertion(+), 1 deletion(-)
+antirez in commit a5b66da8:
+ Make more obvious why there was issue #3843.
+ 1 file changed, 3 insertions(+)
 
-antirez in commit c9c04b11:
- Fix #3848 by closing the descriptor on error.
- 1 file changed, 2 insertions(+), 1 deletion(-)
+antirez in commit f60d6f09:
+ Fix modules blocking commands awake delay.
+ 3 files changed, 42 insertions(+)
+
+antirez in commit c56668c8:
+ Rax library updated.
+ 3 files changed, 152 insertions(+), 265 deletions(-)
+
+antirez in commit c4716d33:
+ Cluster: hash slots tracking using a radix tree.
+ 9 files changed, 2115 insertions(+), 65 deletions(-)
 
-张文康 in commit d3b49924:
- update block->free after some diff data are written to the child process
- 1 file changed, 1 insertion(+)
+vienna in commit a9fefbce:
+ fix #3847: add close socket before return ANET_ERR.
+ 1 file changed, 3 insertions(+), 1 deletion(-)
 
-antirez in commit 6a33952b:
- Test: fix, hopefully, false PSYNC failure like in issue #2715.
+Dvir Volk in commit 17250409:
+ fixed free of blocked client before refering to it
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-John.Koepi in commit b83f9fea:
- fix #2883, #2857 pipe fds leak when fork() failed on bg aof rw
- 1 file changed, 1 insertion(+)
+Oran Agra in commit 8aced9e9:
+ add LFU policies to the test suite, just for coverage
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-antirez in commit 10dbb5cd:
- Don't leak file descriptor on syncWithMaster().
- 1 file changed, 2 insertions(+), 1 deletion(-)
+antirez in commit 3aa656ab:
+ Use sha256 instead of sha1 to generate tarball hashes.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-================================================================================
-Redis 3.2.8     Released Sun Feb 12 16:11:18 CET 2017
-================================================================================
+Salvatore Sanfilippo in commit 42d6a6c3:
+ Makefile: fix building with Solaris C compiler, 64 bit.
+ 1 file changed, 7 insertions(+)
 
-Upgrade urgency CRITICAL: This release reverts back the Jemalloc upgrade
-                          that is believed to potentially cause a server
-                          deadlock. A MIGRATE crash is also fixed.
+Salvatore Sanfilippo in commit e082d056:
+ Use ARM unaligned accesses ifdefs for SPARC as well.
+ 3 files changed, 11 insertions(+), 2 deletions(-)
 
-Two important bug fixes, the first of one is critical:
+Salvatore Sanfilippo in commit 7269d547:
+ Fix BITPOS unaligned memory access.
+ 1 file changed, 14 insertions(+), 7 deletions(-)
 
-1. Apparently Jemalloc 4.4.0 may contain a deadlock under particular
-   conditions. See https://github.com/antirez/redis/issues/3799.
-   We reverted back to the previously used Jemalloc versions and plan
-   to upgrade Jemalloc again after having more info about the
-   cause of the bug.
+antirez in commit 15520588:
+ Solaris fixes about tail usage and atomic vars.
+ 4 files changed, 7 insertions(+), 7 deletions(-)
 
-2. MIGRATE could crash the server after a socket error. See for reference:
-   https://github.com/antirez/redis/issues/3796.
+antirez in commit 9faeed04:
+ Test: replication-psync, wait more to detect write load.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-List of commits:
+antirez in commit b3440b35:
+ Test: fix conditional execution of HINCRBYFLOAT representation test.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-antirez in commit 7178cac:
- Revert "Jemalloc updated to 4.4.0."
- 150 files changed, 6330 insertions(+), 17245 deletions(-)
+antirez in commit 5a413303:
+ SipHash 2-4 -> SipHash 1-2.
+ 1 file changed, 15 insertions(+), 14 deletions(-)
 
-antirez in commit 33fad43:
- Fix MIGRATE closing of cached socket on error.
- 1 file changed, 23 insertions(+), 6 deletions(-)
+antirez in commit a8cbc3ec:
+ freeMemoryIfNeeded(): improve code and lazyfree handling.
+ 1 file changed, 42 insertions(+), 19 deletions(-)
 
-================================================================================
-Redis 3.2.7     Released Tue Jan 31 16:21:41 CET 2017
-================================================================================
+antirez in commit 857e6d56:
+ Use locale agnostic tolower() in dict.c hash function.
+ 3 files changed, 27 insertions(+), 17 deletions(-)
+
+antirez in commit 34387cea:
+ SipHash x86 optimizations.
+ 1 file changed, 23 insertions(+), 2 deletions(-)
+
+antirez in commit ba647598:
+ Use SipHash hash function to mitigate HashDos attempts.
+ 12 files changed, 361 insertions(+), 82 deletions(-)
+
+Salvatore Sanfilippo in commit 2ee19d98:
+ ARM: Avoid fast path for BITOP.
+ 1 file changed, 5 insertions(+), 1 deletion(-)
 
-Upgrade urgency HIGH: This release fixes important security and correctness
-                      issues. It is especially important to upgrade for Redis
-                      Cluster users and for users running Redis in their laptop
-                      since a cross-scripting attack is fixed in this release.
-
-Main bugs fixes and improvements in this release:
-
-1. MIGRATE could incorrectly move keys between Redis Cluster nodes by turning
-   keys with an expire set into persisting keys. This bug was introduced with
-   the multiple-keys migration recently. It is now fixed. Only applies to
-   Redis Cluster users that use the resharding features of Redis Cluster.
-
-2. As Redis 4.0 beta and the unstable branch already did (for some months at
-   this point), Redis 3.2.7 also aliases the Host: and POST commands to QUIT
-   avoiding to process the remaining pipeline if there are pending commands.
-   This is a security protection against a "Cross Scripting" attack, that
-   usually involves trying to feed Redis with HTTP in order to execute commands.
-   Example: a developer is running a local copy of Redis for development
-   purposes. She also runs a web browser in the same computer. The web browser
-   could send an HTTP request to http://127.0.0.1:6379 in order to access the
-   Redis instance, since a specially crafted HTTP requesta may also be partially
-   valid Redis protocol. However if POST and Host: break the connection, this
-   problem should be avoided. IMPORTANT: It is important to realize that it
-   is not impossible that another way will be found to talk with a localhost
-   Redis using a Cross Protocol attack not involving sending POST or Host: so
-   this is only a layer of protection but not a definitive fix for this class
-   of issues.
-
-3. A ziplist bug that could cause data corruption, could crash the server and
-   MAY ALSO HAVE SECURITY IMPLICATIONS was fixed. The bug looks complex to
-   exploit, but attacks always get worse, never better (cit). The bug is very
-   very hard to catch in practice, it required manual analysis of the ziplist
-   code in order to be found. However it is also possible that rarely it
-   happened in the wild. Upgrading is required if you use LINSERT and other
-   in-the-middle list manipulation commands.
-
-4. We upgraded to Jemalloc 4.4.0 since the version we used to ship with Redis
-   was an early 4.0 release of Jemalloc. This version may have several
-   improvements including the ability to better reclaim/use the memory of
-   system.
+Salvatore Sanfilippo in commit eb62cfea:
+ ARM: Use libc malloc by default.
+ 1 file changed, 6 insertions(+), 3 deletions(-)
+
+Salvatore Sanfilippo in commit 620e48b1:
+ ARM: Avoid memcpy() in MurmurHash64A() if we are using 64 bit ARM.
+ 3 files changed, 5 insertions(+), 1 deletion(-)
 
-The following is the list of commits:
+Salvatore Sanfilippo in commit 980d8805:
+ ARM: Fix 64 bit unaligned access in MurmurHash64A().
+ 2 files changed, 10 insertions(+)
+
+John.Koepi in commit 522b10e4:
+ fix #2883, #2857 pipe fds leak when fork() failed on bg aof rw
+ 1 file changed, 1 insertion(+)
 
-antirez in commit 3876d98:
+antirez in commit 03f55722:
+ Don't leak file descriptor on syncWithMaster().
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+antirez in commit 8d55aeb5:
+ Fix MIGRATE closing of cached socket on error.
+ 1 file changed, 23 insertions(+), 6 deletions(-)
+
+antirez in commit 7c22d768:
+ Fix ziplist fix...
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+antirez in commit 8327b813:
  Ziplist: insertion bug under particular conditions fixed.
  1 file changed, 9 insertions(+), 1 deletion(-)
 
-antirez in commit 153f2f0:
+antirez in commit 1688ccff:
+ ziplist: better comments, some refactoring.
+ 1 file changed, 250 insertions(+), 100 deletions(-)
+
+antirez in commit 36c1acc2:
  Jemalloc updated to 4.4.0.
- 150 files changed, 17271 insertions(+), 6356 deletions(-)
+ 150 files changed, 17242 insertions(+), 6359 deletions(-)
+
+Jan-Erik Rediger in commit 37b4c954:
+ Don't divide by zero
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-miter in commit ca532c9:
+miter in commit aee1ddca:
  Change switch statment to if statment
  1 file changed, 2 insertions(+), 4 deletions(-)
 
-oranagra in commit a735035:
+oranagra in commit af292b54:
  fix rare assertion in DEBUG DIGEST
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-Itamar Haber in commit b917e3f:
+Itamar Haber in commit c3c2aa3b:
  Verify pairs are provided after subcommands
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-antirez in commit 1177cf6:
- Avoid geo.c warning in initialization.
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit 7c2153da:
+ Add panic() into redisassert.h.
+ 1 file changed, 2 insertions(+)
 
-antirez in commit 874804d:
- Security: Cross Protocol Scripting protection.
- 3 files changed, 27 insertions(+), 2 deletions(-)
+antirez in commit dc83ddf0:
+ serverPanic(): allow printf() alike formatting.
+ 2 files changed, 14 insertions(+), 4 deletions(-)
 
-antirez in commit 273cd7f:
+antirez in commit 3ef81eb3:
  Ziplist: remove static from functions, they prevent good crash reports.
  1 file changed, 14 insertions(+), 14 deletions(-)
 
-Jan-Erik Rediger in commit 389b9f5:
+Jan-Erik Rediger in commit 96f75faa:
  Initialize help only in repl mode
  1 file changed, 5 insertions(+), 5 deletions(-)
 
-Yossi Gottlieb in commit 1370a88:
- Fix redis-cli rare crash.
- 1 file changed, 4 insertions(+)
+antirez in commit bcd51a6a:
+ Use const in modules types mem_usage method.
+ 3 files changed, 4 insertions(+), 4 deletions(-)
+
+antirez in commit 354ccf0c:
+ Add memory defragmenting capability in 4.0 release notes.
+ 1 file changed, 3 insertions(+)
+
+antirez in commit 57c81853:
+ Defrag: don't crash when a module value is encountered.
+ 1 file changed, 3 insertions(+)
+
+antirez in commit e36d5222:
+ MEMORY USAGE: support for modules data types.
+ 3 files changed, 16 insertions(+), 5 deletions(-)
+
+antirez in commit 82ec0fe6:
+ Defrag: document the feature in redis.conf.
+ 1 file changed, 49 insertions(+), 6 deletions(-)
+
+antirez in commit 19bf0249:
+ Defrag: not enabled by default. Error on CONFIG SET if not available.
+ 2 files changed, 11 insertions(+), 1 deletion(-)
+
+antirez in commit fa0d8b62:
+ Defrag: fix function name typo defarg -> defrag.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+antirez in commit ebb9a7e7:
+ Defrag: do not crash on empty quicklist.
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+antirez in commit da84b9c4:
+ Defrag: fix comments & code to conform to the Redis code base.
+ 1 file changed, 84 insertions(+), 54 deletions(-)
+
+antirez in commit a18f3cf3:
+ Defrag: activate it only if running modified version of Jemalloc.
+ 4 files changed, 40 insertions(+), 26 deletions(-)
+
+oranagra in commit 1ad48837:
+ active defrag improvements
+ 4 files changed, 63 insertions(+), 44 deletions(-)
 
-antirez in commit 68aab8e:
+oranagra in commit 67def261:
+ active memory defragmentation
+ 13 files changed, 755 insertions(+), 8 deletions(-)
+
+antirez in commit b4f3c5a4:
+ deps/hiredis updated to latest version.
+ 34 files changed, 2393 insertions(+), 817 deletions(-)
+
+antirez in commit 6549c6cf:
+ Fix test "server is up" detection after logging changes.
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+Alexander Zhukov in commit b87fd120:
+ Fix an article usage
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+whatacold in commit bd845493:
+ fix the wrong description of intsetGet().
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 952e8706:
+ 4.0 release notes updated with API incompatibility notice about GEO.
+ 1 file changed, 12 insertions(+)
+
+antirez in commit f3add069:
+ Geo: fuzzy test inconsistency report fixed to show all points.
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+antirez in commit 056c81e4:
+ Geo: fix GEOHASH return value for consistency.
+ 1 file changed, 3 insertions(+), 4 deletions(-)
+
+antirez in commit d5036018:
+ Geo: fix edge case return values for uniformity.
+ 1 file changed, 5 insertions(+), 6 deletions(-)
+
+Justin Carvalho in commit 47b46253:
+ Fix missing brackets around encoding variable in ZIP_DECODE_LENGTH macro
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit a0e95118:
+ Remove first version of ASCII wave, later discarded.
+ 1 file changed, 2 deletions(-)
+
+antirez in commit 3334a409:
+ Only show Redis logo if logging to stdout / TTY.
+ 4 files changed, 44 insertions(+), 11 deletions(-)
+
+antirez in commit db53c230:
+ adjustOpenFilesLimit() comment made hopefully more clear.
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+antirez in commit bc00ef45:
+ Hopefully improve code comments for issue #3616.
+ 1 file changed, 8 insertions(+), 7 deletions(-)
+
+itamar in commit 075a3381:
+ Corrects a couple of omissions in the modules docs
+ 2 files changed, 3 insertions(+), 2 deletions(-)
+
+andyli in commit 8d82b3b1:
+ Modify MIN->MAX
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+oranagra in commit 69282df8:
+ when a slave loads an RDB, stop an AOFRW fork before flusing db and parsing rdb file, to avoid a CoW disaster.
+ 1 file changed, 19 insertions(+), 13 deletions(-)
+
+hylepo in commit 869dda84:
+ Update redis-benchmark.c
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+oranagra in commit 7f870fad:
+ fix unsigned int overflow in adjustOpenFilesLimit
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+antirez in commit 2e375d4f:
+ Switch PFCOUNT to LogLog-Beta algorithm.
+ 4 files changed, 16 insertions(+), 57 deletions(-)
+
+antirez in commit 735b928b:
+ Use llroundl() before converting loglog-beta output to integer.
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+antirez in commit 6cae609e:
+ Fix HLL gnuplot graph generator script for new redis-rb versions.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+Harish Murthy in commit 4d475e0f:
+ LogLog-Beta Algorithm support within HLL Config option to use LogLog-Beta Algorithm for Cardinality
+ 4 files changed, 57 insertions(+), 27 deletions(-)
+
+Dvir Volk in commit 90d918bd:
+ fixed stop condition in RM_ZsetRangeNext and RM_ZsetRangePrev
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+antirez in commit 3b19580a:
+ ziplist.c explanation of format improved a bit.
+ 1 file changed, 18 insertions(+), 11 deletions(-)
+
+antirez in commit 457c6878:
+ DEBUG: new "ziplist" subcommand added. Dumps a ziplist on stdout.
+ 4 files changed, 35 insertions(+), 13 deletions(-)
+
+antirez in commit 17cda261:
  MIGRATE: Remove upfront ttl initialization.
  1 file changed, 3 insertions(+), 4 deletions(-)
 
-Jan-Erik Rediger in commit 788e892:
+Jan-Erik Rediger in commit 9515648d:
  Reset the ttl for additional keys
  1 file changed, 1 insertion(+)
 
+antirez in commit 1eec780e:
+ Writable slaves expires: unit test.
+ 1 file changed, 12 insertions(+)
+
+antirez in commit 9a8bc6d2:
+ Writable slaves expires: fix leak in key tracking.
+ 2 files changed, 16 insertions(+), 2 deletions(-)
+
+antirez in commit 746d70b0:
+ INFO: show num of slave-expires keys tracked.
+ 3 files changed, 11 insertions(+), 2 deletions(-)
+
+antirez in commit 1469c4ed:
+ Fix created->created typo in expire.c
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit c65dfb43:
+ Replication: fix the infamous key leakage of writable slaves + EXPIRE.
+ 8 files changed, 161 insertions(+), 11 deletions(-)
+
+Yossi Gottlieb in commit 80944aac:
+ Fix redis-cli rare crash.
+ 1 file changed, 4 insertions(+)
+
 ================================================================================
-Redis 3.2.6     Released Tue Dec 06 09:33:29 CET 2016
+Redis 4.0.0-RC2     Released Tue Dec 06 09:25:35 CET 2016
 ================================================================================
 
-Upgrade urgency MODERATE: GEORADIUS, BITFIELD and Redis Cluster minor fixes.
+Upgrade urgency LOW: This release mainly fixes a rare GEO API bug and a crash
+                     related to the modules subsystem.
 
-This release mainly fixes three bugs:
+Redis 4.0.0-RC2 (version number 3.9.102) just fixes two bugs:
 
-1. A bug with BITFIELD that may cause the bitmap corruption when setting offsets
-   larger than the current string size.
+1. GEORADIUS could fail reporting items with very big radius lengths because
+   of a bug in the bounding box computation function. This was fixed and tests
+   with large radius sizes were added.
 
-2. A GEORADIUS bug that may happen when using very large radius lengths, in
-   the range of 10000km or alike, due to wrong bounding box calculation.
+2. There was a crash in the modules subsystem that was not merged into RC1 for
+   an error, while it was already fixed into the "unstable" branch.
 
-3. A bug with Redis Cluster which crashes when reading a nodes configuration
-   file with zero bytes at the end, which sometimes happens with certain ext4
-   configurations after a system crash.
+The list of commits follows:
 
-The following is the list of commits:
+wangshaonan in commit 77241e8:
+ Add '\n' to MEMORY DOCTOR command output message when num_reports is 0 or empty is 1
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+Chris Lamb in commit 0ee6a23:
+ src/rdb.c: Correct "whenver" -> "whenever" typo.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+Yossi Gottlieb in commit 2d0d2c8:
+ Fix typo in RedisModuleTypeMethods declaration.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+Dvir Volk in commit 0fb9f34:
+ fix memory corruption on RM_FreeCallReply
+ 1 file changed, 3 insertions(+), 1 deletion(-)
 
-antirez in commit f20f3ea:
+antirez in commit 41994f2:
  Geo: improve fuzz test.
  1 file changed, 11 insertions(+), 3 deletions(-)
 
-antirez in commit 8c22086:
+antirez in commit ef9b4cf:
  Geo: fix computation of bounding box.
- 2 files changed, 33 insertions(+), 27 deletions(-)
+ 2 files changed, 33 insertions(+), 44 deletions(-)
+
+================================================================================
+Redis 4.0.0-RC1   Released Fri Dec 2 10:40:01 CEST 2016
+================================================================================
+
+Redis 4.0.0-RC1 (version number 3.9.101) is the first release candidate of
+Redis 4.0. It is not a production quality release but all the major features
+received some testing at this point, the release in feature freeze excluding
+things that are considered in the middle ground between fixes and improvements.
+
+Redis 4.0 is not called 3.4 because it is a major release that adds a number
+of important and non trivial features. Many core functionalities of Redis were
+seriously reworked. In the next release candidates, with your help, we'll gain
+informations about the stability level of this release and will produce a new
+RC every 2-4 weeks. When the entity and frequency of bug reports will slow down
+under a certain level, Redis 4.0 final will be released.
+
+As usually, certain changes to Cluster and Sentinel may not follow the Redis
+release cycle and could be incorporated into Redis 4.0 at RC stage or even
+after the final version, every time the changes are considered to benefit
+the user base enough to be worth incorporating them ASAP without waiting
+for Redis 4.2.
+
+So, what's new in Redis 4.0?
+
+Major features
+---
+
+* Redis modules system. Redis now allows developers to write modules that can extend the Redis functionalities and implement new data types. The module API implements a complete abstraction layer that separates the Redis core from the module implementation, allowing the same module to be loaded by different versions of Redis without modifications. See the modules documentation here for more info: https://github.com/antirez/redis/blob/unstable/src/modules/INTRO.md
+
+* Partial Replication (PSYNC) version 2. The replication protocol was enhanced (in a backward compatible way, so that 4.0 can still act as a slave of older instances) in order to be able to partially resynchronize slaves and masters in conditions where it was impossible in the past: after a master switch because of a failover and when a slave instance is restared. Even masters turned into slaves will usually be able to partially resynchronize with the new master, if the new master was a former slave of the old master instance. The way the replication work for chained slaves (sub-slaves) is now very different, and each slave receives the same replication stream generated by the top-level master.
+
+* Cache eviction improvements. Redis 4.0 implements LFU (Least Frequently Used) as a new eviction algorithm, and improves the functionality, performances and precision of the existing algorithms. This blog post contains info about the changes: http://antirez.com/news/109
+
+* Lazy freeing of keys. Redis is now able to delete keys in the background in a different thread without blocking the server. The new `UNLINK` command is the same as `DEL` but working in a non blocking way. Similarly an `ASYNC` option was added to `FLUSHALL` and `FLUSHDB` in order to let the entire dataset or a single database to be freed asynchronously.
+
+* Mixed RDB-AOF format. If enabled the new format is used when rewriting the AOF file: the rewrite uses the more compact and faster to generate RDB format, and an AOF stream is appended to the file. This allows faster rewrites and reloads when using the AOF persistence.
+
+* A new MEMORY command, able to perform memory analysis of different kinds: troubleshooting of memory issues (with MEMORY DOCTOR, similar to LATENCY DOCTOR), reporting of the amount of memory used by a single key, more in-depth reporting of Redis memory usage compared to what the INFO command offers.
 
-antirez in commit 92958df:
+* Redis Cluster support for NAT / Docker. There are new functionalities in order to force cluster instances to announce specific sets of IP address, client and bus ports, to the rest of the cluster, regardless of the auto detected IP. This required a bus protocol change that will force users to mass-restart all the nodes of a Redis 3.2 installation in order to upgrade to 4.0.
+
+* Redis uses now less memory in order to store the same amount of data. The gain depends a lot on the kind of dataset stored.
+
+* Redis is now able to defragment the used memory and reclaim space incrementally
+while running. See the example `redis.conf` for more information.
+
+Smaller features
+---
+
+* Improvements to the RDB format to support 64 bit lengths, binary sorted set scores, and more. The RDB file check utility now uses the same code base of the one used by Redis itself in order to load the RDB file in memory.
+
+* SWAPDB command: ability to completely and immediately (no latency) replace two Redis databases.
+
+* Improvements to `dict.c`, the Redis hash table implementation.
+
+* Security improvements mapping POST and Host: commands to QUIT in order to prevent cross protocol scripting attacks.
+
+* RPUSHX and LPUSHX now accept a variable number of elements.
+
+* Reporting of additional memory used by copy on write in the INFO output.
+
+* Serious refactoring of many core parts of Redis.
+
+List of commits
+---
+
+antirez in commit 434e6b2:
+ PSYNC2: Do not accept WAIT in slave instances.
+ 1 file changed, 5 insertions(+)
+
+antirez in commit 71e8d15:
+ Modules: change type registration API to use a struct of methods.
+ 4 files changed, 65 insertions(+), 10 deletions(-)
+
+antirez in commit ce1f9cf:
+ PSYNC2 test: check ability to resync after restart.
+ 1 file changed, 35 insertions(+), 1 deletion(-)
+
+antirez in commit 93c5198:
+ PSYNC2 test: 20 seconds are enough...
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+antirez in commit f6e42f0:
+ PSYNC2 test: test added to the default tests.
+ 1 file changed, 1 insertion(+)
+
+antirez in commit 6eb720f:
+ PSYNC2: Minor memory leak reading -NOMASTERLINK master reply fixed.
+ 1 file changed, 1 insertion(+)
+
+antirez in commit c8f0690:
+ PSYNC2 test: modify the test for production.
+ 1 file changed, 33 insertions(+), 17 deletions(-)
+
+antirez in commit eab865a:
+ PSYNC2: stop sending newlines to sub-slaves when master is down.
+ 3 files changed, 6 insertions(+), 30 deletions(-)
+
+antirez in commit 16559a0:
+ PSYNC2: Test (WIP).
+ 1 file changed, 127 insertions(+)
+
+antirez in commit 790310d:
+ Better protocol errors logging.
+ 1 file changed, 29 insertions(+), 10 deletions(-)
+
+antirez in commit e09e31b:
+ PSYNC2: on transient error jump to error, not write_error.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 1f55170:
+ Modules: fix client blocking calls access to invalid struct field.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 5b7d42f:
+ PSYNC2: bugfixing pre release.
+ 2 files changed, 39 insertions(+), 11 deletions(-)
+
+antirez in commit 73dd51c:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit f115461:
+ Test: WAIT tests added in wait.tcl unit.
+ 2 files changed, 43 insertions(+)
+
+Salvatore Sanfilippo in commit 5b83fa4:
+ Merge pull request #3612 from deep011/unstable
+antirez in commit 8fb3ad2:
+ Merge branch 'psync2' into unstable
+antirez in commit 59f2e7c:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit cfdb3a2:
  Cluster: handle zero bytes at the end of nodes.conf.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-antirez in commit 0ee28ae:
+deep011 in commit 13a92a5:
+ fix a possible bug for 'replconf getack'
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 28c96d7:
+ PSYNC2: Save replication ID/offset on RDB file.
+ 4 files changed, 29 insertions(+), 3 deletions(-)
+
+antirez in commit 4e5e366:
+ PSYNC2: Wrap debugging code with if(0)
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+antirez in commit 2669fb8:
+ PSYNC2: different improvements to Redis replication.
+ 10 files changed, 440 insertions(+), 143 deletions(-)
+
+Salvatore Sanfilippo in commit b399288:
+ Merge pull request #3568 from MichaelTSS/patch-1
+antirez in commit 18d32c7:
+ redis-cli typo fixed: perferences -> preferences.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+Salvatore Sanfilippo in commit fa2dc4b:
+ Merge pull request #3514 from charsyam/feature/simple-refactoring
+Salvatore Sanfilippo in commit 25811bc:
+ Merge pull request #3547 from yyoshiki41/refactor/redis-trib
+Salvatore Sanfilippo in commit b3e7073:
+ Merge pull request #3575 from deep011/unstable
+Salvatore Sanfilippo in commit c17fc39:
+ Merge pull request #3581 from dvirsky/fix_io_ctx_sizeof
+Dvir Volk in commit ec8fd6e:
+ fixed sizeof in allocating io RedisModuleCtx*
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 9749e96:
  Test: regression test for #3564 added.
  1 file changed, 9 insertions(+)
 
-sunhe in commit 289fadb:
- bitops.c/bitfieldCommand: update higest_write_offset with check
- 1 file changed, 3 insertions(+), 2 deletions(-)
+Salvatore Sanfilippo in commit 77b1abf:
+ Merge pull request #3565 from sunheehnus/bitfield-fix-highest_write_offset
+Salvatore Sanfilippo in commit f48ca55:
+ Merge pull request #3573 from jybaek/module-io-context
+Salvatore Sanfilippo in commit fbfa0a1:
+ Merge pull request #3579 from guybe7/unstable
+Guy Benoish in commit 8b070b5:
+ Fixed wrong sizeof(client) in object.c
+ 1 file changed, 7 insertions(+), 7 deletions(-)
+
+deep in commit 7f1bb22:
+ fix a bug for quicklistDup() function
+ 1 file changed, 3 insertions(+), 3 deletions(-)
 
-jybaek in commit f4f7d2c:
+jybaek in commit a06d59b:
  Add missing fclose()
  1 file changed, 1 insertion(+)
 
-================================================================================
-Redis 3.2.5     Released Wed Oct 26 09:16:40 CEST 2016
-================================================================================
+Michel Tresseras in commit 20feafd:
+ Typo
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Upgrade urgency LOW: This release only fixes a compilation issue due to the
-                     missing -ldl at linking time.
+sunhe in commit 949a274:
+ bitops.c/bitfieldCommand: update higest_write_offset with check
+ 1 file changed, 3 insertions(+), 2 deletions(-)
 
-zach shipko in commit 4736407:
- BSDs don't have -ldl
- 1 file changed, 15 insertions(+), 5 deletions(-)
+antirez in commit f39e7d4:
+ Remove "Hey!" warning...
+ 1 file changed, 1 deletion(-)
 
-antirez in commit 9ada818:
- Fix modules compilation when libc malloc is used.
+antirez in commit a9f50a3:
+ Better target MacOS on __atomic macros conditional compilation.
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+Salvatore Sanfilippo in commit ea95262:
+ Merge pull request #3560 from melo/fix-macos-10-8-compile
+Pedro Melo in commit 2000abc:
+ Fixes compilation on MacOS 10.8.5, Clang tags/Apple/clang-421.0.57
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit f633212:
+ Fix SELECT test, broken cause change in error msg.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit c7a4e69:
+ SWAPDB command.
+ 3 files changed, 88 insertions(+), 1 deletion(-)
+
+antirez in commit a3b3ca7:
+ Modules: use RedisModule_AbortBlock() in the example.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 95c17c0:
+ Modules: AbortBlock() API implemented.
+ 3 files changed, 12 insertions(+), 1 deletion(-)
+
+antirez in commit 58601c8:
+ Modules: blocking API documented.
+ 1 file changed, 265 insertions(+)
+
+antirez in commit 553aa0e:
+ module.c: trim comment to 80 cols.
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+antirez in commit 870274b:
+ Example modules: remove warnings about types and not used args.
+ 2 files changed, 13 insertions(+), 2 deletions(-)
+
+yyoshiki41 in commit 16f6506:
+ Refactor redis-trib.rb
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+antirez in commit 7dde8bf:
+ Modules: blocking command example added.
+ 1 file changed, 115 insertions(+)
+
+antirez in commit 3459969:
+ Modules: fixes to the blocking commands API: examples now works.
+ 1 file changed, 10 insertions(+), 2 deletions(-)
+
+antirez in commit f156038:
+ Modules: RM_Milliseconds() API added.
+ 2 files changed, 8 insertions(+)
+
+antirez in commit ffb00fb:
+ Modules: blocking commands WIP: API exported, a first example.
+ 3 files changed, 38 insertions(+), 3 deletions(-)
+
+antirez in commit 3aa816e:
+ Modules: introduce warning suppression macro for unused args.
+ 3 files changed, 22 insertions(+)
+
+antirez in commit 3879923:
+ Enable warning in example modules Makefile.
  1 file changed, 2 insertions(+), 2 deletions(-)
 
-================================================================================
-Redis 3.2.4     Released Mon Sep 26 08:58:21 CEST 2016
-================================================================================
+antirez in commit 8fadfe5:
+ Module: API to block clients with threading support.
+ 4 files changed, 185 insertions(+), 11 deletions(-)
+
+antirez in commit a5998d1:
+ Fix typos in GetContextFromIO API declaration.
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+antirez in commit 799208d:
+ Fix name of mispelled function.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 152c1b6:
+ Module: Ability to get context from IO context.
+ 5 files changed, 30 insertions(+)
+
+antirez in commit 72279e3:
+ Copyright notice added to module.c.
+ 2 files changed, 30 insertions(+), 1 deletion(-)
+
+antirez in commit 3dc84c5:
+ Modules: API to save/load single precision floating point numbers.
+ 4 files changed, 48 insertions(+), 2 deletions(-)
+
+antirez in commit a1b1fd4:
+ Modules: API to log from module I/O callbacks.
+ 2 files changed, 40 insertions(+), 16 deletions(-)
+
+antirez in commit 4674efd:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit 0d9febf:
+ Add compiler optimizations to example module makefile.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-Upgrade urgency CRITICAL: Redis 3.2 and unstable contained a security
-                          vulnerability fixed by this release.
+antirez in commit 6782e77:
+ debug.c: include dlfcn.h regardless of BACKTRACE support.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Hello Redis Wizards of the Memory Stores Empire,
+antirez in commit 2564031:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit 6d9f8e2:
+ Security: CONFIG SET client-output-buffer-limit overflow fixed.
+ 1 file changed, 5 insertions(+), 3 deletions(-)
 
-this is a Redis critical release in order to fix a security issue
-which is documented clearly here:
+charsyam in commit ca6fc4f:
+ Simple change just using slaves instead of server.slaves
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-    https://github.com/antirez/redis/commit/6d9f8e2462fc2c426d48c941edeb78e5df7d2977
+Salvatore Sanfilippo in commit 6e866ee:
+ Merge pull request #3511 from dvirsky/create_string_printf
+Dvir Volk in commit a91650f:
+ added RM_CreateStringPrintf
+ 4 files changed, 52 insertions(+), 3 deletions(-)
 
-Thanks to Cory Duplantis of Cisco Talos for reporting the issue.
+antirez in commit 6705867:
+ dict.c: fix dictGenericDelete() return ASAP condition.
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
-IMPACT:
+antirez in commit e9d861e:
+ Clear child data when opening the pipes.
+ 1 file changed, 2 insertions(+)
 
-The gist is that using CONFIG SET calls (or by manipulating redis.conf)
-an attacker is able to compromise certain fields of the "server" global
-structure, including the aof filename pointer, that could be made pointing
-to something else. In turn the AOF name is used in different contexts such
-as logging, rename(2) and open(2) syscalls, leading to potential problems.
+antirez in commit e565632:
+ Child -> Parent pipe for COW info transferring.
+ 6 files changed, 132 insertions(+), 3 deletions(-)
 
-Please note that since having access to CONFIG SET also means to be able
-to change the AOF filename (and many other things) directly, this issue
-actual real world impact is quite small, so I would not panik: if you
-have CONFIG SET level of access, you can do more and more easily.
+antirez in commit e1eccf9:
+ zmalloc: Make fp var non local to fix build.
+ 1 file changed, 3 insertions(+), 2 deletions(-)
 
-AFFECTED VERSIONS:
+antirez in commit 945a2f9:
+ zmalloc: zmalloc_get_smap_bytes_by_field() modified to work for any PID.
+ 5 files changed, 24 insertions(+), 12 deletions(-)
 
-All Redis 3.2.x versions are affected.
+antirez in commit b13759e:
+ redis-cli: "allocator-stats" -> "malloc-stats".
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-OTHER CHANGES IN THIS RELEASE:
+antirez in commit 4263b12:
+ Typo fixed from MEMORY DOCTOR output.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-This release also includes other things:
+antirez in commit 8a00ffc:
+ Surround allocator name with quotes in MEMORY DOCTOR output.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-* TCP binding bug fixed when only certain addresses were available for
-a given port.
+antirez in commit 44e714a:
+ MEMORY DOCTOR initial implementation.
+ 4 files changed, 104 insertions(+), 8 deletions(-)
 
-* A much better crash report that includes part of the Redis binary:
-this will allow to fix bugs even when we just have a crash log and
-no other help from the original poster oft the issue.
+antirez in commit d9325ac:
+ Provide percentage of memory peak used info.
+ 3 files changed, 13 insertions(+), 1 deletion(-)
 
-* A fix for Redis Cluster redis-trib displaying of info after creating
-a new cluster.
+oranagra in commit 309c2bc:
+ add zmalloc used mem to DEBUG SDSLEN
+ 2 files changed, 7 insertions(+), 3 deletions(-)
 
-Please check the following list of commits for credits about who did what.
-Thanks to all the contributors and a special thank to Oran Agra for the
-help in this release.
+antirez in commit 78f35f8:
+ Memory related subcommands of DEBUG moved to MEMORY.
+ 3 files changed, 43 insertions(+), 41 deletions(-)
 
-List of commits:
+antirez in commit 123891d:
+ Group MEMORY command related APIs together in the source code.
+ 1 file changed, 53 insertions(+), 53 deletions(-)
 
-antirez in commit 0539634:
- Security: CONFIG SET client-output-buffer-limit overflow fixed.
- 1 file changed, 5 insertions(+), 3 deletions(-)
+antirez in commit adcfb77:
+ objectComputeSize(): skiplist nodes have different sizes.
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+antirez in commit e9629e1:
+ MEMORY command: HELP + dataset percentage (like in INFO).
+ 3 files changed, 20 insertions(+), 8 deletions(-)
+
+antirez in commit 5443726:
+ MEMORY USAGE: SAMPLES option added + fixes to size computation.
+ 1 file changed, 27 insertions(+), 18 deletions(-)
+
+antirez in commit 7229af3:
+ INFO: new memory reporting fields added.
+ 1 file changed, 15 insertions(+), 1 deletion(-)
+
+antirez in commit bf2624e:
+ C struct memoh renamed redisMemOverhead. API prototypes added.
+ 2 files changed, 28 insertions(+), 26 deletions(-)
+
+antirez in commit be5439b:
+ MEMORY OVERHEAD refactored into a generic API.
+ 1 file changed, 130 insertions(+), 73 deletions(-)
+
+antirez in commit 09a50d3:
+ dict.c: dictReplaceRaw() -> dictAddOrFind().
+ 3 files changed, 4 insertions(+), 4 deletions(-)
+
+antirez in commit 041ab04:
+ Trim comment to 80 cols.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit a636aea:
+ Apply the new dictUnlink() where possible.
+ 3 files changed, 9 insertions(+), 8 deletions(-)
+
+oranagra in commit afcbcc0:
+ dict.c: introduce dictUnlink().
+ 3 files changed, 45 insertions(+), 11 deletions(-)
+
+antirez in commit 8c84c96:
+ MEMORY OVERHEAD implemented (using Oran Agra initial implementation).
+ 3 files changed, 104 insertions(+), 2 deletions(-)
+
+antirez in commit 89dec69:
+ objectComputeSize(): estimate collections sampling N elements.
+ 3 files changed, 51 insertions(+), 31 deletions(-)
+
+oranagra in commit 8c24325:
+ Adding objectComputeSize() function.
+ 1 file changed, 113 insertions(+)
+
+oranagra in commit 68bf45f:
+ Optimize repeated keyname hashing.
+ 5 files changed, 56 insertions(+), 59 deletions(-)
+
+Salvatore Sanfilippo in commit d680eb6:
+ Merge pull request #3492 from wyxustcsa09/fix-memory
+antirez in commit c6dc8d5:
+ Merge branch 'unstable' of github.com:antirez/redis into unstable
+antirez in commit 56dba3a:
+ Example modules: Add C99 standard to cflags.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-antirez in commit c01abcd:
+antirez in commit 3793afa:
+ Merge branch 'aofrdb' into unstable
+antirez in commit f962481:
  fix the fix for the TCP binding.
  1 file changed, 15 insertions(+), 10 deletions(-)
 
-oranagra in commit a6d0698:
+oranagra in commit 9203828:
  fix tcp binding when IPv6 is unsupported
  2 files changed, 14 insertions(+), 10 deletions(-)
 
-antirez in commit 22b6c28:
+antirez in commit d35deb2:
  debug.c: no need to define _GNU_SOURCE, is defined in fmacros.h.
  1 file changed, 1 deletion(-)
 
-antirez in commit 9e9d398:
+antirez in commit 6211e77:
  crash log - improve code dump with more info and called symbols.
  1 file changed, 59 insertions(+), 20 deletions(-)
 
-oranagra in commit 3745c5d:
+wyx in commit f9c9b4b:
+ fix memory error on module unload
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+oranagra in commit 24811fc:
  crash log - add hex dump of function code
  1 file changed, 22 insertions(+)
 
-antirez in commit c1cc07b:
- Sentinel example config: warn about protected mode.
- 1 file changed, 16 insertions(+), 1 deletion(-)
+antirez in commit 0d179d1:
+ dict.c benchmark minor improvements.
+ 1 file changed, 19 insertions(+), 1 deletion(-)
+
+antirez in commit bd6c4ca:
+ dict.c benchmark: mixed del/insert benchmark.
+ 1 file changed, 11 insertions(+)
 
-rojingeorge in commit 011dc9f:
- Display the nodes summary once the cluster is established using redis-trib.rb
+antirez in commit 0f708ab:
+ dict.c benchmark: finish rehashing before testing lookups.
  1 file changed, 5 insertions(+)
 
-Guo Xiao in commit f4e3a94:
- Use the standard predefined identifier __func__ (since C99)
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit ed6a451:
+ dict.c benchmark improvements.
+ 1 file changed, 27 insertions(+), 4 deletions(-)
 
-================================================================================
-Redis 3.2.3     Released Tue Aug 02 10:55:24 CEST 2016
-================================================================================
-
-Upgrade urgency MODERATE: Fix replication delay and redis-cli security issue.
+antirez in commit 1074f73:
+ dict.c benchmark: take optional count argument.
+ 1 file changed, 11 insertions(+), 3 deletions(-)
 
-Hello,
+antirez in commit 91a59e0:
+ dict.c benchmark.
+ 2 files changed, 60 insertions(+), 1 deletion(-)
 
-this is a minor release of Redis addressing two bugs:
+antirez in commit 57a0db9:
+ Fix rdb.c var types when calling rdbLoadLen().
+ 1 file changed, 3 insertions(+), 3 deletions(-)
 
-1. There was an inverted if statement logic problem in replication.c causing
-   a replication delay. This is not an actual problem since things work
-   as expected, but worth to fix ASAP anyway.
+antirez in commit 9f76d82:
+ sds: don't check for impossible string size in 32 bit systems.
+ 1 file changed, 3 insertions(+)
 
-2. Redis-cli created the history file with insecure permissions, allowing
-   reding from the file. This was actually a bug in linenoise which is
-   now fixed. The applied fix is from Chris Lamb.
+antirez in commit dacb69e:
+ RDB AOF preamble: test it in the aofrw unit.
+ 1 file changed, 52 insertions(+), 49 deletions(-)
+
+antirez in commit 764cc69:
+ Document RDB preamble in AOF rewrites in redis.conf.
+ 1 file changed, 14 insertions(+)
 
-List of commits:
+antirez in commit e0d4146:
+ Sentinel example config: warn about protected mode.
+ 1 file changed, 16 insertions(+), 1 deletion(-)
 
-Qu Chen in commit e67ad1d:
- Fix a bug to delay bgsave while AOF rewrite in progress for replication
+antirez in commit 543e25e:
+ RDB AOF preamble: WIP 4 (Mixed RDB/AOF loading).
+ 2 files changed, 33 insertions(+), 6 deletions(-)
+
+antirez in commit f1c32f0:
+ RDB AOF preamble: WIP 3 (RDB loading refactoring).
+ 1 file changed, 38 insertions(+), 29 deletions(-)
+
+antirez in commit feda523:
+ RDB AOF preamble: WIP 2.
+ 5 files changed, 37 insertions(+), 28 deletions(-)
+
+antirez in commit 4426cb1:
+ RDB AOF preamble: WIP 1.
+ 4 files changed, 72 insertions(+), 35 deletions(-)
+
+Salvatore Sanfilippo in commit 9f779b3:
+ Merge pull request #3340 from rojingeorge/unstable
+Salvatore Sanfilippo in commit c5414ce:
+ Merge pull request #3429 from guoxiao/warning
+Guo Xiao in commit 4bd72ab:
+ Use the standard predefined identifier __func__ (since C99)
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-antirez in commit 7153668:
- Update linenoise to fix insecure redis-cli history file creation.
- 1 file changed, 6 insertions(+), 1 deletion(-)
+antirez in commit e7f1798:
+ Modules: basic call/reply tests in test module.
+ 1 file changed, 71 insertions(+)
 
-================================================================================
-Redis 3.2.2     Released Thu Jul 28 14:14:54 CEST 2016
-================================================================================
+antirez in commit 13f18d2:
+ Modules: handle NULL replies more gracefully.
+ 1 file changed, 6 insertions(+)
 
-Upgrade urgency MODERATE: A Redis server and a Sentinel crash are now fixed.
-                          GEORADIUS errors in reported entries are fixed.
+antirez in commit a81a92c:
+ Security: Cross Protocol Scripting protection.
+ 3 files changed, 27 insertions(+), 2 deletions(-)
 
-Hi all! Redis 3.2.2 is finally out with non trivial bugfixes and a few new
-features. Let's start from the bugs:
+antirez in commit ede6e22:
+ Fix comment over 80 cols.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-1. There was a bug in the List type implementation, able to cause the
-   crash of the server under certain (non trivial to replicate) circumstances
-   when the LSET command was used. Now the bug is fixed and a new stress tester
-   that was able to easily trigger the bug was added to the test suite.
-
-2. Redis Sentinel, when monitoring multiple masters, could crash after
-   a Sentinel address update event.
-
-3. Redis Sentinel now checks slaves INFO state more often when disconnected.
-   This is not really a bug fix, but may allow to more easily detect that
-   a slave is able to fail over its master reducing certain delays.
-
-4. It was possible, under a variety of conditions, that the AOF and RDB children
-   process could spawn at the same time. This is known to trash disk I/O,
-   AOF performances, and to ultimately create latency in the Redis server.
-   Normally Redis avoids to have the two writing children at the same time, but
-   there were edge cases discovered by Oran Agra (that also co-authored the
-   fix with me) where the double-fork could happen. In order to fix this bug
-   non trivial changes to the replication code were operated, however it was
-   important to back port this fix into 3.2.2 because the bug could lead to
-   bad latency experiences in certain cases.
-
-5. Many GEORADIUS bugs are now fixed \o/. This started as a failing CI
-   test. I grepped for more clues and there were a number of random failures
-   in the points reported by GEORADIUS. The errors were found to be related
-   to three different bugs (one of these was a bug in the test itself).
-   It's not a critical bug: the effect is to, sometimes, don't report objects
-   that are near the radius, but only with specific sets of coordinates
-   and radius settings. However now the issues are fixed and the error
-   vectors were added as regression tests.
-
-And now the good news (not that bug fixes are not good...), that is, the
-new features!
-
-1. Now slaves support the slave-announce-ip and slave-announce-port options.
-   Using these features a slave can be reported by the master `INFO` output
-   and `ROLE` command as having arbitrary IP and port. This allows to have
-   Sentinel deployments when working with containers or NAT-ed environments
-   more easily.
-
-2. The RDB check utlity is now part of Redis and uses the same RDB code that
-   Redis uses in order to load the dataset in memory, so a given version
-   of Redis is always able to check the RDB it produced... without another
-   external check tool which is supposed to be taken in sync with the
-   rdb.c implementation. This in turn also means that the new RDB checking
-   is able to spot more complex bugs, since it really loads the dataset
-   instead of just skipping bytes.
-
-About the redis-check-dump utility, now it is also able to show certain
-information about the RDB file, like the version that produced it, when
-it was produced, and so forth. Example:
-
-    ./redis-check-rdb dump.rdb
-    [offset 0] Checking RDB file dump.rdb
-    [offset 32] AUX FIELD redis-ver = '3.2.2'
-    [offset 46] AUX FIELD redis-bits = '64'
-    [offset 58] AUX FIELD ctime = '1469710178'
-    [offset 73] AUX FIELD used-mem = '1186528'
+antirez in commit 04340e1:
+ Modules: initial draft for a testing module.
+ 3 files changed, 235 insertions(+), 93 deletions(-)
 
-The ability to check how much memory was used by the instance that produced
-the RDB file can be especially useful.
+antirez in commit 7829e4e:
+ Modules: StringAppendBuffer() and ability to retain strings.
+ 3 files changed, 91 insertions(+), 5 deletions(-)
 
-For credits and the full change log, see the list of commits below, that was
-modified in order to be a bit less verbose compared to the last releases.
+Qu Chen in commit d982f44:
+ Fix a bug to delay bgsave while AOF rewrite in progress for replication
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Enjoy!
-Salvatore
+antirez in commit 9424fe4:
+ Remove extra "-" from ASCII horizontal bar in comment.
+ 2 files changed, 2 insertions(+), 2 deletions(-)
+
+antirez in commit 9d52411:
+ Update linenoise to fix insecure redis-cli history file creation.
+ 1 file changed, 6 insertions(+), 1 deletion(-)
+
+antirez in commit 8966d4c:
+ Changelog format modified to be less verbose.
+ 1 file changed, 5 insertions(+), 1 deletion(-)
 
-antirez in commit 0a45fbc:
+antirez in commit 55385f9:
  Ability of slave to announce arbitrary ip/port to master.
  6 files changed, 129 insertions(+), 17 deletions(-)
 
-antirez in commit c3982c0:
- redis-benchmark: new option to show server errors on stdout.
- 1 file changed, 17 insertions(+), 1 deletion(-)
-
-antirez in commit fdafe23:
+antirez in commit 356a630:
  Multiple GEORADIUS bugs fixed.
- 6 files changed, 177 insertions(+), 21 deletions(-)
+ 6 files changed, 199 insertions(+), 21 deletions(-)
 
-antirez in commit a1bfe22:
+antirez in commit 03f5b50:
  Replication: when possible start RDB saving ASAP.
  1 file changed, 8 insertions(+), 2 deletions(-)
 
-antirez in commit 7ca69af:
+antirez in commit 8b76d55:
  Sentinel: new test unit 07 that tests master down conditions.
  1 file changed, 68 insertions(+)
 
-antirez in commit 5b5e652:
+antirez in commit 3e9ce38:
  Sentinel: check Slave INFO state more often when disconnected.
  2 files changed, 10 insertions(+), 3 deletions(-)
 
-antirez in commit 21cffc2:
+antirez in commit 0a628e5:
  Avoid simultaneous RDB and AOF child process.
  4 files changed, 51 insertions(+), 8 deletions(-)
 
-antirez in commit 017378e:
+antirez in commit 780a8b1:
  Replication: start BGSAVE for replication always in replicationCron().
  1 file changed, 15 insertions(+), 12 deletions(-)
 
-antirez in commit 940be9a:
+antirez in commit e0582b3:
+ Fix maxmemory shared integer check bug introduced with LFU.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 2d5eb1f:
+ Volatile-ttl eviction policy implemented in terms of the pool.
+ 2 files changed, 25 insertions(+), 48 deletions(-)
+
+antirez in commit 9f1b7ab:
+ test-lru.rb: support for testing volatile-ttl policy.
+ 1 file changed, 49 insertions(+), 14 deletions(-)
+
+antirez in commit 6854c7b:
+ LFU: make counter log factor and decay time configurable.
+ 5 files changed, 95 insertions(+), 14 deletions(-)
+
+antirez in commit 6416ab1:
+ LFU: Use the LRU pool for the LFU algorithm.
+ 1 file changed, 25 insertions(+), 36 deletions(-)
+
+antirez in commit dbce190:
+ LFU: Fix bugs in frequency decay code.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+antirez in commit a8e2d08:
+ LFU: Initial naive eviction cycle.
+ 3 files changed, 49 insertions(+), 4 deletions(-)
+
+antirez in commit 24dd4a8:
+ redis-cli LRU test mode: randomize value of key when setting.
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+antirez in commit b8450d7:
+ redis-cli LRU test mode: remove newline from key names.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 5d07984:
+ LFU: Redis object level implementation.
+ 5 files changed, 142 insertions(+), 15 deletions(-)
+
+antirez in commit ada70c7:
+ LFU simulator: remove dead code.
+ 1 file changed, 5 deletions(-)
+
+antirez in commit fc92c66:
+ LRU simulator: fix new entry creation decr time.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit f50dc38:
+ LRU simulator: fix new entry creation.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+antirez in commit 09fcb00:
+ LFU: Simulation of the algorithm planned for Redis.
+ 1 file changed, 163 insertions(+)
+
+antirez in commit e423f76:
+ LRU: Make cross-database choices for eviction.
+ 3 files changed, 161 insertions(+), 110 deletions(-)
+
+antirez in commit e64bf05:
+ LRU: cache SDS strings in the eviction pool.
+ 1 file changed, 29 insertions(+), 13 deletions(-)
+
+antirez in commit 965905c:
+ Move the struct evictionPoolEntry() into only file using it.
+ 2 files changed, 22 insertions(+), 12 deletions(-)
+
+antirez in commit d8e92a8:
+ Move prototype of evictionPoolAlloc() in server.h.
+ 2 files changed, 3 insertions(+), 2 deletions(-)
+
+antirez in commit 3b9495d:
+ LRU: use C99 variable len stack array in evictionPoolPopulate().
+ 1 file changed, 1 insertion(+), 11 deletions(-)
+
+antirez in commit 2a12473:
+ redis-benchmark: new option to show server errors on stdout.
+ 1 file changed, 17 insertions(+), 1 deletion(-)
+
+antirez in commit 382991f:
+ Remove useless memmove() from freeMemoryIfNeeded().
+ 1 file changed, 2 insertions(+), 7 deletions(-)
+
+antirez in commit b19b2df:
+ LRU: Fix output fixes to new test-lru.rb.
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+antirez in commit 6a1c00c:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit 32a5494:
+ LRU: test-lru.rb improved in different ways.
+ 2 files changed, 180 insertions(+), 98 deletions(-)
+
+antirez in commit 51c1d40:
+ redis_check_rdb(): the rio structure must be global.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit eee878c:
+ redis_check_rdb_main(): create shared objects only if needed.
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+antirez in commit 24882e3:
+ Fix redis_check_rdb() return value.
+ 1 file changed, 3 insertions(+), 2 deletions(-)
+
+antirez in commit 1e6bb9e:
+ Remove dead code from geohash_helper.c.
+ 1 file changed, 6 deletions(-)
+
+antirez in commit 3961071:
+ Fix signess issue in geohashEstimateStepsByRadius().
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+antirez in commit 504ccad:
+ Fix definition of M_PI in geohash_helper.c.
+ 2 files changed, 2 insertions(+), 1 deletion(-)
+
+antirez in commit eaa713e:
+ geohash.c and geohash_helper.c are part of Redis.
+ 11 files changed, 686 insertions(+), 717 deletions(-)
+
+antirez in commit 4a140d3:
+ Add expire.c and evict.c.
+ 2 files changed, 718 insertions(+)
+
+antirez in commit b46239e:
+ Expire and LRU related code moved into different files.
+ 5 files changed, 4 insertions(+), 633 deletions(-)
+
+antirez in commit 0610683:
+ Makefile: don't build dependencies file for clean, distclean.
+ 1 file changed, 3 insertions(+)
+
+antirez in commit 1036182:
+ Generate Makefile.dep at every build.
+ 3 files changed, 6 insertions(+), 194 deletions(-)
+
+antirez in commit abb3385:
  Regression test for issue #3333.
  1 file changed, 6 insertions(+)
 
-antirez in commit 21736b4:
+antirez in commit 2379182:
  getLongLongFromObject: use string2ll() instead of strict_strtoll().
- 1 file changed, 1 insertion(+), 6 deletions(-)
+ 1 file changed, 1 insertion(+), 15 deletions(-)
 
-antirez in commit 0b748e9:
+antirez in commit ef6a4df:
  redis-cli: check SELECT reply type just in state updated.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-sskorgal in commit 1158386:
- Fix for redis_cli printing default DB when select command fails.
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
-antirez in commit 026f9fc:
+Salvatore Sanfilippo in commit 0df2865:
+ Merge pull request #3365 from sskorgal/unstable
+antirez in commit c383be3:
  Sentinel: fix cross-master Sentinel address update.
  1 file changed, 9 insertions(+), 2 deletions(-)
 
-antirez in commit 11523b3:
+antirez in commit b2cc8bc:
  CONFIG GET is now no longer case sensitive.
  1 file changed, 12 insertions(+), 12 deletions(-)
 
-antirez in commit f5a7f4f:
+antirez in commit a0dd014:
  Fix test for new RDB checksum failure message.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-antirez in commit 4c6ff74:
+antirez in commit b99ad1b:
  Make tcp-keepalive default to 300 in internal conf.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-antirez in commit 27dbec2:
+antirez in commit 7e220a9:
  In Redis RDB check: more details in error reportings.
- 1 file changed, 24 insertions(+), 13 deletions(-)
+ 1 file changed, 21 insertions(+), 13 deletions(-)
 
-antirez in commit 41f3004:
+antirez in commit e697153:
  In Redis RDB check: log decompression errors.
  2 files changed, 23 insertions(+), 2 deletions(-)
 
-antirez in commit 278fe3e:
+antirez in commit df3c69e:
  In Redis RDB check: log object type on error.
  1 file changed, 27 insertions(+), 2 deletions(-)
 
-antirez in commit a117dfa:
+antirez in commit c0f4d19:
  Added a trivial program to randomly corrupt RDB files in /utils.
  1 file changed, 44 insertions(+)
 
-antirez in commit f5110c3:
+antirez in commit 2ab7097:
  In Redis RDB check: minor output message changes.
  1 file changed, 4 insertions(+), 1 deletion(-)
 
-antirez in commit 35b18bf:
+antirez in commit e9f31ba:
  In Redis RDB check: better error reporting.
  4 files changed, 71 insertions(+), 14 deletions(-)
 
-antirez in commit f578f08:
- In Redis RDB check: initial POC.
- 2 files changed, 189 insertions(+), 647 deletions(-)
+sskorgal in commit 9dfd9d1:
+ Fix for redis_cli printing default DB when select command fails.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-tielei in commit 7f1e1ca:
- A string with 21 chars is not representable as a 64-bit integer.
- 1 file changed, 2 insertions(+), 2 deletions(-)
+antirez in commit e97fadb:
+ In Redis RDB check: initial POC.
+ 2 files changed, 189 insertions(+), 660 deletions(-)
 
-antirez in commit 7a3a595:
+Rojin George in commit d0f5307:
+ Merge remote-tracking branch 'refs/remotes/antirez/unstable' into unstable
+antirez in commit 24bd9b1:
  Test: new randomized stress tester for #3343 alike bugs.
  1 file changed, 27 insertions(+), 2 deletions(-)
 
-antirez in commit c75ca10:
+antirez in commit f983318:
  Stress tester WIP.
  1 file changed, 3 insertions(+)
 
-antirez in commit 2c3fcf8:
+antirez in commit 4989986:
  Regression test for issue #3343 exact min crash sequence.
  1 file changed, 16 insertions(+)
 
-antirez in commit 7041967:
+antirez in commit dc18a6a:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit 5e176e1:
  Fix quicklistReplaceAtIndex() by updating the quicklist ziplist size.
  1 file changed, 1 insertion(+)
 
-================================================================================
-Redis 3.2.1     Released Fri Jun 17 15:01:56 CEST 2016
-================================================================================
+Salvatore Sanfilippo in commit ae4f5b3:
+ Merge pull request #3342 from yossigo/fix_calloc
+Yossi Gottlieb in commit 19c401d:
+ Fix RedisModule_Calloc() definition typo.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Upgrade urgency HIGH: Critical fix to Redis Sentinel, due to 3.2.0 regression
-                      compared to 3.0.
+rojingeorge in commit 4242fdf:
+ Display the nodes summary once the cluster is established using redis-trib.rb
+ 1 file changed, 5 insertions(+)
 
-Hey, this is Redis 3.2.1, and this release should bring some grain of
-maturity to Redis 3.2. The list of commits following this note will tell
-you the details, but the main things addressed in this release are the
-following:
-
-1. A critical bug in Sentinel was hopefully fixed. During the big 3.2
-   refactoring of Redis Sentinel, in order to implement connection sharing
-   to make Sentinel able to scale better (few Sentinels to monitor many
-   masters), a bug was introduced that mis-counted the number of pending
-   commands in the Redis link. This in turn resulted into an inability to talk
-   with certain Redis instances. A common result of this bug was the inability
-   of Redis Sentinel to reconfigure back the old master, after a failover,
-   when it is reachable again, as the slave of the new master. This was due
-   to the inability to talk with the old master at all.
-
-2. BITFIELD bugs fixed.
-
-3. GEO commands fixes on syntax errors and edge cases.
-
-4. RESTORE now accepts dumps generated by older Redis versions.
-
-5. Jemalloc now is really configured to save you memory, for a problem a
-   change in the jemalloc configuration did not really survived when the
-   3.2.0 release was finalized.
-
-6. TTL and TYPE command no longer alter the last access time of a key, for
-   LRU evictions purposes. A new TOUCH command was introduced *just* to
-   update the access time of a key.
-
-7. A bug was fixed in redis-cli, that connected to the instance running on the
-   port 6379 if there was one, regardless of what was specified.
-
-8. TCP keep alive is now enabled by default. This should fix most ghost
-   connections problems without resulting in any practical change in otherwise
-   sane deployments.
-
-9. A Sentinel crash that could happen during failovers was fixed.
-
-And of course, more minor things that you can read in the detailed log
-below. There are still reported bugs for 3.2 that were not fixed in this
-release, but nothing critical AFAIK, and I wanted to release this one ASAP,
-so likely a new release will not be too far.
+rojingeorge in commit 4aab50a:
+ Merge remote-tracking branch 'refs/remotes/antirez/unstable' into unstable
+Salvatore Sanfilippo in commit f60aa4d:
+ Merge pull request #3324 from mishan/fix-wrong-comment-about-sentinel-mode
+antirez in commit 1898311:
+ Modules: mention RedisModule_Calloc() in the doc.
+ 1 file changed, 1 insertion(+)
 
-Enjoy,
-Salvatore
+Salvatore Sanfilippo in commit 3a0b776:
+ Merge pull request #3335 from dvirsky/rm_calloc
+antirez in commit c026b5c:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit 0f484d8:
+ Actually remove static from #3331.
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+Salvatore Sanfilippo in commit 28ea585:
+ Merge pull request #3336 from yossigo/create_string_from_string
+antirez in commit c0ca87d:
+ Minor change to conform PR #3331 to Redis code base style.
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+Salvatore Sanfilippo in commit a66dd43:
+ Merge pull request #3331 from yossigo/fix_openkey_crash
+Salvatore Sanfilippo in commit 393c468:
+ Merge pull request #3338 from tielei/unstable
+tielei in commit f648c5a:
+ A string with 21 chars is not representable as a 64-bit integer.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| config set list-max-ziplist-size didn't support negative values, unlike config file
-| By oranagra, 2016-05-22 20:35:14 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/8207e828043e37a0d7e058530d2886bb3ff395ff
+Salvatore Sanfilippo in commit 3d48c93:
+ Merge pull request #3330 from yossigo/fix_const
+antirez in commit 4b12c6a:
+ Modules: changes to logging function.
+ 3 files changed, 39 insertions(+), 19 deletions(-)
+
+Yossi Gottlieb in commit 715794b:
+ Add RedisModule_Log() logging API function.
+ 3 files changed, 42 insertions(+)
 
+antirez in commit b507289:
+ Commit change in autoMemoryFreed(): first -> last.
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
- src/config.c | 6 +++---
- 1 file changed, 3 insertions(+), 3 deletions(-)
+antirez in commit f2dbc02:
+ Modules: implement zig-zag scanning in autoMemoryFreed().
+ 1 file changed, 20 insertions(+), 16 deletions(-)
+
+Salvatore Sanfilippo in commit 2fe9b79:
+ Merge pull request #3244 from dvirsky/optimize_autoMemoryFreed
+Yossi Gottlieb in commit 61172ed:
+ Add RedisModule_CreateStringFromString().
+ 5 files changed, 26 insertions(+), 2 deletions(-)
+
+Dvir Volk in commit dc7f3fe:
+ added RM_Calloc implementation
+ 2 files changed, 13 insertions(+), 1 deletion(-)
+
+antirez in commit 4e10b08:
+ Modules doc: hint about replacing libc malloc calls.
+ 1 file changed, 15 insertions(+), 1 deletion(-)
+
+Yossi Gottlieb in commit e22f3e4:
+ Cleanup: remove zset reset function from RM_ZsetRangeStop().
+ 1 file changed, 13 insertions(+), 7 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Fix Sentinel pending commands counting.
-| By antirez, 2016-06-16 19:24:34 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/6ad0371c9b4206a7a6692d50c9a301457baf9b6d
+Yossi Gottlieb in commit a8e2034:
+ Fix occasional RM_OpenKey() crashes.
+ 1 file changed, 1 insertion(+)
 
-This bug most experienced effect was an inability of Redis to
-reconfigure back old masters to slaves after they are reachable again
-after a failover. This was due to failing to reset the count of the
-pending commands properly, so the master appeared fovever down.
+Yossi Gottlieb in commit 8f3a4df:
+ Use const in Redis Module API where possible.
+ 13 files changed, 38 insertions(+), 38 deletions(-)
+
+Salvatore Sanfilippo in commit 0b4b7eb:
+ Merge pull request #3252 from oranagra/config_fix
+Misha Nasledov in commit 7a5538d:
+ Fix incorrect comment for checkForSentinelMode function
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Was introduced in Redis 3.2 new Sentinel connection sharing feature
-which is a lot more complex than the 3.0 code, but more scalable.
+antirez in commit f7351f4:
+ Fix Sentinel pending commands counting.
+ 1 file changed, 1 insertion(+)
 
-Many thanks to people reporting the issue, and especially to
-@sskorgal for investigating the issue in depth.
+antirez in commit 7c8f275:
+ redis-cli: really connect to the right server.
+ 1 file changed, 5 insertions(+), 2 deletions(-)
 
-Hopefully closes #3285.
+antirez in commit a3f893b:
+ RESTORE: accept RDB dumps with older versions.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/sentinel.c | 1 +
- 1 file changed, 1 insertion(+)
+Salvatore Sanfilippo in commit 8272cea:
+ Merge pull request #3255 from oranagra/error_string
+Salvatore Sanfilippo in commit 64b834b:
+ Merge pull request #3256 from oranagra/georasius_neg
+antirez in commit 2f2fd64:
+ Minor aesthetic fixes to PR #3264.
+ 1 file changed, 5 insertions(+), 5 deletions(-)
+
+Salvatore Sanfilippo in commit 33a9836:
+ Merge pull request #3264 from oranagra/bitfield_fix2
+Salvatore Sanfilippo in commit 5d83f6c:
+ Merge pull request #3274 from MOON-CLJ/fix_promoted_slave
+antirez in commit 3bd20ea:
+ Test TOUCH and new TTL / TYPE behavior about object access time.
+ 2 files changed, 24 insertions(+)
+
+Salvatore Sanfilippo in commit 226f679:
+ Merge pull request #3283 from ideal/unstable
+Salvatore Sanfilippo in commit bd2cd70:
+ Merge pull request #3281 from jamespedwards42/unstable
+antirez in commit 2d86995:
+ GETRANGE: return empty string with negative, inverted start/end.
+ 2 files changed, 6 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| redis-cli: really connect to the right server.
-| By antirez, 2016-06-16 17:23:31 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/58f1d446c35e8fe62df7c9ebe10f3c40a386c022
+antirez in commit eb45e11:
+ Remove additional round brackets from fix for #3282.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-I recently introduced populating the autocomplete help array with the
-COMMAND command if available. However this was performed before parsing
-the arguments, defaulting to instance 6379. After the connection is
-performed it remains stable.
+antirez in commit ca54335:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+Salvatore Sanfilippo in commit 001cadc:
+ Merge pull request #3282 from wenduo/unstable
+antirez in commit 212f157:
+ Regression test for #3282.
+ 1 file changed, 10 insertions(+)
 
-The effect is that if there is an instance running on port 6339,
-whatever port you specify is ignored and 6379 is connected to instead.
-The right port will be selected only after a reconnection.
+Salvatore Sanfilippo in commit 3deb7ba:
+ Merge pull request #3226 from MichielDeMey/patch-1
+Salvatore Sanfilippo in commit 82554ca:
+ Merge pull request #3313 from zshipko/unstable
+zach shipko in commit b7b9aa6:
+ BSDs don't have -ldl
+ 1 file changed, 15 insertions(+), 5 deletions(-)
 
-Close #3314.
+antirez in commit 41d804d:
+ TTL and TYPE LRU access fixed. TOUCH implemented.
+ 3 files changed, 60 insertions(+), 8 deletions(-)
 
- src/redis-cli.c | 7 +++++--
- 1 file changed, 5 insertions(+), 2 deletions(-)
+antirez in commit cd8e688:
+ redis-cli help.h updated.
+ 1 file changed, 13 insertions(+), 8 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Remove debug printing
-| By Jan-Erik Rediger, 2016-05-21 13:50:01 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/b6007b324b81dbd4ffe519b3bdb19ab65fbb407f
+antirez in commit c6e3ce3:
+ Enable tcp-keepalive by default.
+ 1 file changed, 3 insertions(+), 2 deletions(-)
 
+antirez in commit 5ba9bde:
+ Modules: document how to pass config params to modules.
+ 1 file changed, 19 insertions(+), 1 deletion(-)
+
+antirez in commit 5831dd8:
+ Fix example modules to have the right OnLoad() prototype.
+ 2 files changed, 8 insertions(+), 2 deletions(-)
+
+antirez in commit a4bce77:
+ Don't assume no padding or specific ordering in moduleLoadQueueEntry structure.
+ 2 files changed, 4 insertions(+), 3 deletions(-)
 
- src/redis-cli.c | 3 ---
+antirez in commit 9a02dac:
+ Free module context after loading.
+ 1 file changed, 1 insertion(+)
+
+antirez in commit b6cd008:
+ Make sure modules arguments are raw strings.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 1ad5c22:
+ Minor changes to unifor C style to Redis code base for PR #3293.
+ 3 files changed, 8 insertions(+), 6 deletions(-)
+
+Salvatore Sanfilippo in commit e8d5387:
+ Merge pull request #3293 from yossigo/module_config
+antirez in commit e71f22f:
+ Fix typo: after -> before.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit e4567f2:
+ Explain why module type names are 9 chars.
+ 1 file changed, 52 insertions(+)
+
+Salvatore Sanfilippo in commit 688996f:
+ Merge pull request #3295 from catwell/pr-1-warnings
+Salvatore Sanfilippo in commit b4327ae:
+ Merge pull request #3294 from yossigo/fix_unload
+antirez in commit a1684ff:
+ Remove tryObjectEncoding() calls from list type.
  1 file changed, 3 deletions(-)
 
-+-------------------------------------------------------------------------------
-| RESTORE: accept RDB dumps with older versions.
-| By antirez, 2016-06-16 15:53:57 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/f592b4d3178963878084a522b4fd050772c335ae
+antirez in commit 5beec97:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+Michiel De Mey in commit 90781de:
+ Added documentation for non-interactive install procedure
+ 1 file changed, 19 insertions(+), 3 deletions(-)
+
+Salvatore Sanfilippo in commit ab73544:
+ Merge pull request #3296 from catwell/pr-2-variadic-pushx
+andyli in commit 93a0987:
+ fix comment "b>a" to "a > b"
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 2a57ad5:
+ Fixed typo in Sentinel compareSlavesForPromotion() comment.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 243c9dc:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+Salvatore Sanfilippo in commit 01a34b1:
+ Merge pull request #2870 from SaurabhJha/documenation-fixes
+antirez in commit 67fcd26:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+Salvatore Sanfilippo in commit bac4de7:
+ Merge pull request #3180 from bogdanvlviv/fix_pidfile
+antirez in commit 5481336:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+Salvatore Sanfilippo in commit 53c008a:
+ Merge pull request #3303 from jspraul/patch-1
+antirez in commit b664aeb:
+ Improve timer callback creation comment.
+ 1 file changed, 3 insertions(+), 2 deletions(-)
 
-Reference issue #3218.
+jspraul in commit 4df95e8:
+ Include 'fd_set' type name
+ 1 file changed, 1 insertion(+)
 
-Checking the code I can't find a reason why the original RESTORE
-code was so opinionated about restoring only the current version. The
-code in to `rdb.c` appears to be capable as always to restore data from
-older versions of Redis, and the only places where it is needed the
-current version in order to correctly restore data, is while loading the
-opcodes, not the values itself as it happens in the case of RESTORE.
+Salvatore Sanfilippo in commit 30c1a85:
+ Merge pull request #3301 from yossigo/fix_unused_warning
+Yossi Gottlieb in commit 2fd6ca3:
+ Remove gcc warning when redismodule.h is included by a multi-file module.
+ 1 file changed, 1 insertion(+)
 
-For the above reasons, this commit enables RESTORE to accept older
-versions of values payloads.
+Saurabh Jha in commit 319b126:
+ Fixup
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+Saurabh Jha in commit 61717ac:
+ More edits to README
+ 1 file changed, 15 insertions(+), 15 deletions(-)
 
- src/cluster.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+Saurabh Jha in commit 0f10b16:
+ Address grammatical comments
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+Saurabh Jha in commit 90a3647:
+ Fix typos in documentation
+ 2 files changed, 15 insertions(+), 16 deletions(-)
+
+Pierre Chapuis in commit d88c3c7:
+ make RPUSHX and LPUSHX variadic
+ 3 files changed, 18 insertions(+), 9 deletions(-)
+
+Pierre Chapuis in commit b670a16:
+ remove unused variable
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| CLIENT error message was out of date
-| By oranagra, 2016-05-23 11:42:21 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/047ced4473ee35485e22e45db8b8b4a272bf1177
+Pierre Chapuis in commit 3e9c20f:
+ untangle LINSERT and {L,R}PUSHX implementations
+ 1 file changed, 45 insertions(+), 40 deletions(-)
+
+Pierre Chapuis in commit 188d90f:
+ fix some compiler warnings
+ 3 files changed, 17 insertions(+), 10 deletions(-)
+
+Yossi Gottlieb in commit 87312ff:
+ Fix MODULE UNLOAD crash and/or wrong error message.
+ 1 file changed, 14 insertions(+), 7 deletions(-)
+
+Yossi Gottlieb in commit cc58f11:
+ Use RedisModuleString for OnLoad argv.
+ 3 files changed, 5 insertions(+), 11 deletions(-)
+
+Yossi Gottlieb in commit 2bd13cf:
+ Allow passing arguments to modules on load.
+ 3 files changed, 46 insertions(+), 13 deletions(-)
+
+antirez in commit 550fa7e:
+ modules API.md updated.
+ 1 file changed, 232 insertions(+), 10 deletions(-)
+
+antirez in commit c3f5b6e:
+ Modules: native types doc, 70% done.
+ 1 file changed, 305 insertions(+)
+
+antirez in commit 5830d88:
+ Modules: pool allocator doc.
+ 1 file changed, 53 insertions(+), 1 deletion(-)
+
+antirez in commit 31eb8ec:
+ Modules: top comments in helloworld.c and hellotype.c.
+ 2 files changed, 74 insertions(+)
+
+antirez in commit 8ec2800:
+ Modules: support for modules native data types.
+ 11 files changed, 991 insertions(+), 35 deletions(-)
+
+antirez in commit 27e5f38:
+ RDB v8: fix rdbLoadLen() return value.
+ 3 files changed, 61 insertions(+), 36 deletions(-)
+
+antirez in commit e6554be:
+ RDB v8: new ZSET storage format with binary doubles.
+ 2 files changed, 27 insertions(+), 5 deletions(-)
+
+antirez in commit 4aae4f7:
+ RDB v8: ability to save uint64_t lengths.
+ 3 files changed, 34 insertions(+), 44 deletions(-)
 
+antirez in commit b64fcbc:
+ Test: run GEO tests by default.
+ 1 file changed, 1 insertion(+)
 
- src/networking.c | 2 +-
+antirez in commit 231c9db:
+ Now that SPOP can be called by scripts use BLPOP on 's' flag test.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| fix georadius returns multiple replies
-| By oranagra, 2016-05-23 13:58:50 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/14e04847ac2960aefe31dccbec63d2503cf09ca5
+antirez in commit 2503acf:
+ Avoid undefined behavior in BITFIELD implementation.
+ 1 file changed, 15 insertions(+), 8 deletions(-)
 
+Salvatore Sanfilippo in commit 9200312:
+ Merge pull request #3278 from itamarhaber/patch-8
+antirez in commit 5d4b5fb:
+ Geo: fix typo in geohashEstimateStepsByRadius().
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/geo.c | 7 +++++--
- 1 file changed, 5 insertions(+), 2 deletions(-)
+antirez in commit 18a513f:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit 4eff3dc:
+ Fix GEORADIUS wrong output with radius > Earth radius.
+ 1 file changed, 2 insertions(+)
 
-+-------------------------------------------------------------------------------
-| Minor aesthetic fixes to PR #3264.
-| By antirez, 2016-06-16 12:54:33 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/bd23ea3f9f3defbbdf512864ee1a88fd02665a7f
-
-Comment format fixed + local var modified from camel case to underscore
-separators as Redis code base normally does (camel case is mostly used
-for global symbols like structure names, function names, global vars,
-...).
+ideal in commit 4067132:
+ fix mistake comment in object.c
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/bitops.c | 10 +++++-----
- 1 file changed, 5 insertions(+), 5 deletions(-)
+wenduo in commit 41dacdb:
+ bitcount bug:return non-zero value when start > end (both negative)
+ 1 file changed, 4 insertions(+)
 
-+-------------------------------------------------------------------------------
-| check WRONGTYPE in BITFIELD before looping on the operations.
-| By oranagra, 2016-05-24 23:31:36 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/2a3ee58ec73b6abdeeb4890937b25191119bce35
+jamespedwards42 in commit 3432061:
+ Fix modules intro typos.
+ 1 file changed, 3 insertions(+), 4 deletions(-)
 
-optimization: lookup key only once, and grow at once to the max need
-fixes #3259 and #3221, and also an early return if wrongtype is discovered by SET
+Itamar Haber in commit 2866e02:
+ Allow SPOP from Lua scripts
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/bitops.c | 27 ++++++++++++++++++---------
+MOON_CLJ in commit aa57844:
+ fix check when can't send the command to the promoted slave
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+oranagra in commit 5d96b7e:
+ check WRONGTYPE in BITFIELD before looping on the operations.
  1 file changed, 18 insertions(+), 9 deletions(-)
 
-+-------------------------------------------------------------------------------
-| fix crash in BITFIELD GET on non existing key or wrong type see #3259
-| By oranagra, 2016-05-24 14:52:43 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/a2e27b810edfad18b3ecc9c176a4606f94a2f0e4
+oranagra in commit c4433d2:
+ fix crash in BITFIELD GET on non existing key or wrong type see #3259
+ 1 file changed, 5 insertions(+), 3 deletions(-)
 
-this was a bug in the recent refactoring: bee963c4459223d874e3294a0d8638a588d33c8e
+oranagra in commit f3e81de:
+ fix georadius returns multiple replies
+ 1 file changed, 5 insertions(+), 2 deletions(-)
 
- src/bitops.c | 8 +++++---
- 1 file changed, 5 insertions(+), 3 deletions(-)
+oranagra in commit 8d9d8d1:
+ CLIENT error message was out of date
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+Salvatore Sanfilippo in commit 8c4f4d1:
+ Merge pull request #3249 from badboy/rcli-debug-printing
+oranagra in commit 5fa711f:
+ config set list-max-ziplist-size didn't support negative values, unlike config file
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+Jan-Erik Rediger in commit 892565f:
+ Remove debug printing
+ 1 file changed, 3 deletions(-)
+
+Dvir Volk in commit 137fd86:
+ optimized amFree even further
+ 1 file changed, 9 insertions(+), 4 deletions(-)
+
+Dvir Volk in commit 46b07cb:
+ Optimized autoMemoryFreed loop
+ 1 file changed, 4 insertions(+), 1 deletion(-)
+
+antirez in commit b09a6b6:
+ Fix modules compilation when libc malloc is used.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| fix check when can't send the command to the promoted slave
-| By MOON_CLJ, 2016-05-26 13:10:12 +0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/26555f5e008b099b888ef39cabec632f4b31a038
+Salvatore Sanfilippo in commit bafed3d:
+ Merge pull request #3222 from oranagra/more_minir_fixes
+antirez in commit e3edae9:
+ Modules: RM_HashSet() SDS ownership business clarified in comments.
+ 1 file changed, 5 insertions(+), 5 deletions(-)
 
+Salvatore Sanfilippo in commit 01a83d0:
+ Merge pull request #3239 from dvirsky/fix_hashset_crash
+antirez in commit bee963c:
+ Code to access object string bytes repeated 3x refactored into 1 function.
+ 1 file changed, 39 insertions(+), 35 deletions(-)
 
- src/sentinel.c | 2 +-
+antirez in commit ffd1600:
+ Clarify that the LOG_STR_SIZE includes null term.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Test TOUCH and new TTL / TYPE behavior about object access time.
-| By antirez, 2016-06-15 17:15:18 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/f1c237cb6a647ad5400b0ebce124fd9802ea7f89
+Salvatore Sanfilippo in commit 4c9c9d7:
+ Merge pull request #3221 from oranagra/bitfield_fix
+antirez in commit 078f461:
+ Test for BITFIELD regression #3221.
+ 1 file changed, 5 insertions(+)
 
+antirez in commit c6c86ea:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit 968e838:
+ Actually use --with-lg-quantum=3 to build jemalloc.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- tests/test_helper.tcl          |  1 +
- tests/unit/introspection-2.tcl | 23 +++++++++++++++++++++++
- 2 files changed, 24 insertions(+)
+Dvir Volk in commit cfaef8d:
+ fixed bad transfer of ownership in HashSet causing a potential crash
+ 1 file changed, 7 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| GETRANGE: return empty string with negative, inverted start/end.
-| By antirez, 2016-06-15 12:48:58 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/d4831e328759bf5bd07c2c6e6ce1d60e84ba196f
+Salvatore Sanfilippo in commit b1b1f4e:
+ Merge pull request #3238 from oranagra/struct_fix
+oranagra in commit 283a812:
+ reduce struct padding by reordering members
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
+antirez in commit 9aff564:
+ Modules: initial pool allocator and a LEFTPAD usage example.
+ 3 files changed, 147 insertions(+), 4 deletions(-)
 
- src/bitops.c   | 4 ++--
- src/t_string.c | 4 ++++
- 2 files changed, 6 insertions(+), 2 deletions(-)
+Michiel De Mey in commit af1e63c:
+ Allow non-interactive execution of install_server
+ 1 file changed, 45 insertions(+), 28 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Remove additional round brackets from fix for #3282.
-| By antirez, 2016-06-15 12:16:39 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/9942070f5a41fa3bc953e9628a7248aeb7c0befa
+antirez in commit 646c958:
+ Modules: doc layout improved.
+ 4 files changed, 1475 insertions(+), 575 deletions(-)
 
+antirez in commit 745845d:
+ Modules doc: mention the functions not yet documented.
+ 1 file changed, 25 insertions(+), 8 deletions(-)
 
- src/bitops.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+oranagra in commit 77a9144:
+ fix crash in BITFIELD GET when key is integer encoded
+ 1 file changed, 15 insertions(+), 3 deletions(-)
 
-+-------------------------------------------------------------------------------
-| bitcount bug:return non-zero value when start > end (both negative)
-| By wenduo, 2016-05-30 16:21:08 +0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/f45fa5d05f47a5729786a69962119c9b3dc12645
+antirez in commit 5daece2:
+ RM_ZsetRangeNext()/Prev() typo in define name leading to crash fixed.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
+antirez in commit 5f977c3:
+ Modules: commandFlagsFromString() top comment back to 80 cols max.
+ 1 file changed, 29 insertions(+), 24 deletions(-)
 
- src/bitops.c | 4 ++++
- 1 file changed, 4 insertions(+)
+antirez in commit ef2b4f6:
+ Trailing spaces removed from moduleCreateArgvFromUserFormat().
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Regression test for #3282.
-| By antirez, 2016-06-15 11:49:49 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0cb86064e602a093a23b56943a7321fe1af64984
+antirez in commit 6250a6b:
+ Modules: RM_GetClientId() implemented.
+ 2 files changed, 19 insertions(+)
 
+Dvir Volk in commit 9a71df5:
+ fixed crash when calling CreateStringFromCallReply on array elements
+ 1 file changed, 1 insertion(+)
 
- tests/unit/bitops.tcl | 10 ++++++++++
- 1 file changed, 10 insertions(+)
+Itamar Haber in commit 3816f16:
+ Avoids reallocating and double String on truncate
+ 1 file changed, 17 insertions(+), 18 deletions(-)
 
-+-------------------------------------------------------------------------------
-| TTL and TYPE LRU access fixed. TOUCH implemented.
-| By antirez, 2016-06-14 15:33:59 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/b23aa6706ac79a1c86c64aef07bd35e38f10f842
+Dvir Volk in commit d41bd23:
+ fixed comment formatting in RM_CreateCommand
+ 1 file changed, 13 insertions(+), 13 deletions(-)
 
+Ramon Snir in commit 909a707:
+ vector of strings is implemented now
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/db.c     | 61 +++++++++++++++++++++++++++++++++++++++++++++++++++++-------
- src/server.c |  1 +
- src/server.h |  6 +++++-
- 3 files changed, 60 insertions(+), 8 deletions(-)
+Dvir Volk in commit a00e872:
+ another small comment fix
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| redis-cli help.h updated.
-| By antirez, 2016-06-14 14:45:48 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/6e4204fec9c78f3300d887ebc3db014df2c8b33e
+Dvir Volk in commit 87de31f:
+ fixed comment
+ 1 file changed, 3 insertions(+), 1 deletion(-)
 
+Dvir Volk in commit 8fc6708:
+ second attempt at vector formtting
+ 1 file changed, 12 insertions(+), 1 deletion(-)
 
- src/help.h | 43 +++++++++++++++++++++++++++++--------------
- 1 file changed, 29 insertions(+), 14 deletions(-)
+antirez in commit 7f5e134:
+ Modules: add ZADD_INCR flag to zset increment API.
+ 1 file changed, 1 insertion(+)
 
-+-------------------------------------------------------------------------------
-| Fix GEORADIUS wrong output with radius > Earth radius.
-| By antirez, 2016-05-30 12:45:49 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/bb43f4cab2f756c0412ca2b94d9e29c3db5025ab
+Itamar Haber in commit 1186f92:
+ typo: %s/Emtpy/Empty/g
+ 1 file changed, 5 insertions(+), 5 deletions(-)
 
-Close #3266
+antirez in commit 227d680:
+ Modules: command <-> core interface modified to get flags & keys.
+ 7 files changed, 177 insertions(+), 40 deletions(-)
 
- deps/geohash-int/geohash_helper.c | 2 ++
- 1 file changed, 2 insertions(+)
+Ramon Snir in commit 676a6a4:
+ tiny typo in Redis Modules API documentation
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Geo: fix typo in geohashEstimateStepsByRadius().
-| By antirez, 2016-05-30 15:31:19 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/16102bc0af0912a0c9a92aedddf796eb24a80b9e
+Dvir Volk in commit a1f8e22:
+ fixed return value of HashGet (and a slight error in the documentation)
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-I'm the author of this line but I can't see a good reason for it to
-don't be a typo, a step of 26 should be valid with 52 bits per
-coordinate, moreover the line was:
+antirez in commit 02c4a6c:
+ Modules: REDISMODULE_POSTPONED_ARRAY_LEN doc.
+ 1 file changed, 45 insertions(+)
+
+antirez in commit 42f7221:
+ Modules: Hash API defines made more uniform.
+ 3 files changed, 38 insertions(+), 42 deletions(-)
+
+antirez in commit 9b0556c:
+ Modules: Hash type API WIP #2.
+ 3 files changed, 60 insertions(+), 4 deletions(-)
+
+antirez in commit 10993ca:
+ Modules: Hash type API WIP #1.
+ 4 files changed, 212 insertions(+), 6 deletions(-)
+
+antirez in commit 5bf5fd2:
+ Modules: a few fixes for the zset iterator.
+ 2 files changed, 13 insertions(+), 6 deletions(-)
+
+antirez in commit 33e1231:
+ Modules: postponed array lengths.
+ 2 files changed, 86 insertions(+), 3 deletions(-)
+
+antirez in commit 00109e1:
+ Modules: zset lex iterator #3.
+ 3 files changed, 49 insertions(+), 3 deletions(-)
+
+antirez in commit db3ade2:
+ Modules: zset lex iterator #2.
+ 3 files changed, 30 insertions(+), 6 deletions(-)
+
+antirez in commit 2b04f86:
+ Modules: zset lex iterator #1.
+ 3 files changed, 77 insertions(+), 4 deletions(-)
+
+antirez in commit 083f527:
+ Modules: zset iterator redesign #1.
+ 4 files changed, 76 insertions(+), 106 deletions(-)
+
+antirez in commit d998170:
+ Simple Ruby script to generate reference doc added.
+ 1 file changed, 38 insertions(+)
+
+antirez in commit 0fd6d54:
+ Modules: fix top comments to be user-facing doc quality. About 33% done.
+ 1 file changed, 137 insertions(+), 51 deletions(-)
+
+antirez in commit f362f7a:
+ Modules: sorted set iterators WIP #3.
+ 4 files changed, 134 insertions(+), 24 deletions(-)
 
-    if (step > 26) step = 25;
+antirez in commit bdbb5a0:
+ Modules: put zset iterator current element in auto memory pool.
+ 1 file changed, 6 insertions(+), 2 deletions(-)
 
-So a step of 26 was actually already used, except when one of 27 was
-computed (which is invalid) only then it was trimmed to 25 instead of
-26.
+antirez in commit 6eeeda3:
+ Modules: sorted set iterators WIP #2.
+ 3 files changed, 34 insertions(+), 4 deletions(-)
 
-All tests passing after the change.
+antirez in commit eac5a13:
+ Modules: sorted set iterators WIP.
+ 4 files changed, 221 insertions(+), 1 deletion(-)
 
- deps/geohash-int/geohash_helper.c | 2 +-
+antirez in commit 556d593:
+ Remove useless space.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Avoid undefined behavior in BITFIELD implementation.
-| By antirez, 2016-05-31 11:52:07 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/014bf8044285c6d401d83e6e24829d276ab837f9
-
-Probably there is no compiler that will actaully break the code or raise
-a signal for unsigned -> signed overflowing conversion, still it was
-apparently possible to write it in a more correct way.
+antirez in commit d5ecedd:
+ Modules: ZSET API WIP #4.
+ 2 files changed, 33 insertions(+), 1 deletion(-)
 
-All tests passing.
-
- src/bitops.c | 23 +++++++++++++++--------
- 1 file changed, 15 insertions(+), 8 deletions(-)
+antirez in commit e1b34ec:
+ Modules: ZSET API WIP #3.
+ 2 files changed, 24 insertions(+)
 
-+-------------------------------------------------------------------------------
-| Now that SPOP can be called by scripts use BLPOP on 's' flag test.
-| By antirez, 2016-05-31 16:43:21 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/b4e5e2ec1ad7e9d1f4e7e559b61e0ecd4e50f2da
+antirez in commit 4457e4a:
+ Modules: ZSET API WIP #2.
+ 2 files changed, 93 insertions(+), 1 deletion(-)
+
+antirez in commit f199504:
+ Modules: ZSET API WIP.
+ 2 files changed, 14 insertions(+), 5 deletions(-)
+
+antirez in commit 11b3df2:
+ Modules: expire API and documentation.
+ 4 files changed, 101 insertions(+)
+
+antirez in commit f4e0129:
+ Modules: RedisModule_ReplyWithCallReply().
+ 4 files changed, 31 insertions(+), 1 deletion(-)
 
+Itamar Haber in commit 6054089:
+ Stops SPLICE from accepting negative counts
+ 1 file changed, 6 insertions(+), 2 deletions(-)
 
- tests/unit/scripting.tcl | 2 +-
+Sun He in commit 2e464bf:
+ modules/RM_StringTruncate: correct reallocate condition
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Test: run GEO tests by default.
-| By antirez, 2016-05-31 16:43:49 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/df419281a19e13429b27814a3e384f6f029c3519
-
-Thanks to @oranagra for noticing it was missing.
+Sun He in commit 3a7b170:
+ modules/RM_OpenKey: avoid decrRefCount obj twice
+ 1 file changed, 1 deletion(-)
 
- tests/test_helper.tcl | 1 +
+Sun He in commit 1868dee:
+ modules/RM_StringSet: set key->value
  1 file changed, 1 insertion(+)
 
-+-------------------------------------------------------------------------------
-| Enable tcp-keepalive by default.
-| By antirez, 2016-06-13 12:03:14 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/40cfe13141c7178d22fd43e4ffbecc37686e0b43
-
+Sun He in commit fded8aa:
+ modules: correct protolen
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
- redis.conf | 5 +++--
- 1 file changed, 3 insertions(+), 2 deletions(-)
+antirez in commit 4efe9e1:
+ Add the last break for consistency in moduleCreateCallReplyFromProto.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| fix some compiler warnings
-| By Pierre Chapuis, 2016-06-05 15:34:43 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/a650aaaf4f074ec428b450ef88799db1dcd34b0f
+Dvir Volk in commit e453d36e:
+ fixed case in moduleCreateCallReplyFromProto
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
+Dvir Volk in commit ae5cb3f:
+ renamed RedisModule_ReplyWithNull to RM_ReplyWithNull to fix compilation
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/bitops.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
+antirez in commit 2967c00:
+ Modules: RedisModule_ReplyWithNull() implemented.
+ 2 files changed, 9 insertions(+)
 
-+-------------------------------------------------------------------------------
-| Fixed typo in Sentinel compareSlavesForPromotion() comment.
-| By antirez, 2016-06-10 09:15:01 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/3fd4baf1e77f125a306d57b788b72de5026c0564
+Dvir Volk in commit e711a9a:
+ fixed the doc with a right function name
+ 1 file changed, 3 insertions(+), 2 deletions(-)
 
+Yossi Gottlieb in commit e443ad9:
+ Log loadmodule dlopen() errors.
+ 1 file changed, 4 insertions(+), 1 deletion(-)
 
- src/sentinel.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit 85919f8:
+ Modules: avoid conflict between modules func pointers and dynamic symbols.
+ 2 files changed, 95 insertions(+), 88 deletions(-)
+
+antirez in commit 6020469:
+ Modules: remove warnings due to void/function pointer conversion.
+ 1 file changed, 7 insertions(+), 6 deletions(-)
+
+Dvir Volk in commit 34f2fb7:
+ fixed makefile for linux
+ 1 file changed, 12 insertions(+), 2 deletions(-)
+
+antirez in commit 6dead2c:
+ Modules: first preview 31 March 2016.
+ 13 files changed, 2625 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| fix comment "b>a" to "a > b"
-| By andyli, 2016-06-07 14:42:50 +0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/8d029a5950f4ef40723c02b5c486b171aff0189c
+oranagra in commit 9682b61:
+ minor fixes - mainly signalModifiedKey, and GEORADIUS
+ 6 files changed, 19 insertions(+), 16 deletions(-)
 
+antirez in commit 3b644e8:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+Salvatore Sanfilippo in commit b44ad30:
+ Merge pull request #732 from evilpacket/remove_dofile
+antirez in commit 8eb43bf:
+ redis-cli: integrate help.h with COMMAND output.
+ 1 file changed, 70 insertions(+), 10 deletions(-)
 
- src/sentinel.c | 2 +-
+antirez in commit f9ee039:
+ Scripting test: match new error message.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| fix pidfile in redis.conf
-| By bogdanvlviv, 2016-04-19 14:43:06 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/6937f5960d1803ca0eda1ab6f4bc60023f50c914
+antirez in commit 2205c46:
+ Cluster: don't check scripts key slots during AOF loading.
+ 1 file changed, 4 insertions(+), 2 deletions(-)
 
+antirez in commit 94dc71f:
+ redis-cli: remove debugging message.
+ 1 file changed, 1 deletion(-)
 
- redis.conf | 2 +-
+antirez in commit bdbeb07:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit 68dd1c9:
+ Revert "Fix commandCommand arity"
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+Salvatore Sanfilippo in commit f0fcc36:
+ Merge pull request #2956 from pkulchenko/global-protection-msg-typo
+Ruben Bridgewater in commit efa0840:
+ Fix commandCommand arity
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+Salvatore Sanfilippo in commit f5ff91f:
+ Merge pull request #2998 from danielhtshih/unstable
+Salvatore Sanfilippo in commit 0c1f84f:
+ Merge pull request #3006 from baishaofei/unstable
+Salvatore Sanfilippo in commit 7b90815:
+ Merge pull request #3008 from badboy/fix-2911
+antirez in commit 02db338:
+ redis-cli: don't free historyfile, is used later.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Include 'fd_set' type name
-| By jspraul, 2016-06-07 16:46:00 -0400
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/b5758cc5ce6c51ff75c86f9216214fe4d5e4c257
+antirez in commit 4c53bab:
+ Cluster test 12: reshard back just a few slots to speedup the test.
+ 1 file changed, 7 insertions(+), 7 deletions(-)
 
-Fix an MSYS2-build-breaking error: unknown type name ‘fd_set’
- src/ae_select.c | 1 +
- 1 file changed, 1 insertion(+)
+antirez in commit 971e3c5:
+ Cluster: make getNodeByQuery() responsible of -CLUSTERDOWN errors.
+ 2 files changed, 21 insertions(+), 18 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Allow SPOP from Lua scripts
-| By Itamar Haber, 2016-05-28 20:01:46 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/620783e3b582e9ba6e1d8fbd47987281ce0b6317
+Salvatore Sanfilippo in commit 330715a:
+ Merge pull request #3039 from itamarhaber/patch-3
+Salvatore Sanfilippo in commit a4df156:
+ Merge pull request #3077 from Palethorn/ipv6-redirect-parse
+antirez in commit c77b95f:
+ Bind both IPv4 and IPv6 or exit with an error by default.
+ 1 file changed, 10 insertions(+), 8 deletions(-)
 
-The existing `R` flag appears to be sufficient and there's no apparent reason why the command should be blocked.
- src/server.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit 0bb787d:
+ Quick fix to avoid false positive in replica migration test.
+ 1 file changed, 4 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| minor fixes - mainly signalModifiedKey, and GEORADIUS
-| By oranagra, 2016-05-09 09:12:38 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/603234076f4e59967f331bc97de3c0db9947c8ef
+Chris Thunes in commit d827dbf:
+ Ensure slots are rechecked on EXEC.
+ 1 file changed, 7 insertions(+), 2 deletions(-)
 
+Salvatore Sanfilippo in commit 91b4966:
+ Merge pull request #3188 from therealbill/unstable
+Salvatore Sanfilippo in commit de3a673:
+ Merge pull request #3193 from sethbergman/patch-1
+Salvatore Sanfilippo in commit 09153b9:
+ Merge pull request #3152 from be-hase/fix/check_open_slots
+antirez in commit b76d27c:
+ Added a tool for generating changelogs automatically.
+ 1 file changed, 26 insertions(+)
 
- src/geo.c    |  1 +
- src/sds.c    |  8 ++++----
- src/server.c |  2 +-
- src/server.h |  3 +--
- src/t_set.c  |  9 ++++++---
- src/t_zset.c | 12 ++++++------
- 6 files changed, 19 insertions(+), 16 deletions(-)
+antirez in commit b632f78:
+ Minor redis-cli wording change in --help output.
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Code to access object string bytes repeated 3x refactored into 1 function.
-| By antirez, 2016-05-18 15:35:17 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/2e6b99499abb5ff1fbeee3bac4d064e5ff4ea256
+antirez in commit 995b9ff:
+ Allow CONFIG GET during loading.
+ 2 files changed, 7 insertions(+), 1 deletion(-)
 
+antirez in commit 5500c51:
+ Command "r" flag removed from commands not accessing the key space.
+ 1 file changed, 35 insertions(+), 35 deletions(-)
 
- src/bitops.c | 74 ++++++++++++++++++++++++++++++++----------------------------
- 1 file changed, 39 insertions(+), 35 deletions(-)
+antirez in commit 840ac20:
+ DEBUG command self documentation.
+ 2 files changed, 49 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| fix crash in BITFIELD GET when key is integer encoded
-| By oranagra, 2016-05-10 11:19:45 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/dcaeafc8280eb8329e7ce68e7ab02c67d98f0cf4
+Salvatore Sanfilippo in commit b5352ee:
+ Merge pull request #3191 from oranagra/minor_fix
+antirez in commit 2c22f59:
+ Reply with error on negative geo radius.
+ 1 file changed, 4 insertions(+), 1 deletion(-)
 
+antirez in commit 9c48f28:
+ Cluster regression test for #3043.
+ 1 file changed, 61 insertions(+)
 
- src/bitops.c | 18 +++++++++++++++---
- 1 file changed, 15 insertions(+), 3 deletions(-)
+antirez in commit 4fdde78:
+ New masters with slots are now targets of migration if others are.
+ 1 file changed, 35 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Clarify that the LOG_STR_SIZE includes null term.
-| By antirez, 2016-05-18 15:23:18 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/4ad088818a3353ebd619e8d43847b5d58108af20
+Seth Bergman in commit da26f2b:
+ Fixed typo in README.md
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
+Oran Agra in commit 5e3880a:
+ various cleanups and minor fixes
+ 12 files changed, 39 insertions(+), 45 deletions(-)
 
- src/server.h | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+Oran Agra in commit 6ed8c28:
+ dict.c minor optimization
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Test for BITFIELD regression #3221.
-| By antirez, 2016-05-18 14:53:30 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/f991cdc3e19c187035855355808575efd6b4c149
+Oran Agra in commit 7b52ef1:
+ networking.c minor optimization
+ 1 file changed, 5 insertions(+), 6 deletions(-)
 
+Oran Agra in commit f8909a2:
+ add DEBUG JEMALLC PURGE and JEMALLOC INFO cleanup
+ 2 files changed, 17 insertions(+), 2 deletions(-)
 
- tests/unit/bitfield.tcl | 5 +++++
- 1 file changed, 5 insertions(+)
+Oran Agra in commit 7ba9022:
+ fix small issues in redis 3.2
+ 2 files changed, 3 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| reduce struct padding by reordering members
-| By oranagra, 2016-05-16 20:12:11 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/cb3e89e2cb0753d2d111eaeadc9c73cbe24025ab
+Oran Agra in commit b554895:
+ additional fix to issue #2948
+ 1 file changed, 3 insertions(+)
 
+therealbill in commit 14086a4:
+ fix for #3187
+ 3 files changed, 4 insertions(+), 4 deletions(-)
 
- src/quicklist.h | 2 +-
+bogdanvlviv in commit 5565cc6:
+ fix pidfile in redis.conf
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Actually use --with-lg-quantum=3 to build jemalloc.
-| By antirez, 2016-05-18 11:58:36 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/a7f0fb448c110e125eece44dc955d6939e494daa
+Salvatore Sanfilippo in commit 4cbe044:
+ Merge pull request #3174 from djanowski/fix-zincrby-return-value
+Damian Janowski in commit 0b4bb50:
+ Fix ZINCRBY return value.
+ 2 files changed, 8 insertions(+)
+
+antirez in commit dda0f37:
+ ZREM refactored into proper API.
+ 2 files changed, 48 insertions(+), 49 deletions(-)
+
+antirez in commit 6f926c3:
+ ZRANK refactored into proper API.
+ 2 files changed, 72 insertions(+), 50 deletions(-)
+
+antirez in commit b73c7af:
+ zsetAdd() API exposed into server.h.
+ 2 files changed, 16 insertions(+), 15 deletions(-)
+
+antirez in commit b1f181a:
+ ZADD refactored into a proper API.
+ 1 file changed, 182 insertions(+), 86 deletions(-)
 
-This change is documented in deps/README.md but was lost in one way or
-the other, neutralizing the benefits of 24 bytes size classes (and
-others).
-
-Close #3208.
+antirez in commit e0eb5f6:
+ redis-cli preferences and rc file support.
+ 1 file changed, 85 insertions(+), 17 deletions(-)
 
- deps/Makefile | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit 70b3314:
+ redis-cli help.h updated.
+ 1 file changed, 18 insertions(+), 8 deletions(-)
 
-+-------------------------------------------------------------------------------
-| redis-cli: integrate help.h with COMMAND output.
-| By antirez, 2016-05-07 13:03:25 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/029dc0d97fd492a2fd579796d4c1cc04053c7190
+antirez in commit d1ddf7e:
+ redis-cli hints.
+ 3 files changed, 62 insertions(+), 1 deletion(-)
 
-Use the COMMAND output to fill with partial information the built-in
-help. This makes redis-cli able to at least complete commands that are
-exported by the Redis server it is connected to, but were not available
-in the help.h file when the redis-cli binary was compiled.
+antirez in commit d6e2cc7:
+ Linenoise updated again (hints support).
+ 4 files changed, 248 insertions(+), 8 deletions(-)
 
- src/redis-cli.c | 80 +++++++++++++++++++++++++++++++++++++++++++++++++--------
- 1 file changed, 70 insertions(+), 10 deletions(-)
+antirez in commit 8a98b8d:
+ Linenoise updated.
+ 1 file changed, 45 insertions(+), 15 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Removed dofile() from Lua
-| By Adam Baldwin, 2012-10-25 20:27:10 -0700
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/95def3aee044468504bb07633084afd49b085db3
+antirez in commit b9feef9:
+ ae.c: Fix delay until next timer event.
+ 1 file changed, 12 insertions(+), 9 deletions(-)
 
+antirez in commit ace780c:
+ ae.c: comment to explain why we have a useless maxId check.
+ 1 file changed, 5 insertions(+), 1 deletion(-)
 
- src/scripting.c | 2 ++
- 1 file changed, 2 insertions(+)
+antirez in commit 67b70a1:
+ Fix ae.c to avoid timers infinite loop.
+ 4 files changed, 28 insertions(+), 30 deletions(-)
 
+Ryosuke Hasebe in commit cad9ea5:
+ fix variable
+ 1 file changed, 5 insertions(+), 5 deletions(-)
 
-================================================================================
-Redis 3.2.0     Released Fri May 06 08:47:10 CEST 2016
-================================================================================
+Ryosuke Hasebe in commit d5aa7e2:
+ fix check_open_slots
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
-Upgrade urgency HIGH: 3.2-RC users should upgrade ASAP to this more
-                      stable release of Redis.
+antirez in commit 28c291c:
+ BITFIELD: overflow wrap behavior fuzz tester.
+ 1 file changed, 51 insertions(+)
 
-Hello, this is Redis 3.2.0 stable! And with the new release there is a new
-format for the changelog. Now it is composed of a "letter" like the one
-you are reading, followed by all the commits composing the release for people
-interested in the details.
+antirez in commit ae7317e:
+ BITFIELD basic unit tests.
+ 1 file changed, 85 insertions(+), 1 deletion(-)
 
-There are a few changes between the latest release candidate of Redis 3.2
-and the final 3.2.0 release. The main ones are the obvious bug fixes you
-can find detailed below, also a few new things:
+antirez in commit fc84378:
+ BITFIELD: Farest bit set is offset+bits-1. Off by one error fixed.
+ 1 file changed, 4 insertions(+), 2 deletions(-)
 
-Critical bugs fixed:
+antirez in commit 9a00da0:
+ BITFIELD: overflow fuzzy testing.
+ 2 files changed, 53 insertions(+)
 
-* There was a problem in the way a cluster instance loaded the AOF that
-  could cause data written via scripts to be lost during reshardings.
+antirez in commit 27fc01a:
+ Fix typo in bitops.tcl comment.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-New things:
+antirez in commit fe64960:
+ More BITFIELD fixes. Overflow conditional simplified.
+ 1 file changed, 8 insertions(+), 9 deletions(-)
 
-* There is a new very powerful BITFIELD command. Check the documentation
-  here: http://redis.io/commands/BITFIELD
+Salvatore Sanfilippo in commit 235f553:
+ Merge pull request #3118 from sunheehnus/bitfield-fix-minor-bug
+Sun He in commit 93cc8ba:
+ bitops/bitfield: fix length, overflow condition and *sign
+ 1 file changed, 8 insertions(+), 5 deletions(-)
 
-* CONFIG GET is allowed during the loading of the dataset.
+antirez in commit e85d6f2:
+ Fix INFO commandstats reporting when argv is rewritten.
+ 2 files changed, 3 insertions(+), 3 deletions(-)
 
-* The DEBUG command have new features and can show an help with DEBUG HELP.
+antirez in commit 32289d5:
+ BITFIELD: refactoring & fix of retval on FAIL.
+ 1 file changed, 24 insertions(+), 8 deletions(-)
 
-* redis-cli show hits about the commands arguments to the right.
+antirez in commit 11745e0:
+ BITFIELD: Fix #<index> form parsing.
+ 1 file changed, 4 insertions(+), 6 deletions(-)
 
-* GEORADIUS got a STORE / STOREDIST option to store the result into a target
-  key (as as orted set) instead of reporting it to the user.
+antirez in commit 2800d09:
+ BITFIELD: Support #<index> offsets form.
+ 1 file changed, 23 insertions(+), 6 deletions(-)
 
-* Redis Cluster replicas migration now works in a slightly different way. In
-  the past a slave could migrate only to a master that used to have slaves
-  in the past (and if there was still trace of this information). Now instead
-  if a new slave gets at least a slot, and at least one other master in the
-  cluster has a slave, then the new master is considered a valid target for
-  replica migration. So if it will be orphaned and there is a spare slave
-  it will get one.
+antirez in commit 70af626:
+ BITFIELD command initial implementation.
+ 3 files changed, 476 insertions(+), 32 deletions(-)
 
-* CLUSTER SLOTS output now includes the node ID (in a backward compatible
-  manner).
+Salvatore Sanfilippo in commit 438ae49:
+ Merge pull request #3101 from itamarhaber/geohumanized
+Itamar Haber in commit b5149f0:
+ Eliminates engineers near the equator & prime meridian
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
-* A lot of bug fixes you can read in the commits details below, with the
-  authors that kindly provided many useful patches. Thanks.
+Itamar Haber in commit 41030ae:
+ Fixes a typo in a comment
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-As usually what "stable" means is that we are confident the release is mature,
-however do your tests before putting it into production in your environemnt
-as it's fresh meat anyway.
+Itamar Haber in commit 4e9c302:
+ Adjusts accuracy for GEODIST
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Cheers,
-Salvatore
+antirez in commit cf42c48:
+ addReplyHumanLongDouble() API added.
+ 2 files changed, 10 insertions(+)
 
-+-------------------------------------------------------------------------------
-| Cluster: don't check scripts key slots during AOF loading.
-| By antirez, 2016-05-05 23:37:08 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/746e1bebb4baf876c1e8cd2fe2d468a1c41e5dc3
+antirez in commit f4befcc:
+ GEOADD STORE/STOREDIST tests.
+ 1 file changed, 54 insertions(+)
 
+antirez in commit bb75ecd:
+ New options for GEORADIUS: STORE and STOREDIST.
+ 4 files changed, 116 insertions(+), 49 deletions(-)
+
+antirez in commit 15f37eb:
+ Cluster: resharding test provides more state when failing.
+ 1 file changed, 8 insertions(+), 3 deletions(-)
 
- src/scripting.c | 6 ++++--
- 1 file changed, 4 insertions(+), 2 deletions(-)
+antirez in commit b0ec22f:
+ Include full paths on RDB/AOF files errors.
+ 2 files changed, 32 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| redis-cli: remove debugging message.
-| By antirez, 2016-05-05 18:05:37 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/3907b059280898c6340b53982b3b65957535da7c
+antirez in commit fcd7df5:
+ Remove Lua state reference from buffers in lua_cmsgpack.
+ 1 file changed, 25 insertions(+), 28 deletions(-)
 
+Salvatore Sanfilippo in commit 66dbc5e:
+ Merge pull request #3072 from yoav-steinberg/cmsgpack_fix
+David Cavar in commit c30ffaa:
+ Reverse redirect address parse
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/redis-cli.c | 1 -
- 1 file changed, 1 deletion(-)
+yoav@monfort.co.il in commit fdbefc9:
+ cmsgpack: pass correct osize values to lua allocator, update correct buf free space in cmsgpack
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Revert "Fix commandCommand arity"
-| By antirez, 2016-05-05 17:35:33 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/f01a2714582a9a916b41e6cb90e42474a104925d
+Salvatore Sanfilippo in commit aa953b6:
+ Merge pull request #3059 from itamarhaber/keyspacenotif-lrem
+Itamar Haber in commit 31a70a8:
+ Fixes a typo
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-This reverts commit 1189a4eae6d009fc0da8d50fd542ba1391542165.
+Itamar Haber in commit 68e779f:
+ Adds keyspace notifications for lrem
+ 1 file changed, 6 insertions(+), 1 deletion(-)
 
-Actually this is wrong, the command can be called without args at all.
+antirez in commit 5b7b235:
+ Fix to Cluster test to support @busport format.
+ 1 file changed, 4 insertions(+), 2 deletions(-)
 
- src/server.c | 2 +-
+antirez in commit cbcffed:
+ Cluster: redis-trib: support @busport format in ClusterNode.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Fix commandCommand arity
-| By Ruben Bridgewater, 2016-01-04 11:39:45 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/1189a4eae6d009fc0da8d50fd542ba1391542165
+antirez in commit b841f3a:
+ Cluster: store busport with different separator in CLUSTER NODES.
+ 1 file changed, 13 insertions(+), 9 deletions(-)
 
-
- src/server.c | 2 +-
+antirez in commit 92b9de2:
+ Cluster announce: WIP, allow building again.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Fix a possible race condition of sdown detection if the connection to master/slave/sentinel decames disconnected just after the last PONG and before the next PING.
-| By Daniel Shih, 2016-01-12 17:06:47 +0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/d9dc0d777b775f2fe4f23f42e1b4130f4de1ed72
+antirez in commit 5ac5e3e:
+ Cluster announce ip/port/bus-port documented in redis.conf.
+ 1 file changed, 33 insertions(+)
 
+antirez in commit e27b9b1:
+ Merge branch 'cluster-docker' into unstable
+antirez in commit cdbe8a6:
+ Typo ASII -> ASCII fixed in comment.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/sentinel.c | 2 ++
- 1 file changed, 2 insertions(+)
+antirez in commit c285862:
+ Cluster: include node IDs in SLOTS output.
+ 1 file changed, 6 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Fix nanosecond conversion
-| By Jan-Erik Rediger, 2016-01-13 10:22:29 -0700
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/13bd702844eda7bccc7c672b6ff77f53e21ab841
+antirez in commit d0a8512:
+ Cluster anounce-ip/port WIP.
+ 1 file changed, 1 insertion(+)
 
-1 microsecond = 1000 nanoseconds
-1e3 = 1000
-10e3 = 10000
+antirez in commit 4abf486:
+ Cluster announce port: set port/bport for myself at startup.
+ 1 file changed, 7 insertions(+), 2 deletions(-)
 
- src/redis-cli.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit 1c03837:
+ Cluster: persist bus port in nodes.conf.
+ 1 file changed, 8 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| redis-cli: don't free historyfile, is used later.
-| By antirez, 2016-05-05 13:57:57 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/f6b7df3aec1d8fddf3121c4315fea4bf45cc4cfe
+antirez in commit dc98907:
+ Cluster announce ip: take myself->ip always in sync.
+ 1 file changed, 30 insertions(+), 6 deletions(-)
+
+antirez in commit 11436b1:
+ Cluster announce ip / port initial implementation.
+ 5 files changed, 127 insertions(+), 42 deletions(-)
+
+antirez in commit b093930:
+ Cluster announce ip / port configuration handling.
+ 3 files changed, 12 insertions(+)
 
+antirez in commit a455e4b:
+ Cluster: add announce ip field in messages header.
+ 1 file changed, 3 insertions(+), 2 deletions(-)
 
- src/redis-cli.c | 2 +-
+Itamar Haber in commit 9e46bf2:
+ Fixes a typo
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Cluster test 12: reshard back just a few slots to speedup the test.
-| By antirez, 2016-05-05 11:49:27 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/97ce72fa2d348f914fc40ccf0a32008c7362b817
-
-
- tests/cluster/tests/12-replica-migration-2.tcl | 14 +++++++-------
- 1 file changed, 7 insertions(+), 7 deletions(-)
-
-+-------------------------------------------------------------------------------
-| Cluster: make getNodeByQuery() responsible of -CLUSTERDOWN errors.
-| By antirez, 2016-05-05 11:33:43 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/708f486c77b455fa7ae1e87cf31278474eb9d432
-
-This fixes a bug introduced by d827dbf, and makes the code consistent
-with the logic of always allowing, while the cluster is down, commands
-that don't target any key.
+antirez in commit 8870a7e:
+ 03_test_release.sh: proper cleanup before testing.
+ 1 file changed, 2 insertions(+)
 
-As a side effect the code is also simpler now.
+antirez in commit 5bbb09e:
+ Cluster: check packets length before accessing far fields.
+ 1 file changed, 10 insertions(+), 5 deletions(-)
 
- src/cluster.c | 13 +++++++++++--
- src/server.c  | 26 ++++++++++----------------
- 2 files changed, 21 insertions(+), 18 deletions(-)
+antirez in commit 751b566:
+ Sentinel: improve handling of known Sentinel instances.
+ 1 file changed, 34 insertions(+), 19 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Fixes a typo
-| By Itamar Haber, 2016-01-28 21:47:18 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/1fc2ed61bec2f2bf266b48e566a197c5214b4350
+antirez in commit 5bc7e01:
+ Use a smoother running average for avg_ttl in INFO.
+ 1 file changed, 9 insertions(+), 5 deletions(-)
 
+antirez in commit fe44a7c:
+ Cluster: mismatch sender ID log put back at DEBUG level.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/cluster.c | 2 +-
+antirez in commit d6c5922:
+ Cluster: fix missing ntohs() call to access gossip section port.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Reverse redirect address parse
-| By David Cavar, 2016-02-09 15:04:42 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/787d5ab9be45bf4feb6cfa8a227c185c93aaadae
+antirez in commit 592419b:
+ Better address udpate strategy when processing gossip sections.
+ 1 file changed, 15 insertions(+), 6 deletions(-)
 
-Fix issue in case the redirect address is in ipv6 format. Parse from behind to extract last part of the response which represents actual port.
- src/redis-cli.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit 22892ce:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit bc15586:
+ Fix memory leak in masterauth config option loading.
+ 1 file changed, 1 insertion(+)
 
-+-------------------------------------------------------------------------------
-| Bind both IPv4 and IPv6 or exit with an error by default.
-| By antirez, 2016-05-05 10:02:42 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0fda06225f19b18a370d63ac650a8bb61020235d
+Salvatore Sanfilippo in commit 7837c48:
+ Merge pull request #3023 from itamarhaber/patch-2
+Itamar Haber in commit 57f8230:
+ Removes an extra space in protected mode message
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+antirez in commit 83b862a:
+ Minor MIGRATE refactoring.
+ 1 file changed, 12 insertions(+), 5 deletions(-)
+
+antirez in commit f5a1e60:
+ More variadic MIGRATE fixes.
+ 1 file changed, 9 insertions(+), 8 deletions(-)
+
+antirez in commit 00d3a40:
+ Various fixes to MIGRATE with multiple keys.
+ 1 file changed, 45 insertions(+), 12 deletions(-)
+
+antirez in commit cfc879b:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit b01b32b:
+ Test: Handle LOADING in restart_instance.
+ 1 file changed, 12 insertions(+)
+
+Salvatore Sanfilippo in commit 8637384:
+ Merge pull request #2726 from seppo0010/patch-2
+antirez in commit 5432fc8:
+ Detect and show crashes on Sentinel/Cluster tests.
+ 1 file changed, 18 insertions(+)
+
+antirez in commit fc3ca8f:
+ Cluster: fix setting nodes slaveof pointer to NULL on node release.
+ 1 file changed, 3 insertions(+), 14 deletions(-)
 
-Thanks to @tushar2708 for the PR. I applied a slightly different fix.
-Thanks to @cespare for reporting.
+antirez in commit a411d55:
+ Cluster: clarify node->slave may be NULL.
+ 1 file changed, 4 insertions(+), 1 deletion(-)
 
-Close #3024
-Close #3020
+Jan-Erik Rediger in commit 15dacfe:
+ Fix nanosecond conversion
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/server.c | 18 ++++++++++--------
- 1 file changed, 10 insertions(+), 8 deletions(-)
+antirez in commit f984cef:
+ Cluster: fix rebalancing to always empty nodes.
+ 1 file changed, 24 insertions(+), 3 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Quick fix to avoid false positive in replica migration test.
-| By antirez, 2016-05-05 09:45:31 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/65707fa6b5bb38b5818af57ab93b9b1da47d708a
+root in commit 28e80bf:
+ fix linux compile bug
+ 2 files changed, 9 insertions(+), 9 deletions(-)
 
+antirez in commit 152e9f6:
+ Cluster: redis-trib move_to_slot: don't send SETSLOT to slaves.
+ 1 file changed, 1 insertion(+)
 
- tests/cluster/tests/12-replica-migration-2.tcl | 5 ++++-
- 1 file changed, 4 insertions(+), 1 deletion(-)
+Daniel Shih in commit e6d9705:
+ Fix a possible race condition of sdown detection if the connection to master/slave/sentinel decames disconnected just after the last PONG and before the next PING.
+ 1 file changed, 2 insertions(+)
 
-+-------------------------------------------------------------------------------
-| Ensure slots are rechecked on EXEC.
-| By Chris Thunes, 2016-03-11 15:22:36 -0500
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/1f3ed652e2a6cfcbbd5300a31f5771f2ce842e98
+antirez in commit c6e5088:
+ Cluster: fix redis-trib reference of variable in warning.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Fixes #2515.
+antirez in commit 02c40c9:
+ CLUSTER BUMPEPOCH initial implementation fixed.
+ 2 files changed, 25 insertions(+), 14 deletions(-)
 
- src/server.c | 9 +++++++--
- 1 file changed, 7 insertions(+), 2 deletions(-)
+antirez in commit e4eb6c7:
+ Cluster: implement redis-trib fix when slot is open without owners.
+ 1 file changed, 39 insertions(+), 9 deletions(-)
 
-+-------------------------------------------------------------------------------
-| fix for #3187
-| By therealbill, 2016-04-22 10:43:48 -0500
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/3a4810678904af013901a896ab0bb3c71856644c
-
-I've renamed maxmemoryToString to evictPolicyToString since that is
-more accurate (and easier to mentally connect with the correct data), as
-well as updated the function to user server.maxmemory_policy rather than
-server.maxmemory. Now with a default config it is actually returning
-the correct policy rather than volatile-lru.
-
- src/config.c | 4 ++--
- src/server.c | 2 +-
- src/server.h | 2 +-
- 3 files changed, 4 insertions(+), 4 deletions(-)
+antirez in commit 04ae459:
+ Cluster: implement redis-trib fix for uncovered slots.
+ 1 file changed, 32 insertions(+), 9 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Fixed typo in README.md
-| By Seth Bergman, 2016-04-30 11:58:48 -0500
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/bba53d7fc7a759b53d72a7c3be17a00abe32039e
+antirez in commit b58796f:
+ Cluster: CLUSTER BUMPEPOCH introduced to help redis-trib fix.
+ 1 file changed, 7 insertions(+)
 
+antirez in commit 524be1e:
+ Cluster: don't allow CLUSTER SETSLOT with slaves.
+ 1 file changed, 5 insertions(+)
 
- README.md | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit f43c794:
+ Scripting: handle trailing comments.
+ 2 files changed, 5 insertions(+), 1 deletion(-)
+
+antirez in commit e15e518:
+ Allow MIGRATE to always be called on local keys for open slots.
+ 1 file changed, 7 insertions(+), 6 deletions(-)
 
-+-------------------------------------------------------------------------------
-| fix variable
-| By Ryosuke Hasebe, 2016-03-30 23:09:36 +0900
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/ab7581489871eebcf0253915acc26efb27f5df23
+antirez in commit 36704d6:
+ Fix typos & grammar in clusterBumpConfigEpochWithoutConsensus() comment.
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
+antirez in commit 7c1a5ff:
+ Lua debugger: support direct calls to SCRIPT DEBUG in redis-cli.
+ 1 file changed, 21 insertions(+)
 
- src/redis-trib.rb | 10 +++++-----
- 1 file changed, 5 insertions(+), 5 deletions(-)
+antirez in commit a75aa4b:
+ Lua debugger: fix crash printing nested or deep objects.
+ 1 file changed, 14 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| fix check_open_slots
-| By Ryosuke Hasebe, 2016-03-30 21:56:22 +0900
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0fcf896ac14c6e5c57e3b79e836dd8bf7dad94b5
+antirez in commit 1e7a8f8:
+ Another typo in protected mode error message.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
+antirez in commit 08c7bba:
+ Fix protected mode error message typo.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/redis-trib.rb | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
+antirez in commit edd4d55:
+ New security feature: Redis protected mode.
+ 5 files changed, 75 insertions(+), 3 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Minor redis-cli wording change in --help output.
-| By antirez, 2016-05-04 22:34:17 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/b8a63635e39ce312b2c5664f2c2a59184849b8fb
+antirez in commit 00d637f:
+ Cluster: don't send -ASK to MIGRATE.
+ 1 file changed, 5 insertions(+), 3 deletions(-)
 
+antirez in commit 8b3aa73:
+ Cluster test: do leaks detection with OSX leaks utility.
+ 1 file changed, 32 insertions(+)
 
- src/redis-cli.c | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
+antirez in commit 190babe:
+ redis-trib: Remove duplicated key in hash initialization.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Allow CONFIG GET during loading.
-| By antirez, 2016-05-04 15:45:38 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/ae95de93312d6bb2c8c365c31f2a3fd0b6d2c100
+antirez in commit b1f84d4:
+ Cluster/Sentinel test: report ability to run via valgrind.
+ 1 file changed, 1 insertion(+)
 
-Thanks to @oranagra for the idea of allowing CONFIG GET during loading.
+Salvatore Sanfilippo in commit 075ea16:
+ Merge pull request #2954 from pkulchenko/debug-table-pretty-printing
+Salvatore Sanfilippo in commit f054b4a:
+ Merge pull request #2957 from pkulchenko/debug-userdata-pretty-printing
+antirez in commit 80b7037:
+ Cluster: rebalance now supports --threshold option.
+ 1 file changed, 24 insertions(+), 2 deletions(-)
+
+antirez in commit 628af70:
+ Cluster: redis-trib reshard / rebalance --pipeline support.
+ 1 file changed, 21 insertions(+), 5 deletions(-)
+
+antirez in commit 77f849b:
+ Cluster: verify slaves consistency after resharding.
+ 1 file changed, 23 insertions(+)
+
+antirez in commit 9b4dd92:
+ Cluster: resharding test now checks AOF consistency.
+ 1 file changed, 42 insertions(+)
 
- src/config.c | 6 ++++++
- src/server.c | 2 +-
- 2 files changed, 7 insertions(+), 1 deletion(-)
+antirez in commit bb21537:
+ Fix a race that may lead to the active (slave) client to be freed.
+ 1 file changed, 6 insertions(+)
 
-+-------------------------------------------------------------------------------
-| Command "r" flag removed from commands not accessing the key space.
-| By antirez, 2016-05-04 15:42:14 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/3ff8f57ef32e3b1ddd407b65d474f610881bef34
+antirez in commit 218e522:
+ Fix processCommand() comment about return value.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-Thanks to @oranagra for the hint about misplaced 'r' flags.
+antirez in commit a1c9c05:
+ Hopefully better memory test on crash.
+ 3 files changed, 133 insertions(+), 86 deletions(-)
+
+antirez in commit b9aeb98:
+ Suppress harmless warnings.
+ 3 files changed, 8 insertions(+), 4 deletions(-)
+
+antirez in commit ac8f4a6:
+ memtest.c now can be called as API in non interactive mode.
+ 2 files changed, 73 insertions(+), 43 deletions(-)
+
+antirez in commit 30f057d:
+ Crash report format improvements.
+ 1 file changed, 35 insertions(+), 24 deletions(-)
 
- src/server.c | 70 ++++++++++++++++++++++++++++++------------------------------
- 1 file changed, 35 insertions(+), 35 deletions(-)
+Paul Kulchenko in commit b754c8e:
+ Update pretty printing in debugging to generate valid Lua code for userdata-like types.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| DEBUG command self documentation.
-| By antirez, 2016-05-04 12:45:55 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/07b852d24ec8d7cb47044b096baf0af1410c69ed
+Paul Kulchenko in commit 3969e9d:
+ Update pretty printing in debugging to generate valid Lua code for tables.
+ 1 file changed, 2 insertions(+), 1 deletion(-)
 
+Paul Kulchenko in commit 2f3f3fd:
+ Update global protection error message to fix a typo.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/debug.c  | 49 ++++++++++++++++++++++++++++++++++++++++++++++++-
- src/server.c |  2 +-
- 2 files changed, 49 insertions(+), 2 deletions(-)
+antirez in commit 6db8e85:
+ Log address causing SIGSEGV.
+ 1 file changed, 4 insertions(+)
 
-+-------------------------------------------------------------------------------
-| various cleanups and minor fixes
-| By Oran Agra, 2016-04-25 16:49:57 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/cfc08b65b04cf972ebeadf3be9f39f2acd7672b3
-
-
- src/adlist.c             | 18 ++++++------------
- src/ae_epoll.c           |  6 ++----
- src/aof.c                |  5 ++++-
- src/db.c                 |  2 +-
- src/rdb.c                |  6 ++++--
- src/rio.c                |  5 +++--
- src/rio.h                |  2 ++
- src/server.h             |  3 +--
- tests/support/test.tcl   |  6 ------
- tests/unit/bitops.tcl    |  2 +-
- tests/unit/other.tcl     |  1 +
- tests/unit/scripting.tcl | 27 ++++++++++++++-------------
- 12 files changed, 39 insertions(+), 44 deletions(-)
-
-+-------------------------------------------------------------------------------
-| dict.c minor optimization
-| By Oran Agra, 2016-04-25 16:48:25 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/6710c8dc15680b756de26d1d45df110987b951b3
+antirez in commit 8f8c399:
+ Cluster: allows abbreviated node IDs with rebalance --weight option.
+ 1 file changed, 19 insertions(+), 3 deletions(-)
+
+antirez in commit 9df1ae8:
+ Cluster: rebalancing option --simulate, and a fix.
+ 1 file changed, 12 insertions(+), 8 deletions(-)
+
+antirez in commit cba1c29:
+ Cluster: redis-trib rebalance initial implementation.
+ 1 file changed, 154 insertions(+), 17 deletions(-)
 
+antirez in commit 3782902:
+ Initial implementation of redis-trib info subcommand.
+ 1 file changed, 22 insertions(+)
 
- src/dict.c | 8 ++++----
- 1 file changed, 4 insertions(+), 4 deletions(-)
+Salvatore Sanfilippo in commit 9f63e75:
+ Merge pull request #2943 from sunheehnus/issue2855
+Sun He in commit 3a47c8c:
+ lua_struct.c/getnum: throw error if overflow happen
+ 1 file changed, 6 insertions(+), 4 deletions(-)
+
+antirez in commit f0b168e:
+ Cluster: redis-trib: use variadic MIGRATE.
+ 1 file changed, 13 insertions(+), 15 deletions(-)
+
+antirez in commit 4e252e4:
+ MIGRATE: Fix key extraction for new form.
+ 3 files changed, 29 insertions(+), 1 deletion(-)
+
+antirez in commit 82fd74a:
+ MIGRATE: test more corner cases.
+ 1 file changed, 37 insertions(+)
+
+antirez in commit ac0a731:
+ MIGRATE: Fix new argument rewriting refcount handling.
+ 1 file changed, 2 insertions(+), 3 deletions(-)
+
+antirez in commit d85fc1e:
+ MIGRATE: fix replies processing and argument rewriting.
+ 2 files changed, 40 insertions(+), 15 deletions(-)
 
-+-------------------------------------------------------------------------------
-| networking.c minor optimization
-| By Oran Agra, 2016-04-25 16:48:09 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/be5c0869821b16f18104d9ea62ab42bfa0615816
+antirez in commit 29d680e:
+ Test: pipelined MIGRATE tests added.
+ 1 file changed, 54 insertions(+)
 
+antirez in commit 9ebf7a6:
+ Pipelined multiple keys MIGRATE.
+ 2 files changed, 115 insertions(+), 63 deletions(-)
 
- src/networking.c | 11 +++++------
- 1 file changed, 5 insertions(+), 6 deletions(-)
+antirez in commit e7945cf:
+ Cluster: redis-trib migrate default timeout set to 60 sec.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| add DEBUG JEMALLC PURGE and JEMALLOC INFO cleanup
-| By Oran Agra, 2016-04-25 16:47:42 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/3ede6c7a506bcff3c7d2147c8af140dd4102a36e
+daniele in commit 3d254e0:
+ redis-trib.rb: --timeout XXXXX option added to fix and reshard commands. Defaults to 15000 milliseconds
+ 1 file changed, 10 insertions(+), 4 deletions(-)
 
+antirez in commit adc2fe6:
+ Cluster: replica migration with delay.
+ 2 files changed, 39 insertions(+), 17 deletions(-)
 
- src/debug.c     | 17 ++++++++++++++++-
- src/redis-cli.c |  2 +-
- 2 files changed, 17 insertions(+), 2 deletions(-)
+antirez in commit 41db54a:
+ Cluster: more reliable migration tests.
+ 1 file changed, 24 insertions(+), 43 deletions(-)
 
-+-------------------------------------------------------------------------------
-| fix small issues in redis 3.2
-| By Oran Agra, 2016-04-25 14:19:28 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/e2fab184efd01ffa0d510739f4d819a30b1d6787
+antirez in commit b55affb:
+ Cluster: more reliable replicas migration test.
+ 1 file changed, 75 insertions(+)
 
+antirez in commit 4159055:
+ Remove debugging message left there for error.
+ 1 file changed, 1 deletion(-)
 
- src/config.c | 2 ++
- src/rdb.c    | 2 +-
- 2 files changed, 3 insertions(+), 1 deletion(-)
+antirez in commit 69897f5:
+ unlinkClient(): clear flags according to ops performed.
+ 1 file changed, 2 insertions(+)
 
-+-------------------------------------------------------------------------------
-| additional fix to issue #2948
-| By Oran Agra, 2016-04-25 14:18:40 +0300
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/9d57ceec08687545c2a63a2c18c28e2bcaf74664
+antirez in commit e0f22df:
+ Fix replicas migration by adding a new flag.
+ 2 files changed, 31 insertions(+), 20 deletions(-)
 
+antirez in commit f147225:
+ Fix typo UNCOMMENT -> COMMENT in example redis.conf.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/networking.c | 3 +++
- 1 file changed, 3 insertions(+)
+antirez in commit acc2336:
+ Centralize slave replication handshake aborting.
+ 1 file changed, 23 insertions(+), 22 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Reply with error on negative geo radius.
-| By antirez, 2016-05-04 08:59:56 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/7ba2cf5f8bea9cd125e773de147e3ea9b19ee2b0
+antirez in commit fceaa46:
+ Test HINCRBYFLOAT rounding only in x86_64 and when valgrind is not in use.
+ 1 file changed, 16 insertions(+), 5 deletions(-)
 
-Thanks to @tidwall for reporting.
-Close #3194.
+antirez in commit 96628cc:
+ fix sprintf and snprintf format string
+ 2 files changed, 3 insertions(+), 3 deletions(-)
 
- src/geo.c | 5 ++++-
- 1 file changed, 4 insertions(+), 1 deletion(-)
+antirez in commit e6a5117:
+ Fix typo in prepareClientToWrite() comment.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Cluster regression test for #3043.
-| By antirez, 2016-05-02 18:36:09 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/38cf2bd257d09b360be6adf450d59592a359696d
-
-The test works but is very slow so far, since it involves resharding
-1/5 of all the cluster slots from master 0 to the other 4 masters and
-back into the original master.
+antirez in commit c2c68c5:
+ Merge branch 'unstable' of github.com:/antirez/redis into unstable
+antirez in commit da82723:
+ Handle wait3() errors.
+ 1 file changed, 7 insertions(+), 1 deletion(-)
+
+Salvatore Sanfilippo in commit 8164418:
+ Merge pull request #2899 from itamarhaber/patch-1
+Itamar Haber in commit 36801f7:
+ Revert Lua's `redis.LOG_<level>` to original
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
- tests/cluster/tests/12-replica-migration-2.tcl | 61 ++++++++++++++++++++++++++
- 1 file changed, 61 insertions(+)
+antirez in commit a0d41e5:
+ Redis Cluster: hint about validity factor when slave can't failover.
+ 1 file changed, 3 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| New masters with slots are now targets of migration if others are.
-| By antirez, 2016-05-02 16:41:56 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/7b618823c189c24313effbccda7022d167ea419c
-
-This fixes issue #3043.
-
-Before this fix, after a complete resharding of a master slots
-to other nodes, the master remains empty and the slaves migrate away
-to other masters with non-zero nodes. However the old master now empty,
-is no longer considered a target for migration, because the system has
-no way to tell it had slaves in the past.
-
-This fix leaves the algorithm used in the past untouched, but adds a
-new rule. When a new or old master which is empty and without slaves,
-are assigend with their first slot, if other masters in the cluster have
-slaves, they are automatically considered to be targets for replicas
-migration.
+antirez in commit 4d625bb:
+ Added Tcl program to show commits graphicaly.
+ 2 files changed, 112 insertions(+)
+
+antirez in commit 4b0b28b:
+ Lua debugger: infinite loop detection.
+ 1 file changed, 35 insertions(+), 7 deletions(-)
+
+antirez in commit 1f35f2d:
+ Lua debugger: fix trace command infinite loop.
+ 1 file changed, 6 insertions(+), 5 deletions(-)
 
- src/cluster.c | 36 +++++++++++++++++++++++++++++++++++-
- 1 file changed, 35 insertions(+), 1 deletion(-)
+antirez in commit 6604e04:
+ Lua debugger: redis-cli: allow restart after end of session.
+ 1 file changed, 3 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Test ZINCRBY return value.
-| By antirez, 2016-05-02 08:57:30 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/1101b515c73dcb0ff4a868ba38a91dcebb5b85cc
+antirez in commit 58573f1:
+ Lua debugger: redis-cli can restart Lua debugging sessions.
+ 1 file changed, 74 insertions(+), 44 deletions(-)
+
+antirez in commit 0cc1917:
+ Lua debugger: maxlen command implemented.
+ 2 files changed, 55 insertions(+), 14 deletions(-)
+
+antirez in commit c560c64:
+ Lua debugger: trace command implemented.
+ 1 file changed, 24 insertions(+)
+
+antirez in commit 22959e0:
+ Lua debugger: redis-cli: show compile errors in LDB mode.
+ 1 file changed, 12 insertions(+), 3 deletions(-)
+
+antirez in commit 70a5169:
+ Lua debugger: print without args show all local vars.
+ 1 file changed, 34 insertions(+), 5 deletions(-)
+
+antirez in commit fb53459:
+ Lua debugger: default behavior of "list" command changed.
+ 1 file changed, 14 insertions(+), 4 deletions(-)
 
+antirez in commit 6de2306:
+ Lua debugger: redis-cli error when --ldb is without --eval.
+ 1 file changed, 7 insertions(+)
 
- tests/unit/type/zset.tcl | 6 ++++++
- 1 file changed, 6 insertions(+)
+antirez in commit e57cccd:
+ Lua debugger: use sds_malloc() to allocate eval cli array.
+ 5 files changed, 35 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| redis-cli preferences and rc file support.
-| By antirez, 2016-04-13 13:58:30 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/bbf93108ef2a7ac7bd53e26c96bf838f7c5e72df
+antirez in commit 34aadf7:
+ Lua debugging: fix error message for SCRIPT DEBUG.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
+antirez in commit 3d24cd6:
+ Lua debugger: reply +OK to SCRIPT DEBUG no.
+ 1 file changed, 1 insertion(+)
 
- src/redis-cli.c | 102 ++++++++++++++++++++++++++++++++++++++++++++++----------
- 1 file changed, 85 insertions(+), 17 deletions(-)
+antirez in commit 333547d:
+ Lua debugger: call wait3() if there are pending forked debugging sessions.
+ 3 files changed, 10 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| redis-cli hints.
-| By antirez, 2016-04-13 12:34:14 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/3fd3fca0dd38cb21c900e4ba98e3d41f333335aa
+antirez in commit 0163643:
+ Lua debugger: abort implemented.
+ 1 file changed, 5 insertions(+)
 
+antirez in commit d99ce09:
+ Lua debugger: ldbSendLogs() memory leak fixed.
+ 1 file changed, 1 insertion(+)
 
- deps/linenoise/linenoise.c |  8 +++++++
- deps/linenoise/linenoise.h |  2 +-
- src/redis-cli.c            | 53 ++++++++++++++++++++++++++++++++++++++++++++++
- 3 files changed, 62 insertions(+), 1 deletion(-)
+antirez in commit 87672ad:
+ Lua debugger: better support for synchronous mode.
+ 2 files changed, 22 insertions(+), 3 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Linenoise updated again (hints support).
-| By antirez, 2016-04-12 23:39:18 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/34354473ffe8d60b80acdbc8c16b194f8bbd70a0
+antirez in commit 7be9170:
+ Lua debugger: handle forked sessions children during shutdown.
+ 3 files changed, 51 insertions(+), 5 deletions(-)
 
+antirez in commit 3ab0b4d:
+ Lua debugger: inform user changes are rolled back.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- deps/linenoise/README.markdown | 176 ++++++++++++++++++++++++++++++++++++++++-
- deps/linenoise/example.c       |  10 +++
- deps/linenoise/linenoise.c     |  55 ++++++++++++-
- deps/linenoise/linenoise.h     |  15 +++-
- 4 files changed, 248 insertions(+), 8 deletions(-)
+antirez in commit 56d9bb8:
+ Lua debugger: fix help typo, beark -> break.
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Linenoise updated.
-| By antirez, 2016-04-06 13:37:27 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/58229cd766fa02f399267310b5b488aac2c55a6a
+antirez in commit e386cd8:
+ Lua debugger: clear end of session protocol.
+ 2 files changed, 23 insertions(+), 9 deletions(-)
+
+antirez in commit 7492237:
+ Lua debugger: redis.debug() implemented.
+ 2 files changed, 44 insertions(+), 15 deletions(-)
 
-As a side effect, cat commands.txt | redis-cli now is able to handle
-lines more than 4096 bytes.
+antirez in commit 23a4d70:
+ Lua debugger: redis-cli, mark end of debugging session.
+ 1 file changed, 1 insertion(+)
 
- deps/linenoise/linenoise.c | 60 ++++++++++++++++++++++++++++++++++------------
- 1 file changed, 45 insertions(+), 15 deletions(-)
+antirez in commit cd112db:
+ Lua debugger: removing breakpoints now works.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| ae.c: Fix delay until next timer event.
-| By antirez, 2016-04-04 14:08:16 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/29645f1f44926ac2662ed768fe1e369775a30b66
+antirez in commit a076e42:
+ Lua debugger: redis command implemented.
+ 1 file changed, 26 insertions(+), 1 deletion(-)
 
-This fix was written by Anthony LaTorre.
-The old code mis-calculated the amount of time to wait till next event.
+antirez in commit e6eb6ea:
+ Lua debugger: try to eval as expression first.
+ 1 file changed, 13 insertions(+), 4 deletions(-)
 
- src/ae.c | 21 ++++++++++++---------
- 1 file changed, 12 insertions(+), 9 deletions(-)
+antirez in commit 1f8fdaf:
+ Lua debugger: much better Lua values pretty printer.
+ 2 files changed, 70 insertions(+), 17 deletions(-)
 
-+-------------------------------------------------------------------------------
-| ae.c: comment to explain why we have a useless maxId check.
-| By antirez, 2016-04-04 12:23:10 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/aa79c1f1c1d288e4cc2c0f4689ad01488678bf9d
+antirez in commit f480580:
+ Lua debugger: print now handles ARGV and KEYS.
+ 1 file changed, 10 insertions(+), 2 deletions(-)
 
+antirez in commit 36392dd:
+ Lua debugger: added comment about helper functions.
+ 1 file changed, 3 insertions(+)
 
- src/ae.c | 6 +++++-
- 1 file changed, 5 insertions(+), 1 deletion(-)
+antirez in commit 3a04cb0:
+ Lua debugger: redis.breakpoint() implemented.
+ 1 file changed, 27 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Fix ae.c to avoid timers infinite loop.
-| By antirez, 2016-01-08 15:05:14 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0b69c9865619b54b75576e67aaafe7b018734bec
-
-This fix was suggested by Anthony LaTorre, that provided also a good
-test case that was used to verify the fix.
-
-The problem with the old implementation is that, the time returned by
-a timer event (that is the time after it want to run again) is added
-to the event *start time*. So if the event takes, in order to run, more
-than the time it says it want to be scheduled again for running, an
-infinite loop is triggered.
-
- src/ae.c          | 51 ++++++++++++++++++++++-----------------------------
- src/ae.h          |  3 +++
- src/anet.h        |  2 ++
- src/redis-trib.rb |  2 +-
- 4 files changed, 28 insertions(+), 30 deletions(-)
+antirez in commit cf4700b:
+ Lua debugger: output improvements, eval command.
+ 2 files changed, 186 insertions(+), 54 deletions(-)
 
-+-------------------------------------------------------------------------------
-| BITFIELD: overflow wrap behavior fuzz tester.
-| By antirez, 2016-03-02 17:22:42 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/258857cd62e0eb70da32742651a55213fbc28a53
+antirez in commit 1f8d614:
+ Lua debugger: breakpoints.
+ 2 files changed, 148 insertions(+), 12 deletions(-)
 
+antirez in commit 5c4f492:
+ Lua debugger: ability to show local vars content.
+ 1 file changed, 85 insertions(+), 7 deletions(-)
 
- tests/unit/bitfield.tcl | 51 +++++++++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 51 insertions(+)
+antirez in commit 5417217:
+ Lua debugger: log Redis commands. List command.
+ 2 files changed, 82 insertions(+), 7 deletions(-)
 
-+-------------------------------------------------------------------------------
-| BITFIELD basic unit tests.
-| By antirez, 2016-03-02 16:31:02 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/35d05d6dc5d7fb810e732f9de7b05c6b14933fb6
+antirez in commit d3d1fa9:
+ Lua debugger: initial REPL.
+ 2 files changed, 164 insertions(+), 20 deletions(-)
 
+antirez in commit c494db8:
+ Lua debugger: foundations implemented.
+ 5 files changed, 206 insertions(+), 21 deletions(-)
 
- tests/unit/bitfield.tcl | 86 ++++++++++++++++++++++++++++++++++++++++++++++++-
- 1 file changed, 85 insertions(+), 1 deletion(-)
+antirez in commit 7cfdccd:
+ Remove "s" flag for MIGRATE in command table.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| BITFIELD: Farest bit set is offset+bits-1. Off by one error fixed.
-| By antirez, 2016-03-02 16:20:28 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/6cf83feffad7f7b7693a207a9d63278354769ece
+antirez in commit f3dd472:
+ Update redis-cli help and the script to generate it.
+ 2 files changed, 183 insertions(+), 9 deletions(-)
 
+antirez in commit 0cb66fa:
+ Fix MIGRATE entry in command table.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/bitops.c | 6 ++++--
+antirez in commit 8a0258a:
+ AOF: rewriting child killed by SIGUSR1 is not an error.
  1 file changed, 4 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| BITFIELD: overflow fuzzy testing.
-| By antirez, 2016-03-02 15:15:18 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/b4d65c9501be01531eb8fbeb4ba2b444e35d6494
+antirez in commit 54f5ecf:
+ call() deserves a good top-comment.
+ 1 file changed, 38 insertions(+), 2 deletions(-)
 
+Salvatore Sanfilippo in commit c950fac:
+ Merge pull request #2848 from badboy/removed-printf
+antirez in commit 87a12a6:
+ Best effort flush of slave buffers before SHUTDOWN.
+ 2 files changed, 14 insertions(+), 1 deletion(-)
 
- tests/test_helper.tcl   |  1 +
- tests/unit/bitfield.tcl | 52 +++++++++++++++++++++++++++++++++++++++++++++++++
- 2 files changed, 53 insertions(+)
-
-+-------------------------------------------------------------------------------
-| Fix typo in bitops.tcl comment.
-| By antirez, 2016-03-02 15:14:53 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/d75e0fdbe6ecf3074b18c4dd1e8b71a474254ccc
+antirez in commit b719eed:
+ Use clientHasPendingReplies() in flushSlavesOutputBuffers()
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
+antirez in commit 1b5d24e:
+ Scripting: fix redis.call() error reporting.
+ 1 file changed, 18 insertions(+), 5 deletions(-)
 
- tests/unit/bitops.tcl | 2 +-
+antirez in commit 111d24f:
+ Fix error reply in subscribed Pub/Sub mode.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| More BITFIELD fixes. Overflow conditional simplified.
-| By antirez, 2016-03-02 15:13:45 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/5f3ef73ed41be6e051daad9fdb7efa91b4ca682d
+antirez in commit cd8f19e:
+ Initialize all Lua scripting related things into scripting.c
+ 3 files changed, 33 insertions(+), 12 deletions(-)
 
-See issue #3114.
+antirez in commit 9aa1f94:
+ scripting.c source code better organized into sections.
+ 2 files changed, 182 insertions(+), 155 deletions(-)
 
- src/bitops.c | 17 ++++++++---------
- 1 file changed, 8 insertions(+), 9 deletions(-)
+antirez in commit 71aa9b7:
+ Fix HINCRBYFLOAT to work with long doubles.
+ 3 files changed, 8 insertions(+), 8 deletions(-)
 
-+-------------------------------------------------------------------------------
-| bitops/bitfield: fix length, overflow condition and *sign
-| By Sun He, 2016-03-02 18:11:30 +0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/5b9aa5026204fb6c8b0098d4e47c2e001cf06151
+antirez in commit f625570:
+ Add regression test for HINCRBYFLOAT formatting change.
+ 1 file changed, 7 insertions(+)
 
+Salvatore Sanfilippo in commit de776a4:
+ Merge pull request #2850 from Joe8Bit/fix_typo-in-readme
+antirez in commit dfe90ac:
+ README new internals section improved a bit more.
+ 1 file changed, 9 insertions(+), 8 deletions(-)
 
- src/bitops.c | 13 ++++++++-----
- 1 file changed, 8 insertions(+), 5 deletions(-)
+Joe Pettersson in commit 8bc8f6f:
+ Fix typo in READme sever/server
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Fix INFO commandstats reporting when argv is rewritten.
-| By antirez, 2016-03-02 08:51:27 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/ba9154d7e7bf959b002533384319a1e90545447b
+antirez in commit 462026c:
+ README: remove garbage at end of line.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-We want to report the original command in the stats, for example GEOADD,
-even when what is actually executed is the ZADD implementation.
+antirez in commit 73510f4:
+ README operations -> commands, is more clear now #2.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
- src/scripting.c | 2 +-
- src/server.c    | 4 ++--
- 2 files changed, 3 insertions(+), 3 deletions(-)
+antirez in commit b9fb240:
+ README operations -> commands, is more clear now.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| BITFIELD: refactoring & fix of retval on FAIL.
-| By antirez, 2016-02-29 09:08:46 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/76b22e3728e37fe11582b71802bf98a2be09623f
+antirez in commit 8badf16:
+ A few README typos fixed #2.
+ 1 file changed, 2 insertions(+), 2 deletions(-)
 
+antirez in commit d80d051:
+ A few README typos fixed.
+ 1 file changed, 6 insertions(+), 6 deletions(-)
 
- src/bitops.c | 32 ++++++++++++++++++++++++--------
- 1 file changed, 24 insertions(+), 8 deletions(-)
+antirez in commit 15d57c3:
+ README now has info about Redis codebase layout.
+ 1 file changed, 257 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| BITFIELD: Fix #<index> form parsing.
-| By antirez, 2016-02-26 15:53:29 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/c333a9e2d7873190b22aaee8835a188bc55b60dc
+Jan-Erik Rediger in commit 35afefc:
+ Remove printf
+ 1 file changed, 1 deletion(-)
 
+antirez in commit 30b3246:
+ Test: improve PFCOUNT with multiple keys testing.
+ 1 file changed, 17 insertions(+), 2 deletions(-)
+
+antirez in commit 77362b9:
+ Dependencies updated.
+ 1 file changed, 150 insertions(+), 106 deletions(-)
+
+antirez in commit 5b63ae3:
+ Scripting: commands replication tests.
+ 1 file changed, 107 insertions(+), 1 deletion(-)
 
- src/bitops.c | 10 ++++------
- 1 file changed, 4 insertions(+), 6 deletions(-)
+antirez in commit f26072e:
+ More reliable DEBUG loadaof.
+ 1 file changed, 1 insertion(+)
 
-+-------------------------------------------------------------------------------
-| BITFIELD: Support #<index> offsets form.
-| By antirez, 2016-02-26 15:16:24 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/f84871cb5dd3bb3c04bfd7ac53b6e06b246f511f
+antirez in commit 073a42b:
+ Scripting: execute tests with command replication as well.
+ 1 file changed, 88 insertions(+), 79 deletions(-)
+
+antirez in commit ff6d296:
+ Scripting: ability to turn on Lua commands style replication globally.
+ 4 files changed, 8 insertions(+), 1 deletion(-)
 
+antirez in commit eda06b5:
+ Scripting: test Redis provided Lua functions error reporting.
+ 1 file changed, 9 insertions(+)
 
- src/bitops.c | 29 +++++++++++++++++++++++------
- 1 file changed, 23 insertions(+), 6 deletions(-)
+antirez in commit ebaa922:
+ Scripting: fix error reporting of many Redis provided functions.
+ 1 file changed, 14 insertions(+), 14 deletions(-)
 
-+-------------------------------------------------------------------------------
-| BITFIELD command initial implementation.
-| By antirez, 2016-02-25 23:31:45 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/761a77287107ce53dbf4755f1435cc9660b6c86d
-
-The new bitfield command is an extension to the Redis bit operations,
-where not just single bit operations are performed, but the array of
-bits composing a string, can be addressed at random, not aligned
-offsets, with any width unsigned and signed integers like u8, s5, u10
-(up to 64 bit signed integers and 63 bit unsigned integers).
-
-The BITFIELD command supports subcommands that can SET, GET, or INCRBY
-those arbitrary bit counters, with multiple overflow semantics.
-
-Trivial and credits:
-
-A similar command was imagined a few times in the past, but for
-some reason looked a bit far fetched or not well specified.
-Finally the command was proposed again in a clear form by
-Yoav Steinberg from Redis Labs, that proposed a set of commands on
-arbitrary sized integers stored at bit offsets.
-
-Starting from this proposal I wrote an initial specification of a single
-command with sub-commands similar to what Yoav envisioned, using short
-names for types definitions, and adding control on the overflow.
-
-This commit is the resulting implementation.
-
-Examples:
-
-    BITFIELD mykey OVERFLOW wrap INCRBY i2 10 -1 GET i2 10
-
- src/bitops.c | 506 +++++++++++++++++++++++++++++++++++++++++++++++++++++++----
- src/server.c |   1 +
- src/server.h |   1 +
- 3 files changed, 476 insertions(+), 32 deletions(-)
+antirez in commit 2dabf82:
+ Fix call() FORCE_REPL/AOF flags setting.
+ 2 files changed, 16 insertions(+), 15 deletions(-)
+
+antirez in commit 514a234:
+ Lua script selective replication fixes.
+ 3 files changed, 32 insertions(+), 20 deletions(-)
+
+antirez in commit a3e8de0:
+ Lua script selective replication WIP.
+ 2 files changed, 58 insertions(+), 3 deletions(-)
+
+antirez in commit fc38235:
+ Scripting: single commands replication mode implemented.
+ 3 files changed, 72 insertions(+), 8 deletions(-)
+
+antirez in commit cdda674:
+ call(): selective ability to prevent propagation on AOF / slaves.
+ 2 files changed, 35 insertions(+), 7 deletions(-)
+
+antirez in commit 9dd3d2e:
+ call(): don't inherit CLIENT_PREVENT_PROP + minor refactoring.
+ 1 file changed, 6 insertions(+), 3 deletions(-)
+
+antirez in commit d37ef78:
+ CONTRIBUTING updated.
+ 1 file changed, 7 insertions(+), 5 deletions(-)
+
+antirez in commit 86f0a2e:
+ CLIENT REPLY command implemented: ON, OFF and SKIP modes.
+ 2 files changed, 31 insertions(+), 1 deletion(-)
+
+Salvatore Sanfilippo in commit bdcb145:
+ Merge pull request #2810 from dwlt/add-copy-replace-parameters-to-redis-trib-import
+antirez in commit 6ed12bd:
+ Redis.conf example: make clear user must pass its path as argument.
+ 1 file changed, 6 insertions(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Eliminates engineers near the equator & prime meridian
-| By Itamar Haber, 2016-02-18 15:11:30 -0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/4b89ea3a95ef72353e14e0eb5cbf293bf2dc8b48
+antirez in commit 5f0fef5:
+ Regression test for issue #2813.
+ 1 file changed, 53 insertions(+)
+
+antirez in commit ed62288:
+ PR 2813 fix ported to unstable.
+ 2 files changed, 25 insertions(+), 20 deletions(-)
 
+David Thomson in commit 8a85ad2:
+ Add back blank line
+ 1 file changed, 1 insertion(+)
 
- src/geo.c | 8 ++++----
- 1 file changed, 4 insertions(+), 4 deletions(-)
+David Thomson in commit 03d0de7:
+ Update import command to optionally use copy and replace parameters
+ 1 file changed, 7 insertions(+), 3 deletions(-)
+
+antirez in commit 35a0c77:
+ DEBUG RESTART/CRASH-AND-RECOVER [delay] implemented.
+ 2 files changed, 17 insertions(+)
+
+antirez in commit 7342746:
+ Server: restartServer() API.
+ 2 files changed, 73 insertions(+), 4 deletions(-)
+
+antirez in commit c372a59:
+ Cluster: redis-trib fix, coverage for migrating=1 case.
+ 1 file changed, 12 insertions(+), 2 deletions(-)
+
+antirez in commit 6ddcba6:
+ Test: basic lazyfree unit test.
+ 2 files changed, 40 insertions(+)
 
-+-------------------------------------------------------------------------------
-| Fixes a typo in a comment
-| By Itamar Haber, 2016-02-18 15:01:34 -0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0f46f9bd423a146f96e1993aca6221e1305f9a28
+antirez in commit 363c0f6:
+ Test: fix attach_to_replication_stream to handle newlines.
+ 1 file changed, 5 insertions(+), 2 deletions(-)
+
+antirez in commit f29e384:
+ Fix extractLongLatOrReply() sanity check conditionals.
+ 1 file changed, 9 insertions(+), 9 deletions(-)
+
+antirez in commit 3f38b51:
+ Jemalloc configure script fixed to work nested.
+ 1 file changed, 18 deletions(-)
+
+antirez in commit a9951b1:
+ Jemalloc updated to 4.0.3.
+ 140 files changed, 25333 insertions(+), 15474 deletions(-)
+
+antirez in commit e3ded02:
+ Added a README into deps on dependencies and how to upgrade.
+ 1 file changed, 66 insertions(+)
 
+antirez in commit ceaf58d:
+ Regression test for GEORADIUS COUNT arity check.
+ 1 file changed, 5 insertions(+)
 
- src/geo.c | 2 +-
+antirez in commit 319d180:
+ Fix GEORADIUS COUNT option arity checks.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Adjusts accuracy for GEODIST
-| By Itamar Haber, 2016-02-18 15:00:39 -0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/9de844603c5203ae6ff6e7882a3dcb47a9f79a85
+antirez in commit 19f6ab5:
+ Lazyfree options documented in the example redis.conf.
+ 1 file changed, 52 insertions(+), 1 deletion(-)
 
+antirez in commit 880c606:
+ Lazyfree options implemented in the configuration.
+ 1 file changed, 36 insertions(+)
 
- src/geo.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
+antirez in commit 252cfa0:
+ Lazyfree: cond vars to enabled/disable it based on DEL context.
+ 4 files changed, 51 insertions(+), 35 deletions(-)
 
-+-------------------------------------------------------------------------------
-| addReplyHumanLongDouble() API added.
-| By antirez, 2016-02-18 22:08:47 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/79e553a58d7f814fd08482b118561fcf9854b1df
+antirez in commit 5359696:
+ Fixed a bug in the emptyDb() new implementation.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
-Send a long double or double as a bulk reply, in a human friendly
-format.
+antirez in commit ecdbc33:
+ FLUSHDB and FLUSHALL ASYNC option implemented.
+ 2 files changed, 39 insertions(+), 8 deletions(-)
 
- src/networking.c | 9 +++++++++
- src/server.h     | 1 +
- 2 files changed, 10 insertions(+)
+antirez in commit 1f26a94:
+ Lazyfree: pending objects count in INFO output.
+ 3 files changed, 10 insertions(+), 2 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Fix GEORADIUS STORE/DIST refcount after backport to 3.2.
-| By antirez, 2016-02-18 15:33:02 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/158d1e2fbf6badb881a4d78623fd1bffde34cc49
+antirez in commit c69c6c8:
+ Lazyfree: ability to free whole DBs in background.
+ 7 files changed, 106 insertions(+), 14 deletions(-)
 
+antirez in commit b08c36c:
+ Lazyfree: keep count of objects to free.
+ 2 files changed, 11 insertions(+), 3 deletions(-)
 
- src/geo.c | 2 ++
- 1 file changed, 2 insertions(+)
+antirez in commit c7b46a4:
+ zmalloc.c converted to use atomicvar.h.
+ 1 file changed, 5 insertions(+), 33 deletions(-)
 
-+-------------------------------------------------------------------------------
-| GEOADD STORE/STOREDIST tests.
-| By antirez, 2016-02-18 14:42:42 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/123cd88286127cc20684bf0457cb51107a67cfa2
+antirez in commit 7e5d690:
+ Atomic vars implemented in a more general way.
+ 1 file changed, 94 insertions(+)
 
+antirez in commit 7af4eeb:
+ Lazyfree: incremental removed, only threaded survived.
+ 3 files changed, 24 insertions(+), 191 deletions(-)
 
- tests/unit/geo.tcl | 54 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 54 insertions(+)
+antirez in commit 9253d85:
+ Threaded lazyfree WIP #1.
+ 5 files changed, 36 insertions(+), 8 deletions(-)
 
-+-------------------------------------------------------------------------------
-| New options for GEORADIUS: STORE and STOREDIST.
-| By antirez, 2016-02-18 10:24:11 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0b6daf5a6b27447f03c76387b8b707ce0ab7b08d
-
-Related to issue #3019.
-
- src/geo.c    | 143 +++++++++++++++++++++++++++++++++++++++++------------------
- src/server.c |   4 +-
- src/server.h |   1 +
- src/t_zset.c |  18 +++++---
- 4 files changed, 117 insertions(+), 49 deletions(-)
-
-+-------------------------------------------------------------------------------
-| Include full paths on RDB/AOF files errors.
-| By antirez, 2016-02-15 16:14:56 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/f7af1beaab938b7e319d1b91d7736f043b7ef682
+antirez in commit 4d50d69:
+ bio.c: new API bioWaitStepOfType().
+ 2 files changed, 32 insertions(+), 5 deletions(-)
 
-Close #3086.
+antirez in commit 5b850d7:
+ Test: stack_logging var should be initialized to 0.
+ 1 file changed, 1 insertion(+)
 
- src/aof.c | 17 +++++++++++++++--
- src/rdb.c | 19 +++++++++++++++++--
- 2 files changed, 32 insertions(+), 4 deletions(-)
+antirez in commit 1dab60d:
+ Hash new implementation memleaks fixed.
+ 2 files changed, 52 insertions(+), 12 deletions(-)
+
+antirez in commit 97ba4e3:
+ Lazyfree: Hash converted to use plain SDS WIP 5.
+ 3 files changed, 30 insertions(+), 34 deletions(-)
+
+antirez in commit 36be34b:
+ Test: support for stack logging for OSX malloc/leaks.
+ 2 files changed, 7 insertions(+)
+
+antirez in commit 974514b:
+ Lazyfree: Hash converted to use plain SDS WIP 4.
+ 9 files changed, 76 insertions(+), 70 deletions(-)
+
+antirez in commit 4a18352:
+ Lazyfree: Hash converted to use plain SDS WIP 3.
+ 2 files changed, 20 insertions(+), 29 deletions(-)
+
+antirez in commit 777396a:
+ Lazyfree: Hash converted to use plain SDS WIP 2.
+ 4 files changed, 64 insertions(+), 37 deletions(-)
+
+antirez in commit 1c24755:
+ Lazyfree: Hash converted to use plain SDS WIP 1.
+ 5 files changed, 188 insertions(+), 163 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Remove Lua state reference from buffers in lua_cmsgpack.
-| By antirez, 2016-02-10 09:12:17 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0b4a628fc716ab6b88c9823b143de174601a790d
+antirez in commit afc4b92:
+ DEBUG DIGEST Set type memory leak fixed.
+ 1 file changed, 1 insertion(+)
 
+antirez in commit 34e489c:
+ SORT memory leak fixed.
+ 1 file changed, 3 insertions(+), 3 deletions(-)
 
- deps/lua/src/lua_cmsgpack.c | 53 +++++++++++++++++++++------------------------
- 1 file changed, 25 insertions(+), 28 deletions(-)
+antirez in commit a7c5be1:
+ Lazyfree: Sorted sets convereted to plain SDS. (several commits squashed)
+ 10 files changed, 306 insertions(+), 266 deletions(-)
 
-+-------------------------------------------------------------------------------
-| cmsgpack: pass correct osize values to lua allocator, update correct buf free space in cmsgpack
-| By yoav@monfort.co.il, 2016-02-07 20:24:28 +0200
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/43509f686452fba68966aa89b87d1be065b50e17
+antirez in commit 86d48ef:
+ Lazyfree: Convert Sets to use plains SDS (several commits squashed).
+ 9 files changed, 183 insertions(+), 163 deletions(-)
 
+antirez in commit 4ff3c17:
+ Lazyfree: client output buffers no longer use Redis Objects.
+ 2 files changed, 72 insertions(+), 97 deletions(-)
 
- deps/lua/src/lua_cmsgpack.c | 8 ++++----
- 1 file changed, 4 insertions(+), 4 deletions(-)
+antirez in commit 0c05436:
+ Lazyfree: a first implementation of non blocking DEL.
+ 8 files changed, 341 insertions(+), 53 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Fixes a typo
-| By Itamar Haber, 2016-02-03 11:04:09 -0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/cd9f7c6976f81c0e9ffae9e34b31eda19384a7dd
+antirez in commit 712ea72:
+ Call writeToClient() directly instead of the write handler.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
+antirez in commit 01c08b5:
+ Fix processEventsWhileBlocked() to handle PENDING_WRITE clients.
+ 2 files changed, 7 insertions(+), 3 deletions(-)
 
- src/server.c | 4 ++--
- 1 file changed, 2 insertions(+), 2 deletions(-)
+antirez in commit 1e71538:
+ Refactoring: unlinkClient() added to lower freeClient() complexity.
+ 3 files changed, 48 insertions(+), 51 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Adds keyspace notifications for lrem
-| By Itamar Haber, 2016-02-02 09:58:19 -0800
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/bf30f5a73922e5111d6a39da7351e22357213134
+antirez in commit fdb3be9:
+ Refactoring: new function to test if client has pending output.
+ 3 files changed, 17 insertions(+), 8 deletions(-)
 
+antirez in commit 825f65d:
+ Reverse list of clients with pending writes.
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
- src/t_list.c | 7 ++++++-
- 1 file changed, 6 insertions(+), 1 deletion(-)
+antirez in commit 063ecbd:
+ writeToClient(): don't remove write handler if not needed.
+ 1 file changed, 4 insertions(+), 4 deletions(-)
 
-+-------------------------------------------------------------------------------
-| Typo ASII -> ASCII fixed in comment.
-| By antirez, 2016-01-29 12:08:10 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0c7c7631d206964b8bf1dae3db286a3acda4edad
+antirez in commit b741a90:
+ handleClientsWithPendingWrites(): detect dead clients.
+ 1 file changed, 17 insertions(+), 7 deletions(-)
+
+antirez in commit 481a0db:
+ Move handleClientsWithPendingWrites() in networking.c.
+ 3 files changed, 29 insertions(+), 28 deletions(-)
+
+antirez in commit 1c7d87d:
+ Avoid installing the client write handler when possible.
+ 4 files changed, 56 insertions(+), 7 deletions(-)
 
+antirez in commit d1b6a17:
+ redis-cli pipe mode: don't stay in the write loop forever.
+ 1 file changed, 6 insertions(+), 1 deletion(-)
 
- src/server.h | 2 +-
+antirez in commit 622366a:
+ Mark version of unstable branch in an unique way.
  1 file changed, 1 insertion(+), 1 deletion(-)
 
-+-------------------------------------------------------------------------------
-| Cluster: include node IDs in SLOTS output.
-| By antirez, 2016-01-29 12:00:38 +0100
-+--------------------------------------------------------------------------------
-https://github.com/antirez/redis/commit/0f3fb0097ae70e36ee65468b79f0be4160934bb4
+Sebastian Waisbrot in commit 97a2248:
+ Fix race condition in unit/introspection
+ 1 file changed, 4 insertions(+), 3 deletions(-)
 
-CLUSTER SLOTS now includes IDs in the nodes description associated with
-a given slot range. Certain client libraries implementations need a way
-to reference a node in an unique way, so they were relying on CLUSTER
-NODES, that is not a stable API and may change frequently depending on
-Redis Cluster future requirements.
+Adam Baldwin in commit 45fa113:
+ Removed dofile() from Lua
+ 1 file changed, 2 insertions(+)
 
- src/cluster.c | 8 ++++++--
- 1 file changed, 6 insertions(+), 2 deletions(-)
+Migrating from 3.2 to 4.0
+=========================
 
+Redis 3.2 is mostly a strict subset of 4.0, you should not have any problem
+upgrading your application from 3.2 to 4.0. However this is a list of small
+non-backward compatible changes introduced in the 4.0 release:
+
+* The Redis Cluster bus protocol of 4.0 is no longer compatible with Redis 3.2.
+  This was needed in order to provide Docker / NAT compatibility to Redis
+  Cluster. SO in order to upgrade a Redis Cluster to 4.0, a mass restart of
+  all the instances is needed.
 
-~~~~~~~~~~~~~~~~~~~~~~~~~~ OLD STYLE CHANGELOG ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+* Writable slaves do not propagate writes to their sub-slaves, so writes to
+  writable slaves remain just local.
 
---[ Redis 3.2.0 RC3 (version 3.1.103) ] Release date: 28 jan 2016
+* The RDB format changed. Redis 4.0 is still able to read 3.2 (and all the
+  past versions) files, but not the other way around.
 
-Upgrade urgency MODERATE: this release fixes a non trivial Sentinel crash.
+* Certain log formats and sentences are different in Redis 4.0.
 
-* [FIX] avg_ttl reporting in INFO improved. (Salvatore Sanfilippo)
-* [FIX] Sentinel: improve handling of known Sentinel instances.
-        (Salvatore Sanfilippo, thanks to Paweł Kowalczykf or the original
-         crash report).
-* [FIX] Redis Cluster address update (via gossip section) processing improved
-        to avoid initiating inwanted handshakes.
-
---[ Redis 3.2.0 RC2 (version 3.1.102) ] Release date: 25 jan 2016
-
-Upgrade urgency MODERATE: this release fixes important Redis Cluster bugs.
-
-* [FIX] Many fixes to MIGRATE multiple keys implementation. The command
-        could handle errors in a faulty way leading to crashes or other
-        unexpected behaviors. MIGRATE command refactoring.
-        (The analysis of the faulty conditions was conducted by
-         Kevin McGehee. The fix was developed by Salvatore Sanfilippo)
-* [FIX] A Redis Cluster node crash was fixed because of wrong handling of
-        node->slaveof pointers.
-        (Reported by JackyWoo, fixed by Salvatore Sanfilippo)
-* [FIX] Fix redis-trib rebalance when nodes need to be left empty because
-        the specified weight is zero.
-        (Reported by Shahar Mor, fixed by Salvatore Sanfilippo)
-* [FIX] MIGRATE: Never send -ASK redirections for MIGRATE when there are
-        open slots. Redis-trib and other cluster management utility must
-        always be free to move keys between nodes about open slots, in order
-        to reshard, fix the cluster configuration, and so forth.
-        (Salvatore Sanfilippo)
-* [FIX] Lua debugger crash when printing too deeply nested objects.
-        (Reported by Paul Kulchenko, fixed by Salvatore Sanfilippo)
-* [FIX] Redis-cli implementation of Lua debugging now allows to use the
-        SCRIPT DEBUG command directly, switching to debugging mode as needed.
-        (Reported by Paul Kulchenko, fixed by Salvatore Sanfilippo)
-* [FIX] Redis-trib is now able to fix more errors. A new CLUSTER subcommand
-        called BUMPEPOCH was introduced in order to support new modes
-        for the "fix" subcommand. (Salvatore Sanfilippo)
-* [NEW] Redis proctected mode: this feature improves Redis security and makes
-        harder to run Redis in a configuration that is unsecure because no
-        firewalling was used in order to protect Redis from external accesses.
-        See this Reddit post for more info: https://www.reddit.com/r/redis/comments/3zv85m/new_security_feature_redis_protected_mode/ (Salvatore Sanfilippo)
-* [NEW] Cluster/Sentinel tests now use OSX leak to perform leak detection
-        at the end of every unit. (Salvatore Sanfilippo)
-* [NEW] Detect and show server crashes during Cluster/Sentinel tests.
-        (Salvatore Sanfilippo)
-* [NEW] More reliable Cluster/Sentinel test becuase of timing errors and
-        -LOADING errors. (Salvatore Sanfilippo)
-
---[ Redis 3.2.0 RC1 (version 3.1.101) ] Release date: 23 dec 2015
-
-This is the first release candidate of Redis 3.2. The changelog above shows
-what's new in this release. In the next of the following weeks we'll test
-in depth every feature and we'll release new RCs as bugs are discovered
-and fixed. Note that while 3.2 looks solid already, it contains many changes
-to its internals. It's still fresh code compared to 3.0.
-
-General changes:
-
-* [NEW] Lua scripts "effect replication". Makes possible to write scripts
-        with side effects, use of random commands, and so forth.
-        (Salvatore Sanfilippo)
-* [NEW] Lua scripts selective replication. Makes possible to replicate to
-        slaves and AOF only selected parts of a script. (Design by
-        Yossi Gottlieb and Salvatore Sanfilippo, implemented by Salvatore)
-* [NEW] Geo indexing support via GEOADD, GEORADIUS and other commands.
-        See http://redis.io/commands/geoadd for more information.
-        (Initially implemented in a fork of Redis called "Ardb".
-         Matt Stancliff "imported back" the work to Redis and created the
-         initial API and implementation. Salvatore Sanfilippo modified
-         the API and the implementation, fixed bugs, improved performances
-         and unified the duplicated code with t_zset.c)
-* [NEW] Lua debugger. A complete stepping, remote debugger for Lua scripts.
-        Video here: https://www.youtube.com/watch?v=IMvRfStaoyM
-        (Salvatore Sanfilippo with many feedbacks and testing from
-         Itamar Haber)
-* [NEW] SDS improvements for speed and maximum string length.
-        This makes Redis more memory efficient in different use cases.
-        (Design and implementation by Oran Agra, some additional work
-         by Salvatore Sanfilippo)
-* [NEW] Modify Jemalloc size classes to make certain Redis objects fit
-        better, improving memory efficiency. (Oran Agra)
-* [NEW] Better consistency behavior between masters and slaves for expired
-        keys. The slaves are only able to logically consider a key expired
-        even before receiving the `DEL` command from the master. This avoids
-        the delay there is sometimes between the natural expire of the key
-        and the moment the slave is notified. (Salvatore Sanfilippo)
-* [NEW] Support daemon supervision by upstart or systemd (Pierre-Yves Ritschard)
-* [NEW] New encoding for the List type: Quicklists. Very important memory
-        savings and storage space in RDB gains (up to 10x sometimes).
-        (Design and implementation by Matt Stancliff. RDB storage reworked
-         by Salvatore Sanfilippo)
-* [NEW] SPOP with optional count argument. (Initial implementation by
-        Alon Diamant, mostly reimplemented by Salvatore Sanfilippo for speed
-        and in order to make the replication of a this class of commands,
-        having as logical effect the execution of multiple commands, possible).
-* [NEW] Support for RDB AUX fields. Now RDB files contain additional info
-        like the creation date, version of Redis generating it and so forth.
-        (Salvatore Sanfilippo)
-* [NEW] Faster RDB loading via the RESIZEDB opcode to avoid useless hash tables
-        rehashings. (Salvatore Sanfilippo)
-* [NEW] HSTRLEN command. (@landmime and Salvatore Sanfilippo)
-* [NEW] CONFIG SET/GET implementations refactored, partially rewritten,
-        now exposing more config options. (Salvatore Sanfilippo)
-* [NEW] CLUSTER NODES major speedup. (Salvatore Sanfilippo)
-* [NEW] CLIENT KILL TYPE MASTER, to kill (disconnect) masters from slaves.
-        (Salvatore Sanfilippo)
-* [NEW] Jemalloc updated to 4.0.3 (Salvatore Sanfilippo)
-* [NEW] DEBUG RESTART/CRASH-AND-RECOVER [delay] (Salvatore Sanfilippo)
-* [NEW] CLIENT REPLY command implemented: ON, OFF and SKIP modes.
-        (Salvatore Sanfilippo)
-* [NEW] Crash report produced by Redis on crash improved. (Salvatore Sanfilippo)
-* [NEW] Better memory test on crash. (Salvatore Sanfilippo)
-
-Redis Cluster changes:
-
-All the Redis Cluster changes in 3.2 were backported to 3.0, so there is
-technically nothing new for now in this release. The most important things
-are:
-
-* Cluster rebalancing.
-* A pipelined MIGRATE command which is 10x faster and makes resharding
-  and rebalancing faster.
-* Improved replicas migration.
-* As a side effect of quicklists encoding (see above items), moving big
-  lists between nodes is now a lot faster.
-
-Redis Sentinel changes:
-
-* [NEW] Sentinel connection sharing. Makes Sentinels able to scale to
-        monitor many masters. (Salvatore Sanfilippo)
-* [NEW] New SENTINEL INFO-CACHE command. (Matt Stancliff)
-* More things backported to Redis 3.0 in the past, so no longer news of 3.2.
+* Certain INFO fields, especially related to replication, are now different.
 
-Migrating from 3.0 to 3.2
-=========================
+* GEODIST, GEOPOS and GEOHASH return values changed for non existing keys:
+  Previously the return value was inconsistent between non existing key
+  and non existing elements. Now the return is always like if the key
+  contains no elements if the key does not exist. So, for instance,
+  "GEOHASH non_existing_key A B C" now returns an array of 3 NULL values
+  as it should. In general this change should not break compatibility with
+  the past since in the past two different forms were provided by the server
+  and the new behavior is one of the two.
 
-Redis 3.0 is mostly a strict subset of 3.2, you should not have any problem
-upgrading your application from 3.0 to 3.2. However this is a list of small
-non-backward compatible changes introduced in the 3.2 release:
-
-* The default configuration file now binds to 127.0.0.1.
-* Slaves try to no longer expose stale data about already expired keys.
-* The RDB format changed. Redis 3.2 is still able to read 3.0 (and all the
-  past versions) files, but not the other way around.
-* Behavior on crash may be different. The crash log format changed and
-  the memory test executed is now different.
+* The SLOWLOG command entires contain additional two fields: the client address
+  and name. This is documented in the SLOWLOG command online documentation.
 
 --------------------------------------------------------------------------------
 
 Credits: For each release, a list of changes with the relative author is
 provided. Where not specified the implementation and design is done by
 Salvatore Sanfilippo. Thanks to Redis Labs for making all this possible.
 Also many thanks to all the other contributors and the amazing community
 we have.
 
 Commit messages may contain additional credits.
 
-Cheers,
+Enjoy,
 Salvatore
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/CONTRIBUTING /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/CONTRIBUTING
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/CONTRIBUTING	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/CONTRIBUTING	2017-07-14 19:28:42.000000000 +0800
@@ -9,25 +9,25 @@
 
 * Github issues SHOULD ONLY BE USED to report bugs, and for DETAILED feature
   requests. Everything else belongs to the Redis Google Group.
 
   PLEASE DO NOT POST GENERAL QUESTIONS that are not about bugs or suspected
   bugs in the Github issues system. We'll be very happy to help you and provide
-  all the support Reddit sub:
+  all the support at the Reddit sub:
 
       http://reddit.com/r/redis
 
   There is also an active community of Redis users at Stack Overflow:
 
       http://stackoverflow.com/questions/tagged/redis
 
 # How to provide a patch for a new feature
 
 1. If it is a major feature or a semantical change, please post it as a new submission in r/redis on Reddit at http://reddit.com/r/redis. Try to be passionate about why the feature is needed, make users upvote your proposal to gain traction and so forth. Read feedbacks about the community. But in this first step **please don't write code yet**.
 
-2. If in step 1 you get an acknowledge from the project leaders, use the
+2. If in step 1 you get an acknowledgment from the project leaders, use the
    following procedure to submit a patch:
 
     a. Fork Redis on github ( http://help.github.com/fork-a-repo/ )
     b. Create a topic branch (git checkout -b my_branch)
     c. Push to your branch (git push origin my_branch)
     d. Initiate a pull request on github ( http://help.github.com/send-pull-requests/ )
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps: geohash-int
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/adapters: glib.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/adapters: ivykis.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/adapters/libevent.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/adapters/libevent.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/adapters/libevent.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/adapters/libevent.h	2017-07-14 19:28:42.000000000 +0800
@@ -27,19 +27,19 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __HIREDIS_LIBEVENT_H__
 #define __HIREDIS_LIBEVENT_H__
-#include <event.h>
+#include <event2/event.h>
 #include "../hiredis.h"
 #include "../async.h"
 
 typedef struct redisLibeventEvents {
     redisAsyncContext *context;
-    struct event rev, wev;
+    struct event *rev, *wev;
 } redisLibeventEvents;
 
 static void redisLibeventReadEvent(int fd, short event, void *arg) {
     ((void)fd); ((void)event);
     redisLibeventEvents *e = (redisLibeventEvents*)arg;
     redisAsyncHandleRead(e->context);
@@ -50,34 +50,34 @@
     redisLibeventEvents *e = (redisLibeventEvents*)arg;
     redisAsyncHandleWrite(e->context);
 }
 
 static void redisLibeventAddRead(void *privdata) {
     redisLibeventEvents *e = (redisLibeventEvents*)privdata;
-    event_add(&e->rev,NULL);
+    event_add(e->rev,NULL);
 }
 
 static void redisLibeventDelRead(void *privdata) {
     redisLibeventEvents *e = (redisLibeventEvents*)privdata;
-    event_del(&e->rev);
+    event_del(e->rev);
 }
 
 static void redisLibeventAddWrite(void *privdata) {
     redisLibeventEvents *e = (redisLibeventEvents*)privdata;
-    event_add(&e->wev,NULL);
+    event_add(e->wev,NULL);
 }
 
 static void redisLibeventDelWrite(void *privdata) {
     redisLibeventEvents *e = (redisLibeventEvents*)privdata;
-    event_del(&e->wev);
+    event_del(e->wev);
 }
 
 static void redisLibeventCleanup(void *privdata) {
     redisLibeventEvents *e = (redisLibeventEvents*)privdata;
-    event_del(&e->rev);
-    event_del(&e->wev);
+    event_del(e->rev);
+    event_del(e->wev);
     free(e);
 }
 
 static int redisLibeventAttach(redisAsyncContext *ac, struct event_base *base) {
     redisContext *c = &(ac->c);
     redisLibeventEvents *e;
@@ -96,13 +96,13 @@
     ac->ev.addWrite = redisLibeventAddWrite;
     ac->ev.delWrite = redisLibeventDelWrite;
     ac->ev.cleanup = redisLibeventCleanup;
     ac->ev.data = e;
 
     /* Initialize and install read/write events */
-    event_set(&e->rev,c->fd,EV_READ,redisLibeventReadEvent,e);
-    event_set(&e->wev,c->fd,EV_WRITE,redisLibeventWriteEvent,e);
-    event_base_set(base,&e->rev);
-    event_base_set(base,&e->wev);
+    e->rev = event_new(base, c->fd, EV_READ, redisLibeventReadEvent, e);
+    e->wev = event_new(base, c->fd, EV_WRITE, redisLibeventWriteEvent, e);
+    event_add(e->rev, NULL);
+    event_add(e->wev, NULL);
     return REDIS_OK;
 }
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/adapters/libuv.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/adapters/libuv.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/adapters/libuv.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/adapters/libuv.h	2017-07-14 19:28:42.000000000 +0800
@@ -1,32 +1,32 @@
 #ifndef __HIREDIS_LIBUV_H__
 #define __HIREDIS_LIBUV_H__
+#include <stdlib.h>
 #include <uv.h>
 #include "../hiredis.h"
 #include "../async.h"
 #include <string.h>
 
 typedef struct redisLibuvEvents {
   redisAsyncContext* context;
   uv_poll_t          handle;
   int                events;
 } redisLibuvEvents;
 
-int redisLibuvAttach(redisAsyncContext*, uv_loop_t*);
 
 static void redisLibuvPoll(uv_poll_t* handle, int status, int events) {
   redisLibuvEvents* p = (redisLibuvEvents*)handle->data;
 
   if (status != 0) {
     return;
   }
 
-  if (events & UV_READABLE) {
+  if (p->context != NULL && (events & UV_READABLE)) {
     redisAsyncHandleRead(p->context);
   }
-  if (events & UV_WRITABLE) {
+  if (p->context != NULL && (events & UV_WRITABLE)) {
     redisAsyncHandleWrite(p->context);
   }
 }
 
 
 static void redisLibuvAddRead(void *privdata) {
@@ -80,12 +80,13 @@
 }
 
 
 static void redisLibuvCleanup(void *privdata) {
   redisLibuvEvents* p = (redisLibuvEvents*)privdata;
 
+  p->context = NULL; // indicate that context might no longer exist
   uv_close((uv_handle_t*)&p->handle, on_close);
 }
 
 
 static int redisLibuvAttach(redisAsyncContext* ac, uv_loop_t* loop) {
   redisContext *c = &(ac->c);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/adapters: macosx.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/adapters: qt.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis: appveyor.yml
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.c	2017-07-14 19:28:42.000000000 +0800
@@ -55,13 +55,13 @@
     } while(0)
 #define _EL_CLEANUP(ctx) do { \
         if ((ctx)->ev.cleanup) (ctx)->ev.cleanup((ctx)->ev.data); \
     } while(0);
 
 /* Forward declaration of function in hiredis.c */
-void __redisAppendCommand(redisContext *c, char *cmd, size_t len);
+int __redisAppendCommand(redisContext *c, const char *cmd, size_t len);
 
 /* Functions managing dictionary of callbacks for pub/sub. */
 static unsigned int callbackHash(const void *key) {
     return dictGenHashFunction((const unsigned char *)key,
                                sdslen((const sds)key));
 }
@@ -139,12 +139,15 @@
     return ac;
 }
 
 /* We want the error field to be accessible directly instead of requiring
  * an indirection to the redisContext struct. */
 static void __redisAsyncCopyError(redisAsyncContext *ac) {
+    if (!ac)
+        return;
+
     redisContext *c = &(ac->c);
     ac->err = c->err;
     ac->errstr = c->errstr;
 }
 
 redisAsyncContext *redisAsyncConnect(const char *ip, int port) {
@@ -170,12 +173,20 @@
     redisContext *c = redisConnectBindNonBlock(ip,port,source_addr);
     redisAsyncContext *ac = redisAsyncInitialize(c);
     __redisAsyncCopyError(ac);
     return ac;
 }
 
+redisAsyncContext *redisAsyncConnectBindWithReuse(const char *ip, int port,
+                                                  const char *source_addr) {
+    redisContext *c = redisConnectBindNonBlockWithReuse(ip,port,source_addr);
+    redisAsyncContext *ac = redisAsyncInitialize(c);
+    __redisAsyncCopyError(ac);
+    return ac;
+}
+
 redisAsyncContext *redisAsyncConnectUnix(const char *path) {
     redisContext *c;
     redisAsyncContext *ac;
 
     c = redisConnectUnixNonBlock(path);
     if (c == NULL)
@@ -404,13 +415,14 @@
     int status;
 
     while((status = redisGetReply(c,&reply)) == REDIS_OK) {
         if (reply == NULL) {
             /* When the connection is being disconnected and there are
              * no more replies, this is the cue to really disconnect. */
-            if (c->flags & REDIS_DISCONNECTING && sdslen(c->obuf) == 0) {
+            if (c->flags & REDIS_DISCONNECTING && sdslen(c->obuf) == 0
+                && ac->replies.head == NULL) {
                 __redisAsyncDisconnect(ac);
                 return;
             }
 
             /* If monitor mode, repush callback */
             if(c->flags & REDIS_MONITORING) {
@@ -474,13 +486,13 @@
     /* Disconnect when there was an error reading the reply */
     if (status != REDIS_OK)
         __redisAsyncDisconnect(ac);
 }
 
 /* Internal helper function to detect socket status the first time a read or
- * write event fires. When connecting was not succesful, the connect callback
+ * write event fires. When connecting was not successful, the connect callback
  * is called with a REDIS_ERR status and the context is free'd. */
 static int __redisAsyncHandleConnect(redisAsyncContext *ac) {
     redisContext *c = &(ac->c);
 
     if (redisCheckSocketError(c) == REDIS_ERR) {
         /* Try again later when connect(2) is still in progress. */
@@ -548,14 +560,14 @@
         _EL_ADD_READ(ac);
     }
 }
 
 /* Sets a pointer to the first argument and its length starting at p. Returns
  * the number of bytes to skip to get to the following argument. */
-static char *nextArgument(char *start, char **str, size_t *len) {
-    char *p = start;
+static const char *nextArgument(const char *start, const char **str, size_t *len) {
+    const char *p = start;
     if (p[0] != '$') {
         p = strchr(p,'$');
         if (p == NULL) return NULL;
     }
 
     *len = (int)strtol(p+1,NULL,10);
@@ -565,20 +577,21 @@
     return p+2+(*len)+2;
 }
 
 /* Helper function for the redisAsyncCommand* family of functions. Writes a
  * formatted command to the output buffer and registers the provided callback
  * function with the context. */
-static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, char *cmd, size_t len) {
+static int __redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len) {
     redisContext *c = &(ac->c);
     redisCallback cb;
     int pvariant, hasnext;
-    char *cstr, *astr;
+    const char *cstr, *astr;
     size_t clen, alen;
-    char *p;
+    const char *p;
     sds sname;
+    int ret;
 
     /* Don't accept new commands when the connection is about to be closed. */
     if (c->flags & (REDIS_DISCONNECTING | REDIS_FREEING)) return REDIS_ERR;
 
     /* Setup callback */
     cb.fn = fn;
@@ -596,15 +609,17 @@
         c->flags |= REDIS_SUBSCRIBED;
 
         /* Add every channel/pattern to the list of subscription callbacks. */
         while ((p = nextArgument(p,&astr,&alen)) != NULL) {
             sname = sdsnewlen(astr,alen);
             if (pvariant)
-                dictReplace(ac->sub.patterns,sname,&cb);
+                ret = dictReplace(ac->sub.patterns,sname,&cb);
             else
-                dictReplace(ac->sub.channels,sname,&cb);
+                ret = dictReplace(ac->sub.channels,sname,&cb);
+
+            if (ret == 0) sdsfree(sname);
         }
     } else if (strncasecmp(cstr,"unsubscribe\r\n",13) == 0) {
         /* It is only useful to call (P)UNSUBSCRIBE when the context is
          * subscribed to one or more channels or patterns. */
         if (!(c->flags & REDIS_SUBSCRIBED)) return REDIS_ERR;
 
@@ -634,12 +649,17 @@
 
 int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap) {
     char *cmd;
     int len;
     int status;
     len = redisvFormatCommand(&cmd,format,ap);
+
+    /* We don't want to pass -1 or -2 to future functions as a length. */
+    if (len < 0)
+        return REDIS_ERR;
+
     status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
     free(cmd);
     return status;
 }
 
 int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...) {
@@ -649,14 +669,19 @@
     status = redisvAsyncCommand(ac,fn,privdata,format,ap);
     va_end(ap);
     return status;
 }
 
 int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen) {
-    char *cmd;
+    sds cmd;
     int len;
     int status;
-    len = redisFormatCommandArgv(&cmd,argc,argv,argvlen);
+    len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);
     status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
-    free(cmd);
+    sdsfree(cmd);
+    return status;
+}
+
+int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len) {
+    int status = __redisAsyncCommand(ac,fn,privdata,cmd,len);
     return status;
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.h	2017-07-14 19:28:42.000000000 +0800
@@ -100,12 +100,14 @@
     } sub;
 } redisAsyncContext;
 
 /* Functions that proxy to hiredis */
 redisAsyncContext *redisAsyncConnect(const char *ip, int port);
 redisAsyncContext *redisAsyncConnectBind(const char *ip, int port, const char *source_addr);
+redisAsyncContext *redisAsyncConnectBindWithReuse(const char *ip, int port,
+                                                  const char *source_addr);
 redisAsyncContext *redisAsyncConnectUnix(const char *path);
 int redisAsyncSetConnectCallback(redisAsyncContext *ac, redisConnectCallback *fn);
 int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn);
 void redisAsyncDisconnect(redisAsyncContext *ac);
 void redisAsyncFree(redisAsyncContext *ac);
 
@@ -115,12 +117,13 @@
 
 /* Command functions for an async context. Write the command to the
  * output buffer and register the provided callback. */
 int redisvAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, va_list ap);
 int redisAsyncCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *format, ...);
 int redisAsyncCommandArgv(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, int argc, const char **argv, const size_t *argvlen);
+int redisAsyncFormattedCommand(redisAsyncContext *ac, redisCallbackFn *fn, void *privdata, const char *cmd, size_t len);
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/CHANGELOG.md /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/CHANGELOG.md
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/CHANGELOG.md	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/CHANGELOG.md	2017-07-14 19:28:42.000000000 +0800
@@ -1,6 +1,131 @@
+### 1.0.0 (unreleased)
+
+**Fixes**:
+
+* Catch a buffer overflow when formatting the error message
+* Import latest upstream sds. This breaks applications that are linked against the old hiredis v0.13
+* Fix warnings, when compiled with -Wshadow
+* Make hiredis compile in Cygwin on Windows, now CI-tested
+
+**BREAKING CHANGES**:
+
+* Change `redisReply.len` to `size_t`, as it denotes the the size of a string
+
+User code should compare this to `size_t` values as well.
+If it was used to compare to other values, casting might be necessary or can be removed, if casting was applied before.
+
+* Remove backwards compatibility macro's
+
+This removes the following old function aliases, use the new name now:
+
+| Old                         | New                    |
+| --------------------------- | ---------------------- |
+| redisReplyReaderCreate      | redisReaderCreate      |
+| redisReplyReaderCreate      | redisReaderCreate      |
+| redisReplyReaderFree        | redisReaderFree        |
+| redisReplyReaderFeed        | redisReaderFeed        |
+| redisReplyReaderGetReply    | redisReaderGetReply    |
+| redisReplyReaderSetPrivdata | redisReaderSetPrivdata |
+| redisReplyReaderGetObject   | redisReaderGetObject   |
+| redisReplyReaderGetError    | redisReaderGetError    |
+
+* The `DEBUG` variable in the Makefile was renamed to `DEBUG_FLAGS`
+
+Previously it broke some builds for people that had `DEBUG` set to some arbitrary value,
+due to debugging other software.
+By renaming we avoid unintentional name clashes.
+
+Simply rename `DEBUG` to `DEBUG_FLAGS` in your environment to make it working again.
+
+### 0.13.3 (2015-09-16)
+
+* Revert "Clear `REDIS_CONNECTED` flag when connection is closed".
+* Make tests pass on FreeBSD (Thanks, Giacomo Olgeni)
+
+
+If the `REDIS_CONNECTED` flag is cleared,
+the async onDisconnect callback function will never be called.
+This causes problems as the disconnect is never reported back to the user.
+
+### 0.13.2 (2015-08-25)
+
+* Prevent crash on pending replies in async code (Thanks, @switch-st)
+* Clear `REDIS_CONNECTED` flag when connection is closed (Thanks, Jerry Jacobs)
+* Add MacOS X addapter (Thanks, @dizzus)
+* Add Qt adapter (Thanks, Pietro Cerutti)
+* Add Ivykis adapter (Thanks, Gergely Nagy)
+
+All adapters are provided as is and are only tested where possible.
+
+### 0.13.1 (2015-05-03)
+
+This is a bug fix release.
+The new `reconnect` method introduced new struct members, which clashed with pre-defined names in pre-C99 code.
+Another commit forced C99 compilation just to make it work, but of course this is not desirable for outside projects.
+Other non-C99 code can now use hiredis as usual again.
+Sorry for the inconvenience.
+
+* Fix memory leak in async reply handling (Salvatore Sanfilippo)
+* Rename struct member to avoid name clash with pre-c99 code (Alex Balashov, ncopa)
+
+### 0.13.0 (2015-04-16)
+
+This release adds a minimal Windows compatibility layer.
+The parser, standalone since v0.12.0, can now be compiled on Windows
+(and thus used in other client libraries as well)
+
+* Windows compatibility layer for parser code (tzickel)
+* Properly escape data printed to PKGCONF file (Dan Skorupski)
+* Fix tests when assert() undefined (Keith Bennett, Matt Stancliff)
+* Implement a reconnect method for the client context, this changes the structure of `redisContext` (Aaron Bedra)
+
+### 0.12.1 (2015-01-26)
+
+* Fix `make install`: DESTDIR support, install all required files, install PKGCONF in proper location
+* Fix `make test` as 32 bit build on 64 bit platform
+
+### 0.12.0 (2015-01-22)
+
+* Add optional KeepAlive support
+
+* Try again on EINTR errors
+
+* Add libuv adapter
+
+* Add IPv6 support
+
+* Remove possiblity of multiple close on same fd
+
+* Add ability to bind source address on connect
+
+* Add redisConnectFd() and redisFreeKeepFd()
+
+* Fix getaddrinfo() memory leak
+
+* Free string if it is unused (fixes memory leak)
+
+* Improve redisAppendCommandArgv performance 2.5x
+
+* Add support for SO_REUSEADDR
+
+* Fix redisvFormatCommand format parsing
+
+* Add GLib 2.0 adapter
+
+* Refactor reading code into read.c
+
+* Fix errno error buffers to not clobber errors
+
+* Generate pkgconf during build
+
+* Silence _BSD_SOURCE warnings
+
+* Improve digit counting for multibulk creation
+
+
 ### 0.11.0
 
 * Increase the maximum multi-bulk reply depth to 7.
 
 * Increase the read buffer size from 2k to 16k.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/dict.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/dict.c	2017-07-14 19:28:42.000000000 +0800
@@ -158,13 +158,13 @@
  * element with such key and dictReplace() just performed a value update
  * operation. */
 static int dictReplace(dict *ht, void *key, void *val) {
     dictEntry *entry, auxentry;
 
     /* Try to add the element. If the key
-     * does not exists dictAdd will suceed. */
+     * does not exists dictAdd will succeed. */
     if (dictAdd(ht, key, val) == DICT_OK)
         return 1;
     /* It already exists, get the entry */
     entry = dictFind(ht, key);
     /* Free the old value and set the new one */
     /* Set the new value and free the old one. Note that it is important
@@ -290,13 +290,13 @@
 }
 
 /* ------------------------- private functions ------------------------------ */
 
 /* Expand the hash table if needed */
 static int _dictExpandIfNeeded(dict *ht) {
-    /* If the hash table is empty expand it to the intial size,
+    /* If the hash table is empty expand it to the initial size,
      * if the table is "full" dobule its size. */
     if (ht->size == 0)
         return dictExpand(ht, DICT_HT_INITIAL_SIZE);
     if (ht->used == ht->size)
         return dictExpand(ht, ht->size*2);
     return DICT_OK;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/examples/example.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/examples/example.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/examples/example.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/examples/example.c	2017-07-14 19:28:42.000000000 +0800
@@ -54,13 +54,13 @@
     /* Create a list of numbers, from 0 to 9 */
     reply = redisCommand(c,"DEL mylist");
     freeReplyObject(reply);
     for (j = 0; j < 10; j++) {
         char buf[64];
 
-        snprintf(buf,64,"%d",j);
+        snprintf(buf,64,"%u",j);
         reply = redisCommand(c,"LPUSH mylist element-%s", buf);
         freeReplyObject(reply);
     }
 
     /* Let's check what we have inside the list */
     reply = redisCommand(c,"LRANGE mylist 0 -1");
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/examples: example-glib.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/examples: example-ivykis.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/examples: example-macosx.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/examples: example-qt.cpp
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/examples: example-qt.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/fmacros.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/fmacros.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/fmacros.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/fmacros.h	2017-07-14 19:28:42.000000000 +0800
@@ -1,24 +1,25 @@
 #ifndef __HIREDIS_FMACRO_H
 #define __HIREDIS_FMACRO_H
 
-#if !defined(_BSD_SOURCE)
+#if defined(__linux__)
 #define _BSD_SOURCE
+#define _DEFAULT_SOURCE
 #endif
 
-#if defined(_AIX)
-#define _ALL_SOURCE
+#if defined(__CYGWIN__)
+#include <sys/cdefs.h>
 #endif
 
 #if defined(__sun__)
 #define _POSIX_C_SOURCE 200112L
-#elif defined(__linux__) || defined(__OpenBSD__) || defined(__NetBSD__)
-#define _XOPEN_SOURCE 600
 #else
-#define _XOPEN_SOURCE
+#if !(defined(__APPLE__) && defined(__MACH__))
+#define _XOPEN_SOURCE 600
+#endif
 #endif
 
-#if __APPLE__ && __MACH__
+#if defined(__APPLE__) && defined(__MACH__)
 #define _OSX
 #endif
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/.gitignore /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/.gitignore
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/.gitignore	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/.gitignore	2017-07-14 19:28:42.000000000 +0800
@@ -1,6 +1,7 @@
 /hiredis-test
 /examples/hiredis-example*
 /*.o
 /*.so
 /*.dylib
 /*.a
+/*.pc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.c	2017-07-14 19:28:42.000000000 +0800
@@ -1,9 +1,11 @@
 /*
  * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>
- * Copyright (c) 2010-2011, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2010-2014, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2015, Matt Stancliff <matt at genges dot com>,
+ *                     Jan-Erik Rediger <janerik at fnordig dot com>
  *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
@@ -70,12 +72,15 @@
 
 /* Free a reply object */
 void freeReplyObject(void *reply) {
     redisReply *r = reply;
     size_t j;
 
+    if (r == NULL)
+        return;
+
     switch(r->type) {
     case REDIS_REPLY_INTEGER:
         break; /* Nothing to free */
     case REDIS_REPLY_ARRAY:
         if (r->element != NULL) {
             for (j = 0; j < r->elements; j++)
@@ -180,521 +185,41 @@
         assert(parent->type == REDIS_REPLY_ARRAY);
         parent->element[task->idx] = r;
     }
     return r;
 }
 
-static void __redisReaderSetError(redisReader *r, int type, const char *str) {
-    size_t len;
-
-    if (r->reply != NULL && r->fn && r->fn->freeObject) {
-        r->fn->freeObject(r->reply);
-        r->reply = NULL;
-    }
-
-    /* Clear input buffer on errors. */
-    if (r->buf != NULL) {
-        sdsfree(r->buf);
-        r->buf = NULL;
-        r->pos = r->len = 0;
-    }
-
-    /* Reset task stack. */
-    r->ridx = -1;
-
-    /* Set error. */
-    r->err = type;
-    len = strlen(str);
-    len = len < (sizeof(r->errstr)-1) ? len : (sizeof(r->errstr)-1);
-    memcpy(r->errstr,str,len);
-    r->errstr[len] = '\0';
-}
-
-static size_t chrtos(char *buf, size_t size, char byte) {
-    size_t len = 0;
-
-    switch(byte) {
-    case '\\':
-    case '"':
-        len = snprintf(buf,size,"\"\\%c\"",byte);
-        break;
-    case '\n': len = snprintf(buf,size,"\"\\n\""); break;
-    case '\r': len = snprintf(buf,size,"\"\\r\""); break;
-    case '\t': len = snprintf(buf,size,"\"\\t\""); break;
-    case '\a': len = snprintf(buf,size,"\"\\a\""); break;
-    case '\b': len = snprintf(buf,size,"\"\\b\""); break;
-    default:
-        if (isprint(byte))
-            len = snprintf(buf,size,"\"%c\"",byte);
-        else
-            len = snprintf(buf,size,"\"\\x%02x\"",(unsigned char)byte);
-        break;
-    }
-
-    return len;
-}
-
-static void __redisReaderSetErrorProtocolByte(redisReader *r, char byte) {
-    char cbuf[8], sbuf[128];
-
-    chrtos(cbuf,sizeof(cbuf),byte);
-    snprintf(sbuf,sizeof(sbuf),
-        "Protocol error, got %s as reply type byte", cbuf);
-    __redisReaderSetError(r,REDIS_ERR_PROTOCOL,sbuf);
-}
-
-static void __redisReaderSetErrorOOM(redisReader *r) {
-    __redisReaderSetError(r,REDIS_ERR_OOM,"Out of memory");
-}
-
-static char *readBytes(redisReader *r, unsigned int bytes) {
-    char *p;
-    if (r->len-r->pos >= bytes) {
-        p = r->buf+r->pos;
-        r->pos += bytes;
-        return p;
-    }
-    return NULL;
-}
-
-/* Find pointer to \r\n. */
-static char *seekNewline(char *s, size_t len) {
-    int pos = 0;
-    int _len = len-1;
-
-    /* Position should be < len-1 because the character at "pos" should be
-     * followed by a \n. Note that strchr cannot be used because it doesn't
-     * allow to search a limited length and the buffer that is being searched
-     * might not have a trailing NULL character. */
-    while (pos < _len) {
-        while(pos < _len && s[pos] != '\r') pos++;
-        if (s[pos] != '\r') {
-            /* Not found. */
-            return NULL;
-        } else {
-            if (s[pos+1] == '\n') {
-                /* Found. */
-                return s+pos;
-            } else {
-                /* Continue searching. */
-                pos++;
-            }
-        }
-    }
-    return NULL;
-}
-
-/* Read a long long value starting at *s, under the assumption that it will be
- * terminated by \r\n. Ambiguously returns -1 for unexpected input. */
-static long long readLongLong(char *s) {
-    long long v = 0;
-    int dec, mult = 1;
-    char c;
-
-    if (*s == '-') {
-        mult = -1;
-        s++;
-    } else if (*s == '+') {
-        mult = 1;
-        s++;
-    }
-
-    while ((c = *(s++)) != '\r') {
-        dec = c - '0';
-        if (dec >= 0 && dec < 10) {
-            v *= 10;
-            v += dec;
-        } else {
-            /* Should not happen... */
-            return -1;
-        }
-    }
-
-    return mult*v;
-}
-
-static char *readLine(redisReader *r, int *_len) {
-    char *p, *s;
-    int len;
-
-    p = r->buf+r->pos;
-    s = seekNewline(p,(r->len-r->pos));
-    if (s != NULL) {
-        len = s-(r->buf+r->pos);
-        r->pos += len+2; /* skip \r\n */
-        if (_len) *_len = len;
-        return p;
-    }
-    return NULL;
-}
-
-static void moveToNextTask(redisReader *r) {
-    redisReadTask *cur, *prv;
-    while (r->ridx >= 0) {
-        /* Return a.s.a.p. when the stack is now empty. */
-        if (r->ridx == 0) {
-            r->ridx--;
-            return;
-        }
-
-        cur = &(r->rstack[r->ridx]);
-        prv = &(r->rstack[r->ridx-1]);
-        assert(prv->type == REDIS_REPLY_ARRAY);
-        if (cur->idx == prv->elements-1) {
-            r->ridx--;
-        } else {
-            /* Reset the type because the next item can be anything */
-            assert(cur->idx < prv->elements);
-            cur->type = -1;
-            cur->elements = -1;
-            cur->idx++;
-            return;
-        }
-    }
-}
-
-static int processLineItem(redisReader *r) {
-    redisReadTask *cur = &(r->rstack[r->ridx]);
-    void *obj;
-    char *p;
-    int len;
-
-    if ((p = readLine(r,&len)) != NULL) {
-        if (cur->type == REDIS_REPLY_INTEGER) {
-            if (r->fn && r->fn->createInteger)
-                obj = r->fn->createInteger(cur,readLongLong(p));
-            else
-                obj = (void*)REDIS_REPLY_INTEGER;
-        } else {
-            /* Type will be error or status. */
-            if (r->fn && r->fn->createString)
-                obj = r->fn->createString(cur,p,len);
-            else
-                obj = (void*)(size_t)(cur->type);
-        }
-
-        if (obj == NULL) {
-            __redisReaderSetErrorOOM(r);
-            return REDIS_ERR;
-        }
-
-        /* Set reply if this is the root object. */
-        if (r->ridx == 0) r->reply = obj;
-        moveToNextTask(r);
-        return REDIS_OK;
-    }
-
-    return REDIS_ERR;
-}
-
-static int processBulkItem(redisReader *r) {
-    redisReadTask *cur = &(r->rstack[r->ridx]);
-    void *obj = NULL;
-    char *p, *s;
-    long len;
-    unsigned long bytelen;
-    int success = 0;
-
-    p = r->buf+r->pos;
-    s = seekNewline(p,r->len-r->pos);
-    if (s != NULL) {
-        p = r->buf+r->pos;
-        bytelen = s-(r->buf+r->pos)+2; /* include \r\n */
-        len = readLongLong(p);
-
-        if (len < 0) {
-            /* The nil object can always be created. */
-            if (r->fn && r->fn->createNil)
-                obj = r->fn->createNil(cur);
-            else
-                obj = (void*)REDIS_REPLY_NIL;
-            success = 1;
-        } else {
-            /* Only continue when the buffer contains the entire bulk item. */
-            bytelen += len+2; /* include \r\n */
-            if (r->pos+bytelen <= r->len) {
-                if (r->fn && r->fn->createString)
-                    obj = r->fn->createString(cur,s+2,len);
-                else
-                    obj = (void*)REDIS_REPLY_STRING;
-                success = 1;
-            }
-        }
-
-        /* Proceed when obj was created. */
-        if (success) {
-            if (obj == NULL) {
-                __redisReaderSetErrorOOM(r);
-                return REDIS_ERR;
-            }
-
-            r->pos += bytelen;
-
-            /* Set reply if this is the root object. */
-            if (r->ridx == 0) r->reply = obj;
-            moveToNextTask(r);
-            return REDIS_OK;
-        }
-    }
-
-    return REDIS_ERR;
-}
-
-static int processMultiBulkItem(redisReader *r) {
-    redisReadTask *cur = &(r->rstack[r->ridx]);
-    void *obj;
-    char *p;
-    long elements;
-    int root = 0;
-
-    /* Set error for nested multi bulks with depth > 7 */
-    if (r->ridx == 8) {
-        __redisReaderSetError(r,REDIS_ERR_PROTOCOL,
-            "No support for nested multi bulk replies with depth > 7");
-        return REDIS_ERR;
-    }
-
-    if ((p = readLine(r,NULL)) != NULL) {
-        elements = readLongLong(p);
-        root = (r->ridx == 0);
-
-        if (elements == -1) {
-            if (r->fn && r->fn->createNil)
-                obj = r->fn->createNil(cur);
-            else
-                obj = (void*)REDIS_REPLY_NIL;
-
-            if (obj == NULL) {
-                __redisReaderSetErrorOOM(r);
-                return REDIS_ERR;
-            }
-
-            moveToNextTask(r);
-        } else {
-            if (r->fn && r->fn->createArray)
-                obj = r->fn->createArray(cur,elements);
-            else
-                obj = (void*)REDIS_REPLY_ARRAY;
-
-            if (obj == NULL) {
-                __redisReaderSetErrorOOM(r);
-                return REDIS_ERR;
-            }
-
-            /* Modify task stack when there are more than 0 elements. */
-            if (elements > 0) {
-                cur->elements = elements;
-                cur->obj = obj;
-                r->ridx++;
-                r->rstack[r->ridx].type = -1;
-                r->rstack[r->ridx].elements = -1;
-                r->rstack[r->ridx].idx = 0;
-                r->rstack[r->ridx].obj = NULL;
-                r->rstack[r->ridx].parent = cur;
-                r->rstack[r->ridx].privdata = r->privdata;
-            } else {
-                moveToNextTask(r);
-            }
-        }
-
-        /* Set reply if this is the root object. */
-        if (root) r->reply = obj;
-        return REDIS_OK;
-    }
-
-    return REDIS_ERR;
-}
-
-static int processItem(redisReader *r) {
-    redisReadTask *cur = &(r->rstack[r->ridx]);
-    char *p;
-
-    /* check if we need to read type */
-    if (cur->type < 0) {
-        if ((p = readBytes(r,1)) != NULL) {
-            switch (p[0]) {
-            case '-':
-                cur->type = REDIS_REPLY_ERROR;
-                break;
-            case '+':
-                cur->type = REDIS_REPLY_STATUS;
-                break;
-            case ':':
-                cur->type = REDIS_REPLY_INTEGER;
-                break;
-            case '$':
-                cur->type = REDIS_REPLY_STRING;
-                break;
-            case '*':
-                cur->type = REDIS_REPLY_ARRAY;
-                break;
-            default:
-                __redisReaderSetErrorProtocolByte(r,*p);
-                return REDIS_ERR;
-            }
-        } else {
-            /* could not consume 1 byte */
-            return REDIS_ERR;
-        }
-    }
-
-    /* process typed item */
-    switch(cur->type) {
-    case REDIS_REPLY_ERROR:
-    case REDIS_REPLY_STATUS:
-    case REDIS_REPLY_INTEGER:
-        return processLineItem(r);
-    case REDIS_REPLY_STRING:
-        return processBulkItem(r);
-    case REDIS_REPLY_ARRAY:
-        return processMultiBulkItem(r);
-    default:
-        assert(NULL);
-        return REDIS_ERR; /* Avoid warning. */
-    }
-}
-
-redisReader *redisReaderCreate(void) {
-    redisReader *r;
-
-    r = calloc(sizeof(redisReader),1);
-    if (r == NULL)
-        return NULL;
-
-    r->err = 0;
-    r->errstr[0] = '\0';
-    r->fn = &defaultFunctions;
-    r->buf = sdsempty();
-    r->maxbuf = REDIS_READER_MAX_BUF;
-    if (r->buf == NULL) {
-        free(r);
-        return NULL;
-    }
-
-    r->ridx = -1;
-    return r;
-}
-
-void redisReaderFree(redisReader *r) {
-    if (r->reply != NULL && r->fn && r->fn->freeObject)
-        r->fn->freeObject(r->reply);
-    if (r->buf != NULL)
-        sdsfree(r->buf);
-    free(r);
-}
-
-int redisReaderFeed(redisReader *r, const char *buf, size_t len) {
-    sds newbuf;
-
-    /* Return early when this reader is in an erroneous state. */
-    if (r->err)
-        return REDIS_ERR;
-
-    /* Copy the provided buffer. */
-    if (buf != NULL && len >= 1) {
-        /* Destroy internal buffer when it is empty and is quite large. */
-        if (r->len == 0 && r->maxbuf != 0 && sdsavail(r->buf) > r->maxbuf) {
-            sdsfree(r->buf);
-            r->buf = sdsempty();
-            r->pos = 0;
-
-            /* r->buf should not be NULL since we just free'd a larger one. */
-            assert(r->buf != NULL);
-        }
-
-        newbuf = sdscatlen(r->buf,buf,len);
-        if (newbuf == NULL) {
-            __redisReaderSetErrorOOM(r);
-            return REDIS_ERR;
-        }
-
-        r->buf = newbuf;
-        r->len = sdslen(r->buf);
-    }
-
-    return REDIS_OK;
-}
-
-int redisReaderGetReply(redisReader *r, void **reply) {
-    /* Default target pointer to NULL. */
-    if (reply != NULL)
-        *reply = NULL;
-
-    /* Return early when this reader is in an erroneous state. */
-    if (r->err)
-        return REDIS_ERR;
-
-    /* When the buffer is empty, there will never be a reply. */
-    if (r->len == 0)
-        return REDIS_OK;
-
-    /* Set first item to process when the stack is empty. */
-    if (r->ridx == -1) {
-        r->rstack[0].type = -1;
-        r->rstack[0].elements = -1;
-        r->rstack[0].idx = -1;
-        r->rstack[0].obj = NULL;
-        r->rstack[0].parent = NULL;
-        r->rstack[0].privdata = r->privdata;
-        r->ridx = 0;
-    }
-
-    /* Process items in reply. */
-    while (r->ridx >= 0)
-        if (processItem(r) != REDIS_OK)
-            break;
-
-    /* Return ASAP when an error occurred. */
-    if (r->err)
-        return REDIS_ERR;
-
-    /* Discard part of the buffer when we've consumed at least 1k, to avoid
-     * doing unnecessary calls to memmove() in sds.c. */
-    if (r->pos >= 1024) {
-        sdsrange(r->buf,r->pos,-1);
-        r->pos = 0;
-        r->len = sdslen(r->buf);
-    }
-
-    /* Emit a reply when there is one. */
-    if (r->ridx == -1) {
-        if (reply != NULL)
-            *reply = r->reply;
-        r->reply = NULL;
-    }
-    return REDIS_OK;
-}
-
-/* Calculate the number of bytes needed to represent an integer as string. */
-static int intlen(int i) {
-    int len = 0;
-    if (i < 0) {
-        len++;
-        i = -i;
-    }
-    do {
-        len++;
-        i /= 10;
-    } while(i);
-    return len;
+/* Return the number of digits of 'v' when converted to string in radix 10.
+ * Implementation borrowed from link in redis/src/util.c:string2ll(). */
+static uint32_t countDigits(uint64_t v) {
+  uint32_t result = 1;
+  for (;;) {
+    if (v < 10) return result;
+    if (v < 100) return result + 1;
+    if (v < 1000) return result + 2;
+    if (v < 10000) return result + 3;
+    v /= 10000U;
+    result += 4;
+  }
 }
 
 /* Helper that calculates the bulk length given a certain string length. */
 static size_t bulklen(size_t len) {
-    return 1+intlen(len)+2+len+2;
+    return 1+countDigits(len)+2+len+2;
 }
 
 int redisvFormatCommand(char **target, const char *format, va_list ap) {
     const char *c = format;
     char *cmd = NULL; /* final command */
     int pos; /* position in final command */
     sds curarg, newarg; /* current argument */
     int touched = 0; /* was the current argument touched? */
     char **curargv = NULL, **newargv = NULL;
     int argc = 0;
     int totlen = 0;
+    int error_type = 0; /* 0 = no error; -1 = memory error; -2 = format error */
     int j;
 
     /* Abort if there is not target to set */
     if (target == NULL)
         return -1;
 
@@ -705,25 +230,25 @@
 
     while(*c != '\0') {
         if (*c != '%' || c[1] == '\0') {
             if (*c == ' ') {
                 if (touched) {
                     newargv = realloc(curargv,sizeof(char*)*(argc+1));
-                    if (newargv == NULL) goto err;
+                    if (newargv == NULL) goto memory_err;
                     curargv = newargv;
                     curargv[argc++] = curarg;
                     totlen += bulklen(sdslen(curarg));
 
                     /* curarg is put in argv so it can be overwritten. */
                     curarg = sdsempty();
-                    if (curarg == NULL) goto err;
+                    if (curarg == NULL) goto memory_err;
                     touched = 0;
                 }
             } else {
                 newarg = sdscatlen(curarg,c,1);
-                if (newarg == NULL) goto err;
+                if (newarg == NULL) goto memory_err;
                 curarg = newarg;
                 touched = 1;
             }
         } else {
             char *arg;
             size_t size;
@@ -748,23 +273,20 @@
                 newarg = sdscat(curarg,"%");
                 break;
             default:
                 /* Try to detect printf format */
                 {
                     static const char intfmts[] = "diouxX";
+                    static const char flags[] = "#0-+ ";
                     char _format[16];
                     const char *_p = c+1;
                     size_t _l = 0;
                     va_list _cpy;
 
                     /* Flags */
-                    if (*_p != '\0' && *_p == '#') _p++;
-                    if (*_p != '\0' && *_p == '0') _p++;
-                    if (*_p != '\0' && *_p == '-') _p++;
-                    if (*_p != '\0' && *_p == ' ') _p++;
-                    if (*_p != '\0' && *_p == '+') _p++;
+                    while (*_p != '\0' && strchr(flags,*_p) != NULL) _p++;
 
                     /* Field width */
                     while (*_p != '\0' && isdigit(*_p)) _p++;
 
                     /* Precision */
                     if (*_p == '.') {
@@ -826,13 +348,13 @@
                         }
                         goto fmt_invalid;
                     }
 
                 fmt_invalid:
                     va_end(_cpy);
-                    goto err;
+                    goto format_err;
 
                 fmt_valid:
                     _l = (_p+1)-c;
                     if (_l < sizeof(_format)-2) {
                         memcpy(_format,c,_l);
                         _format[_l] = '\0';
@@ -845,41 +367,41 @@
 
                     va_end(_cpy);
                     break;
                 }
             }
 
-            if (newarg == NULL) goto err;
+            if (newarg == NULL) goto memory_err;
             curarg = newarg;
 
             touched = 1;
             c++;
         }
         c++;
     }
 
     /* Add the last argument if needed */
     if (touched) {
         newargv = realloc(curargv,sizeof(char*)*(argc+1));
-        if (newargv == NULL) goto err;
+        if (newargv == NULL) goto memory_err;
         curargv = newargv;
         curargv[argc++] = curarg;
         totlen += bulklen(sdslen(curarg));
     } else {
         sdsfree(curarg);
     }
 
     /* Clear curarg because it was put in curargv or was free'd. */
     curarg = NULL;
 
     /* Add bytes needed to hold multi bulk count */
-    totlen += 1+intlen(argc)+2;
+    totlen += 1+countDigits(argc)+2;
 
     /* Build the command at protocol level */
     cmd = malloc(totlen+1);
-    if (cmd == NULL) goto err;
+    if (cmd == NULL) goto memory_err;
 
     pos = sprintf(cmd,"*%d\r\n",argc);
     for (j = 0; j < argc; j++) {
         pos += sprintf(cmd+pos,"$%zu\r\n",sdslen(curargv[j]));
         memcpy(cmd+pos,curargv[j],sdslen(curargv[j]));
         pos += sdslen(curargv[j]);
@@ -891,26 +413,35 @@
     cmd[pos] = '\0';
 
     free(curargv);
     *target = cmd;
     return totlen;
 
-err:
-    while(argc--)
-        sdsfree(curargv[argc]);
-    free(curargv);
+format_err:
+    error_type = -2;
+    goto cleanup;
+
+memory_err:
+    error_type = -1;
+    goto cleanup;
+
+cleanup:
+    if (curargv) {
+        while(argc--)
+            sdsfree(curargv[argc]);
+        free(curargv);
+    }
 
-    if (curarg != NULL)
-        sdsfree(curarg);
+    sdsfree(curarg);
 
     /* No need to check cmd since it is the last statement that can fail,
      * but do it anyway to be as defensive as possible. */
     if (cmd != NULL)
         free(cmd);
 
-    return -1;
+    return error_type;
 }
 
 /* Format a command according to the Redis protocol. This function
  * takes a format similar to printf:
  *
  * %s represents a C null terminated string you want to interpolate
@@ -925,28 +456,92 @@
 int redisFormatCommand(char **target, const char *format, ...) {
     va_list ap;
     int len;
     va_start(ap,format);
     len = redisvFormatCommand(target,format,ap);
     va_end(ap);
+
+    /* The API says "-1" means bad result, but we now also return "-2" in some
+     * cases.  Force the return value to always be -1. */
+    if (len < 0)
+        len = -1;
+
     return len;
 }
 
+/* Format a command according to the Redis protocol using an sds string and
+ * sdscatfmt for the processing of arguments. This function takes the
+ * number of arguments, an array with arguments and an array with their
+ * lengths. If the latter is set to NULL, strlen will be used to compute the
+ * argument lengths.
+ */
+int redisFormatSdsCommandArgv(sds *target, int argc, const char **argv,
+                              const size_t *argvlen)
+{
+    sds cmd;
+    unsigned long long totlen;
+    int j;
+    size_t len;
+
+    /* Abort on a NULL target */
+    if (target == NULL)
+        return -1;
+
+    /* Calculate our total size */
+    totlen = 1+countDigits(argc)+2;
+    for (j = 0; j < argc; j++) {
+        len = argvlen ? argvlen[j] : strlen(argv[j]);
+        totlen += bulklen(len);
+    }
+
+    /* Use an SDS string for command construction */
+    cmd = sdsempty();
+    if (cmd == NULL)
+        return -1;
+
+    /* We already know how much storage we need */
+    cmd = sdsMakeRoomFor(cmd, totlen);
+    if (cmd == NULL)
+        return -1;
+
+    /* Construct command */
+    cmd = sdscatfmt(cmd, "*%i\r\n", argc);
+    for (j=0; j < argc; j++) {
+        len = argvlen ? argvlen[j] : strlen(argv[j]);
+        cmd = sdscatfmt(cmd, "$%u\r\n", len);
+        cmd = sdscatlen(cmd, argv[j], len);
+        cmd = sdscatlen(cmd, "\r\n", sizeof("\r\n")-1);
+    }
+
+    assert(sdslen(cmd)==totlen);
+
+    *target = cmd;
+    return totlen;
+}
+
+void redisFreeSdsCommand(sds cmd) {
+    sdsfree(cmd);
+}
+
 /* Format a command according to the Redis protocol. This function takes the
  * number of arguments, an array with arguments and an array with their
  * lengths. If the latter is set to NULL, strlen will be used to compute the
  * argument lengths.
  */
 int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen) {
     char *cmd = NULL; /* final command */
     int pos; /* position in final command */
     size_t len;
     int totlen, j;
 
+    /* Abort on a NULL target */
+    if (target == NULL)
+        return -1;
+
     /* Calculate number of bytes needed for the command */
-    totlen = 1+intlen(argc)+2;
+    totlen = 1+countDigits(argc)+2;
     for (j = 0; j < argc; j++) {
         len = argvlen ? argvlen[j] : strlen(argv[j]);
         totlen += bulklen(len);
     }
 
     /* Build the command at protocol level */
@@ -967,57 +562,113 @@
     cmd[pos] = '\0';
 
     *target = cmd;
     return totlen;
 }
 
+void redisFreeCommand(char *cmd) {
+    free(cmd);
+}
+
 void __redisSetError(redisContext *c, int type, const char *str) {
     size_t len;
 
     c->err = type;
     if (str != NULL) {
         len = strlen(str);
         len = len < (sizeof(c->errstr)-1) ? len : (sizeof(c->errstr)-1);
         memcpy(c->errstr,str,len);
         c->errstr[len] = '\0';
     } else {
         /* Only REDIS_ERR_IO may lack a description! */
         assert(type == REDIS_ERR_IO);
-        strerror_r(errno,c->errstr,sizeof(c->errstr));
+        __redis_strerror_r(errno, c->errstr, sizeof(c->errstr));
     }
 }
 
+redisReader *redisReaderCreate(void) {
+    return redisReaderCreateWithFunctions(&defaultFunctions);
+}
+
 static redisContext *redisContextInit(void) {
     redisContext *c;
 
     c = calloc(1,sizeof(redisContext));
     if (c == NULL)
         return NULL;
 
     c->err = 0;
     c->errstr[0] = '\0';
     c->obuf = sdsempty();
     c->reader = redisReaderCreate();
+    c->tcp.host = NULL;
+    c->tcp.source_addr = NULL;
+    c->unix_sock.path = NULL;
+    c->timeout = NULL;
+
+    if (c->obuf == NULL || c->reader == NULL) {
+        redisFree(c);
+        return NULL;
+    }
+
     return c;
 }
 
 void redisFree(redisContext *c) {
+    if (c == NULL)
+        return;
     if (c->fd > 0)
         close(c->fd);
     if (c->obuf != NULL)
         sdsfree(c->obuf);
     if (c->reader != NULL)
         redisReaderFree(c->reader);
+    if (c->tcp.host)
+        free(c->tcp.host);
+    if (c->tcp.source_addr)
+        free(c->tcp.source_addr);
+    if (c->unix_sock.path)
+        free(c->unix_sock.path);
+    if (c->timeout)
+        free(c->timeout);
     free(c);
 }
 
 int redisFreeKeepFd(redisContext *c) {
-	int fd = c->fd;
-	c->fd = -1;
-	redisFree(c);
-	return fd;
+    int fd = c->fd;
+    c->fd = -1;
+    redisFree(c);
+    return fd;
+}
+
+int redisReconnect(redisContext *c) {
+    c->err = 0;
+    memset(c->errstr, '\0', strlen(c->errstr));
+
+    if (c->fd > 0) {
+        close(c->fd);
+    }
+
+    sdsfree(c->obuf);
+    redisReaderFree(c->reader);
+
+    c->obuf = sdsempty();
+    c->reader = redisReaderCreate();
+
+    if (c->connection_type == REDIS_CONN_TCP) {
+        return redisContextConnectBindTcp(c, c->tcp.host, c->tcp.port,
+                c->timeout, c->tcp.source_addr);
+    } else if (c->connection_type == REDIS_CONN_UNIX) {
+        return redisContextConnectUnix(c, c->unix_sock.path, c->timeout);
+    } else {
+        /* Something bad happened here and shouldn't have. There isn't
+           enough information in the context to reconnect. */
+        __redisSetError(c,REDIS_ERR_OTHER,"Not enough information to reconnect");
+    }
+
+    return REDIS_ERR;
 }
 
 /* Connect to a Redis instance. On error the field error in the returned
  * context will be set to the return value of the error function.
  * When no set of reply functions is given, the default set will be used. */
 redisContext *redisConnect(const char *ip, int port) {
@@ -1061,12 +712,21 @@
     redisContext *c = redisContextInit();
     c->flags &= ~REDIS_BLOCK;
     redisContextConnectBindTcp(c,ip,port,NULL,source_addr);
     return c;
 }
 
+redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
+                                                const char *source_addr) {
+    redisContext *c = redisContextInit();
+    c->flags &= ~REDIS_BLOCK;
+    c->flags |= REDIS_REUSEADDR;
+    redisContextConnectBindTcp(c,ip,port,NULL,source_addr);
+    return c;
+}
+
 redisContext *redisConnectUnix(const char *path) {
     redisContext *c;
 
     c = redisContextInit();
     if (c == NULL)
         return NULL;
@@ -1159,16 +819,16 @@
     return REDIS_OK;
 }
 
 /* Write the output buffer to the socket.
  *
  * Returns REDIS_OK when the buffer is empty, or (a part of) the buffer was
- * succesfully written to the socket. When the buffer is empty after the
+ * successfully written to the socket. When the buffer is empty after the
  * write operation, "done" is set to 1 (if given).
  *
- * Returns REDIS_ERR if an error occured trying to write and sets
+ * Returns REDIS_ERR if an error occurred trying to write and sets
  * c->errstr to hold the appropriate error string.
  */
 int redisBufferWrite(redisContext *c, int *done) {
     int nwritten;
 
     /* Return early when the context has seen an error. */
@@ -1271,12 +931,15 @@
     int len;
 
     len = redisvFormatCommand(&cmd,format,ap);
     if (len == -1) {
         __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
         return REDIS_ERR;
+    } else if (len == -2) {
+        __redisSetError(c,REDIS_ERR_OTHER,"Invalid format string");
+        return REDIS_ERR;
     }
 
     if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {
         free(cmd);
         return REDIS_ERR;
     }
@@ -1293,38 +956,38 @@
     ret = redisvAppendCommand(c,format,ap);
     va_end(ap);
     return ret;
 }
 
 int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen) {
-    char *cmd;
+    sds cmd;
     int len;
 
-    len = redisFormatCommandArgv(&cmd,argc,argv,argvlen);
+    len = redisFormatSdsCommandArgv(&cmd,argc,argv,argvlen);
     if (len == -1) {
         __redisSetError(c,REDIS_ERR_OOM,"Out of memory");
         return REDIS_ERR;
     }
 
     if (__redisAppendCommand(c,cmd,len) != REDIS_OK) {
-        free(cmd);
+        sdsfree(cmd);
         return REDIS_ERR;
     }
 
-    free(cmd);
+    sdsfree(cmd);
     return REDIS_OK;
 }
 
 /* Helper function for the redisCommand* family of functions.
  *
  * Write a formatted command to the output buffer. If the given context is
  * blocking, immediately read the reply into the "reply" pointer. When the
  * context is non-blocking, the "reply" pointer will not be used and the
  * command is simply appended to the write buffer.
  *
- * Returns the reply when a reply was succesfully retrieved. Returns NULL
+ * Returns the reply when a reply was successfully retrieved. Returns NULL
  * otherwise. When NULL is returned in a blocking context, the error field
  * in the context will be set.
  */
 static void *__redisBlockForReply(redisContext *c) {
     void *reply;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.h	2017-07-14 19:28:42.000000000 +0800
@@ -1,9 +1,11 @@
 /*
  * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>
- * Copyright (c) 2010-2011, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2010-2014, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2015, Matt Stancliff <matt at genges dot com>,
+ *                     Jan-Erik Rediger <janerik at fnordig dot com>
  *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
@@ -28,32 +30,22 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #ifndef __HIREDIS_H
 #define __HIREDIS_H
-#include <stdio.h> /* for size_t */
+#include "read.h"
 #include <stdarg.h> /* for va_list */
 #include <sys/time.h> /* for struct timeval */
+#include <stdint.h> /* uintXX_t, etc */
+#include "sds.h" /* for sds */
 
 #define HIREDIS_MAJOR 0
-#define HIREDIS_MINOR 11
-#define HIREDIS_PATCH 0
-
-#define REDIS_ERR -1
-#define REDIS_OK 0
-
-/* When an error occurs, the err flag in a context is set to hold the type of
- * error that occured. REDIS_ERR_IO means there was an I/O error and you
- * should use the "errno" variable to find out what is wrong.
- * For other values, the "errstr" field will hold a description. */
-#define REDIS_ERR_IO 1 /* Error in read or write */
-#define REDIS_ERR_EOF 3 /* End of file */
-#define REDIS_ERR_PROTOCOL 4 /* Protocol error */
-#define REDIS_ERR_OOM 5 /* Out of memory */
-#define REDIS_ERR_OTHER 2 /* Everything else... */
+#define HIREDIS_MINOR 13
+#define HIREDIS_PATCH 3
+#define HIREDIS_SONAME 0.13
 
 /* Connection type can be blocking or non-blocking and is set in the
  * least significant bit of the flags field in redisContext. */
 #define REDIS_BLOCK 0x1
 
 /* Connection may be disconnected before being free'd. The second bit
@@ -76,113 +68,124 @@
 /* Flag that is set when the async context has one or more subscriptions. */
 #define REDIS_SUBSCRIBED 0x20
 
 /* Flag that is set when monitor mode is active */
 #define REDIS_MONITORING 0x40
 
-#define REDIS_REPLY_STRING 1
-#define REDIS_REPLY_ARRAY 2
-#define REDIS_REPLY_INTEGER 3
-#define REDIS_REPLY_NIL 4
-#define REDIS_REPLY_STATUS 5
-#define REDIS_REPLY_ERROR 6
-
-#define REDIS_READER_MAX_BUF (1024*16)  /* Default max unused reader buffer. */
+/* Flag that is set when we should set SO_REUSEADDR before calling bind() */
+#define REDIS_REUSEADDR 0x80
 
 #define REDIS_KEEPALIVE_INTERVAL 15 /* seconds */
 
+/* number of times we retry to connect in the case of EADDRNOTAVAIL and
+ * SO_REUSEADDR is being used. */
+#define REDIS_CONNECT_RETRIES  10
+
+/* strerror_r has two completely different prototypes and behaviors
+ * depending on system issues, so we need to operate on the error buffer
+ * differently depending on which strerror_r we're using. */
+#ifndef _GNU_SOURCE
+/* "regular" POSIX strerror_r that does the right thing. */
+#define __redis_strerror_r(errno, buf, len)                                    \
+    do {                                                                       \
+        strerror_r((errno), (buf), (len));                                     \
+    } while (0)
+#else
+/* "bad" GNU strerror_r we need to clean up after. */
+#define __redis_strerror_r(errno, buf, len)                                    \
+    do {                                                                       \
+        char *err_str = strerror_r((errno), (buf), (len));                     \
+        /* If return value _isn't_ the start of the buffer we passed in,       \
+         * then GNU strerror_r returned an internal static buffer and we       \
+         * need to copy the result into our private buffer. */                 \
+        if (err_str != (buf)) {                                                \
+            strncpy((buf), err_str, ((len) - 1));                              \
+            buf[(len)-1] = '\0';                                               \
+        }                                                                      \
+    } while (0)
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /* This is the reply object returned by redisCommand() */
 typedef struct redisReply {
     int type; /* REDIS_REPLY_* */
     long long integer; /* The integer when type is REDIS_REPLY_INTEGER */
-    int len; /* Length of string */
+    size_t len; /* Length of string */
     char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */
     size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */
     struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */
 } redisReply;
 
-typedef struct redisReadTask {
-    int type;
-    int elements; /* number of elements in multibulk container */
-    int idx; /* index in parent (array) object */
-    void *obj; /* holds user-generated value for a read task */
-    struct redisReadTask *parent; /* parent task */
-    void *privdata; /* user-settable arbitrary field */
-} redisReadTask;
-
-typedef struct redisReplyObjectFunctions {
-    void *(*createString)(const redisReadTask*, char*, size_t);
-    void *(*createArray)(const redisReadTask*, int);
-    void *(*createInteger)(const redisReadTask*, long long);
-    void *(*createNil)(const redisReadTask*);
-    void (*freeObject)(void*);
-} redisReplyObjectFunctions;
-
-/* State for the protocol parser */
-typedef struct redisReader {
-    int err; /* Error flags, 0 when there is no error */
-    char errstr[128]; /* String representation of error when applicable */
-
-    char *buf; /* Read buffer */
-    size_t pos; /* Buffer cursor */
-    size_t len; /* Buffer length */
-    size_t maxbuf; /* Max length of unused buffer */
-
-    redisReadTask rstack[9];
-    int ridx; /* Index of current read task */
-    void *reply; /* Temporary reply pointer */
-
-    redisReplyObjectFunctions *fn;
-    void *privdata;
-} redisReader;
-
-/* Public API for the protocol parser. */
 redisReader *redisReaderCreate(void);
-void redisReaderFree(redisReader *r);
-int redisReaderFeed(redisReader *r, const char *buf, size_t len);
-int redisReaderGetReply(redisReader *r, void **reply);
-
-/* Backwards compatibility, can be removed on big version bump. */
-#define redisReplyReaderCreate redisReaderCreate
-#define redisReplyReaderFree redisReaderFree
-#define redisReplyReaderFeed redisReaderFeed
-#define redisReplyReaderGetReply redisReaderGetReply
-#define redisReplyReaderSetPrivdata(_r, _p) (int)(((redisReader*)(_r))->privdata = (_p))
-#define redisReplyReaderGetObject(_r) (((redisReader*)(_r))->reply)
-#define redisReplyReaderGetError(_r) (((redisReader*)(_r))->errstr)
 
 /* Function to free the reply objects hiredis returns by default. */
 void freeReplyObject(void *reply);
 
 /* Functions to format a command according to the protocol. */
 int redisvFormatCommand(char **target, const char *format, va_list ap);
 int redisFormatCommand(char **target, const char *format, ...);
 int redisFormatCommandArgv(char **target, int argc, const char **argv, const size_t *argvlen);
+int redisFormatSdsCommandArgv(sds *target, int argc, const char ** argv, const size_t *argvlen);
+void redisFreeCommand(char *cmd);
+void redisFreeSdsCommand(sds cmd);
+
+enum redisConnectionType {
+    REDIS_CONN_TCP,
+    REDIS_CONN_UNIX
+};
 
 /* Context for a connection to Redis */
 typedef struct redisContext {
     int err; /* Error flags, 0 when there is no error */
     char errstr[128]; /* String representation of error when applicable */
     int fd;
     int flags;
     char *obuf; /* Write buffer */
     redisReader *reader; /* Protocol reader */
+
+    enum redisConnectionType connection_type;
+    struct timeval *timeout;
+
+    struct {
+        char *host;
+        char *source_addr;
+        int port;
+    } tcp;
+
+    struct {
+        char *path;
+    } unix_sock;
+
 } redisContext;
 
 redisContext *redisConnect(const char *ip, int port);
 redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv);
 redisContext *redisConnectNonBlock(const char *ip, int port);
-redisContext *redisConnectBindNonBlock(const char *ip, int port, const char *source_addr);
+redisContext *redisConnectBindNonBlock(const char *ip, int port,
+                                       const char *source_addr);
+redisContext *redisConnectBindNonBlockWithReuse(const char *ip, int port,
+                                                const char *source_addr);
 redisContext *redisConnectUnix(const char *path);
 redisContext *redisConnectUnixWithTimeout(const char *path, const struct timeval tv);
 redisContext *redisConnectUnixNonBlock(const char *path);
 redisContext *redisConnectFd(int fd);
+
+/**
+ * Reconnect the given context using the saved information.
+ *
+ * This re-uses the exact same connect options as in the initial connection.
+ * host, ip (or path), timeout and bind address are reused,
+ * flags are used unmodified from the existing context.
+ *
+ * Returns REDIS_OK on successful connect or REDIS_ERR otherwise.
+ */
+int redisReconnect(redisContext *c);
+
 int redisSetTimeout(redisContext *c, const struct timeval tv);
 int redisEnableKeepAlive(redisContext *c);
 void redisFree(redisContext *c);
 int redisFreeKeepFd(redisContext *c);
 int redisBufferRead(redisContext *c);
 int redisBufferWrite(redisContext *c, int *done);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/libhiredis.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/libhiredis.a differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/Makefile	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/Makefile	2017-07-14 19:28:42.000000000 +0800
@@ -1,18 +1,30 @@
 # Hiredis Makefile
 # Copyright (C) 2010-2011 Salvatore Sanfilippo <antirez at gmail dot com>
 # Copyright (C) 2010-2011 Pieter Noordhuis <pcnoordhuis at gmail dot com>
 # This file is released under the BSD license, see the COPYING file
 
-OBJ=net.o hiredis.o sds.o async.o
-EXAMPLES=hiredis-example hiredis-example-libevent hiredis-example-libev
+OBJ=net.o hiredis.o sds.o async.o read.o
+EXAMPLES=hiredis-example hiredis-example-libevent hiredis-example-libev hiredis-example-glib
 TESTS=hiredis-test
 LIBNAME=libhiredis
+PKGCONFNAME=hiredis.pc
 
-HIREDIS_MAJOR=0
-HIREDIS_MINOR=11
+HIREDIS_MAJOR=$(shell grep HIREDIS_MAJOR hiredis.h | awk '{print $$3}')
+HIREDIS_MINOR=$(shell grep HIREDIS_MINOR hiredis.h | awk '{print $$3}')
+HIREDIS_PATCH=$(shell grep HIREDIS_PATCH hiredis.h | awk '{print $$3}')
+HIREDIS_SONAME=$(shell grep HIREDIS_SONAME hiredis.h | awk '{print $$3}')
+
+# Installation related variables and target
+PREFIX?=/usr/local
+INCLUDE_PATH?=include/hiredis
+LIBRARY_PATH?=lib
+PKGCONF_PATH?=pkgconfig
+INSTALL_INCLUDE_PATH= $(DESTDIR)$(PREFIX)/$(INCLUDE_PATH)
+INSTALL_LIBRARY_PATH= $(DESTDIR)$(PREFIX)/$(LIBRARY_PATH)
+INSTALL_PKGCONF_PATH= $(INSTALL_LIBRARY_PATH)/$(PKGCONF_PATH)
 
 # redis-server configuration used for testing
 REDIS_PORT=56379
 REDIS_SERVER=redis-server
 define REDIS_TEST_CONFIG
 	daemonize yes
@@ -22,21 +34,22 @@
 	unixsocket /tmp/hiredis-test-redis.sock
 endef
 export REDIS_TEST_CONFIG
 
 # Fallback to gcc when $CC is not in $PATH.
 CC:=$(shell sh -c 'type $(CC) >/dev/null 2>/dev/null && echo $(CC) || echo gcc')
+CXX:=$(shell sh -c 'type $(CXX) >/dev/null 2>/dev/null && echo $(CXX) || echo g++')
 OPTIMIZATION?=-O3
 WARNINGS=-Wall -W -Wstrict-prototypes -Wwrite-strings
-DEBUG?= -g -ggdb
-REAL_CFLAGS=$(OPTIMIZATION) -fPIC $(CFLAGS) $(WARNINGS) $(DEBUG) $(ARCH)
+DEBUG_FLAGS?= -g -ggdb
+REAL_CFLAGS=$(OPTIMIZATION) -fPIC $(CFLAGS) $(WARNINGS) $(DEBUG_FLAGS) $(ARCH)
 REAL_LDFLAGS=$(LDFLAGS) $(ARCH)
 
 DYLIBSUFFIX=so
 STLIBSUFFIX=a
-DYLIB_MINOR_NAME=$(LIBNAME).$(DYLIBSUFFIX).$(HIREDIS_MAJOR).$(HIREDIS_MINOR)
+DYLIB_MINOR_NAME=$(LIBNAME).$(DYLIBSUFFIX).$(HIREDIS_SONAME)
 DYLIB_MAJOR_NAME=$(LIBNAME).$(DYLIBSUFFIX).$(HIREDIS_MAJOR)
 DYLIBNAME=$(LIBNAME).$(DYLIBSUFFIX)
 DYLIB_MAKE_CMD=$(CC) -shared -Wl,-soname,$(DYLIB_MINOR_NAME) -o $(DYLIBNAME) $(LDFLAGS)
 STLIBNAME=$(LIBNAME).$(STLIBSUFFIX)
 STLIB_MAKE_CMD=ar rcs $(STLIBNAME)
 
@@ -46,25 +59,26 @@
   REAL_LDFLAGS+= -ldl -lnsl -lsocket
   DYLIB_MAKE_CMD=$(CC) -G -o $(DYLIBNAME) -h $(DYLIB_MINOR_NAME) $(LDFLAGS)
   INSTALL= cp -r
 endif
 ifeq ($(uname_S),Darwin)
   DYLIBSUFFIX=dylib
-  DYLIB_MINOR_NAME=$(LIBNAME).$(HIREDIS_MAJOR).$(HIREDIS_MINOR).$(DYLIBSUFFIX)
-  DYLIB_MAJOR_NAME=$(LIBNAME).$(HIREDIS_MAJOR).$(DYLIBSUFFIX)
+  DYLIB_MINOR_NAME=$(LIBNAME).$(HIREDIS_SONAME).$(DYLIBSUFFIX)
   DYLIB_MAKE_CMD=$(CC) -shared -Wl,-install_name,$(DYLIB_MINOR_NAME) -o $(DYLIBNAME) $(LDFLAGS)
 endif
 
-all: $(DYLIBNAME)
+all: $(DYLIBNAME) $(STLIBNAME) hiredis-test $(PKGCONFNAME)
 
 # Deps (use make dep to generate this)
-net.o: net.c fmacros.h net.h hiredis.h
-async.o: async.c async.h hiredis.h sds.h dict.c dict.h
-hiredis.o: hiredis.c fmacros.h hiredis.h net.h sds.h
+async.o: async.c fmacros.h async.h hiredis.h read.h sds.h net.h dict.c dict.h
+dict.o: dict.c fmacros.h dict.h
+hiredis.o: hiredis.c fmacros.h hiredis.h read.h sds.h net.h
+net.o: net.c fmacros.h net.h hiredis.h read.h sds.h
+read.o: read.c fmacros.h read.h sds.h
 sds.o: sds.c sds.h
-test.o: test.c hiredis.h
+test.o: test.c fmacros.h hiredis.h read.h sds.h
 
 $(DYLIBNAME): $(OBJ)
 	$(DYLIB_MAKE_CMD) $(OBJ)
 
 $(STLIBNAME): $(OBJ)
 	$(STLIB_MAKE_CMD) $(OBJ)
@@ -76,12 +90,21 @@
 hiredis-example-libevent: examples/example-libevent.c adapters/libevent.h $(STLIBNAME)
 	$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. $< -levent $(STLIBNAME)
 
 hiredis-example-libev: examples/example-libev.c adapters/libev.h $(STLIBNAME)
 	$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. $< -lev $(STLIBNAME)
 
+hiredis-example-glib: examples/example-glib.c adapters/glib.h $(STLIBNAME)
+	$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) $(shell pkg-config --cflags --libs glib-2.0) -I. $< $(STLIBNAME)
+
+hiredis-example-ivykis: examples/example-ivykis.c adapters/ivykis.h $(STLIBNAME)
+	$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. $< -livykis $(STLIBNAME)
+
+hiredis-example-macosx: examples/example-macosx.c adapters/macosx.h $(STLIBNAME)
+	$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. $< -framework CoreFoundation $(STLIBNAME)
+
 ifndef AE_DIR
 hiredis-example-ae:
 	@echo "Please specify AE_DIR (e.g. <redis repository>/src)"
 	@false
 else
 hiredis-example-ae: examples/example-ae.c adapters/ae.h $(STLIBNAME)
@@ -91,66 +114,94 @@
 ifndef LIBUV_DIR
 hiredis-example-libuv:
 	@echo "Please specify LIBUV_DIR (e.g. ../libuv/)"
 	@false
 else
 hiredis-example-libuv: examples/example-libuv.c adapters/libuv.h $(STLIBNAME)
-	$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. -I$(LIBUV_DIR)/include $< $(LIBUV_DIR)/.libs/libuv.a -lpthread $(STLIBNAME)
+	$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. -I$(LIBUV_DIR)/include $< $(LIBUV_DIR)/.libs/libuv.a -lpthread -lrt $(STLIBNAME)
+endif
+
+ifeq ($(and $(QT_MOC),$(QT_INCLUDE_DIR),$(QT_LIBRARY_DIR)),)
+hiredis-example-qt:
+	@echo "Please specify QT_MOC, QT_INCLUDE_DIR AND QT_LIBRARY_DIR"
+	@false
+else
+hiredis-example-qt: examples/example-qt.cpp adapters/qt.h $(STLIBNAME)
+	$(QT_MOC) adapters/qt.h -I. -I$(QT_INCLUDE_DIR) -I$(QT_INCLUDE_DIR)/QtCore | \
+	    $(CXX) -x c++ -o qt-adapter-moc.o -c - $(REAL_CFLAGS) -I. -I$(QT_INCLUDE_DIR) -I$(QT_INCLUDE_DIR)/QtCore
+	$(QT_MOC) examples/example-qt.h -I. -I$(QT_INCLUDE_DIR) -I$(QT_INCLUDE_DIR)/QtCore | \
+	    $(CXX) -x c++ -o qt-example-moc.o -c - $(REAL_CFLAGS) -I. -I$(QT_INCLUDE_DIR) -I$(QT_INCLUDE_DIR)/QtCore
+	$(CXX) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. -I$(QT_INCLUDE_DIR) -I$(QT_INCLUDE_DIR)/QtCore -L$(QT_LIBRARY_DIR) qt-adapter-moc.o qt-example-moc.o $< -pthread $(STLIBNAME) -lQtCore
 endif
 
 hiredis-example: examples/example.c $(STLIBNAME)
 	$(CC) -o examples/$@ $(REAL_CFLAGS) $(REAL_LDFLAGS) -I. $< $(STLIBNAME)
 
 examples: $(EXAMPLES)
 
 hiredis-test: test.o $(STLIBNAME)
-	$(CC) -o $@ $(REAL_LDFLAGS) $< $(STLIBNAME)
+
+hiredis-%: %.o $(STLIBNAME)
+	$(CC) $(REAL_CFLAGS) -o $@ $(REAL_LDFLAGS) $< $(STLIBNAME)
 
 test: hiredis-test
 	./hiredis-test
 
 check: hiredis-test
 	@echo "$$REDIS_TEST_CONFIG" | $(REDIS_SERVER) -
-	./hiredis-test -h 127.0.0.1 -p $(REDIS_PORT) -s /tmp/hiredis-test-redis.sock || \
+	$(PRE) ./hiredis-test -h 127.0.0.1 -p $(REDIS_PORT) -s /tmp/hiredis-test-redis.sock || \
 			( kill `cat /tmp/hiredis-test-redis.pid` && false )
 	kill `cat /tmp/hiredis-test-redis.pid`
 
 .c.o:
 	$(CC) -std=c99 -pedantic -c $(REAL_CFLAGS) $<
 
 clean:
-	rm -rf $(DYLIBNAME) $(STLIBNAME) $(TESTS) examples/hiredis-example* *.o *.gcda *.gcno *.gcov
+	rm -rf $(DYLIBNAME) $(STLIBNAME) $(TESTS) $(PKGCONFNAME) examples/hiredis-example* *.o *.gcda *.gcno *.gcov
 
 dep:
 	$(CC) -MM *.c
 
-# Installation related variables and target
-PREFIX?=/usr/local
-INSTALL_INCLUDE_PATH= $(PREFIX)/include/hiredis
-INSTALL_LIBRARY_PATH= $(PREFIX)/lib
-
 ifeq ($(uname_S),SunOS)
   INSTALL?= cp -r
 endif
 
 INSTALL?= cp -a
 
-install: $(DYLIBNAME) $(STLIBNAME)
+$(PKGCONFNAME): hiredis.h
+	@echo "Generating $@ for pkgconfig..."
+	@echo prefix=$(PREFIX) > $@
+	@echo exec_prefix=\$${prefix} >> $@
+	@echo libdir=$(PREFIX)/$(LIBRARY_PATH) >> $@
+	@echo includedir=$(PREFIX)/$(INCLUDE_PATH) >> $@
+	@echo >> $@
+	@echo Name: hiredis >> $@
+	@echo Description: Minimalistic C client library for Redis. >> $@
+	@echo Version: $(HIREDIS_MAJOR).$(HIREDIS_MINOR).$(HIREDIS_PATCH) >> $@
+	@echo Libs: -L\$${libdir} -lhiredis >> $@
+	@echo Cflags: -I\$${includedir} -D_FILE_OFFSET_BITS=64 >> $@
+
+install: $(DYLIBNAME) $(STLIBNAME) $(PKGCONFNAME)
 	mkdir -p $(INSTALL_INCLUDE_PATH) $(INSTALL_LIBRARY_PATH)
-	$(INSTALL) hiredis.h async.h adapters $(INSTALL_INCLUDE_PATH)
+	$(INSTALL) hiredis.h async.h read.h sds.h adapters $(INSTALL_INCLUDE_PATH)
 	$(INSTALL) $(DYLIBNAME) $(INSTALL_LIBRARY_PATH)/$(DYLIB_MINOR_NAME)
-	cd $(INSTALL_LIBRARY_PATH) && ln -sf $(DYLIB_MINOR_NAME) $(DYLIB_MAJOR_NAME)
-	cd $(INSTALL_LIBRARY_PATH) && ln -sf $(DYLIB_MAJOR_NAME) $(DYLIBNAME)
+	cd $(INSTALL_LIBRARY_PATH) && ln -sf $(DYLIB_MINOR_NAME) $(DYLIBNAME)
 	$(INSTALL) $(STLIBNAME) $(INSTALL_LIBRARY_PATH)
+	mkdir -p $(INSTALL_PKGCONF_PATH)
+	$(INSTALL) $(PKGCONFNAME) $(INSTALL_PKGCONF_PATH)
 
 32bit:
 	@echo ""
 	@echo "WARNING: if this fails under Linux you probably need to install libc6-dev-i386"
 	@echo ""
 	$(MAKE) CFLAGS="-m32" LDFLAGS="-m32"
 
+32bit-vars:
+	$(eval CFLAGS=-m32)
+	$(eval LDFLAGS=-m32)
+
 gprof:
 	$(MAKE) CFLAGS="-pg" LDFLAGS="-pg"
 
 gcov:
 	$(MAKE) CFLAGS="-fprofile-arcs -ftest-coverage" LDFLAGS="-fprofile-arcs"
 
@@ -160,7 +211,7 @@
 	lcov -d . -c -o tmp/lcov/hiredis.info
 	genhtml --legend -o tmp/lcov/report tmp/lcov/hiredis.info
 
 noopt:
 	$(MAKE) OPTIMIZATION=""
 
-.PHONY: all test check clean dep install 32bit gprof gcov noopt
+.PHONY: all test check clean dep install 32bit 32bit-vars gprof gcov noopt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.c	2017-07-14 19:28:42.000000000 +0800
@@ -1,10 +1,12 @@
 /* Extracted from anet.c to work properly with Hiredis error reporting.
  *
- * Copyright (c) 2006-2011, Salvatore Sanfilippo <antirez at gmail dot com>
- * Copyright (c) 2010-2011, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2010-2014, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2015, Matt Stancliff <matt at genges dot com>,
+ *                     Jan-Erik Rediger <janerik at fnordig dot com>
  *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
@@ -44,12 +46,13 @@
 #include <netdb.h>
 #include <errno.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <poll.h>
 #include <limits.h>
+#include <stdlib.h>
 
 #include "net.h"
 #include "sds.h"
 
 /* Defined in hiredis.c */
 void __redisSetError(redisContext *c, int type, const char *str);
@@ -64,13 +67,13 @@
 static void __redisSetErrorFromErrno(redisContext *c, int type, const char *prefix) {
     char buf[128] = { 0 };
     size_t len = 0;
 
     if (prefix != NULL)
         len = snprintf(buf,sizeof(buf),"%s: ",prefix);
-    strerror_r(errno,buf+len,sizeof(buf)-len);
+    __redis_strerror_r(errno, (char *)(buf + len), sizeof(buf) - len);
     __redisSetError(c,type,buf);
 }
 
 static int redisSetReuseAddr(redisContext *c) {
     int on = 1;
     if (setsockopt(c->fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
@@ -135,13 +138,13 @@
 #ifdef _OSX
     if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &val, sizeof(val)) < 0) {
         __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));
         return REDIS_ERR;
     }
 #else
-#ifndef __sun
+#if defined(__GLIBC__) && !defined(__FreeBSD_kernel__)
     val = interval;
     if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {
         __redisSetError(c,REDIS_ERR_OTHER,strerror(errno));
         return REDIS_ERR;
     }
 
@@ -172,35 +175,41 @@
     }
     return REDIS_OK;
 }
 
 #define __MAX_MSEC (((LONG_MAX) - 999) / 1000)
 
-static int redisContextWaitReady(redisContext *c, const struct timeval *timeout) {
-    struct pollfd   wfd[1];
-    long msec;
-
-    msec          = -1;
-    wfd[0].fd     = c->fd;
-    wfd[0].events = POLLOUT;
+static int redisContextTimeoutMsec(redisContext *c, long *result)
+{
+    const struct timeval *timeout = c->timeout;
+    long msec = -1;
 
     /* Only use timeout when not NULL. */
     if (timeout != NULL) {
         if (timeout->tv_usec > 1000000 || timeout->tv_sec > __MAX_MSEC) {
-            __redisSetErrorFromErrno(c, REDIS_ERR_IO, NULL);
-            redisContextCloseFd(c);
+            *result = msec;
             return REDIS_ERR;
         }
 
         msec = (timeout->tv_sec * 1000) + ((timeout->tv_usec + 999) / 1000);
 
         if (msec < 0 || msec > INT_MAX) {
             msec = INT_MAX;
         }
     }
 
+    *result = msec;
+    return REDIS_OK;
+}
+
+static int redisContextWaitReady(redisContext *c, long msec) {
+    struct pollfd   wfd[1];
+
+    wfd[0].fd     = c->fd;
+    wfd[0].events = POLLOUT;
+
     if (errno == EINPROGRESS) {
         int res;
 
         if ((res = poll(wfd, 1, msec)) == -1) {
             __redisSetErrorFromErrno(c, REDIS_ERR_IO, "poll(2)");
             redisContextCloseFd(c);
@@ -253,50 +262,107 @@
     return REDIS_OK;
 }
 
 static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
                                    const struct timeval *timeout,
                                    const char *source_addr) {
-    int s, rv;
+    int s, rv, n;
     char _port[6];  /* strlen("65535"); */
     struct addrinfo hints, *servinfo, *bservinfo, *p, *b;
     int blocking = (c->flags & REDIS_BLOCK);
+    int reuseaddr = (c->flags & REDIS_REUSEADDR);
+    int reuses = 0;
+    long timeout_msec = -1;
+
+    servinfo = NULL;
+    c->connection_type = REDIS_CONN_TCP;
+    c->tcp.port = port;
+
+    /* We need to take possession of the passed parameters
+     * to make them reusable for a reconnect.
+     * We also carefully check we don't free data we already own,
+     * as in the case of the reconnect method.
+     *
+     * This is a bit ugly, but atleast it works and doesn't leak memory.
+     **/
+    if (c->tcp.host != addr) {
+        if (c->tcp.host)
+            free(c->tcp.host);
+
+        c->tcp.host = strdup(addr);
+    }
+
+    if (timeout) {
+        if (c->timeout != timeout) {
+            if (c->timeout == NULL)
+                c->timeout = malloc(sizeof(struct timeval));
+
+            memcpy(c->timeout, timeout, sizeof(struct timeval));
+        }
+    } else {
+        if (c->timeout)
+            free(c->timeout);
+        c->timeout = NULL;
+    }
+
+    if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) {
+        __redisSetError(c, REDIS_ERR_IO, "Invalid timeout specified");
+        goto error;
+    }
+
+    if (source_addr == NULL) {
+        free(c->tcp.source_addr);
+        c->tcp.source_addr = NULL;
+    } else if (c->tcp.source_addr != source_addr) {
+        free(c->tcp.source_addr);
+        c->tcp.source_addr = strdup(source_addr);
+    }
 
     snprintf(_port, 6, "%d", port);
     memset(&hints,0,sizeof(hints));
     hints.ai_family = AF_INET;
     hints.ai_socktype = SOCK_STREAM;
 
     /* Try with IPv6 if no IPv4 address was found. We do it in this order since
      * in a Redis client you can't afford to test if you have IPv6 connectivity
      * as this would add latency to every connect. Otherwise a more sensible
      * route could be: Use IPv6 if both addresses are available and there is IPv6
      * connectivity. */
-    if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {
+    if ((rv = getaddrinfo(c->tcp.host,_port,&hints,&servinfo)) != 0) {
          hints.ai_family = AF_INET6;
          if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {
             __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));
             return REDIS_ERR;
         }
     }
     for (p = servinfo; p != NULL; p = p->ai_next) {
+addrretry:
         if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
             continue;
 
         c->fd = s;
         if (redisSetBlocking(c,0) != REDIS_OK)
             goto error;
-        if (source_addr) {
+        if (c->tcp.source_addr) {
             int bound = 0;
             /* Using getaddrinfo saves us from self-determining IPv4 vs IPv6 */
-            if ((rv = getaddrinfo(source_addr, NULL, &hints, &bservinfo)) != 0) {
+            if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {
                 char buf[128];
                 snprintf(buf,sizeof(buf),"Can't get addr: %s",gai_strerror(rv));
                 __redisSetError(c,REDIS_ERR_OTHER,buf);
                 goto error;
             }
+
+            if (reuseaddr) {
+                n = 1;
+                if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*) &n,
+                               sizeof(n)) < 0) {
+                    goto error;
+                }
+            }
+
             for (b = bservinfo; b != NULL; b = b->ai_next) {
                 if (bind(s,b->ai_addr,b->ai_addrlen) != -1) {
                     bound = 1;
                     break;
                 }
             }
@@ -311,14 +377,21 @@
         if (connect(s,p->ai_addr,p->ai_addrlen) == -1) {
             if (errno == EHOSTUNREACH) {
                 redisContextCloseFd(c);
                 continue;
             } else if (errno == EINPROGRESS && !blocking) {
                 /* This is ok. */
+            } else if (errno == EADDRNOTAVAIL && reuseaddr) {
+                if (++reuses >= REDIS_CONNECT_RETRIES) {
+                    goto error;
+                } else {
+                    redisContextCloseFd(c);
+                    goto addrretry;
+                }
             } else {
-                if (redisContextWaitReady(c,timeout) != REDIS_OK)
+                if (redisContextWaitReady(c,timeout_msec) != REDIS_OK)
                     goto error;
             }
         }
         if (blocking && redisSetBlocking(c,1) != REDIS_OK)
             goto error;
         if (redisSetTcpNoDelay(c) != REDIS_OK)
@@ -353,25 +426,46 @@
     return _redisContextConnectTcp(c, addr, port, timeout, source_addr);
 }
 
 int redisContextConnectUnix(redisContext *c, const char *path, const struct timeval *timeout) {
     int blocking = (c->flags & REDIS_BLOCK);
     struct sockaddr_un sa;
+    long timeout_msec = -1;
 
     if (redisCreateSocket(c,AF_LOCAL) < 0)
         return REDIS_ERR;
     if (redisSetBlocking(c,0) != REDIS_OK)
         return REDIS_ERR;
 
+    c->connection_type = REDIS_CONN_UNIX;
+    if (c->unix_sock.path != path)
+        c->unix_sock.path = strdup(path);
+
+    if (timeout) {
+        if (c->timeout != timeout) {
+            if (c->timeout == NULL)
+                c->timeout = malloc(sizeof(struct timeval));
+
+            memcpy(c->timeout, timeout, sizeof(struct timeval));
+        }
+    } else {
+        if (c->timeout)
+            free(c->timeout);
+        c->timeout = NULL;
+    }
+
+    if (redisContextTimeoutMsec(c,&timeout_msec) != REDIS_OK)
+        return REDIS_ERR;
+
     sa.sun_family = AF_LOCAL;
     strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);
     if (connect(c->fd, (struct sockaddr*)&sa, sizeof(sa)) == -1) {
         if (errno == EINPROGRESS && !blocking) {
             /* This is ok. */
         } else {
-            if (redisContextWaitReady(c,timeout) != REDIS_OK)
+            if (redisContextWaitReady(c,timeout_msec) != REDIS_OK)
                 return REDIS_ERR;
         }
     }
 
     /* Reset socket to be blocking after connect(2). */
     if (blocking && redisSetBlocking(c,1) != REDIS_OK)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.h	2017-07-14 19:28:42.000000000 +0800
@@ -1,10 +1,12 @@
 /* Extracted from anet.c to work properly with Hiredis error reporting.
  *
- * Copyright (c) 2006-2011, Salvatore Sanfilippo <antirez at gmail dot com>
- * Copyright (c) 2010-2011, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2009-2011, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2010-2014, Pieter Noordhuis <pcnoordhuis at gmail dot com>
+ * Copyright (c) 2015, Matt Stancliff <matt at genges dot com>,
+ *                     Jan-Erik Rediger <janerik at fnordig dot com>
  *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
@@ -32,13 +34,13 @@
 
 #ifndef __NET_H
 #define __NET_H
 
 #include "hiredis.h"
 
-#if defined(__sun) || defined(_AIX)
+#if defined(__sun)
 #define AF_LOCAL AF_UNIX
 #endif
 
 int redisCheckSocketError(redisContext *c);
 int redisContextSetTimeout(redisContext *c, const struct timeval tv);
 int redisContextConnectTcp(redisContext *c, const char *addr, int port, const struct timeval *timeout);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis: read.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis: read.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis: read.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/README.md /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/README.md
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/README.md	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/README.md	2017-07-14 19:28:42.000000000 +0800
@@ -1,14 +1,16 @@
 [![Build Status](https://travis-ci.org/redis/hiredis.png)](https://travis-ci.org/redis/hiredis)
 
+**This Readme reflects the latest changed in the master branch. See [v0.13.3](https://github.com/redis/hiredis/tree/v0.13.3) for the Readme and documentation for the latest release.**
+
 # HIREDIS
 
 Hiredis is a minimalistic C client library for the [Redis](http://redis.io/) database.
 
 It is minimalistic because it just adds minimal support for the protocol, but
-at the same time it uses an high level printf-alike API in order to make it
+at the same time it uses a high level printf-alike API in order to make it
 much higher level than otherwise suggested by its minimal code base and the
 lack of explicit bindings for every Redis command.
 
 Apart from supporting sending commands and receiving replies, it comes with
 a reply parser that is decoupled from the I/O layer. It
 is a stream parser designed for easy reusability, which can for instance be used
@@ -17,68 +19,87 @@
 Hiredis only supports the binary-safe Redis protocol, so you can use it with any
 Redis version >= 1.2.0.
 
 The library comes with multiple APIs. There is the
 *synchronous API*, the *asynchronous API* and the *reply parsing API*.
 
-## UPGRADING
+## Upgrading to `1.0.0`
+
+Version 1.0.0 marks a stable release of hiredis.
+It includes some minor breaking changes, mostly to make the exposed API more uniform and self-explanatory.
+It also bundles the updated `sds` library, to sync up with upstream and Redis.
+For most applications a recompile against the new hiredis should be enough.
+For code changes see the [Changelog](CHANGELOG.md).
+
+## Upgrading from `<0.9.0`
 
 Version 0.9.0 is a major overhaul of hiredis in every aspect. However, upgrading existing
 code using hiredis should not be a big pain. The key thing to keep in mind when
 upgrading is that hiredis >= 0.9.0 uses a `redisContext*` to keep state, in contrast to
 the stateless 0.0.1 that only has a file descriptor to work with.
 
 ## Synchronous API
 
 To consume the synchronous API, there are only a few function calls that need to be introduced:
 
-    redisContext *redisConnect(const char *ip, int port);
-    void *redisCommand(redisContext *c, const char *format, ...);
-    void freeReplyObject(void *reply);
+```c
+redisContext *redisConnect(const char *ip, int port);
+void *redisCommand(redisContext *c, const char *format, ...);
+void freeReplyObject(void *reply);
+```
 
 ### Connecting
 
 The function `redisConnect` is used to create a so-called `redisContext`. The
 context is where Hiredis holds state for a connection. The `redisContext`
-struct has an integer `err` field that is non-zero when an the connection is in
+struct has an integer `err` field that is non-zero when the connection is in
 an error state. The field `errstr` will contain a string with a description of
 the error. More information on errors can be found in the **Errors** section.
 After trying to connect to Redis using `redisConnect` you should
 check the `err` field to see if establishing the connection was successful:
-
-    redisContext *c = redisConnect("127.0.0.1", 6379);
-    if (c != NULL && c->err) {
+```c
+redisContext *c = redisConnect("127.0.0.1", 6379);
+if (c == NULL || c->err) {
+    if (c) {
         printf("Error: %s\n", c->errstr);
         // handle error
+    } else {
+        printf("Can't allocate redis context\n");
     }
+}
+```
+
+*Note: A `redisContext` is not thread-safe.*
 
 ### Sending commands
 
 There are several ways to issue commands to Redis. The first that will be introduced is
 `redisCommand`. This function takes a format similar to printf. In the simplest form,
 it is used like this:
-
-    reply = redisCommand(context, "SET foo bar");
+```c
+reply = redisCommand(context, "SET foo bar");
+```
 
 The specifier `%s` interpolates a string in the command, and uses `strlen` to
 determine the length of the string:
-
-    reply = redisCommand(context, "SET foo %s", value);
-
+```c
+reply = redisCommand(context, "SET foo %s", value);
+```
 When you need to pass binary safe strings in a command, the `%b` specifier can be
 used. Together with a pointer to the string, it requires a `size_t` length argument
 of the string:
-
-    reply = redisCommand(context, "SET foo %b", value, (size_t) valuelen);
-
+```c
+reply = redisCommand(context, "SET foo %b", value, (size_t) valuelen);
+```
 Internally, Hiredis splits the command in different arguments and will
 convert it to the protocol used to communicate with Redis.
 One or more spaces separates arguments, so you can use the specifiers
 anywhere in an argument:
-
-    reply = redisCommand(context, "SET key:%s %s", myid, value);
+```c
+reply = redisCommand(context, "SET key:%s %s", myid, value);
+```
 
 ### Using replies
 
 The return value of `redisCommand` holds a reply when the command was
 successfully executed. When an error occurs, the return value is `NULL` and
 the `err` field in the context will be set (see section on **Errors**).
@@ -111,38 +132,38 @@
     * A multi bulk reply. The number of elements in the multi bulk reply is stored in
       `reply->elements`. Every element in the multi bulk reply is a `redisReply` object as well
       and can be accessed via `reply->element[..index..]`.
       Redis may reply with nested arrays but this is fully supported.
 
 Replies should be freed using the `freeReplyObject()` function.
-Note that this function will take care of freeing sub-replies objects
+Note that this function will take care of freeing sub-reply objects
 contained in arrays and nested arrays, so there is no need for the user to
 free the sub replies (it is actually harmful and will corrupt the memory).
 
-**Important:** the current version of hiredis (0.10.0) free's replies when the
+**Important:** the current version of hiredis (0.10.0) frees replies when the
 asynchronous API is used. This means you should not call `freeReplyObject` when
 you use this API. The reply is cleaned up by hiredis _after_ the callback
 returns. This behavior will probably change in future releases, so make sure to
 keep an eye on the changelog when upgrading (see issue #39).
 
 ### Cleaning up
 
 To disconnect and free the context the following function can be used:
-
-    void redisFree(redisContext *c);
-
-This function immediately closes the socket and then free's the allocations done in
+```c
+void redisFree(redisContext *c);
+```
+This function immediately closes the socket and then frees the allocations done in
 creating the context.
 
 ### Sending commands (cont'd)
 
 Together with `redisCommand`, the function `redisCommandArgv` can be used to issue commands.
 It has the following prototype:
-
-    void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
-
+```c
+void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
+```
 It takes the number of arguments `argc`, an array of strings `argv` and the lengths of the
 arguments `argvlen`. For convenience, `argvlen` may be set to `NULL` and the function will
 use `strlen(3)` on every argument to determine its length. Obviously, when any of the arguments
 need to be binary safe, the entire array of lengths `argvlen` should be provided.
 
 The return value has the same semantic as `redisCommand`.
@@ -166,41 +187,41 @@
     * Read from the socket until a single reply could be parsed
 
 The function `redisGetReply` is exported as part of the Hiredis API and can be used when a reply
 is expected on the socket. To pipeline commands, the only things that needs to be done is
 filling up the output buffer. For this cause, two commands can be used that are identical
 to the `redisCommand` family, apart from not returning a reply:
-
-    void redisAppendCommand(redisContext *c, const char *format, ...);
-    void redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
-
+```c
+void redisAppendCommand(redisContext *c, const char *format, ...);
+void redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);
+```
 After calling either function one or more times, `redisGetReply` can be used to receive the
 subsequent replies. The return value for this function is either `REDIS_OK` or `REDIS_ERR`, where
 the latter means an error occurred while reading a reply. Just as with the other commands,
 the `err` field in the context can be used to find out what the cause of this error is.
 
 The following examples shows a simple pipeline (resulting in only a single call to `write(2)` and
 a single call to `read(2)`):
-
-    redisReply *reply;
-    redisAppendCommand(context,"SET foo bar");
-    redisAppendCommand(context,"GET foo");
-    redisGetReply(context,&reply); // reply for SET
-    freeReplyObject(reply);
-    redisGetReply(context,&reply); // reply for GET
-    freeReplyObject(reply);
-
+```c
+redisReply *reply;
+redisAppendCommand(context,"SET foo bar");
+redisAppendCommand(context,"GET foo");
+redisGetReply(context,&reply); // reply for SET
+freeReplyObject(reply);
+redisGetReply(context,&reply); // reply for GET
+freeReplyObject(reply);
+```
 This API can also be used to implement a blocking subscriber:
-
-    reply = redisCommand(context,"SUBSCRIBE foo");
+```c
+reply = redisCommand(context,"SUBSCRIBE foo");
+freeReplyObject(reply);
+while(redisGetReply(context,&reply) == REDIS_OK) {
+    // consume message
     freeReplyObject(reply);
-    while(redisGetReply(context,&reply) == REDIS_OK) {
-        // consume message
-        freeReplyObject(reply);
-    }
-
+}
+```
 ### Errors
 
 When a function call is not successful, depending on the function either `NULL` or `REDIS_ERR` is
 returned. The `err` field inside the context will be non-zero and set to one of the
 following constants:
 
@@ -234,97 +255,101 @@
 The function `redisAsyncConnect` can be used to establish a non-blocking connection to
 Redis. It returns a pointer to the newly created `redisAsyncContext` struct. The `err` field
 should be checked after creation to see if there were errors creating the connection.
 Because the connection that will be created is non-blocking, the kernel is not able to
 instantly return if the specified host and port is able to accept a connection.
 
-    redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
-    if (c->err) {
-        printf("Error: %s\n", c->errstr);
-        // handle error
-    }
+*Note: A `redisAsyncContext` is not thread-safe.*
+
+```c
+redisAsyncContext *c = redisAsyncConnect("127.0.0.1", 6379);
+if (c->err) {
+    printf("Error: %s\n", c->errstr);
+    // handle error
+}
+```
 
 The asynchronous context can hold a disconnect callback function that is called when the
 connection is disconnected (either because of an error or per user request). This function should
 have the following prototype:
-
-    void(const redisAsyncContext *c, int status);
-
+```c
+void(const redisAsyncContext *c, int status);
+```
 On a disconnect, the `status` argument is set to `REDIS_OK` when disconnection was initiated by the
 user, or `REDIS_ERR` when the disconnection was caused by an error. When it is `REDIS_ERR`, the `err`
 field in the context can be accessed to find out the cause of the error.
 
-The context object is always free'd after the disconnect callback fired. When a reconnect is needed,
+The context object is always freed after the disconnect callback fired. When a reconnect is needed,
 the disconnect callback is a good point to do so.
 
 Setting the disconnect callback can only be done once per context. For subsequent calls it will
 return `REDIS_ERR`. The function to set the disconnect callback has the following prototype:
-
-    int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn);
-
+```c
+int redisAsyncSetDisconnectCallback(redisAsyncContext *ac, redisDisconnectCallback *fn);
+```
 ### Sending commands and their callbacks
 
 In an asynchronous context, commands are automatically pipelined due to the nature of an event loop.
 Therefore, unlike the synchronous API, there is only a single way to send commands.
 Because commands are sent to Redis asynchronously, issuing a command requires a callback function
 that is called when the reply is received. Reply callbacks should have the following prototype:
-
-    void(redisAsyncContext *c, void *reply, void *privdata);
-
+```c
+void(redisAsyncContext *c, void *reply, void *privdata);
+```
 The `privdata` argument can be used to curry arbitrary data to the callback from the point where
 the command is initially queued for execution.
 
 The functions that can be used to issue commands in an asynchronous context are:
-
-    int redisAsyncCommand(
-      redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,
-      const char *format, ...);
-    int redisAsyncCommandArgv(
-      redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,
-      int argc, const char **argv, const size_t *argvlen);
-
+```c
+int redisAsyncCommand(
+  redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,
+  const char *format, ...);
+int redisAsyncCommandArgv(
+  redisAsyncContext *ac, redisCallbackFn *fn, void *privdata,
+  int argc, const char **argv, const size_t *argvlen);
+```
 Both functions work like their blocking counterparts. The return value is `REDIS_OK` when the command
 was successfully added to the output buffer and `REDIS_ERR` otherwise. Example: when the connection
 is being disconnected per user-request, no new commands may be added to the output buffer and `REDIS_ERR` is
 returned on calls to the `redisAsyncCommand` family.
 
-If the reply for a command with a `NULL` callback is read, it is immediately free'd. When the callback
-for a command is non-`NULL`, the memory is free'd immediately following the callback: the reply is only
+If the reply for a command with a `NULL` callback is read, it is immediately freed. When the callback
+for a command is non-`NULL`, the memory is freed immediately following the callback: the reply is only
 valid for the duration of the callback.
 
 All pending callbacks are called with a `NULL` reply when the context encountered an error.
 
 ### Disconnecting
 
 An asynchronous connection can be terminated using:
-
-    void redisAsyncDisconnect(redisAsyncContext *ac);
-
+```c
+void redisAsyncDisconnect(redisAsyncContext *ac);
+```
 When this function is called, the connection is **not** immediately terminated. Instead, new
 commands are no longer accepted and the connection is only terminated when all pending commands
 have been written to the socket, their respective replies have been read and their respective
 callbacks have been executed. After this, the disconnection callback is executed with the
-`REDIS_OK` status and the context object is free'd.
+`REDIS_OK` status and the context object is freed.
 
 ### Hooking it up to event library *X*
 
 There are a few hooks that need to be set on the context object after it is created.
 See the `adapters/` directory for bindings to *libev* and *libevent*.
 
 ## Reply parsing API
 
 Hiredis comes with a reply parsing API that makes it easy for writing higher
 level language bindings.
 
 The reply parsing API consists of the following functions:
-
-    redisReader *redisReaderCreate(void);
-    void redisReaderFree(redisReader *reader);
-    int redisReaderFeed(redisReader *reader, const char *buf, size_t len);
-    int redisReaderGetReply(redisReader *reader, void **reply);
-
+```c
+redisReader *redisReaderCreate(void);
+void redisReaderFree(redisReader *reader);
+int redisReaderFeed(redisReader *reader, const char *buf, size_t len);
+int redisReaderGetReply(redisReader *reader, void **reply);
+```
 The same set of functions are used internally by hiredis when creating a
 normal Redis context, the above API just exposes it to the user for a direct
 usage.
 
 ### Usage
 
@@ -358,27 +383,29 @@
 ### Reader max buffer
 
 Both when using the Reader API directly or when using it indirectly via a
 normal Redis context, the redisReader structure uses a buffer in order to
 accumulate data from the server.
 Usually this buffer is destroyed when it is empty and is larger than 16
-kb in order to avoid wasting memory in unused buffers
+KiB in order to avoid wasting memory in unused buffers
 
 However when working with very big payloads destroying the buffer may slow
 down performances considerably, so it is possible to modify the max size of
 an idle buffer changing the value of the `maxbuf` field of the reader structure
 to the desired value. The special value of 0 means that there is no maximum
 value for an idle buffer, so the buffer will never get freed.
 
 For instance if you have a normal Redis context you can set the maximum idle
 buffer to zero (unlimited) just with:
-
-    context->reader->maxbuf = 0;
-
+```c
+context->reader->maxbuf = 0;
+```
 This should be done only in order to maximize performances when working with
 large payloads. The context should be set back to `REDIS_READER_MAX_BUF` again
 as soon as possible in order to prevent allocation of useless memory.
 
 ## AUTHORS
 
 Hiredis was written by Salvatore Sanfilippo (antirez at gmail) and
-Pieter Noordhuis (pcnoordhuis at gmail) and is released under the BSD license.
+Pieter Noordhuis (pcnoordhuis at gmail) and is released under the BSD license.  
+Hiredis is currently maintained by Matt Stancliff (matt at genges dot com) and
+Jan-Erik Rediger (janerik at fnordig dot com)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis: read.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sdsalloc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sdsalloc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sdsalloc.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sdsalloc.h	2017-07-14 19:28:42.000000000 +0800
@@ -1,9 +1,10 @@
 /* SDSLib 2.0 -- A C dynamic strings library
  *
  * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2015, Oran Agra
  * Copyright (c) 2015, Redis Labs, Inc
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
@@ -33,10 +34,9 @@
  *
  * This file is used in order to change the SDS allocator at compile time.
  * Just define the following defines to what you want to use. Also add
  * the include of your alternate allocator if needed (not needed in order
  * to use the default libc allocator). */
 
-#include "zmalloc.h"
-#define s_malloc zmalloc
-#define s_realloc zrealloc
-#define s_free zfree
+#define s_malloc malloc
+#define s_realloc realloc
+#define s_free free
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.c	2017-07-14 19:28:42.000000000 +0800
@@ -86,15 +86,15 @@
      * since type 5 is not good at this. */
     if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
     int hdrlen = sdsHdrSize(type);
     unsigned char *fp; /* flags pointer. */
 
     sh = s_malloc(hdrlen+initlen+1);
+    if (sh == NULL) return NULL;
     if (!init)
         memset(sh, 0, hdrlen+initlen+1);
-    if (sh == NULL) return NULL;
     s = (char*)sh+hdrlen;
     fp = ((unsigned char*)s)-1;
     switch(type) {
         case SDS_TYPE_5: {
             *fp = type | (initlen << SDS_TYPE_BITS);
             break;
@@ -574,20 +574,18 @@
  * %I - 64 bit signed integer (long long, int64_t)
  * %u - unsigned int
  * %U - 64 bit unsigned integer (unsigned long long, uint64_t)
  * %% - Verbatim "%" character.
  */
 sds sdscatfmt(sds s, char const *fmt, ...) {
-    size_t initlen = sdslen(s);
     const char *f = fmt;
     int i;
     va_list ap;
 
     va_start(ap,fmt);
-    f = fmt;    /* Next format specifier byte to process. */
-    i = initlen; /* Position of the next byte to write to dest str. */
+    i = sdslen(s); /* Position of the next byte to write to dest str. */
     while(*f) {
         char next, *str;
         size_t l;
         long long num;
         unsigned long long unum;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.h	2017-07-14 19:28:42.000000000 +0800
@@ -76,13 +76,13 @@
 #define SDS_TYPE_8  1
 #define SDS_TYPE_16 2
 #define SDS_TYPE_32 3
 #define SDS_TYPE_64 4
 #define SDS_TYPE_MASK 7
 #define SDS_TYPE_BITS 3
-#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));
+#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)));
 #define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))
 #define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)
 
 static inline size_t sdslen(const sds s) {
     unsigned char flags = s[-1];
     switch(flags&SDS_TYPE_MASK) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/test.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/test.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/test.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/test.c	2017-07-14 19:28:42.000000000 +0800
@@ -8,12 +8,13 @@
 #include <unistd.h>
 #include <signal.h>
 #include <errno.h>
 #include <limits.h>
 
 #include "hiredis.h"
+#include "net.h"
 
 enum connection_type {
     CONN_TCP,
     CONN_UNIX,
     CONN_FD
 };
@@ -26,13 +27,13 @@
         int port;
         struct timeval timeout;
     } tcp;
 
     struct {
         const char *path;
-    } unix;
+    } unix_sock;
 };
 
 /* The following lines make up our testing "framework" :) */
 static int tests = 0, fails = 0;
 #define test(_s) { printf("#%02d ", ++tests); printf(_s); }
 #define test_cond(_c) if(_c) printf("\033[0;32mPASSED\033[0;0m\n"); else {printf("\033[0;31mFAILED\033[0;0m\n"); fails++;}
@@ -40,21 +41,28 @@
 static long long usec(void) {
     struct timeval tv;
     gettimeofday(&tv,NULL);
     return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
 }
 
+/* The assert() calls below have side effects, so we need assert()
+ * even if we are compiling without asserts (-DNDEBUG). */
+#ifdef NDEBUG
+#undef assert
+#define assert(e) (void)(e)
+#endif
+
 static redisContext *select_database(redisContext *c) {
     redisReply *reply;
 
     /* Switch to DB 9 for testing, now that we know we can chat. */
     reply = redisCommand(c,"SELECT 9");
     assert(reply != NULL);
     freeReplyObject(reply);
 
-    /* Make sure the DB is empty */
+    /* Make sure the DB is emtpy */
     reply = redisCommand(c,"DBSIZE");
     assert(reply != NULL);
     if (reply->type == REDIS_REPLY_INTEGER && reply->integer == 0) {
         /* Awesome, DB 9 is empty and we can continue. */
         freeReplyObject(reply);
     } else {
@@ -86,16 +94,16 @@
 static redisContext *connect(struct config config) {
     redisContext *c = NULL;
 
     if (config.type == CONN_TCP) {
         c = redisConnect(config.tcp.host, config.tcp.port);
     } else if (config.type == CONN_UNIX) {
-        c = redisConnectUnix(config.unix.path);
+        c = redisConnectUnix(config.unix_sock.path);
     } else if (config.type == CONN_FD) {
         /* Create a dummy connection just to get an fd to inherit */
-        redisContext *dummy_ctx = redisConnectUnix(config.unix.path);
+        redisContext *dummy_ctx = redisConnectUnix(config.unix_sock.path);
         if (dummy_ctx) {
             int fd = disconnect(dummy_ctx, 1);
             printf("Connecting to inherited fd %d\n", fd);
             c = redisConnectFd(fd);
         }
     } else {
@@ -104,12 +112,13 @@
 
     if (c == NULL) {
         printf("Connection error: can't allocate redis context\n");
         exit(1);
     } else if (c->err) {
         printf("Connection error: %s\n", c->errstr);
+        redisFree(c);
         exit(1);
     }
 
     return select_database(c);
 }
 
@@ -212,12 +221,28 @@
 
     test("Format command by passing argc/argv with lengths: ");
     len = redisFormatCommandArgv(&cmd,argc,argv,lens);
     test_cond(strncmp(cmd,"*3\r\n$3\r\nSET\r\n$7\r\nfoo\0xxx\r\n$3\r\nbar\r\n",len) == 0 &&
         len == 4+4+(3+2)+4+(7+2)+4+(3+2));
     free(cmd);
+
+    sds sds_cmd;
+
+    sds_cmd = sdsempty();
+    test("Format command into sds by passing argc/argv without lengths: ");
+    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,NULL);
+    test_cond(strncmp(sds_cmd,"*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n",len) == 0 &&
+        len == 4+4+(3+2)+4+(3+2)+4+(3+2));
+    sdsfree(sds_cmd);
+
+    sds_cmd = sdsempty();
+    test("Format command into sds by passing argc/argv with lengths: ");
+    len = redisFormatSdsCommandArgv(&sds_cmd,argc,argv,lens);
+    test_cond(strncmp(sds_cmd,"*3\r\n$3\r\nSET\r\n$7\r\nfoo\0xxx\r\n$3\r\nbar\r\n",len) == 0 &&
+        len == 4+4+(3+2)+4+(7+2)+4+(3+2));
+    sdsfree(sds_cmd);
 }
 
 static void test_append_formatted_commands(struct config config) {
     redisContext *c;
     redisReply *reply;
     char *cmd;
@@ -315,32 +340,47 @@
         ((redisReply*)reply)->type == REDIS_REPLY_ARRAY &&
         ((redisReply*)reply)->elements == 0);
     freeReplyObject(reply);
     redisReaderFree(reader);
 }
 
+static void test_free_null(void) {
+    void *redisCtx = NULL;
+    void *reply = NULL;
+
+    test("Don't fail when redisFree is passed a NULL value: ");
+    redisFree(redisCtx);
+    test_cond(redisCtx == NULL);
+
+    test("Don't fail when freeReplyObject is passed a NULL value: ");
+    freeReplyObject(reply);
+    test_cond(reply == NULL);
+}
+
 static void test_blocking_connection_errors(void) {
     redisContext *c;
 
     test("Returns error when host cannot be resolved: ");
-    c = redisConnect((char*)"idontexist.local", 6379);
+    c = redisConnect((char*)"idontexist.test", 6379);
     test_cond(c->err == REDIS_ERR_OTHER &&
         (strcmp(c->errstr,"Name or service not known") == 0 ||
-         strcmp(c->errstr,"Can't resolve: idontexist.local") == 0 ||
+         strcmp(c->errstr,"Can't resolve: idontexist.test") == 0 ||
          strcmp(c->errstr,"nodename nor servname provided, or not known") == 0 ||
          strcmp(c->errstr,"No address associated with hostname") == 0 ||
+         strcmp(c->errstr,"Temporary failure in name resolution") == 0 ||
+         strcmp(c->errstr,"hostname nor servname provided, or not known") == 0 ||
          strcmp(c->errstr,"no address associated with name") == 0));
     redisFree(c);
 
     test("Returns error when the port is not open: ");
     c = redisConnect((char*)"localhost", 1);
     test_cond(c->err == REDIS_ERR_IO &&
         strcmp(c->errstr,"Connection refused") == 0);
     redisFree(c);
 
-    test("Returns error when the unix socket path doesn't accept connections: ");
+    test("Returns error when the unix_sock socket path doesn't accept connections: ");
     c = redisConnectUnix((char*)"/tmp/idontexist.sock");
     test_cond(c->err == REDIS_ERR_IO); /* Don't care about the message... */
     redisFree(c);
 }
 
 static void test_blocking_connection(struct config config) {
@@ -418,12 +458,58 @@
               strcasecmp(reply->element[1]->str,"pong") == 0);
     freeReplyObject(reply);
 
     disconnect(c, 0);
 }
 
+static void test_blocking_connection_timeouts(struct config config) {
+    redisContext *c;
+    redisReply *reply;
+    ssize_t s;
+    const char *cmd = "DEBUG SLEEP 3\r\n";
+    struct timeval tv;
+
+    c = connect(config);
+    test("Successfully completes a command when the timeout is not exceeded: ");
+    reply = redisCommand(c,"SET foo fast");
+    freeReplyObject(reply);
+    tv.tv_sec = 0;
+    tv.tv_usec = 10000;
+    redisSetTimeout(c, tv);
+    reply = redisCommand(c, "GET foo");
+    test_cond(reply != NULL && reply->type == REDIS_REPLY_STRING && memcmp(reply->str, "fast", 4) == 0);
+    freeReplyObject(reply);
+    disconnect(c, 0);
+
+    c = connect(config);
+    test("Does not return a reply when the command times out: ");
+    s = write(c->fd, cmd, strlen(cmd));
+    tv.tv_sec = 0;
+    tv.tv_usec = 10000;
+    redisSetTimeout(c, tv);
+    reply = redisCommand(c, "GET foo");
+    test_cond(s > 0 && reply == NULL && c->err == REDIS_ERR_IO && strcmp(c->errstr, "Resource temporarily unavailable") == 0);
+    freeReplyObject(reply);
+
+    test("Reconnect properly reconnects after a timeout: ");
+    redisReconnect(c);
+    reply = redisCommand(c, "PING");
+    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && strcmp(reply->str, "PONG") == 0);
+    freeReplyObject(reply);
+
+    test("Reconnect properly uses owned parameters: ");
+    config.tcp.host = "foo";
+    config.unix_sock.path = "foo";
+    redisReconnect(c);
+    reply = redisCommand(c, "PING");
+    test_cond(reply != NULL && reply->type == REDIS_REPLY_STATUS && strcmp(reply->str, "PONG") == 0);
+    freeReplyObject(reply);
+
+    disconnect(c, 0);
+}
+
 static void test_blocking_io_errors(struct config config) {
     redisContext *c;
     redisReply *reply;
     void *_reply;
     int major, minor;
 
@@ -441,13 +527,13 @@
         minor = strtol(p,&eptr,10);
         freeReplyObject(reply);
     }
 
     test("Returns I/O error when the connection is lost: ");
     reply = redisCommand(c,"QUIT");
-    if (major >= 2 && minor > 0) {
+    if (major > 2 || (major == 2 && minor > 0)) {
         /* > 2.0 returns OK on QUIT and read() should be issued once more
          * to know the descriptor is at EOF. */
         test_cond(strcasecmp(reply->str,"OK") == 0 &&
             redisGetReply(c,&_reply) == REDIS_ERR);
         freeReplyObject(reply);
     } else {
@@ -479,23 +565,23 @@
 
     config.tcp.timeout.tv_sec = 0;
     config.tcp.timeout.tv_usec = 10000001;
 
     c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);
 
-    test_cond(c->err == REDIS_ERR_IO);
+    test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, "Invalid timeout specified") == 0);
+    redisFree(c);
 
     test("Set error when an invalid timeout sec value is given to redisConnectWithTimeout: ");
 
     config.tcp.timeout.tv_sec = (((LONG_MAX) - 999) / 1000) + 1;
     config.tcp.timeout.tv_usec = 0;
 
     c = redisConnectWithTimeout(config.tcp.host, config.tcp.port, config.tcp.timeout);
 
-    test_cond(c->err == REDIS_ERR_IO);
-
+    test_cond(c->err == REDIS_ERR_IO && strcmp(c->errstr, "Invalid timeout specified") == 0);
     redisFree(c);
 }
 
 static void test_throughput(struct config config) {
     redisContext *c = connect(config);
     redisReply **replies;
@@ -663,13 +749,13 @@
 int main(int argc, char **argv) {
     struct config cfg = {
         .tcp = {
             .host = "127.0.0.1",
             .port = 6379
         },
-        .unix = {
+        .unix_sock = {
             .path = "/tmp/redis.sock"
         }
     };
     int throughput = 1;
     int test_inherit_fd = 1;
 
@@ -684,13 +770,13 @@
             cfg.tcp.host = argv[0];
         } else if (argc >= 2 && !strcmp(argv[0],"-p")) {
             argv++; argc--;
             cfg.tcp.port = atoi(argv[0]);
         } else if (argc >= 2 && !strcmp(argv[0],"-s")) {
             argv++; argc--;
-            cfg.unix.path = argv[0];
+            cfg.unix_sock.path = argv[0];
         } else if (argc >= 1 && !strcmp(argv[0],"--skip-throughput")) {
             throughput = 0;
         } else if (argc >= 1 && !strcmp(argv[0],"--skip-inherit-fd")) {
             test_inherit_fd = 0;
         } else {
             fprintf(stderr, "Invalid argument: %s\n", argv[0]);
@@ -699,33 +785,37 @@
         argv++; argc--;
     }
 
     test_format_commands();
     test_reply_reader();
     test_blocking_connection_errors();
+    test_free_null();
 
     printf("\nTesting against TCP connection (%s:%d):\n", cfg.tcp.host, cfg.tcp.port);
     cfg.type = CONN_TCP;
     test_blocking_connection(cfg);
+    test_blocking_connection_timeouts(cfg);
     test_blocking_io_errors(cfg);
     test_invalid_timeout_errors(cfg);
     test_append_formatted_commands(cfg);
     if (throughput) test_throughput(cfg);
 
-    printf("\nTesting against Unix socket connection (%s):\n", cfg.unix.path);
+    printf("\nTesting against Unix socket connection (%s):\n", cfg.unix_sock.path);
     cfg.type = CONN_UNIX;
     test_blocking_connection(cfg);
+    test_blocking_connection_timeouts(cfg);
     test_blocking_io_errors(cfg);
     if (throughput) test_throughput(cfg);
 
     if (test_inherit_fd) {
-        printf("\nTesting against inherited fd (%s):\n", cfg.unix.path);
+        printf("\nTesting against inherited fd (%s):\n", cfg.unix_sock.path);
         cfg.type = CONN_FD;
         test_blocking_connection(cfg);
     }
 
+
     if (fails) {
         printf("*** %d TESTS FAILED ***\n", fails);
         return 1;
     }
 
     printf("ALL TESTS PASSED\n");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/.travis.yml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/.travis.yml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/.travis.yml	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/.travis.yml	2017-07-14 19:28:42.000000000 +0800
@@ -1,6 +1,39 @@
 language: c
+sudo: false
 compiler:
   - gcc
   - clang
 
-script: make && make check
+os:
+  - linux
+  - osx
+
+before_script:
+    - if [ "$TRAVIS_OS_NAME" == "osx" ] ; then brew update; brew install redis; fi
+
+addons:
+  apt:
+    packages:
+    - libc6-dbg
+    - libc6-dev
+    - libc6:i386
+    - libc6-dev-i386
+    - libc6-dbg:i386
+    - gcc-multilib
+    - valgrind
+
+env:
+    - CFLAGS="-Werror"
+    - PRE="valgrind --track-origins=yes --leak-check=full"
+    - TARGET="32bit" TARGET_VARS="32bit-vars" CFLAGS="-Werror"
+    - TARGET="32bit" TARGET_VARS="32bit-vars" PRE="valgrind --track-origins=yes --leak-check=full"
+
+matrix:
+  exclude:
+    - os: osx
+      env: PRE="valgrind --track-origins=yes --leak-check=full"
+
+    - os: osx
+      env: TARGET="32bit" TARGET_VARS="32bit-vars" PRE="valgrind --track-origins=yes --leak-check=full"
+
+script: make $TARGET CFLAGS="$CFLAGS" && make check PRE="$PRE" && make $TARGET_VARS hiredis-example
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis: win32.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis: zmalloc.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/config.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/config.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/config.log	2017-09-27 22:53:59.578950047 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/config.log	2017-09-27 23:06:47.770921894 +0800
@@ -615,14 +615,14 @@
 configure:7170: checking for secure_getenv
 configure:7170: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
 configure:7170: $? = 0
 configure:7170: result: yes
 configure:7183: checking for issetugid
 configure:7183: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-/tmp/cc0y9rCs.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c:92: undefined reference to `issetugid'
+/tmp/ccZbAFyc.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c:92: undefined reference to `issetugid'
 collect2: error: ld returned 1 exit status
 configure:7183: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
@@ -718,14 +718,14 @@
 |   ;
 |   return 0;
 | }
 configure:7183: result: no
 configure:7196: checking for _malloc_thread_cleanup
 configure:7196: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-/tmp/cceG3Tau.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c:92: undefined reference to `_malloc_thread_cleanup'
+/tmp/cc6UmqWb.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c:92: undefined reference to `_malloc_thread_cleanup'
 collect2: error: ld returned 1 exit status
 configure:7196: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
@@ -821,14 +821,14 @@
 |   ;
 |   return 0;
 | }
 configure:7196: result: no
 configure:7210: checking for _pthread_mutex_init_calloc_cb
 configure:7210: gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden  -D_GNU_SOURCE -D_REENTRANT  conftest.c  -lpthread >&5
-/tmp/cc6kL9yt.o: In function `main':
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c:92: undefined reference to `_pthread_mutex_init_calloc_cb'
+/tmp/cc90kUJd.o: In function `main':
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c:92: undefined reference to `_pthread_mutex_init_calloc_cb'
 collect2: error: ld returned 1 exit status
 configure:7210: $? = 1
 configure: failed program was:
 | /* confdefs.h */
 | #define PACKAGE_NAME ""
 | #define PACKAGE_TARNAME ""
@@ -1715,15 +1715,15 @@
 configure:9637: result: DATADIR            : /usr/local/share
 configure:9639: result: INCLUDEDIR         : /usr/local/include
 configure:9641: result: LIBDIR             : /usr/local/lib
 configure:9643: result: MANDIR             : /usr/local/share/man
 configure:9645: result: 
 configure:9647: result: srcroot            : 
-configure:9649: result: abs_srcroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/
+configure:9649: result: abs_srcroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/
 configure:9651: result: objroot            : 
-configure:9653: result: abs_objroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/
+configure:9653: result: abs_objroot        : /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/
 configure:9655: result: 
 configure:9657: result: JEMALLOC_PREFIX    : je_
 configure:9659: result: JEMALLOC_PRIVATE_NAMESPACE
 configure:9661: result:                    : je_
 configure:9663: result: install_suffix     : 
 configure:9665: result: autogen            : 0
@@ -1894,14 +1894,14 @@
 SOREV='so.2'
 TESTLIBS=''
 XSLROOT='/usr/share/xml/docbook/stylesheet/docbook-xsl'
 XSLTPROC='/opt/anaconda2/bin/xsltproc'
 a='a'
 abi='elf'
-abs_objroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/'
-abs_srcroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/'
+abs_objroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/'
+abs_srcroot='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/'
 ac_ct_CC='gcc'
 bindir='${exec_prefix}/bin'
 build='x86_64-unknown-linux-gnu'
 build_alias=''
 build_cpu='x86_64'
 build_os='linux-gnu'
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/config.status /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/config.status
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/config.status	2017-09-27 22:53:59.106950065 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/config.status	2017-09-27 23:06:47.282921911 +0800
@@ -434,13 +434,13 @@
   with options \"$ac_cs_config\"
 
 Copyright (C) 2012 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
-ac_pwd='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc'
+ac_pwd='/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc'
 srcdir='.'
 INSTALL='/usr/bin/install -c'
 test -n "$AWK" || AWK=awk
 # The default lists apply if the user does not specify any file.
 ac_need_defaults=:
 while test $# != 0
@@ -769,15 +769,15 @@
 S["MANDIR"]="/usr/local/share/man"
 S["DATADIR"]="/usr/local/share"
 S["LIBDIR"]="/usr/local/lib"
 S["INCLUDEDIR"]="/usr/local/include"
 S["BINDIR"]="/usr/local/bin"
 S["PREFIX"]="/usr/local"
-S["abs_objroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/"
+S["abs_objroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/"
 S["objroot"]=""
-S["abs_srcroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/"
+S["abs_srcroot"]="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/"
 S["srcroot"]=""
 S["rev"]="2"
 S["CONFIG"]="--with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence 'CFLAGS=-std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops ' LDFLAGS="
 S["target_alias"]=""
 S["host_alias"]=""
 S["build_alias"]=""
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/doc/html.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/doc/html.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/doc/html.xsl	2017-09-27 22:53:59.146950063 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/doc/html.xsl	2017-09-27 23:06:47.338921909 +0800
@@ -1,4 +1,4 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="/usr/share/xml/docbook/stylesheet/docbook-xsl/html/docbook.xsl"/>
-  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/doc/stylesheet.xsl"/>
 </xsl:stylesheet>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/doc/manpages.xsl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/doc/manpages.xsl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/doc/manpages.xsl	2017-09-27 22:53:59.158950063 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/doc/manpages.xsl	2017-09-27 23:06:47.346921909 +0800
@@ -1,4 +1,4 @@
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
   <xsl:import href="/usr/share/xml/docbook/stylesheet/docbook-xsl/manpages/docbook.xsl"/>
-  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/doc/stylesheet.xsl"/>
+  <xsl:import href="/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/doc/stylesheet.xsl"/>
 </xsl:stylesheet>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/include/jemalloc/jemalloc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/include/jemalloc/jemalloc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/include/jemalloc/jemalloc.h	2017-09-27 22:53:59.558950048 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/include/jemalloc/jemalloc.h	2017-09-27 23:06:47.742921895 +0800
@@ -172,12 +172,16 @@
 #  define JEMALLOC_NOTHROW
 #  define JEMALLOC_SECTION(s)
 #  define JEMALLOC_RESTRICT_RETURN
 #  define JEMALLOC_ALLOCATOR
 #endif
 
+/* This version of Jemalloc, modified for Redis, has the je_get_defrag_hint()
+ * function. */
+#define	JEMALLOC_FRAG_HINT
+
 /*
  * The je_ prefix on the following public symbol declarations is an artifact
  * of namespace management, and should be omitted in application code unless
  * JEMALLOC_NO_DEMANGLE is defined (see jemalloc_mangle.h).
  */
 extern JEMALLOC_EXPORT const char	*je_malloc_conf;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/include/jemalloc/jemalloc_macros.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/include/jemalloc/jemalloc_macros.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/include/jemalloc/jemalloc_macros.h	2017-09-27 22:53:59.182950062 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/include/jemalloc/jemalloc_macros.h	2017-09-27 23:06:47.370921908 +0800
@@ -97,6 +97,10 @@
 #  define JEMALLOC_NOINLINE
 #  define JEMALLOC_NOTHROW
 #  define JEMALLOC_SECTION(s)
 #  define JEMALLOC_RESTRICT_RETURN
 #  define JEMALLOC_ALLOCATOR
 #endif
+
+/* This version of Jemalloc, modified for Redis, has the je_get_defrag_hint()
+ * function. */
+#define JEMALLOC_FRAG_HINT
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/include/jemalloc/jemalloc_macros.h.in	2017-07-14 19:28:42.000000000 +0800
@@ -97,6 +97,10 @@
 #  define JEMALLOC_NOINLINE
 #  define JEMALLOC_NOTHROW
 #  define JEMALLOC_SECTION(s)
 #  define JEMALLOC_RESTRICT_RETURN
 #  define JEMALLOC_ALLOCATOR
 #endif
+
+/* This version of Jemalloc, modified for Redis, has the je_get_defrag_hint()
+ * function. */
+#define JEMALLOC_FRAG_HINT
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/lib/libjemalloc.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/lib/libjemalloc.a differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/Makefile	2017-09-27 22:53:59.134950064 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/Makefile	2017-09-27 23:06:47.322921910 +0800
@@ -16,14 +16,14 @@
 INCLUDEDIR := $(DESTDIR)/usr/local/include
 LIBDIR := $(DESTDIR)/usr/local/lib
 DATADIR := $(DESTDIR)/usr/local/share
 MANDIR := $(DESTDIR)/usr/local/share/man
 srcroot := 
 objroot := 
-abs_srcroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/
-abs_objroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/
+abs_srcroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/
+abs_objroot := /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/
 
 # Build parameters.
 CPPFLAGS :=  -D_GNU_SOURCE -D_REENTRANT -I$(srcroot)include -I$(objroot)include
 CFLAGS := -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops  -fvisibility=hidden
 LDFLAGS := 
 EXTRA_LDFLAGS := 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/arena.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/arena.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/arena.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/arena.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/atomic.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/atomic.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/atomic.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/atomic.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/base.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/base.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/base.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/base.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/bitmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/bitmap.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/bitmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/bitmap.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_dss.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_dss.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_dss.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_dss.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_mmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_mmap.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_mmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_mmap.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ckh.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ckh.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ckh.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ckh.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ctl.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ctl.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ctl.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ctl.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/extent.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/extent.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/extent.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/extent.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/hash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/hash.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/hash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/hash.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/huge.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/huge.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/huge.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/huge.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c	2017-07-14 19:28:42.000000000 +0800
@@ -2588,6 +2588,38 @@
 	malloc_mutex_postfork_child(&arenas_lock);
 	prof_postfork_child();
 	ctl_postfork_child();
 }
 
 /******************************************************************************/
+
+/* Helps the application decide if a pointer is worth re-allocating in order to reduce fragmentation.
+ * returns 0 if the allocation is in the currently active run,
+ * or when it is not causing any frag issue (large or huge bin)
+ * returns the bin utilization and run utilization both in fixed point 16:16.
+ * If the application decides to re-allocate it should use MALLOCX_TCACHE_NONE when doing so. */
+JEMALLOC_EXPORT int JEMALLOC_NOTHROW
+je_get_defrag_hint(void* ptr, int *bin_util, int *run_util) {
+    int defrag = 0;
+    arena_chunk_t *chunk = (arena_chunk_t *)CHUNK_ADDR2BASE(ptr);
+    if (likely(chunk != ptr)) { /* indication that this is not a HUGE alloc */
+        size_t pageind = ((uintptr_t)ptr - (uintptr_t)chunk) >> LG_PAGE;
+        size_t mapbits = arena_mapbits_get(chunk, pageind);
+        if (likely((mapbits & CHUNK_MAP_LARGE) == 0)) { /* indication that this is not a LARGE alloc */
+            arena_t *arena = extent_node_arena_get(&chunk->node);
+            size_t rpages_ind = pageind - arena_mapbits_small_runind_get(chunk, pageind);
+            arena_run_t *run = &arena_miscelm_get(chunk, rpages_ind)->run;
+            arena_bin_t *bin = &arena->bins[run->binind];
+            malloc_mutex_lock(&bin->lock);
+            /* runs that are in the same chunk in as the current chunk, are likely to be the next currun */
+            if (chunk != (arena_chunk_t *)CHUNK_ADDR2BASE(bin->runcur)) {
+                arena_bin_info_t *bin_info = &arena_bin_info[run->binind];
+                size_t availregs = bin_info->nregs * bin->stats.curruns;
+                *bin_util = (bin->stats.curregs<<16) / availregs;
+                *run_util = ((bin_info->nregs - run->nfree)<<16) / bin_info->nregs;
+                defrag = 1;
+            }
+            malloc_mutex_unlock(&bin->lock);
+        }
+    }
+    return defrag;
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mb.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mb.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mutex.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mutex.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mutex.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mutex.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/pages.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/pages.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/pages.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/pages.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/prof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/prof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/prof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/prof.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/quarantine.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/quarantine.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/quarantine.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/quarantine.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/rtree.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/rtree.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/rtree.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/rtree.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/stats.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/stats.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/stats.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/stats.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tcache.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tcache.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tcache.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tcache.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tsd.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tsd.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tsd.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tsd.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/util.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/util.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/util.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/util.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/test/test.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/test/test.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/test/test.sh	2017-09-27 22:53:59.214950061 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/test/test.sh	2017-09-27 23:06:47.402921907 +0800
@@ -21,13 +21,13 @@
 fail_count=0
 for t in $@; do
   if [ $pass_count -ne 0 -o $skip_count -ne 0 -o $fail_count != 0 ] ; then
     echo
   fi
   echo "=== ${t} ==="
-  ${t} /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/
+  ${t} /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/
   result_code=$?
   case ${result_code} in
     ${pass_code})
       pass_count=$((pass_count+1))
       ;;
     ${skip_code})
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise/linenoise.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise/linenoise.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise/linenoise.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise/linenoise.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/fpconv.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/fpconv.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lapi.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lapi.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lauxlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lauxlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lbaselib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lbaselib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lcode.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lcode.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldblib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldblib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldebug.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldebug.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldo.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldo.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lfunc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lfunc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lgc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lgc.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/liblua.a and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/liblua.a differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/linit.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/linit.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/liolib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/liolib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/llex.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/llex.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmathlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmathlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmem.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmem.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loadlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loadlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lobject.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lobject.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lopcodes.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lopcodes.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loslib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loslib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lparser.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lparser.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstate.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstate.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstring.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstring.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstrlib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstrlib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltable.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltable.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltablib.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltablib.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltm.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltm.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_bit.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_bit.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/luac.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/luac.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cjson.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cjson.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cmsgpack.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cmsgpack.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_struct.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_struct.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lundump.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lundump.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lvm.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lvm.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lzio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lzio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/print.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/print.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/strbuf.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/strbuf.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/Makefile	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/Makefile	2017-07-14 19:28:42.000000000 +0800
@@ -33,13 +33,12 @@
 endif
 
 distclean:
 	-(cd hiredis && $(MAKE) clean) > /dev/null || true
 	-(cd linenoise && $(MAKE) clean) > /dev/null || true
 	-(cd lua && $(MAKE) clean) > /dev/null || true
-	-(cd geohash-int && $(MAKE) clean) > /dev/null || true
 	-(cd jemalloc && [ -f Makefile ] && $(MAKE) distclean) > /dev/null || true
 	-(rm -f .make-*)
 
 .PHONY: distclean
 
 hiredis: .make-prerequisites
@@ -79,12 +78,6 @@
 jemalloc: .make-prerequisites
 	@printf '%b %b\n' $(MAKECOLOR)MAKE$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR)
 	cd jemalloc && ./configure --with-lg-quantum=3 --with-jemalloc-prefix=je_ --enable-cc-silence CFLAGS="$(JEMALLOC_CFLAGS)" LDFLAGS="$(JEMALLOC_LDFLAGS)"
 	cd jemalloc && $(MAKE) CFLAGS="$(JEMALLOC_CFLAGS)" LDFLAGS="$(JEMALLOC_LDFLAGS)" lib/libjemalloc.a
 
 .PHONY: jemalloc
-
-geohash-int: .make-prerequisites
-	@printf '%b %b\n' $(MAKECOLOR)MAKE$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR)
-	cd geohash-int && $(MAKE)
-
-.PHONY: geohash-int
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/.gitignore /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/.gitignore
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/.gitignore	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/.gitignore	2017-07-14 19:28:42.000000000 +0800
@@ -24,6 +24,7 @@
 deps/lua/src/lua
 deps/lua/src/luac
 deps/lua/src/liblua.a
 .make-*
 .prerequisites
 *.dSYM
+Makefile.dep
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/README.md /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/README.md
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/README.md	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/README.md	2017-07-14 19:28:42.000000000 +0800
@@ -36,22 +36,22 @@
     % make
 
 You can run a 32 bit Redis binary using:
 
     % make 32bit
 
-After building Redis is a good idea to test it, using:
+After building Redis, it is a good idea to test it using:
 
     % make test
 
 Fixing build problems with dependencies or cached build options
 ---------
 
 Redis has some dependencies which are included into the `deps` directory.
-`make` does not rebuild dependencies automatically, even if something in the
-source code of dependencies is changed.
+`make` does not automatically rebuild dependencies even if something in
+the source code of dependencies changes.
 
 When you update the source code with `git pull` or when code inside the
 dependencies tree is modified in any other way, make sure to use the following
 command in order to really clean everything and rebuild from scratch:
 
     make distclean
@@ -106,20 +106,20 @@
 -------------
 
 To run Redis with the default configuration just type:
 
     % cd src
     % ./redis-server
-    
+
 If you want to provide your redis.conf, you have to run it using an additional
 parameter (the path of the configuration file):
 
     % cd src
     % ./redis-server /path/to/redis.conf
 
-It is possible to alter the Redis configuration passing parameters directly
+It is possible to alter the Redis configuration by passing parameters directly
 as options using the command line. Examples:
 
     % ./redis-server --port 9999 --slaveof 127.0.0.1 6379
     % ./redis-server /etc/redis/6379.conf --loglevel debug
 
 All the options in redis.conf are also supported as options using the command
@@ -171,21 +171,276 @@
 system reboots.
 
 You'll be able to stop and start Redis using the script named
 `/etc/init.d/redis_<portnumber>`, for instance `/etc/init.d/redis_6379`.
 
 Code contributions
----
+-----------------
 
 Note: by contributing code to the Redis project in any form, including sending
 a pull request via Github, a code fragment or patch via private email or
 public discussion groups, you agree to release your code under the terms
 of the BSD license that you can find in the [COPYING][1] file included in the Redis
 source distribution.
 
 Please see the [CONTRIBUTING][2] file in this source distribution for more
 information.
 
-Enjoy!
-
 [1]: https://github.com/antirez/redis/blob/unstable/COPYING
 [2]: https://github.com/antirez/redis/blob/unstable/CONTRIBUTING
+
+Redis internals
+===
+
+If you are reading this README you are likely in front of a Github page
+or you just untarred the Redis distribution tar ball. In both the cases
+you are basically one step away from the source code, so here we explain
+the Redis source code layout, what is in each file as a general idea, the
+most important functions and structures inside the Redis server and so forth.
+We keep all the discussion at a high level without digging into the details
+since this document would be huge otherwise and our code base changes
+continuously, but a general idea should be a good starting point to
+understand more. Moreover most of the code is heavily commented and easy
+to follow.
+
+Source code layout
+---
+
+The Redis root directory just contains this README, the Makefile which
+calls the real Makefile inside the `src` directory and an example
+configuration for Redis and Sentinel. You can find a few shell
+scripts that are used in order to execute the Redis, Redis Cluster and
+Redis Sentinel unit tests, which are implemented inside the `tests`
+directory.
+
+Inside the root are the following important directories:
+
+* `src`: contains the Redis implementation, written in C.
+* `tests`: contains the unit tests, implemented in Tcl.
+* `deps`: contains libraries Redis uses. Everything needed to compile Redis is inside this directory; your system just needs to provide `libc`, a POSIX compatible interface and a C compiler. Notably `deps` contains a copy of `jemalloc`, which is the default allocator of Redis under Linux. Note that under `deps` there are also things which started with the Redis project, but for which the main repository is not `anitrez/redis`. An exception to this rule is `deps/geohash-int` which is the low level geocoding library used by Redis: it originated from a different project, but at this point it diverged so much that it is developed as a separated entity directly inside the Redis repository.
+
+There are a few more directories but they are not very important for our goals
+here. We'll focus mostly on `src`, where the Redis implementation is contained,
+exploring what there is inside each file. The order in which files are
+exposed is the logical one to follow in order to disclose different layers
+of complexity incrementally.
+
+Note: lately Redis was refactored quite a bit. Function names and file
+names have been changed, so you may find that this documentation reflects the
+`unstable` branch more closely. For instance in Redis 3.0 the `server.c`
+and `server.h` files were named to `redis.c` and `redis.h`. However the overall
+structure is the same. Keep in mind that all the new developments and pull
+requests should be performed against the `unstable` branch.
+
+server.h
+---
+
+The simplest way to understand how a program works is to understand the
+data structures it uses. So we'll start from the main header file of
+Redis, which is `server.h`.
+
+All the server configuration and in general all the shared state is
+defined in a global structure called `server`, of type `struct redisServer`.
+A few important fields in this structure are:
+
+* `server.db` is an array of Redis databases, where data is stored.
+* `server.commands` is the command table.
+* `server.clients` is a linked list of clients connected to the server.
+* `server.master` is a special client, the master, if the instance is a slave.
+
+There are tons of other fields. Most fields are commented directly inside
+the structure definition.
+
+Another important Redis data structure is the one defining a client.
+In the past it was called `redisClient`, now just `client`. The structure
+has many fields, here we'll just show the main ones:
+
+    struct client {
+        int fd;
+        sds querybuf;
+        int argc;
+        robj **argv;
+        redisDb *db;
+        int flags;
+        list *reply;
+        char buf[PROTO_REPLY_CHUNK_BYTES];
+        ... many other fields ...
+    }
+
+The client structure defines a *connected client*:
+
+* The `fd` field is the client socket file descriptor.
+* `argc` and `argv` are populated with the command the client is executing, so that functions implementing a given Redis command can read the arguments.
+* `querybuf` accumulates the requests from the client, which are parsed by the Redis server according to the Redis protocol and executed by calling the implementations of the commands the client is executing.
+* `reply` and `buf` are dynamic and static buffers that accumulate the replies the server sends to the client. These buffers are incrementally written to the socket as soon as the file descriptor is writable.
+
+As you can see in the client structure above, arguments in a command
+are described as `robj` structures. The following is the full `robj`
+structure, which defines a *Redis object*:
+
+    typedef struct redisObject {
+        unsigned type:4;
+        unsigned encoding:4;
+        unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */
+        int refcount;
+        void *ptr;
+    } robj;
+
+Basically this structure can represent all the basic Redis data types like
+strings, lists, sets, sorted sets and so forth. The interesting thing is that
+it has a `type` field, so that it is possible to know what type a given
+object has, and a `refcount`, so that the same object can be referenced
+in multiple places without allocating it multiple times. Finally the `ptr`
+field points to the actual representation of the object, which might vary
+even for the same type, depending on the `encoding` used.
+
+Redis objects are used extensively in the Redis internals, however in order
+to avoid the overhead of indirect accesses, recently in many places
+we just use plain dynamic strings not wrapped inside a Redis object.
+
+server.c
+---
+
+This is the entry point of the Redis server, where the `main()` function
+is defined. The following are the most important steps in order to startup
+the Redis server.
+
+* `initServerConfig()` setups the default values of the `server` structure.
+* `initServer()` allocates the data structures needed to operate, setup the listening socket, and so forth.
+* `aeMain()` starts the event loop which listens for new connections.
+
+There are two special functions called periodically by the event loop:
+
+1. `serverCron()` is called periodically (according to `server.hz` frequency), and performs tasks that must be performed from time to time, like checking for timedout clients.
+2. `beforeSleep()` is called every time the event loop fired, Redis served a few requests, and is returning back into the event loop.
+
+Inside server.c you can find code that handles other vital things of the Redis server:
+
+* `call()` is used in order to call a given command in the context of a given client.
+* `activeExpireCycle()` handles eviciton of keys with a time to live set via the `EXPIRE` command.
+* `freeMemoryIfNeeded()` is called when a new write command should be performed but Redis is out of memory according to the `maxmemory` directive.
+* The global variable `redisCommandTable` defines all the Redis commands, specifying the name of the command, the function implementing the command, the number of arguments required, and other properties of each command.
+
+networking.c
+---
+
+This file defines all the I/O functions with clients, masters and slaves
+(which in Redis are just special clients):
+
+* `createClient()` allocates and initializes a new client.
+* the `addReply*()` family of functions are used by commands implementations in order to append data to the client structure, that will be transmitted to the client as a reply for a given command executed.
+* `writeToClient()` transmits the data pending in the output buffers to the client and is called by the *writable event handler* `sendReplyToClient()`.
+* `readQueryFromClient()` is the *readable event handler* and accumulates data from read from the client into the query buffer.
+* `processInputBuffer()` is the entry point in order to parse the client query buffer according to the Redis protocol. Once commands are ready to be processed, it calls `processCommand()` which is defined inside `server.c` in order to actually execute the command.
+* `freeClient()` deallocates, disconnects and removes a client.
+
+aof.c and rdb.c
+---
+
+As you can guess from the names these files implement the RDB and AOF
+persistence for Redis. Redis uses a persistence model based on the `fork()`
+system call in order to create a thread with the same (shared) memory
+content of the main Redis thread. This secondary thread dumps the content
+of the memory on disk. This is used by `rdb.c` to create the snapshots
+on disk and by `aof.c` in order to perform the AOF rewrite when the
+append only file gets too big.
+
+The implementation inside `aof.c` has additional functions in order to
+implement an API that allows commands to append new commands into the AOF
+file as clients execute them.
+
+The `call()` function defined inside `server.c` is responsible to call
+the functions that in turn will write the commands into the AOF.
+
+db.c
+---
+
+Certain Redis commands operate on specific data types, others are general.
+Examples of generic commands are `DEL` and `EXPIRE`. They operate on keys
+and not on their values specifically. All those generic commands are
+defined inside `db.c`.
+
+Moreover `db.c` implements an API in order to perform certain operations
+on the Redis dataset without directly accessing the internal data structures.
+
+The most important functions inside `db.c` which are used in many commands
+implementations are the following:
+
+* `lookupKeyRead()` and `lookupKeyWrite()` are used in order to get a pointer to the value associated to a given key, or `NULL` if the key does not exist.
+* `dbAdd()` and its higher level counterpart `setKey()` create a new key in a Redis database.
+* `dbDelete()` removes a key and its associated value.
+* `emptyDb()` removes an entire single database or all the databases defined.
+
+The rest of the file implements the generic commands exposed to the client.
+
+object.c
+---
+
+The `robj` structure defining Redis objects was already described. Inside
+`object.c` there are all the functions that operate with Redis objects at
+a basic level, like functions to allocate new objects, handle the reference
+counting and so forth. Notable functions inside this file:
+
+* `incrRefcount()` and `decrRefCount()` are used in order to increment or decrement an object reference count. When it drops to 0 the object is finally freed.
+* `createObject()` allocates a new object. There are also specialized functions to allocate string objects having a specific content, like `createStringObjectFromLongLong()` and similar functions.
+
+This file also implements the `OBJECT` command.
+
+replication.c
+---
+
+This is one of the most complex files inside Redis, it is recommended to
+approach it only after getting a bit familiar with the rest of the code base.
+In this file there is the implementation of both the master and slave role
+of Redis.
+
+One of the most important functions inside this file is `replicationFeedSlaves()` that writes commands to the clients representing slave instances connected
+to our master, so that the slaves can get the writes performed by the clients:
+this way their data set will remain synchronized with the one in the master.
+
+This file also implements both the `SYNC` and `PSYNC` commands that are
+used in order to perform the first synchronization between masters and
+slaves, or to continue the replication after a disconnection.
+
+Other C files
+---
+
+* `t_hash.c`, `t_list.c`, `t_set.c`, `t_string.c` and `t_zset.c` contains the implementation of the Redis data types. They implement both an API to access a given data type, and the client commands implementations for these data types.
+* `ae.c` implements the Redis event loop, it's a self contained library which is simple to read and understand.
+* `sds.c` is the Redis string library, check http://github.com/antirez/sds for more information.
+* `anet.c` is a library to use POSIX networking in a simpler way compared to the raw interface exposed by the kernel.
+* `dict.c` is an implementation of a non-blocking hash table which rehashes incrementally.
+* `scripting.c` implements Lua scripting. It is completely self contained from the rest of the Redis implementation and is simple enough to understand if you are familar with the Lua API.
+* `cluster.c` implements the Redis Cluster. Probably a good read only after being very familiar with the rest of the Redis code base. If you want to read `cluster.c` make sure to read the [Redis Cluster specification][3].
+
+[3]: http://redis.io/topics/cluster-spec
+
+Anatomy of a Redis command
+---
+
+All the Redis commands are defined in the following way:
+
+    void foobarCommand(client *c) {
+        printf("%s",c->argv[1]->ptr); /* Do something with the argument. */
+        addReply(c,shared.ok); /* Reply something to the client. */
+    }
+
+The command is then referenced inside `server.c` in the command table:
+
+    {"foobar",foobarCommand,2,"rtF",0,NULL,0,0,0,0,0},
+
+In the above example `2` is the number of arguments the command takes,
+while `"rtF"` are the command flags, as documented in the command table
+top comment inside `server.c`.
+
+After the command operates in some way, it returns a reply to the client,
+usually using `addReply()` or a similar function defined inside `networking.c`.
+
+There are tons of commands implementations inside th Redis source code
+that can serve as examples of actual commands implementations. To write
+a few toy commands can be a good exercise to familiarize with the code base.
+
+There are also many other files not described here, but it is useless to
+cover everything. We want to just help you with the first steps.
+Eventually you'll find your way inside the Redis code base :-)
+
+Enjoy!
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/redis.conf /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/redis.conf
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/redis.conf	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/redis.conf	2017-07-14 19:28:42.000000000 +0800
@@ -32,12 +32,20 @@
 # If instead you are interested in using includes to override configuration
 # options, it is better to use include as the last line.
 #
 # include /path/to/local.conf
 # include /path/to/other.conf
 
+################################## MODULES #####################################
+
+# Load modules at startup. If the server is not able to load modules
+# it will abort. It is possible to use multiple loadmodule directives.
+#
+# loadmodule /path/to/my_module.so
+# loadmodule /path/to/other_module.so
+
 ################################## NETWORK #####################################
 
 # By default, if no "bind" configuration directive is specified, Redis listens
 # for connections from all the network interfaces available on the server.
 # It is possible to listen to just one or multiple selected interfaces using
 # the "bind" configuration directive, followed by one or more IP addresses.
@@ -174,12 +182,20 @@
 
 # Set the number of databases. The default database is DB 0, you can select
 # a different one on a per-connection basis using SELECT <dbid> where
 # dbid is a number between 0 and 'databases'-1
 databases 16
 
+# By default Redis shows an ASCII art logo only when started to log to the
+# standard output and if the standard output is a TTY. Basically this means
+# that normally a logo is displayed only in interactive sessions.
+#
+# However it is possible to force the pre-4.0 behavior and always show a
+# ASCII art logo in startup logs by setting the following option to yes.
+always-show-logo yes
+
 ################################ SNAPSHOTTING  ################################
 #
 # Save the DB on disk:
 #
 #   save <seconds> <changes>
 #
@@ -391,12 +407,16 @@
 
 # After a master has no longer connected slaves for some time, the backlog
 # will be freed. The following option configures the amount of seconds that
 # need to elapse, starting from the time the last slave disconnected, for
 # the backlog buffer to be freed.
 #
+# Note that slaves never free the backlog for timeout, since they may be
+# promoted to masters later, and should be able to correctly "partially
+# resynchronize" with the slaves: hence they should always accumulate backlog.
+#
 # A value of 0 means to never release the backlog.
 #
 # repl-backlog-ttl 3600
 
 # The slave priority is an integer number published by Redis in the INFO output.
 # It is used by Redis Sentinel in order to select a slave to promote into a
@@ -437,13 +457,13 @@
 
 # A Redis master is able to list the address and port of the attached
 # slaves in different ways. For example the "INFO replication" section
 # offers this information, which is used, among other tools, by
 # Redis Sentinel in order to discover slave instances.
 # Another place where this info is available is in the output of the
-# "ROLE" command of a masteer.
+# "ROLE" command of a master.
 #
 # The listed IP and address normally reported by a slave is obtained
 # in the following way:
 #
 #   IP: The address is auto detected by checking the peer address
 #   of the socket used by the slave to connect with the master.
@@ -495,36 +515,38 @@
 #
 # rename-command CONFIG ""
 #
 # Please note that changing the name of commands that are logged into the
 # AOF file or transmitted to slaves may cause problems.
 
-################################### LIMITS ####################################
+################################### CLIENTS ####################################
 
 # Set the max number of connected clients at the same time. By default
 # this limit is set to 10000 clients, however if the Redis server is not
 # able to configure the process file limit to allow for the specified limit
 # the max number of allowed clients is set to the current file limit
 # minus 32 (as Redis reserves a few file descriptors for internal uses).
 #
 # Once the limit is reached Redis will close all the new connections sending
 # an error 'max number of clients reached'.
 #
 # maxclients 10000
 
-# Don't use more memory than the specified amount of bytes.
+############################## MEMORY MANAGEMENT ################################
+
+# Set a memory usage limit to the specified amount of bytes.
 # When the memory limit is reached Redis will try to remove keys
 # according to the eviction policy selected (see maxmemory-policy).
 #
 # If Redis can't remove keys according to the policy, or if the policy is
 # set to 'noeviction', Redis will start to reply with errors to commands
 # that would use more memory, like SET, LPUSH, and so on, and will continue
 # to reply to read-only commands like GET.
 #
-# This option is usually useful when using Redis as an LRU cache, or to set
-# a hard memory limit for an instance (using the 'noeviction' policy).
+# This option is usually useful when using Redis as an LRU or LFU cache, or to
+# set a hard memory limit for an instance (using the 'noeviction' policy).
 #
 # WARNING: If you have slaves attached to an instance with maxmemory on,
 # the size of the output buffers needed to feed the slaves are subtracted
 # from the used memory count, so that network problems / resyncs will
 # not trigger a loop where keys are evicted, and in turn the output
 # buffer of slaves is full with DELs of keys evicted triggering the deletion
@@ -536,18 +558,26 @@
 #
 # maxmemory <bytes>
 
 # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
 # is reached. You can select among five behaviors:
 #
-# volatile-lru -> remove the key with an expire set using an LRU algorithm
-# allkeys-lru -> remove any key according to the LRU algorithm
-# volatile-random -> remove a random key with an expire set
-# allkeys-random -> remove a random key, any key
-# volatile-ttl -> remove the key with the nearest expire time (minor TTL)
-# noeviction -> don't expire at all, just return an error on write operations
+# volatile-lru -> Evict using approximated LRU among the keys with an expire set.
+# allkeys-lru -> Evict any key using approximated LRU.
+# volatile-lfu -> Evict using approximated LFU among the keys with an expire set.
+# allkeys-lfu -> Evict any key using approximated LFU.
+# volatile-random -> Remove a random key among the ones with an expire set.
+# allkeys-random -> Remove a random key, any key.
+# volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
+# noeviction -> Don't evict anything, just return an error on write operations.
+#
+# LRU means Least Recently Used
+# LFU means Least Frequently Used
+#
+# Both LRU, LFU and volatile-ttl are implemented using approximated
+# randomized algorithms.
 #
 # Note: with any of the above policies, Redis will return an error on write
 #       operations, when there are no suitable keys for eviction.
 #
 #       At the date of writing these commands are: set setnx setex append
 #       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
@@ -556,23 +586,72 @@
 #       getset mset msetnx exec sort
 #
 # The default is:
 #
 # maxmemory-policy noeviction
 
-# LRU and minimal TTL algorithms are not precise algorithms but approximated
+# LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated
 # algorithms (in order to save memory), so you can tune it for speed or
 # accuracy. For default Redis will check five keys and pick the one that was
 # used less recently, you can change the sample size using the following
 # configuration directive.
 #
 # The default of 5 produces good enough results. 10 Approximates very closely
-# true LRU but costs a bit more CPU. 3 is very fast but not very accurate.
+# true LRU but costs more CPU. 3 is faster but not very accurate.
 #
 # maxmemory-samples 5
 
+############################# LAZY FREEING ####################################
+
+# Redis has two primitives to delete keys. One is called DEL and is a blocking
+# deletion of the object. It means that the server stops processing new commands
+# in order to reclaim all the memory associated with an object in a synchronous
+# way. If the key deleted is associated with a small object, the time needed
+# in order to execute th DEL command is very small and comparable to most other
+# O(1) or O(log_N) commands in Redis. However if the key is associated with an
+# aggregated value containing millions of elements, the server can block for
+# a long time (even seconds) in order to complete the operation.
+#
+# For the above reasons Redis also offers non blocking deletion primitives
+# such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and
+# FLUSHDB commands, in order to reclaim memory in background. Those commands
+# are executed in constant time. Another thread will incrementally free the
+# object in the background as fast as possible.
+#
+# DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.
+# It's up to the design of the application to understand when it is a good
+# idea to use one or the other. However the Redis server sometimes has to
+# delete keys or flush the whole database as a side effect of other operations.
+# Specifically Redis deletes objects independently of an user call in the
+# following scenarios:
+#
+# 1) On eviction, because of the maxmemory and maxmemory policy configurations,
+#    in order to make room for new data, without going over the specified
+#    memory limit.
+# 2) Because of expire: when a key with an associated time to live (see the
+#    EXPIRE command) must be deleted from memory.
+# 3) Because of a side effect of a command that stores data on a key that may
+#    already exist. For example the RENAME command may delete the old key
+#    content when it is replaced with another one. Similarly SUNIONSTORE
+#    or SORT with STORE option may delete existing keys. The SET command
+#    itself removes any old content of the specified key in order to replace
+#    it with the specified string.
+# 4) During replication, when a slave performs a full resynchronization with
+#    its master, the content of the whole database is removed in order to
+#    load the RDB file just transfered.
+#
+# In all the above cases the default is to delete objects in a blocking way,
+# like if DEL was called. However you can configure each case specifically
+# in order to instead release memory in a non-blocking way like if UNLINK
+# was called, using the following configuration directives:
+
+lazyfree-lazy-eviction no
+lazyfree-lazy-expire no
+lazyfree-lazy-server-del no
+slave-lazy-flush no
+
 ############################## APPEND ONLY MODE ###############################
 
 # By default Redis asynchronously dumps the dataset on disk. This mode is
 # good enough in many applications, but an issue with the Redis process or
 # a power outage may result into a few minutes of writes lost (depending on
 # the configured save points).
@@ -685,12 +764,26 @@
 # Note that if the AOF file will be found to be corrupted in the middle
 # the server will still exit with an error. This option only applies when
 # Redis will try to read more data from the AOF file but not enough bytes
 # will be found.
 aof-load-truncated yes
 
+# When rewriting the AOF file, Redis is able to use an RDB preamble in the
+# AOF file for faster rewrites and recoveries. When this option is turned
+# on the rewritten AOF file is composed of two different stanzas:
+#
+#   [RDB file][AOF tail]
+#
+# When loading Redis recognizes that the AOF file starts with the "REDIS"
+# string and loads the prefixed RDB file, and continues loading the AOF
+# tail.
+#
+# This is currently turned off by default in order to avoid the surprise
+# of a format change, but will at some point be used as the default.
+aof-use-rdb-preamble no
+
 ################################ LUA SCRIPTING  ###############################
 
 # Max execution time of a Lua script in milliseconds.
 #
 # If the maximum execution time is reached Redis will log that a script is
 # still in execution after the maximum allowed time and will start to
@@ -734,13 +827,13 @@
 #
 # cluster-node-timeout 15000
 
 # A slave of a failing master will avoid to start a failover if its data
 # looks too old.
 #
-# There is no simple way for a slave to actually have a exact measure of
+# There is no simple way for a slave to actually have an exact measure of
 # its "data age", so the following two checks are performed:
 #
 # 1) If there are multiple slaves able to failover, they exchange messages
 #    in order to try to give an advantage to the slave with the best
 #    replication offset (more data from the master processed).
 #    Slaves will try to get their rank by offset, and apply to the start
@@ -811,12 +904,45 @@
 #
 # cluster-require-full-coverage yes
 
 # In order to setup your cluster make sure to read the documentation
 # available at http://redis.io web site.
 
+########################## CLUSTER DOCKER/NAT support  ########################
+
+# In certain deployments, Redis Cluster nodes address discovery fails, because
+# addresses are NAT-ted or because ports are forwarded (the typical case is
+# Docker and other containers).
+#
+# In order to make Redis Cluster working in such environments, a static
+# configuration where each node known its public address is needed. The
+# following two options are used for this scope, and are:
+#
+# * cluster-announce-ip
+# * cluster-announce-port
+# * cluster-announce-bus-port
+#
+# Each instruct the node about its address, client port, and cluster message
+# bus port. The information is then published in the header of the bus packets
+# so that other nodes will be able to correctly map the address of the node
+# publishing the information.
+#
+# If the above options are not used, the normal Redis Cluster auto-detection
+# will be used instead.
+#
+# Note that when remapped, the bus port may not be at the fixed offset of
+# clients port + 10000, so you can specify any port and bus-port depending
+# on how they get remapped. If the bus-port is not set, a fixed offset of
+# 10000 will be used as usually.
+#
+# Example:
+#
+# cluster-announce-ip 10.1.1.5
+# cluster-announce-port 6379
+# cluster-announce-bus-port 6380
+
 ################################## SLOW LOG ###################################
 
 # The Redis Slow Log is a system to log queries that exceeded a specified
 # execution time. The execution time does not include the I/O operations
 # like talking with the client, sending the reply and so forth,
 # but just the time needed to actually execute the command (this is the only
@@ -1047,6 +1173,121 @@
 
 # When a child rewrites the AOF file, if the following option is enabled
 # the file will be fsync-ed every 32 MB of data generated. This is useful
 # in order to commit the file to the disk more incrementally and avoid
 # big latency spikes.
 aof-rewrite-incremental-fsync yes
+
+# Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good
+# idea to start with the default settings and only change them after investigating
+# how to improve the performances and how the keys LFU change over time, which
+# is possible to inspect via the OBJECT FREQ command.
+#
+# There are two tunable parameters in the Redis LFU implementation: the
+# counter logarithm factor and the counter decay time. It is important to
+# understand what the two parameters mean before changing them.
+#
+# The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis
+# uses a probabilistic increment with logarithmic behavior. Given the value
+# of the old counter, when a key is accessed, the counter is incremented in
+# this way:
+#
+# 1. A random number R between 0 and 1 is extracted.
+# 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).
+# 3. The counter is incremented only if R < P.
+#
+# The default lfu-log-factor is 10. This is a table of how the frequency
+# counter changes with a different number of accesses with different
+# logarithmic factors:
+#
+# +--------+------------+------------+------------+------------+------------+
+# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
+# +--------+------------+------------+------------+------------+------------+
+# | 0      | 104        | 255        | 255        | 255        | 255        |
+# +--------+------------+------------+------------+------------+------------+
+# | 1      | 18         | 49         | 255        | 255        | 255        |
+# +--------+------------+------------+------------+------------+------------+
+# | 10     | 10         | 18         | 142        | 255        | 255        |
+# +--------+------------+------------+------------+------------+------------+
+# | 100    | 8          | 11         | 49         | 143        | 255        |
+# +--------+------------+------------+------------+------------+------------+
+#
+# NOTE: The above table was obtained by running the following commands:
+#
+#   redis-benchmark -n 1000000 incr foo
+#   redis-cli object freq foo
+#
+# NOTE 2: The counter initial value is 5 in order to give new objects a chance
+# to accumulate hits.
+#
+# The counter decay time is the time, in minutes, that must elapse in order
+# for the key counter to be divided by two (or decremented if it has a value
+# less <= 10).
+#
+# The default value for the lfu-decay-time is 1. A Special value of 0 means to
+# decay the counter every time it happens to be scanned.
+#
+# lfu-log-factor 10
+# lfu-decay-time 1
+
+########################### ACTIVE DEFRAGMENTATION #######################
+#
+# WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested
+# even in production and manually tested by multiple engineers for some
+# time.
+#
+# What is active defragmentation?
+# -------------------------------
+#
+# Active (online) defragmentation allows a Redis server to compact the
+# spaces left between small allocations and deallocations of data in memory,
+# thus allowing to reclaim back memory.
+#
+# Fragmentation is a natural process that happens with every allocator (but
+# less so with Jemalloc, fortunately) and certain workloads. Normally a server
+# restart is needed in order to lower the fragmentation, or at least to flush
+# away all the data and create it again. However thanks to this feature
+# implemented by Oran Agra for Redis 4.0 this process can happen at runtime
+# in an "hot" way, while the server is running.
+#
+# Basically when the fragmentation is over a certain level (see the
+# configuration options below) Redis will start to create new copies of the
+# values in contiguous memory regions by exploiting certain specific Jemalloc
+# features (in order to understand if an allocation is causing fragmentation
+# and to allocate it in a better place), and at the same time, will release the
+# old copies of the data. This process, repeated incrementally for all the keys
+# will cause the fragmentation to drop back to normal values.
+#
+# Important things to understand:
+#
+# 1. This feature is disabled by default, and only works if you compiled Redis
+#    to use the copy of Jemalloc we ship with the source code of Redis.
+#    This is the default with Linux builds.
+#
+# 2. You never need to enable this feature if you don't have fragmentation
+#    issues.
+#
+# 3. Once you experience fragmentation, you can enable this feature when
+#    needed with the command "CONFIG SET activedefrag yes".
+#
+# The configuration parameters are able to fine tune the behavior of the
+# defragmentation process. If you are not sure about what they mean it is
+# a good idea to leave the defaults untouched.
+
+# Enabled active defragmentation
+# activedefrag yes
+
+# Minimum amount of fragmentation waste to start active defrag
+# active-defrag-ignore-bytes 100mb
+
+# Minimum percentage of fragmentation to start active defrag
+# active-defrag-threshold-lower 10
+
+# Maximum percentage of fragmentation at which we use maximum effort
+# active-defrag-threshold-upper 100
+
+# Minimal effort for defrag in CPU percentage
+# active-defrag-cycle-min 25
+
+# Maximal effort for defrag in CPU percentage
+# active-defrag-cycle-max 75
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c	2017-07-14 19:28:42.000000000 +0800
@@ -49,28 +49,36 @@
     list->dup = NULL;
     list->free = NULL;
     list->match = NULL;
     return list;
 }
 
-/* Free the whole list.
- *
- * This function can't fail. */
-void listRelease(list *list)
+/* Remove all the elements from the list without destroying the list itself. */
+void listEmpty(list *list)
 {
     unsigned long len;
     listNode *current, *next;
 
     current = list->head;
     len = list->len;
     while(len--) {
         next = current->next;
         if (list->free) list->free(current->value);
         zfree(current);
         current = next;
     }
+    list->head = list->tail = NULL;
+    list->len = 0;
+}
+
+/* Free the whole list.
+ *
+ * This function can't fail. */
+void listRelease(list *list)
+{
+    listEmpty(list);
     zfree(list);
 }
 
 /* Add a new node to the list, to head, containing the specified 'value'
  * pointer as value.
  *
@@ -330,6 +338,25 @@
     /* Move it as head */
     list->head->prev = tail;
     tail->prev = NULL;
     tail->next = list->head;
     list->head = tail;
 }
+
+/* Add all the elements of the list 'o' at the end of the
+ * list 'l'. The list 'other' remains empty but otherwise valid. */
+void listJoin(list *l, list *o) {
+    if (o->head)
+        o->head->prev = l->tail;
+
+    if (l->tail)
+        l->tail->next = o->head;
+    else
+        l->head = o->head;
+
+    l->tail = o->tail;
+    l->len += o->len;
+
+    /* Setup other as an empty list. */
+    o->head = o->tail = NULL;
+    o->len = 0;
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.h	2017-07-14 19:28:42.000000000 +0800
@@ -69,12 +69,13 @@
 #define listGetFree(l) ((l)->free)
 #define listGetMatchMethod(l) ((l)->match)
 
 /* Prototypes */
 list *listCreate(void);
 void listRelease(list *list);
+void listEmpty(list *list);
 list *listAddNodeHead(list *list, void *value);
 list *listAddNodeTail(list *list, void *value);
 list *listInsertNode(list *list, listNode *old_node, void *value, int after);
 void listDelNode(list *list, listNode *node);
 listIter *listGetIterator(list *list, int direction);
 listNode *listNext(listIter *iter);
@@ -82,12 +83,13 @@
 list *listDup(list *orig);
 listNode *listSearchKey(list *list, void *key);
 listNode *listIndex(list *list, long index);
 void listRewind(list *list, listIter *li);
 void listRewindTail(list *list, listIter *li);
 void listRotate(list *list);
+void listJoin(list *l, list *o);
 
 /* Directions for iterators */
 #define AL_START_HEAD 0
 #define AL_START_TAIL 1
 
 #endif /* __ADLIST_H__ */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.c	2017-07-14 19:28:42.000000000 +0800
@@ -72,12 +72,13 @@
     eventLoop->lastTime = time(NULL);
     eventLoop->timeEventHead = NULL;
     eventLoop->timeEventNextId = 0;
     eventLoop->stop = 0;
     eventLoop->maxfd = -1;
     eventLoop->beforesleep = NULL;
+    eventLoop->aftersleep = NULL;
     if (aeApiCreate(eventLoop) == -1) goto err;
     /* Events with mask == AE_NONE are not set. So let's initialize the
      * vector with it. */
     for (i = 0; i < setsize; i++)
         eventLoop->events[i].mask = AE_NONE;
     return eventLoop;
@@ -340,12 +341,13 @@
  *
  * If flags is 0, the function does nothing and returns.
  * if flags has AE_ALL_EVENTS set, all the kind of events are processed.
  * if flags has AE_FILE_EVENTS set, file events are processed.
  * if flags has AE_TIME_EVENTS set, time events are processed.
  * if flags has AE_DONT_WAIT set the function returns ASAP until all
+ * if flags has AE_CALL_AFTER_SLEEP set, the aftersleep callback is called.
  * the events that's possible to process without to wait are processed.
  *
  * The function returns the number of events processed. */
 int aeProcessEvents(aeEventLoop *eventLoop, int flags)
 {
     int processed = 0, numevents;
@@ -394,13 +396,20 @@
             } else {
                 /* Otherwise we can block */
                 tvp = NULL; /* wait forever */
             }
         }
 
+        /* Call the multiplexing API, will return only on timeout or when
+         * some event fires. */
         numevents = aeApiPoll(eventLoop, tvp);
+
+        /* After sleep callback. */
+        if (eventLoop->aftersleep != NULL && flags & AE_CALL_AFTER_SLEEP)
+            eventLoop->aftersleep(eventLoop);
+
         for (j = 0; j < numevents; j++) {
             aeFileEvent *fe = &eventLoop->events[eventLoop->fired[j].fd];
             int mask = eventLoop->fired[j].mask;
             int fd = eventLoop->fired[j].fd;
             int rfired = 0;
 
@@ -449,17 +458,21 @@
 
 void aeMain(aeEventLoop *eventLoop) {
     eventLoop->stop = 0;
     while (!eventLoop->stop) {
         if (eventLoop->beforesleep != NULL)
             eventLoop->beforesleep(eventLoop);
-        aeProcessEvents(eventLoop, AE_ALL_EVENTS);
+        aeProcessEvents(eventLoop, AE_ALL_EVENTS|AE_CALL_AFTER_SLEEP);
     }
 }
 
 char *aeGetApiName(void) {
     return aeApiName();
 }
 
 void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {
     eventLoop->beforesleep = beforesleep;
 }
+
+void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) {
+    eventLoop->aftersleep = aftersleep;
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.h	2017-07-14 19:28:42.000000000 +0800
@@ -43,12 +43,13 @@
 #define AE_WRITABLE 2
 
 #define AE_FILE_EVENTS 1
 #define AE_TIME_EVENTS 2
 #define AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)
 #define AE_DONT_WAIT 4
+#define AE_CALL_AFTER_SLEEP 8
 
 #define AE_NOMORE -1
 #define AE_DELETED_EVENT_ID -1
 
 /* Macros */
 #define AE_NOTUSED(V) ((void) V)
@@ -95,12 +96,13 @@
     aeFileEvent *events; /* Registered events */
     aeFiredEvent *fired; /* Fired events */
     aeTimeEvent *timeEventHead;
     int stop;
     void *apidata; /* This is used for polling API specific data */
     aeBeforeSleepProc *beforesleep;
+    aeBeforeSleepProc *aftersleep;
 } aeEventLoop;
 
 /* Prototypes */
 aeEventLoop *aeCreateEventLoop(int setsize);
 void aeDeleteEventLoop(aeEventLoop *eventLoop);
 void aeStop(aeEventLoop *eventLoop);
@@ -114,10 +116,11 @@
 int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);
 int aeProcessEvents(aeEventLoop *eventLoop, int flags);
 int aeWait(int fd, int mask, long long milliseconds);
 void aeMain(aeEventLoop *eventLoop);
 char *aeGetApiName(void);
 void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);
+void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep);
 int aeGetSetSize(aeEventLoop *eventLoop);
 int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.c	2017-07-14 19:28:42.000000000 +0800
@@ -377,14 +377,16 @@
     if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
         return ANET_ERR;
 
     sa.sun_family = AF_LOCAL;
     strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);
     if (flags & ANET_CONNECT_NONBLOCK) {
-        if (anetNonBlock(err,s) != ANET_OK)
+        if (anetNonBlock(err,s) != ANET_OK) {
+            close(s);
             return ANET_ERR;
+        }
     }
     if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {
         if (errno == EINPROGRESS &&
             flags & ANET_CONNECT_NONBLOCK)
             return s;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.c	2017-07-14 19:28:42.000000000 +0800
@@ -630,32 +630,58 @@
 int loadAppendOnlyFile(char *filename) {
     struct client *fakeClient;
     FILE *fp = fopen(filename,"r");
     struct redis_stat sb;
     int old_aof_state = server.aof_state;
     long loops = 0;
-    off_t valid_up_to = 0; /* Offset of the latest well-formed command loaded. */
+    off_t valid_up_to = 0; /* Offset of latest well-formed command loaded. */
 
+    if (fp == NULL) {
+        serverLog(LL_WARNING,"Fatal error: can't open the append log file for reading: %s",strerror(errno));
+        exit(1);
+    }
+
+    /* Handle a zero-length AOF file as a special case. An emtpy AOF file
+     * is a valid AOF because an empty server with AOF enabled will create
+     * a zero length file at startup, that will remain like that if no write
+     * operation is received. */
     if (fp && redis_fstat(fileno(fp),&sb) != -1 && sb.st_size == 0) {
         server.aof_current_size = 0;
         fclose(fp);
         return C_ERR;
     }
 
-    if (fp == NULL) {
-        serverLog(LL_WARNING,"Fatal error: can't open the append log file for reading: %s",strerror(errno));
-        exit(1);
-    }
-
     /* Temporarily disable AOF, to prevent EXEC from feeding a MULTI
      * to the same file we're about to read. */
     server.aof_state = AOF_OFF;
 
     fakeClient = createFakeClient();
     startLoading(fp);
 
+    /* Check if this AOF file has an RDB preamble. In that case we need to
+     * load the RDB file and later continue loading the AOF tail. */
+    char sig[5]; /* "REDIS" */
+    if (fread(sig,1,5,fp) != 5 || memcmp(sig,"REDIS",5) != 0) {
+        /* No RDB preamble, seek back at 0 offset. */
+        if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
+    } else {
+        /* RDB preamble. Pass loading the RDB functions. */
+        rio rdb;
+
+        serverLog(LL_NOTICE,"Reading RDB preamble from AOF file...");
+        if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
+        rioInitWithFile(&rdb,fp);
+        if (rdbLoadRio(&rdb,NULL) != C_OK) {
+            serverLog(LL_WARNING,"Error reading the RDB preamble of the AOF file, AOF loading aborted");
+            goto readerr;
+        } else {
+            serverLog(LL_NOTICE,"Reading the remaining AOF tail...");
+        }
+    }
+
+    /* Read the actual AOF file, in REPL format, command by command. */
     while(1) {
         int argc, j;
         unsigned long len;
         robj **argv;
         char buf[128];
         sds argsds;
@@ -710,22 +736,24 @@
         if (!cmd) {
             serverLog(LL_WARNING,"Unknown command '%s' reading the append only file", (char*)argv[0]->ptr);
             exit(1);
         }
 
         /* Run the command in the context of a fake client */
+        fakeClient->cmd = cmd;
         cmd->proc(fakeClient);
 
         /* The fake client should not have a reply */
         serverAssert(fakeClient->bufpos == 0 && listLength(fakeClient->reply) == 0);
         /* The fake client should never get blocked */
         serverAssert((fakeClient->flags & CLIENT_BLOCKED) == 0);
 
         /* Clean up. Command code may have changed argv/argc so we use the
          * argv/argc of the client instead of the local variables. */
         freeFakeClientArgv(fakeClient);
+        fakeClient->cmd = NULL;
         if (server.aof_load_truncated) valid_up_to = ftello(fp);
     }
 
     /* This point can only be reached when EOF is reached without errors.
      * If the client is in the middle of a MULTI/EXEC, log error and quit. */
     if (fakeClient->flags & CLIENT_MULTI) goto uxeof;
@@ -857,22 +885,22 @@
         }
     } else if (o->encoding == OBJ_ENCODING_HT) {
         dictIterator *di = dictGetIterator(o->ptr);
         dictEntry *de;
 
         while((de = dictNext(di)) != NULL) {
-            robj *eleobj = dictGetKey(de);
+            sds ele = dictGetKey(de);
             if (count == 0) {
                 int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                     AOF_REWRITE_ITEMS_PER_CMD : items;
 
                 if (rioWriteBulkCount(r,'*',2+cmd_items) == 0) return 0;
                 if (rioWriteBulkString(r,"SADD",4) == 0) return 0;
                 if (rioWriteBulkObject(r,key) == 0) return 0;
             }
-            if (rioWriteBulkObject(r,eleobj) == 0) return 0;
+            if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
             if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
         dictReleaseIterator(di);
     } else {
         serverPanic("Unknown set encoding");
@@ -923,25 +951,25 @@
     } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = o->ptr;
         dictIterator *di = dictGetIterator(zs->dict);
         dictEntry *de;
 
         while((de = dictNext(di)) != NULL) {
-            robj *eleobj = dictGetKey(de);
+            sds ele = dictGetKey(de);
             double *score = dictGetVal(de);
 
             if (count == 0) {
                 int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                     AOF_REWRITE_ITEMS_PER_CMD : items;
 
                 if (rioWriteBulkCount(r,'*',2+cmd_items*2) == 0) return 0;
                 if (rioWriteBulkString(r,"ZADD",4) == 0) return 0;
                 if (rioWriteBulkObject(r,key) == 0) return 0;
             }
             if (rioWriteBulkDouble(r,*score) == 0) return 0;
-            if (rioWriteBulkObject(r,eleobj) == 0) return 0;
+            if (rioWriteBulkString(r,ele,sdslen(ele)) == 0) return 0;
             if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
             items--;
         }
         dictReleaseIterator(di);
     } else {
         serverPanic("Unknown sorted zset encoding");
@@ -959,23 +987,19 @@
     if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
-        if (vstr) {
+        if (vstr)
             return rioWriteBulkString(r, (char*)vstr, vlen);
-        } else {
+        else
             return rioWriteBulkLongLong(r, vll);
-        }
-
     } else if (hi->encoding == OBJ_ENCODING_HT) {
-        robj *value;
-
-        hashTypeCurrentFromHashTable(hi, what, &value);
-        return rioWriteBulkObject(r, value);
+        sds value = hashTypeCurrentFromHashTable(hi, what);
+        return rioWriteBulkString(r, value, sdslen(value));
     }
 
     serverPanic("Unknown hash encoding");
     return 0;
 }
 
@@ -1004,12 +1028,28 @@
 
     hashTypeReleaseIterator(hi);
 
     return 1;
 }
 
+/* Call the module type callback in order to rewrite a data type
+ * that is exported by a module and is not handled by Redis itself.
+ * The function returns 0 on error, 1 on success. */
+int rewriteModuleObject(rio *r, robj *key, robj *o) {
+    RedisModuleIO io;
+    moduleValue *mv = o->ptr;
+    moduleType *mt = mv->type;
+    moduleInitIOContext(io,mt,r);
+    mt->aof_rewrite(&io,key,mv->value);
+    if (io.ctx) {
+        moduleFreeContext(io.ctx);
+        zfree(io.ctx);
+    }
+    return io.error ? 0 : 1;
+}
+
 /* This function is called by the child rewriting the AOF file to read
  * the difference accumulated from the parent into a buffer, that is
  * concatenated at the end of the rewrite. */
 ssize_t aofReadDiffFromParent(void) {
     char buf[65536]; /* Default pipe buffer size on most Linux systems. */
     ssize_t nread, total = 0;
@@ -1019,57 +1059,29 @@
         server.aof_child_diff = sdscatlen(server.aof_child_diff,buf,nread);
         total += nread;
     }
     return total;
 }
 
-/* Write a sequence of commands able to fully rebuild the dataset into
- * "filename". Used both by REWRITEAOF and BGREWRITEAOF.
- *
- * In order to minimize the number of commands needed in the rewritten
- * log Redis uses variadic commands when possible, such as RPUSH, SADD
- * and ZADD. However at max AOF_REWRITE_ITEMS_PER_CMD items per time
- * are inserted using a single command. */
-int rewriteAppendOnlyFile(char *filename) {
+int rewriteAppendOnlyFileRio(rio *aof) {
     dictIterator *di = NULL;
     dictEntry *de;
-    rio aof;
-    FILE *fp;
-    char tmpfile[256];
-    int j;
-    long long now = mstime();
-    char byte;
     size_t processed = 0;
+    long long now = mstime();
+    int j;
 
-    /* Note that we have to use a different temp name here compared to the
-     * one used by rewriteAppendOnlyFileBackground() function. */
-    snprintf(tmpfile,256,"temp-rewriteaof-%d.aof", (int) getpid());
-    fp = fopen(tmpfile,"w");
-    if (!fp) {
-        serverLog(LL_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", strerror(errno));
-        return C_ERR;
-    }
-
-    server.aof_child_diff = sdsempty();
-    rioInitWithFile(&aof,fp);
-    if (server.aof_rewrite_incremental_fsync)
-        rioSetAutoSync(&aof,AOF_AUTOSYNC_BYTES);
     for (j = 0; j < server.dbnum; j++) {
         char selectcmd[] = "*2\r\n$6\r\nSELECT\r\n";
         redisDb *db = server.db+j;
         dict *d = db->dict;
         if (dictSize(d) == 0) continue;
         di = dictGetSafeIterator(d);
-        if (!di) {
-            fclose(fp);
-            return C_ERR;
-        }
 
         /* SELECT the new DB */
-        if (rioWrite(&aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
-        if (rioWriteBulkLongLong(&aof,j) == 0) goto werr;
+        if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
+        if (rioWriteBulkLongLong(aof,j) == 0) goto werr;
 
         /* Iterate this DB writing every entry */
         while((de = dictNext(di)) != NULL) {
             sds keystr;
             robj key, *o;
             long long expiretime;
@@ -1084,43 +1096,89 @@
             if (expiretime != -1 && expiretime < now) continue;
 
             /* Save the key and associated value */
             if (o->type == OBJ_STRING) {
                 /* Emit a SET command */
                 char cmd[]="*3\r\n$3\r\nSET\r\n";
-                if (rioWrite(&aof,cmd,sizeof(cmd)-1) == 0) goto werr;
+                if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
                 /* Key and value */
-                if (rioWriteBulkObject(&aof,&key) == 0) goto werr;
-                if (rioWriteBulkObject(&aof,o) == 0) goto werr;
+                if (rioWriteBulkObject(aof,&key) == 0) goto werr;
+                if (rioWriteBulkObject(aof,o) == 0) goto werr;
             } else if (o->type == OBJ_LIST) {
-                if (rewriteListObject(&aof,&key,o) == 0) goto werr;
+                if (rewriteListObject(aof,&key,o) == 0) goto werr;
             } else if (o->type == OBJ_SET) {
-                if (rewriteSetObject(&aof,&key,o) == 0) goto werr;
+                if (rewriteSetObject(aof,&key,o) == 0) goto werr;
             } else if (o->type == OBJ_ZSET) {
-                if (rewriteSortedSetObject(&aof,&key,o) == 0) goto werr;
+                if (rewriteSortedSetObject(aof,&key,o) == 0) goto werr;
             } else if (o->type == OBJ_HASH) {
-                if (rewriteHashObject(&aof,&key,o) == 0) goto werr;
+                if (rewriteHashObject(aof,&key,o) == 0) goto werr;
+            } else if (o->type == OBJ_MODULE) {
+                if (rewriteModuleObject(aof,&key,o) == 0) goto werr;
             } else {
                 serverPanic("Unknown object type");
             }
             /* Save the expire time */
             if (expiretime != -1) {
                 char cmd[]="*3\r\n$9\r\nPEXPIREAT\r\n";
-                if (rioWrite(&aof,cmd,sizeof(cmd)-1) == 0) goto werr;
-                if (rioWriteBulkObject(&aof,&key) == 0) goto werr;
-                if (rioWriteBulkLongLong(&aof,expiretime) == 0) goto werr;
+                if (rioWrite(aof,cmd,sizeof(cmd)-1) == 0) goto werr;
+                if (rioWriteBulkObject(aof,&key) == 0) goto werr;
+                if (rioWriteBulkLongLong(aof,expiretime) == 0) goto werr;
             }
             /* Read some diff from the parent process from time to time. */
-            if (aof.processed_bytes > processed+1024*10) {
-                processed = aof.processed_bytes;
+            if (aof->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES) {
+                processed = aof->processed_bytes;
                 aofReadDiffFromParent();
             }
         }
         dictReleaseIterator(di);
         di = NULL;
     }
+    return C_OK;
+
+werr:
+    if (di) dictReleaseIterator(di);
+    return C_ERR;
+}
+
+/* Write a sequence of commands able to fully rebuild the dataset into
+ * "filename". Used both by REWRITEAOF and BGREWRITEAOF.
+ *
+ * In order to minimize the number of commands needed in the rewritten
+ * log Redis uses variadic commands when possible, such as RPUSH, SADD
+ * and ZADD. However at max AOF_REWRITE_ITEMS_PER_CMD items per time
+ * are inserted using a single command. */
+int rewriteAppendOnlyFile(char *filename) {
+    rio aof;
+    FILE *fp;
+    char tmpfile[256];
+    char byte;
+
+    /* Note that we have to use a different temp name here compared to the
+     * one used by rewriteAppendOnlyFileBackground() function. */
+    snprintf(tmpfile,256,"temp-rewriteaof-%d.aof", (int) getpid());
+    fp = fopen(tmpfile,"w");
+    if (!fp) {
+        serverLog(LL_WARNING, "Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s", strerror(errno));
+        return C_ERR;
+    }
+
+    server.aof_child_diff = sdsempty();
+    rioInitWithFile(&aof,fp);
+
+    if (server.aof_rewrite_incremental_fsync)
+        rioSetAutoSync(&aof,AOF_AUTOSYNC_BYTES);
+
+    if (server.aof_use_rdb_preamble) {
+        int error;
+        if (rdbSaveRio(&aof,&error,RDB_SAVE_AOF_PREAMBLE,NULL) == C_ERR) {
+            errno = error;
+            goto werr;
+        }
+    } else {
+        if (rewriteAppendOnlyFileRio(&aof) == C_ERR) goto werr;
+    }
 
     /* Do an initial slow fsync here while the parent is still sending
      * data, in order to make the next final fsync faster. */
     if (fflush(fp) == EOF) goto werr;
     if (fsync(fileno(fp)) == -1) goto werr;
 
@@ -1180,13 +1238,12 @@
     return C_OK;
 
 werr:
     serverLog(LL_WARNING,"Write error writing append only file on disk: %s", strerror(errno));
     fclose(fp);
     unlink(tmpfile);
-    if (di) dictReleaseIterator(di);
     return C_ERR;
 }
 
 /* ----------------------------------------------------------------------------
  * AOF rewrite pipes for IPC
  * -------------------------------------------------------------------------- */
@@ -1280,38 +1337,43 @@
 int rewriteAppendOnlyFileBackground(void) {
     pid_t childpid;
     long long start;
 
     if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
     if (aofCreatePipes() != C_OK) return C_ERR;
+    openChildInfoPipe();
     start = ustime();
     if ((childpid = fork()) == 0) {
         char tmpfile[256];
 
         /* Child */
         closeListeningSockets(0);
         redisSetProcTitle("redis-aof-rewrite");
         snprintf(tmpfile,256,"temp-rewriteaof-bg-%d.aof", (int) getpid());
         if (rewriteAppendOnlyFile(tmpfile) == C_OK) {
-            size_t private_dirty = zmalloc_get_private_dirty();
+            size_t private_dirty = zmalloc_get_private_dirty(-1);
 
             if (private_dirty) {
                 serverLog(LL_NOTICE,
                     "AOF rewrite: %zu MB of memory used by copy-on-write",
                     private_dirty/(1024*1024));
             }
+
+            server.child_info_data.cow_size = private_dirty;
+            sendChildInfo(CHILD_INFO_TYPE_AOF);
             exitFromChild(0);
         } else {
             exitFromChild(1);
         }
     } else {
         /* Parent */
         server.stat_fork_time = ustime()-start;
         server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
         latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
         if (childpid == -1) {
+            closeChildInfoPipe();
             serverLog(LL_WARNING,
                 "Can't rewrite append only file in background: fork: %s",
                 strerror(errno));
             aofClosePipes();
             return C_ERR;
         }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: atomicvar.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.c	2017-07-14 19:28:42.000000000 +0800
@@ -60,13 +60,14 @@
 
 #include "server.h"
 #include "bio.h"
 
 static pthread_t bio_threads[BIO_NUM_OPS];
 static pthread_mutex_t bio_mutex[BIO_NUM_OPS];
-static pthread_cond_t bio_condvar[BIO_NUM_OPS];
+static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS];
+static pthread_cond_t bio_step_cond[BIO_NUM_OPS];
 static list *bio_jobs[BIO_NUM_OPS];
 /* The following array is used to hold the number of pending jobs for every
  * OP type. This allows us to export the bioPendingJobsOfType() API that is
  * useful when the main thread wants to perform some operation that may involve
  * objects shared with the background thread. The main thread will just wait
  * that there are no longer jobs of this type to be executed before performing
@@ -80,12 +81,15 @@
     /* Job specific arguments pointers. If we need to pass more than three
      * arguments we can just pass a pointer to a structure or alike. */
     void *arg1, *arg2, *arg3;
 };
 
 void *bioProcessBackgroundJobs(void *arg);
+void lazyfreeFreeObjectFromBioThread(robj *o);
+void lazyfreeFreeDatabaseFromBioThread(dict *ht1, dict *ht2);
+void lazyfreeFreeSlotsMapFromBioThread(zskiplist *sl);
 
 /* Make sure we have enough stack to perform all the things we do in the
  * main thread. */
 #define REDIS_THREAD_STACK_SIZE (1024*1024*4)
 
 /* Initialize the background system, spawning the thread. */
@@ -95,13 +99,14 @@
     size_t stacksize;
     int j;
 
     /* Initialization of state vars and objects */
     for (j = 0; j < BIO_NUM_OPS; j++) {
         pthread_mutex_init(&bio_mutex[j],NULL);
-        pthread_cond_init(&bio_condvar[j],NULL);
+        pthread_cond_init(&bio_newjob_cond[j],NULL);
+        pthread_cond_init(&bio_step_cond[j],NULL);
         bio_jobs[j] = listCreate();
         bio_pending[j] = 0;
     }
 
     /* Set the stack size as by default it may be small in some system */
     pthread_attr_init(&attr);
@@ -130,13 +135,13 @@
     job->arg1 = arg1;
     job->arg2 = arg2;
     job->arg3 = arg3;
     pthread_mutex_lock(&bio_mutex[type]);
     listAddNodeTail(bio_jobs[type],job);
     bio_pending[type]++;
-    pthread_cond_signal(&bio_condvar[type]);
+    pthread_cond_signal(&bio_newjob_cond[type]);
     pthread_mutex_unlock(&bio_mutex[type]);
 }
 
 void *bioProcessBackgroundJobs(void *arg) {
     struct bio_job *job;
     unsigned long type = (unsigned long) arg;
@@ -165,13 +170,13 @@
 
     while(1) {
         listNode *ln;
 
         /* The loop always starts with the lock hold. */
         if (listLength(bio_jobs[type]) == 0) {
-            pthread_cond_wait(&bio_condvar[type],&bio_mutex[type]);
+            pthread_cond_wait(&bio_newjob_cond[type],&bio_mutex[type]);
             continue;
         }
         /* Pop the job from the queue. */
         ln = listFirst(bio_jobs[type]);
         job = ln->value;
         /* It is now possible to unlock the background system as we know have
@@ -180,17 +185,31 @@
 
         /* Process the job accordingly to its type. */
         if (type == BIO_CLOSE_FILE) {
             close((long)job->arg1);
         } else if (type == BIO_AOF_FSYNC) {
             aof_fsync((long)job->arg1);
+        } else if (type == BIO_LAZY_FREE) {
+            /* What we free changes depending on what arguments are set:
+             * arg1 -> free the object at pointer.
+             * arg2 & arg3 -> free two dictionaries (a Redis DB).
+             * only arg3 -> free the skiplist. */
+            if (job->arg1)
+                lazyfreeFreeObjectFromBioThread(job->arg1);
+            else if (job->arg2 && job->arg3)
+                lazyfreeFreeDatabaseFromBioThread(job->arg2,job->arg3);
+            else if (job->arg3)
+                lazyfreeFreeSlotsMapFromBioThread(job->arg3);
         } else {
             serverPanic("Wrong job type in bioProcessBackgroundJobs().");
         }
         zfree(job);
 
+        /* Unblock threads blocked on bioWaitStepOfType() if any. */
+        pthread_cond_broadcast(&bio_step_cond[type]);
+
         /* Lock again before reiterating the loop, if there are no longer
          * jobs to process we'll block again in pthread_cond_wait(). */
         pthread_mutex_lock(&bio_mutex[type]);
         listDelNode(bio_jobs[type],ln);
         bio_pending[type]--;
     }
@@ -202,12 +221,34 @@
     pthread_mutex_lock(&bio_mutex[type]);
     val = bio_pending[type];
     pthread_mutex_unlock(&bio_mutex[type]);
     return val;
 }
 
+/* If there are pending jobs for the specified type, the function blocks
+ * and waits that the next job was processed. Otherwise the function
+ * does not block and returns ASAP.
+ *
+ * The function returns the number of jobs still to process of the
+ * requested type.
+ *
+ * This function is useful when from another thread, we want to wait
+ * a bio.c thread to do more work in a blocking way.
+ */
+unsigned long long bioWaitStepOfType(int type) {
+    unsigned long long val;
+    pthread_mutex_lock(&bio_mutex[type]);
+    val = bio_pending[type];
+    if (val != 0) {
+        pthread_cond_wait(&bio_step_cond[type],&bio_mutex[type]);
+        val = bio_pending[type];
+    }
+    pthread_mutex_unlock(&bio_mutex[type]);
+    return val;
+}
+
 /* Kill the running bio threads in an unclean way. This function should be
  * used only when it's critical to stop the threads for some reason.
  * Currently Redis does this only on crash (for instance on SIGSEGV) in order
  * to perform a fast memory check without other threads messing with memory. */
 void bioKillThreads(void) {
     int err, j;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.h	2017-07-14 19:28:42.000000000 +0800
@@ -28,14 +28,15 @@
  */
 
 /* Exported API */
 void bioInit(void);
 void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3);
 unsigned long long bioPendingJobsOfType(int type);
-void bioWaitPendingJobsLE(int type, unsigned long long num);
+unsigned long long bioWaitStepOfType(int type);
 time_t bioOlderJobOfType(int type);
 void bioKillThreads(void);
 
 /* Background job opcodes */
 #define BIO_CLOSE_FILE    0 /* Deferred close(2) syscall. */
 #define BIO_AOF_FSYNC     1 /* Deferred AOF fsync. */
-#define BIO_NUM_OPS       2
+#define BIO_LAZY_FREE     2 /* Deferred objects freeing. */
+#define BIO_NUM_OPS       3
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.c	2017-07-14 19:28:42.000000000 +0800
@@ -101,12 +101,13 @@
 long redisBitpos(void *s, unsigned long count, int bit) {
     unsigned long *l;
     unsigned char *c;
     unsigned long skipval, word = 0, one;
     long pos = 0; /* Position of bit, to return to the caller. */
     unsigned long j;
+    int found;
 
     /* Process whole words first, seeking for first word that is not
      * all ones or all zeros respectively if we are lookig for zeros
      * or ones. This is much faster with large strings having contiguous
      * blocks of 1 or 0 bits compared to the vanilla bit per bit processing.
      *
@@ -114,27 +115,33 @@
      * to sizeof(unsigned long) we consume it byte by byte until it is
      * aligned. */
 
     /* Skip initial bits not aligned to sizeof(unsigned long) byte by byte. */
     skipval = bit ? 0 : UCHAR_MAX;
     c = (unsigned char*) s;
+    found = 0;
     while((unsigned long)c & (sizeof(*l)-1) && count) {
-        if (*c != skipval) break;
+        if (*c != skipval) {
+            found = 1;
+            break;
+        }
         c++;
         count--;
         pos += 8;
     }
 
     /* Skip bits with full word step. */
-    skipval = bit ? 0 : ULONG_MAX;
     l = (unsigned long*) c;
-    while (count >= sizeof(*l)) {
-        if (*l != skipval) break;
-        l++;
-        count -= sizeof(*l);
-        pos += sizeof(*l)*8;
+    if (!found) {
+        skipval = bit ? 0 : ULONG_MAX;
+        while (count >= sizeof(*l)) {
+            if (*l != skipval) break;
+            l++;
+            count -= sizeof(*l);
+            pos += sizeof(*l)*8;
+        }
     }
 
     /* Load bytes into "word" considering the first byte as the most significant
      * (we basically consider it as written in big endian, since we consider the
      * string as a set of bits from left to right, with the first bit at position
      * zero.
@@ -651,14 +658,17 @@
         res = (unsigned char*) sdsnewlen(NULL,maxlen);
         unsigned char output, byte;
         unsigned long i;
 
         /* Fast path: as far as we have data for all the input bitmaps we
          * can take a fast path that performs much better than the
-         * vanilla algorithm. */
+         * vanilla algorithm. On ARM we skip the fast path since it will
+         * result in GCC compiling the code using multiple-words load/store
+         * operations that are not supported even in ARM >= v6. */
         j = 0;
+        #ifndef USE_ALIGNED_ACCESS
         if (minlen >= sizeof(unsigned long)*4 && numkeys <= 16) {
             unsigned long *lp[16];
             unsigned long *lres = (unsigned long*) res;
 
             /* Note: sds pointer is always aligned to 8 byte boundary. */
             memcpy(lp,src,sizeof(unsigned long*)*numkeys);
@@ -713,12 +723,13 @@
                     lres+=4;
                     j += sizeof(unsigned long)*4;
                     minlen -= sizeof(unsigned long)*4;
                 }
             }
         }
+        #endif
 
         /* j is set to the next byte to process by the previous loop. */
         for (; j < maxlen; j++) {
             output = (len[0] <= j) ? 0 : src[0][j];
             if (op == BITOP_NOT) output = ~output;
             for (i = 1; i < numkeys; i++) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.c	2017-07-14 19:28:42.000000000 +0800
@@ -133,12 +133,14 @@
  * of operation the client is blocking for. */
 void unblockClient(client *c) {
     if (c->btype == BLOCKED_LIST) {
         unblockClientWaitingData(c);
     } else if (c->btype == BLOCKED_WAIT) {
         unblockClientWaitingReplicas(c);
+    } else if (c->btype == BLOCKED_MODULE) {
+        unblockClientFromModule(c);
     } else {
         serverPanic("Unknown btype in unblockClient().");
     }
     /* Clear the flags, and put the client in the unblocked list so that
      * we'll process new commands in its query buffer ASAP. */
     c->flags &= ~CLIENT_BLOCKED;
@@ -150,18 +152,21 @@
         c->flags |= CLIENT_UNBLOCKED;
         listAddNodeTail(server.unblocked_clients,c);
     }
 }
 
 /* This function gets called when a blocked client timed out in order to
- * send it a reply of some kind. */
+ * send it a reply of some kind. After this function is called,
+ * unblockClient() will be called with the same client as argument. */
 void replyToBlockedClientTimedOut(client *c) {
     if (c->btype == BLOCKED_LIST) {
         addReply(c,shared.nullmultibulk);
     } else if (c->btype == BLOCKED_WAIT) {
         addReplyLongLong(c,replicationCountAcksByOffset(c->bpop.reploffset));
+    } else if (c->btype == BLOCKED_MODULE) {
+        moduleBlockedClientTimedOut(c);
     } else {
         serverPanic("Unknown btype in replyToBlockedClientTimedOut().");
     }
 }
 
 /* Mass-unblock clients because something changed in the instance that makes
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/build_ir.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/build_ir.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/build_ir.sh	2017-09-27 22:54:19.830949305 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/build_ir.sh	2017-09-27 23:07:10.130921074 +0800
@@ -11,642 +11,687 @@
 	then
 		succ=`expr $succ + 1`;
 	fi
 	total=`expr $total + 1`;
 }
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c.bc
 check
-echo "1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.c to bc" >&2
+echo "1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.c.bc
 check
-echo "2 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.c to bc" >&2
+echo "2 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.c.bc
 check
-echo "3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.c to bc" >&2
+echo "3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.c.bc
 check
-echo "4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.c to bc" >&2
+echo "4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise/linenoise.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise/linenoise.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.c.bc
 check
-echo "5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise/linenoise.c to bc" >&2
+echo "5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lapi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lapi.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/read.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/read.c.bc
 check
-echo "6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lapi.c to bc" >&2
+echo "6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/read.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lcode.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lcode.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise/linenoise.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise/linenoise.c.bc
 check
-echo "7 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lcode.c to bc" >&2
+echo "7 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise/linenoise.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldebug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldebug.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lapi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lapi.c.bc
 check
-echo "8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldebug.c to bc" >&2
+echo "8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lapi.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldo.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lcode.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lcode.c.bc
 check
-echo "9 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldo.c to bc" >&2
+echo "9 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lcode.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldebug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldebug.c.bc
 check
-echo "10 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldump.c to bc" >&2
+echo "10 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldebug.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lfunc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lfunc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldo.c.bc
 check
-echo "11 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lfunc.c to bc" >&2
+echo "11 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldo.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lgc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lgc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldump.c.bc
 check
-echo "12 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lgc.c to bc" >&2
+echo "12 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldump.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/llex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/llex.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lfunc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lfunc.c.bc
 check
-echo "13 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/llex.c to bc" >&2
+echo "13 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lfunc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmem.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmem.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lgc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lgc.c.bc
 check
-echo "14 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmem.c to bc" >&2
+echo "14 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lgc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lobject.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lobject.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/llex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/llex.c.bc
 check
-echo "15 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lobject.c to bc" >&2
+echo "15 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/llex.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lopcodes.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lopcodes.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmem.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmem.c.bc
 check
-echo "16 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lopcodes.c to bc" >&2
+echo "16 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmem.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lparser.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lparser.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lobject.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lobject.c.bc
 check
-echo "17 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lparser.c to bc" >&2
+echo "17 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lobject.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstate.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lopcodes.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lopcodes.c.bc
 check
-echo "18 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstate.c to bc" >&2
+echo "18 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lopcodes.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstring.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstring.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lparser.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lparser.c.bc
 check
-echo "19 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstring.c to bc" >&2
+echo "19 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lparser.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltable.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltable.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstate.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstate.c.bc
 check
-echo "20 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltable.c to bc" >&2
+echo "20 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstate.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltm.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstring.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstring.c.bc
 check
-echo "21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltm.c to bc" >&2
+echo "21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstring.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lundump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lundump.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltable.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltable.c.bc
 check
-echo "22 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lundump.c to bc" >&2
+echo "22 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltable.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lvm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lvm.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltm.c.bc
 check
-echo "23 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lvm.c to bc" >&2
+echo "23 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltm.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lzio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lzio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lundump.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lundump.c.bc
 check
-echo "24 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lzio.c to bc" >&2
+echo "24 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lundump.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/strbuf.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/strbuf.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lvm.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lvm.c.bc
 check
-echo "25 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/strbuf.c to bc" >&2
+echo "25 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lvm.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/fpconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/fpconv.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lzio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lzio.c.bc
 check
-echo "26 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/fpconv.c to bc" >&2
+echo "26 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lzio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lauxlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lauxlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/strbuf.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/strbuf.c.bc
 check
-echo "27 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lauxlib.c to bc" >&2
+echo "27 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/strbuf.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lbaselib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lbaselib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/fpconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/fpconv.c.bc
 check
-echo "28 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lbaselib.c to bc" >&2
+echo "28 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/fpconv.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldblib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldblib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lauxlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lauxlib.c.bc
 check
-echo "29 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldblib.c to bc" >&2
+echo "29 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lauxlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/liolib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/liolib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lbaselib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lbaselib.c.bc
 check
-echo "30 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/liolib.c to bc" >&2
+echo "30 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lbaselib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmathlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmathlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldblib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldblib.c.bc
 check
-echo "31 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmathlib.c to bc" >&2
+echo "31 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldblib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loslib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loslib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/liolib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/liolib.c.bc
 check
-echo "32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loslib.c to bc" >&2
+echo "32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/liolib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltablib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltablib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmathlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmathlib.c.bc
 check
-echo "33 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltablib.c to bc" >&2
+echo "33 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmathlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstrlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstrlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loslib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loslib.c.bc
 check
-echo "34 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstrlib.c to bc" >&2
+echo "34 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loslib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loadlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loadlib.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltablib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltablib.c.bc
 check
-echo "35 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loadlib.c to bc" >&2
+echo "35 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltablib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/linit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/linit.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstrlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstrlib.c.bc
 check
-echo "36 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/linit.c to bc" >&2
+echo "36 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstrlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cjson.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cjson.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loadlib.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loadlib.c.bc
 check
-echo "37 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cjson.c to bc" >&2
+echo "37 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loadlib.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_struct.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_struct.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/linit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/linit.c.bc
 check
-echo "38 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_struct.c to bc" >&2
+echo "38 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/linit.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cmsgpack.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cmsgpack.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cjson.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cjson.c.bc
 check
-echo "39 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cmsgpack.c to bc" >&2
+echo "39 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cjson.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_bit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_bit.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_struct.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_struct.c.bc
 check
-echo "40 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_bit.c to bc" >&2
+echo "40 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_struct.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cmsgpack.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cmsgpack.c.bc
 check
-echo "41 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua.c to bc" >&2
+echo "41 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cmsgpack.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/luac.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/luac.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_bit.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_bit.c.bc
 check
-echo "42 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/luac.c to bc" >&2
+echo "42 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_bit.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src
-clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/print.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/print.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua.c.bc
 check
-echo "43 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/print.c to bc" >&2
+echo "43 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/luac.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/luac.c.bc
 check
-echo "44 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash.c to bc" >&2
+echo "44 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/luac.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash_helper.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash_helper.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src
+clang -g -emit-llvm -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/print.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/print.c.bc
 check
-echo "45 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash_helper.c to bc" >&2
+echo "45 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/print.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c.bc
 check
-echo "46 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c to bc" >&2
+echo "46 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -c /tmp/cg6oQxAn/dummy.c -o /tmp/cg6oQxAn/dummy.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -c /tmp/cgFqjaAd/dummy.c -o /tmp/cgFqjaAd/dummy.c.bc
 check
-echo "47 /tmp/cg6oQxAn/dummy.c to bc" >&2
+echo "47 /tmp/cgFqjaAd/dummy.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c.bc
 check
-echo "48 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c to bc" >&2
+echo "48 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/arena.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/arena.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/arena.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/arena.c.bc
 check
-echo "49 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/arena.c to bc" >&2
+echo "49 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/arena.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/atomic.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/atomic.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/atomic.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/atomic.c.bc
 check
-echo "50 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/atomic.c to bc" >&2
+echo "50 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/atomic.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/base.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/base.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/base.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/base.c.bc
 check
-echo "51 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/base.c to bc" >&2
+echo "51 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/base.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/bitmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/bitmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/bitmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/bitmap.c.bc
 check
-echo "52 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/bitmap.c to bc" >&2
+echo "52 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/bitmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk.c.bc
 check
-echo "53 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk.c to bc" >&2
+echo "53 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_dss.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_dss.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_dss.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_dss.c.bc
 check
-echo "54 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_dss.c to bc" >&2
+echo "54 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_dss.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_mmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_mmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_mmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_mmap.c.bc
 check
-echo "55 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_mmap.c to bc" >&2
+echo "55 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_mmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ckh.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ckh.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ckh.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ckh.c.bc
 check
-echo "56 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ckh.c to bc" >&2
+echo "56 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ckh.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ctl.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ctl.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ctl.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ctl.c.bc
 check
-echo "57 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ctl.c to bc" >&2
+echo "57 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ctl.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/extent.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/extent.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/extent.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/extent.c.bc
 check
-echo "58 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/extent.c to bc" >&2
+echo "58 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/extent.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/hash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/hash.c.bc
 check
-echo "59 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/hash.c to bc" >&2
+echo "59 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/hash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/huge.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/huge.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/huge.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/huge.c.bc
 check
-echo "60 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/huge.c to bc" >&2
+echo "60 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/huge.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mb.c.bc
 check
-echo "61 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mb.c to bc" >&2
+echo "61 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mutex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mutex.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mutex.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mutex.c.bc
 check
-echo "62 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mutex.c to bc" >&2
+echo "62 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mutex.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/pages.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/pages.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/pages.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/pages.c.bc
 check
-echo "63 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/pages.c to bc" >&2
+echo "63 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/pages.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/prof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/prof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/prof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/prof.c.bc
 check
-echo "64 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/prof.c to bc" >&2
+echo "64 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/prof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/quarantine.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/quarantine.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/quarantine.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/quarantine.c.bc
 check
-echo "65 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/quarantine.c to bc" >&2
+echo "65 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/quarantine.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/rtree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/rtree.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/rtree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/rtree.c.bc
 check
-echo "66 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/rtree.c to bc" >&2
+echo "66 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/rtree.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/stats.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/stats.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/stats.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/stats.c.bc
 check
-echo "67 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/stats.c to bc" >&2
+echo "67 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/stats.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tcache.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tcache.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tcache.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tcache.c.bc
 check
-echo "68 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tcache.c to bc" >&2
+echo "68 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tcache.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/util.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/util.c.bc
 check
-echo "69 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/util.c to bc" >&2
+echo "69 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/util.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc
-clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tsd.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tsd.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc
+clang -g -emit-llvm -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tsd.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tsd.c.bc
 check
-echo "70 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tsd.c to bc" >&2
+echo "70 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tsd.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.c.bc
 check
-echo "71 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.c to bc" >&2
+echo "71 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.c.bc
 check
-echo "72 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.c to bc" >&2
+echo "72 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.c.bc
 check
-echo "73 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.c to bc" >&2
+echo "73 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.c.bc
 check
-echo "74 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.c to bc" >&2
+echo "74 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.c.bc
 check
-echo "75 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.c to bc" >&2
+echo "75 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.c.bc
 check
-echo "76 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.c to bc" >&2
+echo "76 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.c.bc
 check
-echo "77 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.c to bc" >&2
+echo "77 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_c.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_c.c.bc
 check
-echo "78 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.c to bc" >&2
+echo "78 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_c.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_c.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_c.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_d.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_d.c.bc
 check
-echo "79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_c.c to bc" >&2
+echo "79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_d.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_d.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_d.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pqsort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pqsort.c.bc
 check
-echo "80 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_d.c to bc" >&2
+echo "80 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pqsort.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pqsort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pqsort.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zipmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zipmap.c.bc
 check
-echo "81 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pqsort.c to bc" >&2
+echo "81 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zipmap.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zipmap.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zipmap.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sha1.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sha1.c.bc
 check
-echo "82 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zipmap.c to bc" >&2
+echo "82 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sha1.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sha1.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sha1.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.c.bc
 check
-echo "83 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sha1.c to bc" >&2
+echo "83 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.c.bc
 check
-echo "84 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.c to bc" >&2
+echo "84 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.c.bc
 check
-echo "85 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.c to bc" >&2
+echo "85 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.c.bc
 check
-echo "86 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.c to bc" >&2
+echo "86 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.c.bc
 check
-echo "87 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.c to bc" >&2
+echo "87 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.c.bc
 check
-echo "88 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.c to bc" >&2
+echo "88 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.c.bc
 check
-echo "89 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.c to bc" >&2
+echo "89 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.c.bc
 check
-echo "90 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.c to bc" >&2
+echo "90 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.c.bc
 check
-echo "91 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.c to bc" >&2
+echo "91 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.c.bc
 check
-echo "92 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.c to bc" >&2
+echo "92 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.c.bc
 check
-echo "93 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.c to bc" >&2
+echo "93 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.c.bc
 check
-echo "94 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.c to bc" >&2
+echo "94 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.c.bc
 check
-echo "95 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.c to bc" >&2
+echo "95 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.c.bc
 check
-echo "96 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.c to bc" >&2
+echo "96 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.c.bc
 check
-echo "97 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.c to bc" >&2
+echo "97 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pubsub.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pubsub.c.bc
 check
-echo "98 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.c to bc" >&2
+echo "98 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pubsub.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pubsub.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pubsub.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.c.bc
 check
-echo "99 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pubsub.c to bc" >&2
+echo "99 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.c.bc
 check
-echo "100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.c to bc" >&2
+echo "100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.c.bc
 check
-echo "101 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.c to bc" >&2
+echo "101 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.c.bc
 check
-echo "102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.c to bc" >&2
+echo "102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/syncio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/syncio.c.bc
 check
-echo "103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.c to bc" >&2
+echo "103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/syncio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/syncio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/syncio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.c.bc
 check
-echo "104 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/syncio.c to bc" >&2
+echo "104 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc16.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc16.c.bc
 check
-echo "105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.c to bc" >&2
+echo "105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc16.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc16.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc16.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/endianconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/endianconv.c.bc
 check
-echo "106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc16.c to bc" >&2
+echo "106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/endianconv.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/endianconv.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/endianconv.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.c.bc
 check
-echo "107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/endianconv.c to bc" >&2
+echo "107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.c.bc
 check
-echo "108 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.c to bc" >&2
+echo "108 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.c.bc
 check
-echo "109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.c to bc" >&2
+echo "109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.c.bc
 check
-echo "110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.c to bc" >&2
+echo "110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rand.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rand.c.bc
 check
-echo "111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.c to bc" >&2
+echo "111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rand.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rand.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rand.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/memtest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/memtest.c.bc
 check
-echo "112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rand.c to bc" >&2
+echo "112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/memtest.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/memtest.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/memtest.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc64.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc64.c.bc
 check
-echo "113 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/memtest.c to bc" >&2
+echo "113 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc64.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc64.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc64.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.c.bc
 check
-echo "114 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc64.c to bc" >&2
+echo "114 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.c.bc
 check
-echo "115 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.c to bc" >&2
+echo "115 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/notify.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/notify.c.bc
 check
-echo "116 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.c to bc" >&2
+echo "116 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/notify.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/notify.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/notify.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/setproctitle.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/setproctitle.c.bc
 check
-echo "117 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/notify.c to bc" >&2
+echo "117 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/setproctitle.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/setproctitle.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/setproctitle.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.c.bc
 check
-echo "118 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/setproctitle.c to bc" >&2
+echo "118 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.c.bc
 check
-echo "119 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.c to bc" >&2
+echo "119 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.c.bc
 check
-echo "120 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.c to bc" >&2
+echo "120 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sparkline.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sparkline.c.bc
 check
-echo "121 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.c to bc" >&2
+echo "121 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sparkline.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sparkline.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sparkline.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.c.bc
 check
-echo "122 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sparkline.c to bc" >&2
+echo "122 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.c.bc
 check
-echo "123 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.c to bc" >&2
+echo "123 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.c.bc
 check
-echo "124 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.c to bc" >&2
+echo "124 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lazyfree.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lazyfree.c.bc
 check
-echo "125 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.c to bc" >&2
+echo "125 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lazyfree.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/module.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/module.c.bc
 check
-echo "126 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.c to bc" >&2
+echo "126 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/module.c to bc" >&2
 
-cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src
-clang -g -emit-llvm -DREDIS_STATIC= -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.c.bc
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/evict.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/evict.c.bc
 check
-echo "127 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.c to bc" >&2
+echo "127 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/evict.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/expire.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/expire.c.bc
+check
+echo "128 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/expire.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash.c.bc
+check
+echo "129 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash_helper.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash_helper.c.bc
+check
+echo "130 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash_helper.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/childinfo.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/childinfo.c.bc
+check
+echo "131 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/childinfo.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/defrag.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/defrag.c.bc
+check
+echo "132 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/defrag.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/siphash.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/siphash.c.bc
+check
+echo "133 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/siphash.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rax.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rax.c.bc
+check
+echo "134 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rax.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.c.bc
+check
+echo "135 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.c to bc" >&2
+
+cd /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src
+clang -g -emit-llvm -DREDIS_STATIC= -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.c -o /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.c.bc
+check
+echo "136 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.c to bc" >&2
 echo "Total ir $total" >&2
 echo "Succ ir $succ" >&2
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: childinfo.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: childinfo.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: childinfo.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.c	2017-07-14 19:28:42.000000000 +0800
@@ -164,13 +164,23 @@
             clusterAddNode(n);
         }
         /* Address and port */
         if ((p = strrchr(argv[1],':')) == NULL) goto fmterr;
         *p = '\0';
         memcpy(n->ip,argv[1],strlen(argv[1])+1);
-        n->port = atoi(p+1);
+        char *port = p+1;
+        char *busp = strchr(port,'@');
+        if (busp) {
+            *busp = '\0';
+            busp++;
+        }
+        n->port = atoi(port);
+        /* In older versions of nodes.conf the "@busport" part is missing.
+         * In this case we set it to the default offset of 10000 from the
+         * base port. */
+        n->cport = busp ? atoi(busp) : n->port + CLUSTER_PORT_INCR;
 
         /* Parse flags */
         p = s = argv[2];
         while(p) {
             p = strchr(s,',');
             if (p) *p = '\0';
@@ -409,14 +419,17 @@
     server.cluster->failover_auth_time = 0;
     server.cluster->failover_auth_count = 0;
     server.cluster->failover_auth_rank = 0;
     server.cluster->failover_auth_epoch = 0;
     server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
     server.cluster->lastVoteEpoch = 0;
-    server.cluster->stats_bus_messages_sent = 0;
-    server.cluster->stats_bus_messages_received = 0;
+    for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
+        server.cluster->stats_bus_messages_sent[i] = 0;
+        server.cluster->stats_bus_messages_received[i] = 0;
+    }
+    server.cluster->stats_pfail_nodes = 0;
     memset(server.cluster->slots,0, sizeof(server.cluster->slots));
     clusterCloseAllSlots();
 
     /* Lock the cluster config file to make sure every node uses
      * its own nodes.conf. */
     if (clusterLockConfig(server.cluster_configfile) == C_ERR)
@@ -462,18 +475,25 @@
                 clusterAcceptHandler, NULL) == AE_ERR)
                     serverPanic("Unrecoverable error creating Redis Cluster "
                                 "file event.");
         }
     }
 
-    /* The slots -> keys map is a sorted set. Init it. */
-    server.cluster->slots_to_keys = zslCreate();
+    /* The slots -> keys map is a radix tree. Initialize it here. */
+    server.cluster->slots_to_keys = raxNew();
+    memset(server.cluster->slots_keys_count,0,
+           sizeof(server.cluster->slots_keys_count));
 
-    /* Set myself->port to my listening port, we'll just need to discover
-     * the IP address via MEET messages. */
+    /* Set myself->port / cport to my listening ports, we'll just need to
+     * discover the IP address via MEET messages. */
     myself->port = server.port;
+    myself->cport = server.port+CLUSTER_PORT_INCR;
+    if (server.cluster_announce_port)
+        myself->port = server.cluster_announce_port;
+    if (server.cluster_announce_bus_port)
+        myself->cport = server.cluster_announce_bus_port;
 
     server.cluster->mf_end = 0;
     resetManualFailover();
 }
 
 /* Reset a node performing a soft or hard reset:
@@ -491,13 +511,13 @@
     int j;
 
     /* Turn into master. */
     if (nodeIsSlave(myself)) {
         clusterSetNodeAsMaster(myself);
         replicationUnsetMaster();
-        emptyDb(NULL);
+        emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
     }
 
     /* Close slots, reset manual failover state. */
     clusterCloseAllSlots();
     resetManualFailover();
 
@@ -666,12 +686,13 @@
     node->slaveof = NULL;
     node->ping_sent = node->pong_received = 0;
     node->fail_time = 0;
     node->link = NULL;
     memset(node->ip,0,sizeof(node->ip));
     node->port = 0;
+    node->cport = 0;
     node->fail_reports = listCreate();
     node->voted_time = 0;
     node->orphaned_time = 0;
     node->repl_offset_time = 0;
     node->repl_offset = 0;
     listSetFreeMethod(node->fail_reports,zfree);
@@ -1208,35 +1229,37 @@
     }
 }
 
 /* Return true if we already have a node in HANDSHAKE state matching the
  * specified ip address and port number. This function is used in order to
  * avoid adding a new handshake node for the same address multiple times. */
-int clusterHandshakeInProgress(char *ip, int port) {
+int clusterHandshakeInProgress(char *ip, int port, int cport) {
     dictIterator *di;
     dictEntry *de;
 
     di = dictGetSafeIterator(server.cluster->nodes);
     while((de = dictNext(di)) != NULL) {
         clusterNode *node = dictGetVal(de);
 
         if (!nodeInHandshake(node)) continue;
-        if (!strcasecmp(node->ip,ip) && node->port == port) break;
+        if (!strcasecmp(node->ip,ip) &&
+            node->port == port &&
+            node->cport == cport) break;
     }
     dictReleaseIterator(di);
     return de != NULL;
 }
 
 /* Start an handshake with the specified address if there is not one
  * already in progress. Returns non-zero if the handshake was actually
  * started. On error zero is returned and errno is set to one of the
  * following values:
  *
  * EAGAIN - There is already an handshake in progress for this address.
  * EINVAL - IP or port are not valid. */
-int clusterStartHandshake(char *ip, int port) {
+int clusterStartHandshake(char *ip, int port, int cport) {
     clusterNode *n;
     char norm_ip[NET_IP_STR_LEN];
     struct sockaddr_storage sa;
 
     /* IP sanity check */
     if (inet_pton(AF_INET,ip,
@@ -1250,13 +1273,13 @@
     } else {
         errno = EINVAL;
         return 0;
     }
 
     /* Port sanity check */
-    if (port <= 0 || port > (65535-CLUSTER_PORT_INCR)) {
+    if (port <= 0 || port > 65535 || cport <= 0 || cport > 65535) {
         errno = EINVAL;
         return 0;
     }
 
     /* Set norm_ip as the normalized string representation of the node
      * IP address. */
@@ -1267,23 +1290,24 @@
             norm_ip,NET_IP_STR_LEN);
     else
         inet_ntop(AF_INET6,
             (void*)&(((struct sockaddr_in6 *)&sa)->sin6_addr),
             norm_ip,NET_IP_STR_LEN);
 
-    if (clusterHandshakeInProgress(norm_ip,port)) {
+    if (clusterHandshakeInProgress(norm_ip,port,cport)) {
         errno = EAGAIN;
         return 0;
     }
 
     /* Add the node with a random address (NULL as first argument to
      * createClusterNode()). Everything will be fixed during the
      * handshake. */
     n = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE|CLUSTER_NODE_MEET);
     memcpy(n->ip,norm_ip,sizeof(n->ip));
     n->port = port;
+    n->cport = cport;
     clusterAddNode(n);
     return 1;
 }
 
 /* Process the gossip section of PING or PONG packets.
  * Note that this function assumes that the packet is already sanity-checked
@@ -1296,21 +1320,20 @@
 
     while(count--) {
         uint16_t flags = ntohs(g->flags);
         clusterNode *node;
         sds ci;
 
-        if (server.verbosity == LL_DEBUG) {
-            ci = representClusterNodeFlags(sdsempty(), flags);
-            serverLog(LL_DEBUG,"GOSSIP %.40s %s:%d %s",
-                g->nodename,
-                g->ip,
-                ntohs(g->port),
-                ci);
-            sdsfree(ci);
-        }
+        ci = representClusterNodeFlags(sdsempty(), flags);
+        serverLog(LL_DEBUG,"GOSSIP %.40s %s:%d@%d %s",
+            g->nodename,
+            g->ip,
+            ntohs(g->port),
+            ntohs(g->cport),
+            ci);
+        sdsfree(ci);
 
         /* Update our state accordingly to the gossip sections */
         node = clusterLookupNode(g->nodename);
         if (node) {
             /* We already know this node.
                Handle failure reports, only when the sender is a master. */
@@ -1328,25 +1351,50 @@
                             "Node %.40s reported node %.40s is back online.",
                             sender->name, node->name);
                     }
                 }
             }
 
+            /* If from our POV the node is up (no failure flags are set),
+             * we have no pending ping for the node, nor we have failure
+             * reports for this node, update the last pong time with the
+             * one we see from the other nodes. */
+            if (!(flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &&
+                node->ping_sent == 0 &&
+                clusterNodeFailureReportsCount(node) == 0)
+            {
+                mstime_t pongtime = ntohl(g->pong_received);
+                pongtime *= 1000; /* Convert back to milliseconds. */
+
+                /* Replace the pong time with the received one only if
+                 * it's greater than our view but is not in the future
+                 * (with 500 milliseconds tolerance) from the POV of our
+                 * clock. */
+                if (pongtime <= (server.mstime+500) &&
+                    pongtime > node->pong_received)
+                {
+                    node->pong_received = pongtime;
+                }
+            }
+
             /* If we already know this node, but it is not reachable, and
              * we see a different address in the gossip section of a node that
              * can talk with this other node, update the address, disconnect
              * the old link if any, so that we'll attempt to connect with the
              * new address. */
             if (node->flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL) &&
                 !(flags & CLUSTER_NODE_NOADDR) &&
                 !(flags & (CLUSTER_NODE_FAIL|CLUSTER_NODE_PFAIL)) &&
-                (strcasecmp(node->ip,g->ip) || node->port != ntohs(g->port)))
+                (strcasecmp(node->ip,g->ip) ||
+                 node->port != ntohs(g->port) ||
+                 node->cport != ntohs(g->cport)))
             {
                 if (node->link) freeClusterLink(node->link);
                 memcpy(node->ip,g->ip,NET_IP_STR_LEN);
                 node->port = ntohs(g->port);
+                node->cport = ntohs(g->cport);
                 node->flags &= ~CLUSTER_NODE_NOADDR;
             }
         } else {
             /* If it's not in NOADDR state and we don't have it, we
              * start a handshake process against this IP/PORT pairs.
              *
@@ -1354,53 +1402,68 @@
              * is a well known node in our cluster, otherwise we risk
              * joining another cluster. */
             if (sender &&
                 !(flags & CLUSTER_NODE_NOADDR) &&
                 !clusterBlacklistExists(g->nodename))
             {
-                clusterStartHandshake(g->ip,ntohs(g->port));
+                clusterStartHandshake(g->ip,ntohs(g->port),ntohs(g->cport));
             }
         }
 
         /* Next node */
         g++;
     }
 }
 
-/* IP -> string conversion. 'buf' is supposed to at least be 46 bytes. */
-void nodeIp2String(char *buf, clusterLink *link) {
-    anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);
+/* IP -> string conversion. 'buf' is supposed to at least be 46 bytes.
+ * If 'announced_ip' length is non-zero, it is used instead of extracting
+ * the IP from the socket peer address. */
+void nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
+    if (announced_ip[0] != '\0') {
+        memcpy(buf,announced_ip,NET_IP_STR_LEN);
+        buf[NET_IP_STR_LEN-1] = '\0'; /* We are not sure the input is sane. */
+    } else {
+        anetPeerToString(link->fd, buf, NET_IP_STR_LEN, NULL);
+    }
 }
 
 /* Update the node address to the IP address that can be extracted
- * from link->fd, and at the specified port.
- * Also disconnect the node link so that we'll connect again to the new
- * address.
+ * from link->fd, or if hdr->myip is non empty, to the address the node
+ * is announcing us. The port is taken from the packet header as well.
+ *
+ * If the address or port changed, disconnect the node link so that we'll
+ * connect again to the new address.
  *
  * If the ip/port pair are already correct no operation is performed at
  * all.
  *
  * The function returns 0 if the node address is still the same,
  * otherwise 1 is returned. */
-int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link, int port) {
+int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
+                              clusterMsg *hdr)
+{
     char ip[NET_IP_STR_LEN] = {0};
+    int port = ntohs(hdr->port);
+    int cport = ntohs(hdr->cport);
 
     /* We don't proceed if the link is the same as the sender link, as this
      * function is designed to see if the node link is consistent with the
      * symmetric link that is used to receive PINGs from the node.
      *
      * As a side effect this function never frees the passed 'link', so
      * it is safe to call during packet processing. */
     if (link == node->link) return 0;
 
-    nodeIp2String(ip,link);
-    if (node->port == port && strcmp(ip,node->ip) == 0) return 0;
+    nodeIp2String(ip,link,hdr->myip);
+    if (node->port == port && node->cport == cport &&
+        strcmp(ip,node->ip) == 0) return 0;
 
     /* IP / port is different, update it. */
     memcpy(node->ip,ip,sizeof(ip));
     node->port = port;
+    node->cport = cport;
     if (node->link) freeClusterLink(node->link);
     node->flags &= ~CLUSTER_NODE_NOADDR;
     serverLog(LL_WARNING,"Address updated for node %.40s, now %s:%d",
         node->name, node->ip, node->port);
 
     /* Check if this is our master and we have to change the
@@ -1541,13 +1604,14 @@
  * received from the wrong sender ID). */
 int clusterProcessPacket(clusterLink *link) {
     clusterMsg *hdr = (clusterMsg*) link->rcvbuf;
     uint32_t totlen = ntohl(hdr->totlen);
     uint16_t type = ntohs(hdr->type);
 
-    server.cluster->stats_bus_messages_received++;
+    if (type < CLUSTERMSG_TYPE_COUNT)
+        server.cluster->stats_bus_messages_received[type]++;
     serverLog(LL_DEBUG,"--- Processing packet of type %d, %lu bytes",
         type, (unsigned long) totlen);
 
     /* Perform sanity checks */
     if (totlen < 16) return 1; /* At least signature, version, totlen, count. */
     if (totlen > sdslen(link->rcvbuf)) return 1;
@@ -1633,22 +1697,24 @@
     /* Initial processing of PING and MEET requests replying with a PONG. */
     if (type == CLUSTERMSG_TYPE_PING || type == CLUSTERMSG_TYPE_MEET) {
         serverLog(LL_DEBUG,"Ping packet received: %p", (void*)link->node);
 
         /* We use incoming MEET messages in order to set the address
          * for 'myself', since only other cluster nodes will send us
-         * MEET messagses on handshakes, when the cluster joins, or
+         * MEET messages on handshakes, when the cluster joins, or
          * later if we changed address, and those nodes will use our
          * official address to connect to us. So by obtaining this address
          * from the socket is a simple way to discover / update our own
          * address in the cluster without it being hardcoded in the config.
          *
          * However if we don't have an address at all, we update the address
          * even with a normal PING packet. If it's wrong it will be fixed
          * by MEET later. */
-        if (type == CLUSTERMSG_TYPE_MEET || myself->ip[0] == '\0') {
+        if ((type == CLUSTERMSG_TYPE_MEET || myself->ip[0] == '\0') &&
+            server.cluster_announce_ip == NULL)
+        {
             char ip[NET_IP_STR_LEN];
 
             if (anetSockName(link->fd,ip,sizeof(ip),NULL) != -1 &&
                 strcmp(ip,myself->ip))
             {
                 memcpy(myself->ip,ip,NET_IP_STR_LEN);
@@ -1663,14 +1729,15 @@
          * flags, slaveof pointer, and so forth, as this details will be
          * resolved when we'll receive PONGs from the node. */
         if (!sender && type == CLUSTERMSG_TYPE_MEET) {
             clusterNode *node;
 
             node = createClusterNode(NULL,CLUSTER_NODE_HANDSHAKE);
-            nodeIp2String(node->ip,link);
+            nodeIp2String(node->ip,link,hdr->myip);
             node->port = ntohs(hdr->port);
+            node->cport = ntohs(hdr->cport);
             clusterAddNode(node);
             clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
         }
 
         /* If this is a MEET packet from an unknown node, we still process
          * the gossip section here since we have to trust the sender because
@@ -1694,13 +1761,13 @@
                 /* If we already have this node, try to change the
                  * IP/port of the node with the new one. */
                 if (sender) {
                     serverLog(LL_VERBOSE,
                         "Handshake: we already know node %.40s, "
                         "updating the address if needed.", sender->name);
-                    if (nodeUpdateAddressIfNeeded(sender,link,ntohs(hdr->port)))
+                    if (nodeUpdateAddressIfNeeded(sender,link,hdr))
                     {
                         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                                              CLUSTER_TODO_UPDATE_STATE);
                     }
                     /* Free this node as we already have it. This will
                      * cause the link to be freed as well. */
@@ -1726,22 +1793,23 @@
                     link->node->name,
                     (int)(mstime()-(link->node->ctime)),
                     link->node->flags);
                 link->node->flags |= CLUSTER_NODE_NOADDR;
                 link->node->ip[0] = '\0';
                 link->node->port = 0;
+                link->node->cport = 0;
                 freeClusterLink(link);
                 clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
                 return 0;
             }
         }
 
         /* Update the node address if it changed. */
         if (sender && type == CLUSTERMSG_TYPE_PING &&
             !nodeInHandshake(sender) &&
-            nodeUpdateAddressIfNeeded(sender,link,ntohs(hdr->port)))
+            nodeUpdateAddressIfNeeded(sender,link,hdr))
         {
             clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                                  CLUSTER_TODO_UPDATE_STATE);
         }
 
         /* Update our info about the node */
@@ -2084,13 +2152,18 @@
 void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {
     if (sdslen(link->sndbuf) == 0 && msglen != 0)
         aeCreateFileEvent(server.el,link->fd,AE_WRITABLE,
                     clusterWriteHandler,link);
 
     link->sndbuf = sdscatlen(link->sndbuf, msg, msglen);
-    server.cluster->stats_bus_messages_sent++;
+
+    /* Populate sent messages stats. */
+    clusterMsg *hdr = (clusterMsg*) msg;
+    uint16_t type = ntohs(hdr->type);
+    if (type < CLUSTERMSG_TYPE_COUNT)
+        server.cluster->stats_bus_messages_sent[type]++;
 }
 
 /* Send a message to all the nodes that are part of the cluster having
  * a connected link.
  *
  * It is guaranteed that this function will never have as a side effect
@@ -2132,17 +2205,34 @@
     hdr->sig[1] = 'C';
     hdr->sig[2] = 'm';
     hdr->sig[3] = 'b';
     hdr->type = htons(type);
     memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);
 
+    /* If cluster-announce-ip option is enabled, force the receivers of our
+     * packets to use the specified address for this node. Otherwise if the
+     * first byte is zero, they'll do auto discovery. */
+    memset(hdr->myip,0,NET_IP_STR_LEN);
+    if (server.cluster_announce_ip) {
+        strncpy(hdr->myip,server.cluster_announce_ip,NET_IP_STR_LEN);
+        hdr->myip[NET_IP_STR_LEN-1] = '\0';
+    }
+
+    /* Handle cluster-announce-port as well. */
+    int announced_port = server.cluster_announce_port ?
+                         server.cluster_announce_port : server.port;
+    int announced_cport = server.cluster_announce_bus_port ?
+                          server.cluster_announce_bus_port :
+                          (server.port + CLUSTER_PORT_INCR);
+
     memcpy(hdr->myslots,master->slots,sizeof(hdr->myslots));
     memset(hdr->slaveof,0,CLUSTER_NAMELEN);
     if (myself->slaveof != NULL)
         memcpy(hdr->slaveof,myself->slaveof->name, CLUSTER_NAMELEN);
-    hdr->port = htons(server.port);
+    hdr->port = htons(announced_port);
+    hdr->cport = htons(announced_cport);
     hdr->flags = htons(myself->flags);
     hdr->state = server.cluster->state;
 
     /* Set the currentEpoch and configEpochs. */
     hdr->currentEpoch = htonu64(server.cluster->currentEpoch);
     hdr->configEpoch = htonu64(master->configEpoch);
@@ -2168,12 +2258,39 @@
         totlen += sizeof(clusterMsgDataUpdate);
     }
     hdr->totlen = htonl(totlen);
     /* For PING, PONG, and MEET, fixing the totlen field is up to the caller. */
 }
 
+/* Return non zero if the node is already present in the gossip section of the
+ * message pointed by 'hdr' and having 'count' gossip entries. Otherwise
+ * zero is returned. Helper for clusterSendPing(). */
+int clusterNodeIsInGossipSection(clusterMsg *hdr, int count, clusterNode *n) {
+    int j;
+    for (j = 0; j < count; j++) {
+        if (memcmp(hdr->data.ping.gossip[j].nodename,n->name,
+                CLUSTER_NAMELEN) == 0) break;
+    }
+    return j != count;
+}
+
+/* Set the i-th entry of the gossip section in the message pointed by 'hdr'
+ * to the info of the specified node 'n'. */
+void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
+    clusterMsgDataGossip *gossip;
+    gossip = &(hdr->data.ping.gossip[i]);
+    memcpy(gossip->nodename,n->name,CLUSTER_NAMELEN);
+    gossip->ping_sent = htonl(n->ping_sent/1000);
+    gossip->pong_received = htonl(n->pong_received/1000);
+    memcpy(gossip->ip,n->ip,sizeof(n->ip));
+    gossip->port = htons(n->port);
+    gossip->cport = htons(n->cport);
+    gossip->flags = htons(n->flags);
+    gossip->notused1 = 0;
+}
+
 /* Send a PING or PONG packet to the specified node, making sure to add enough
  * gossip informations. */
 void clusterSendPing(clusterLink *link, int type) {
     unsigned char *buf;
     clusterMsg *hdr;
     int gossipcount = 0; /* Number of gossip sections added so far. */
@@ -2212,17 +2329,21 @@
      * to feature our node, we set the number of entires per packet as
      * 10% of the total nodes we have. */
     wanted = floor(dictSize(server.cluster->nodes)/10);
     if (wanted < 3) wanted = 3;
     if (wanted > freshnodes) wanted = freshnodes;
 
+    /* Include all the nodes in PFAIL state, so that failure reports are
+     * faster to propagate to go from PFAIL to FAIL state. */
+    int pfail_wanted = server.cluster->stats_pfail_nodes;
+
     /* Compute the maxium totlen to allocate our buffer. We'll fix the totlen
      * later according to the number of gossip sections we really were able
      * to put inside the packet. */
     totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
-    totlen += (sizeof(clusterMsgDataGossip)*wanted);
+    totlen += (sizeof(clusterMsgDataGossip)*(wanted+pfail_wanted));
     /* Note: clusterBuildMessageHdr() expects the buffer to be always at least
      * sizeof(clusterMsg) or more. */
     if (totlen < (int)sizeof(clusterMsg)) totlen = sizeof(clusterMsg);
     buf = zcalloc(totlen);
     hdr = (clusterMsg*) buf;
 
@@ -2233,23 +2354,19 @@
 
     /* Populate the gossip fields */
     int maxiterations = wanted*3;
     while(freshnodes > 0 && gossipcount < wanted && maxiterations--) {
         dictEntry *de = dictGetRandomKey(server.cluster->nodes);
         clusterNode *this = dictGetVal(de);
-        clusterMsgDataGossip *gossip;
-        int j;
 
         /* Don't include this node: the whole packet header is about us
          * already, so we just gossip about other nodes. */
         if (this == myself) continue;
 
-        /* Give a bias to FAIL/PFAIL nodes. */
-        if (maxiterations > wanted*2 &&
-            !(this->flags & (CLUSTER_NODE_PFAIL|CLUSTER_NODE_FAIL)))
-            continue;
+        /* PFAIL nodes will be added later. */
+        if (this->flags & CLUSTER_NODE_PFAIL) continue;
 
         /* In the gossip section don't include:
          * 1) Nodes in HANDSHAKE state.
          * 3) Nodes with the NOADDR flag set.
          * 4) Disconnected nodes if they don't have configured slots.
          */
@@ -2257,33 +2374,43 @@
             (this->link == NULL && this->numslots == 0))
         {
             freshnodes--; /* Tecnically not correct, but saves CPU. */
             continue;
         }
 
-        /* Check if we already added this node */
-        for (j = 0; j < gossipcount; j++) {
-            if (memcmp(hdr->data.ping.gossip[j].nodename,this->name,
-                    CLUSTER_NAMELEN) == 0) break;
-        }
-        if (j != gossipcount) continue;
+        /* Do not add a node we already have. */
+        if (clusterNodeIsInGossipSection(hdr,gossipcount,this)) continue;
 
         /* Add it */
+        clusterSetGossipEntry(hdr,gossipcount,this);
         freshnodes--;
-        gossip = &(hdr->data.ping.gossip[gossipcount]);
-        memcpy(gossip->nodename,this->name,CLUSTER_NAMELEN);
-        gossip->ping_sent = htonl(this->ping_sent);
-        gossip->pong_received = htonl(this->pong_received);
-        memcpy(gossip->ip,this->ip,sizeof(this->ip));
-        gossip->port = htons(this->port);
-        gossip->flags = htons(this->flags);
-        gossip->notused1 = 0;
-        gossip->notused2 = 0;
         gossipcount++;
     }
 
+    /* If there are PFAIL nodes, add them at the end. */
+    if (pfail_wanted) {
+        dictIterator *di;
+        dictEntry *de;
+
+        di = dictGetSafeIterator(server.cluster->nodes);
+        while((de = dictNext(di)) != NULL && pfail_wanted > 0) {
+            clusterNode *node = dictGetVal(de);
+            if (node->flags & CLUSTER_NODE_HANDSHAKE) continue;
+            if (node->flags & CLUSTER_NODE_NOADDR) continue;
+            if (!(node->flags & CLUSTER_NODE_PFAIL)) continue;
+            clusterSetGossipEntry(hdr,gossipcount,node);
+            freshnodes--;
+            gossipcount++;
+            /* We take the count of the slots we allocated, since the
+             * PFAIL stats may not match perfectly with the current number
+             * of PFAIL nodes. */
+            pfail_wanted--;
+        }
+        dictReleaseIterator(di);
+    }
+
     /* Ready to send... fix the totlen fiend and queue the message in the
      * output buffer. */
     totlen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
     totlen += (sizeof(clusterMsgDataGossip)*gossipcount);
     hdr->count = htons(gossipcount);
     hdr->totlen = htonl(totlen);
@@ -2713,13 +2840,13 @@
     server.cluster->todo_before_sleep &= ~CLUSTER_TODO_HANDLE_FAILOVER;
 
     /* Compute the failover timeout (the max time we have to send votes
      * and wait for replies), and the failover retry time (the time to wait
      * before trying to get voted again).
      *
-     * Timeout is MIN(NODE_TIMEOUT*2,2000) milliseconds.
+     * Timeout is MAX(NODE_TIMEOUT*2,2000) milliseconds.
      * Retry is two times the Timeout.
      */
     auth_timeout = server.cluster_node_timeout*2;
     if (auth_timeout < 2000) auth_timeout = 2000;
     auth_retry_time = auth_timeout*2;
 
@@ -3071,26 +3198,59 @@
     clusterNode *min_pong_node = NULL;
     static unsigned long long iteration = 0;
     mstime_t handshake_timeout;
 
     iteration++; /* Number of times this function was called so far. */
 
+    /* We want to take myself->ip in sync with the cluster-announce-ip option.
+     * The option can be set at runtime via CONFIG SET, so we periodically check
+     * if the option changed to reflect this into myself->ip. */
+    {
+        static char *prev_ip = NULL;
+        char *curr_ip = server.cluster_announce_ip;
+        int changed = 0;
+
+        if (prev_ip == NULL && curr_ip != NULL) changed = 1;
+        if (prev_ip != NULL && curr_ip == NULL) changed = 1;
+        if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;
+
+        if (changed) {
+            prev_ip = curr_ip;
+            if (prev_ip) prev_ip = zstrdup(prev_ip);
+
+            if (curr_ip) {
+                strncpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);
+                myself->ip[NET_IP_STR_LEN-1] = '\0';
+            } else {
+                myself->ip[0] = '\0'; /* Force autodetection. */
+            }
+        }
+    }
+
     /* The handshake timeout is the time after which a handshake node that was
      * not turned into a normal node is removed from the nodes. Usually it is
      * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use
      * the value of 1 second. */
     handshake_timeout = server.cluster_node_timeout;
     if (handshake_timeout < 1000) handshake_timeout = 1000;
 
-    /* Check if we have disconnected nodes and re-establish the connection. */
+    /* Check if we have disconnected nodes and re-establish the connection.
+     * Also update a few stats while we are here, that can be used to make
+     * better decisions in other part of the code. */
     di = dictGetSafeIterator(server.cluster->nodes);
+    server.cluster->stats_pfail_nodes = 0;
     while((de = dictNext(di)) != NULL) {
         clusterNode *node = dictGetVal(de);
 
+        /* Not interested in reconnecting the link with myself or nodes
+         * for which we have no address. */
         if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) continue;
 
+        if (node->flags & CLUSTER_NODE_PFAIL)
+            server.cluster->stats_pfail_nodes++;
+
         /* A Node in HANDSHAKE state has a limited lifespan equal to the
          * configured node timeout. */
         if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {
             clusterDelNode(node);
             continue;
         }
@@ -3098,24 +3258,23 @@
         if (node->link == NULL) {
             int fd;
             mstime_t old_ping_sent;
             clusterLink *link;
 
             fd = anetTcpNonBlockBindConnect(server.neterr, node->ip,
-                node->port+CLUSTER_PORT_INCR, NET_FIRST_BIND_ADDR);
+                node->cport, NET_FIRST_BIND_ADDR);
             if (fd == -1) {
                 /* We got a synchronous error from connect before
                  * clusterSendPing() had a chance to be called.
                  * If node->ping_sent is zero, failure detection can't work,
                  * so we claim we actually sent a ping now (that will
                  * be really sent as soon as the link is obtained). */
                 if (node->ping_sent == 0) node->ping_sent = mstime();
                 serverLog(LL_DEBUG, "Unable to connect to "
                     "Cluster Node [%s]:%d -> %s", node->ip,
-                    node->port+CLUSTER_PORT_INCR,
-                    server.neterr);
+                    node->cport, server.neterr);
                 continue;
             }
             link = createClusterLink(node);
             link->fd = fd;
             node->link = link;
             aeCreateFileEvent(server.el,link->fd,AE_READABLE,
@@ -3140,13 +3299,13 @@
              * to this node. Instead after the PONG is received and we
              * are no longer in meet/handshake status, we want to send
              * normal PING packets. */
             node->flags &= ~CLUSTER_NODE_MEET;
 
             serverLog(LL_DEBUG,"Connecting with Node %.40s at %s:%d",
-                    node->name, node->ip, node->port+CLUSTER_PORT_INCR);
+                    node->name, node->ip, node->cport);
         }
     }
     dictReleaseIterator(di);
 
     /* Ping some random node 1 time every 10 iterations, so that we usually ping
      * one random node every second. */
@@ -3438,16 +3597,14 @@
 /* Delete all the slots associated with the specified node.
  * The number of deleted slots is returned. */
 int clusterDelNodeSlots(clusterNode *node) {
     int deleted = 0, j;
 
     for (j = 0; j < CLUSTER_SLOTS; j++) {
-        if (clusterNodeGetSlotBit(node,j)) {
-            clusterDelSlot(j);
-            deleted++;
-        }
+        if (clusterNodeGetSlotBit(node,j)) clusterDelSlot(j);
+        deleted++;
     }
     return deleted;
 }
 
 /* Clear the migrating / importing state for all the slots.
  * This is useful at initialization and when turning a master into slave. */
@@ -3675,20 +3832,21 @@
     {CLUSTER_NODE_NOADDR,       "noaddr,"}
 };
 
 /* Concatenate the comma separated list of node flags to the given SDS
  * string 'ci'. */
 sds representClusterNodeFlags(sds ci, uint16_t flags) {
-    size_t orig_len = sdslen(ci);
-    int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
-    for (i = 0; i < size; i++) {
-        struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;
-        if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);
+    if (flags == 0) {
+        ci = sdscat(ci,"noflags,");
+    } else {
+        int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
+        for (i = 0; i < size; i++) {
+            struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;
+            if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);
+        }
     }
-    /* If no flag was added, add the "noflags" special flag. */
-    if (sdslen(ci) == orig_len) ci = sdscat(ci,"noflags,");
     sdsIncrLen(ci,-1); /* Remove trailing comma. */
     return ci;
 }
 
 /* Generate a csv-alike representation of the specified cluster node.
  * See clusterGenNodesDescription() top comment for more information.
@@ -3696,16 +3854,17 @@
  * The function returns the string representation as an SDS string. */
 sds clusterGenNodeDescription(clusterNode *node) {
     int j, start;
     sds ci;
 
     /* Node coordinates */
-    ci = sdscatprintf(sdsempty(),"%.40s %s:%d ",
+    ci = sdscatprintf(sdsempty(),"%.40s %s:%d@%d ",
         node->name,
         node->ip,
-        node->port);
+        node->port,
+        node->cport);
 
     /* Flags */
     ci = representClusterNodeFlags(ci, node->flags);
 
     /* Slave of... or just "-" */
     if (node->slaveof)
@@ -3790,12 +3949,27 @@
 }
 
 /* -----------------------------------------------------------------------------
  * CLUSTER command
  * -------------------------------------------------------------------------- */
 
+const char *clusterGetMessageTypeString(int type) {
+    switch(type) {
+    case CLUSTERMSG_TYPE_PING: return "ping";
+    case CLUSTERMSG_TYPE_PONG: return "pong";
+    case CLUSTERMSG_TYPE_MEET: return "meet";
+    case CLUSTERMSG_TYPE_FAIL: return "fail";
+    case CLUSTERMSG_TYPE_PUBLISH: return "publish";
+    case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: return "auth-req";
+    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return "auth-ack";
+    case CLUSTERMSG_TYPE_UPDATE: return "update";
+    case CLUSTERMSG_TYPE_MFSTART: return "mfstart";
+    }
+    return "unknown";
+}
+
 int getSlotOrReply(client *c, robj *o) {
     long long slot;
 
     if (getLongLongFromObject(o,&slot) != C_OK ||
         slot < 0 || slot >= CLUSTER_SLOTS)
     {
@@ -3882,22 +4056,33 @@
 void clusterCommand(client *c) {
     if (server.cluster_enabled == 0) {
         addReplyError(c,"This instance has cluster support disabled");
         return;
     }
 
-    if (!strcasecmp(c->argv[1]->ptr,"meet") && c->argc == 4) {
-        long long port;
+    if (!strcasecmp(c->argv[1]->ptr,"meet") && (c->argc == 4 || c->argc == 5)) {
+        /* CLUSTER MEET <ip> <port> [cport] */
+        long long port, cport;
 
         if (getLongLongFromObject(c->argv[3], &port) != C_OK) {
-            addReplyErrorFormat(c,"Invalid TCP port specified: %s",
+            addReplyErrorFormat(c,"Invalid TCP base port specified: %s",
                                 (char*)c->argv[3]->ptr);
             return;
         }
 
-        if (clusterStartHandshake(c->argv[2]->ptr,port) == 0 &&
+        if (c->argc == 5) {
+            if (getLongLongFromObject(c->argv[4], &cport) != C_OK) {
+                addReplyErrorFormat(c,"Invalid TCP bus port specified: %s",
+                                    (char*)c->argv[4]->ptr);
+                return;
+            }
+        } else {
+            cport = port + CLUSTER_PORT_INCR;
+        }
+
+        if (clusterStartHandshake(c->argv[2]->ptr,port,cport) == 0 &&
             errno == EINVAL)
         {
             addReplyErrorFormat(c,"Invalid node address specified: %s:%s",
                             (char*)c->argv[2]->ptr, (char*)c->argv[3]->ptr);
         } else {
             addReply(c,shared.ok);
@@ -4006,13 +4191,13 @@
                 addReplyErrorFormat(c,
                     "I'm already the owner of hash slot %u",slot);
                 return;
             }
             if ((n = clusterLookupNode(c->argv[4]->ptr)) == NULL) {
                 addReplyErrorFormat(c,"I don't know about node %s",
-                    (char*)c->argv[4]->ptr);
+                    (char*)c->argv[3]->ptr);
                 return;
             }
             server.cluster->importing_slots_from[slot] = n;
         } else if (!strcasecmp(c->argv[3]->ptr,"stable") && c->argc == 4) {
             /* CLUSTER SETSLOT <SLOT> STABLE */
             server.cluster->importing_slots_from[slot] = NULL;
@@ -4110,26 +4295,50 @@
             "cluster_slots_pfail:%d\r\n"
             "cluster_slots_fail:%d\r\n"
             "cluster_known_nodes:%lu\r\n"
             "cluster_size:%d\r\n"
             "cluster_current_epoch:%llu\r\n"
             "cluster_my_epoch:%llu\r\n"
-            "cluster_stats_messages_sent:%lld\r\n"
-            "cluster_stats_messages_received:%lld\r\n"
             , statestr[server.cluster->state],
             slots_assigned,
             slots_ok,
             slots_pfail,
             slots_fail,
             dictSize(server.cluster->nodes),
             server.cluster->size,
             (unsigned long long) server.cluster->currentEpoch,
-            (unsigned long long) myepoch,
-            server.cluster->stats_bus_messages_sent,
-            server.cluster->stats_bus_messages_received
+            (unsigned long long) myepoch
         );
+
+        /* Show stats about messages sent and received. */
+        long long tot_msg_sent = 0;
+        long long tot_msg_received = 0;
+
+        for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
+            if (server.cluster->stats_bus_messages_sent[i] == 0) continue;
+            tot_msg_sent += server.cluster->stats_bus_messages_sent[i];
+            info = sdscatprintf(info,
+                "cluster_stats_messages_%s_sent:%lld\r\n",
+                clusterGetMessageTypeString(i),
+                server.cluster->stats_bus_messages_sent[i]);
+        }
+        info = sdscatprintf(info,
+            "cluster_stats_messages_sent:%lld\r\n", tot_msg_sent);
+
+        for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
+            if (server.cluster->stats_bus_messages_received[i] == 0) continue;
+            tot_msg_received += server.cluster->stats_bus_messages_received[i];
+            info = sdscatprintf(info,
+                "cluster_stats_messages_%s_received:%lld\r\n",
+                clusterGetMessageTypeString(i),
+                server.cluster->stats_bus_messages_received[i]);
+        }
+        info = sdscatprintf(info,
+            "cluster_stats_messages_received:%lld\r\n", tot_msg_received);
+
+        /* Produce the reply protocol. */
         addReplySds(c,sdscatprintf(sdsempty(),"$%lu\r\n",
             (unsigned long)sdslen(info)));
         addReplySds(c,info);
         addReply(c,shared.crlf);
     } else if (!strcasecmp(c->argv[1]->ptr,"saveconfig") && c->argc == 2) {
         int retval = clusterSaveConfig(1);
@@ -4168,16 +4377,24 @@
             return;
         if (slot < 0 || slot >= CLUSTER_SLOTS || maxkeys < 0) {
             addReplyError(c,"Invalid slot or number of keys");
             return;
         }
 
+        /* Avoid allocating more than needed in case of large COUNT argument
+         * and smaller actual number of keys. */
+        unsigned int keys_in_slot = countKeysInSlot(slot);
+        if (maxkeys > keys_in_slot) maxkeys = keys_in_slot;
+
         keys = zmalloc(sizeof(robj*)*maxkeys);
         numkeys = getKeysInSlot(slot, keys, maxkeys);
         addReplyMultiBulkLen(c,numkeys);
-        for (j = 0; j < numkeys; j++) addReplyBulk(c,keys[j]);
+        for (j = 0; j < numkeys; j++) {
+            addReplyBulk(c,keys[j]);
+            decrRefCount(keys[j]);
+        }
         zfree(keys);
     } else if (!strcasecmp(c->argv[1]->ptr,"forget") && c->argc == 3) {
         /* CLUSTER FORGET <NODE ID> */
         clusterNode *n = clusterLookupNode(c->argv[2]->ptr);
 
         if (!n) {
@@ -4518,13 +4735,13 @@
 
     /* Remove the old key if needed. */
     if (replace) dbDelete(c->db,c->argv[1]);
 
     /* Create the key and set the TTL if any */
     dbAdd(c->db,c->argv[1],obj);
-    if (ttl) setExpire(c->db,c->argv[1],mstime()+ttl);
+    if (ttl) setExpire(c,c->db,c->argv[1],mstime()+ttl);
     signalModifiedKey(c->db,c->argv[1]);
     addReply(c,shared.ok);
     server.dirty++;
 }
 
 /* MIGRATE socket cache implementation.
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.h	2017-07-14 19:28:42.000000000 +0800
@@ -70,12 +70,35 @@
 #define CLUSTER_CANT_FAILOVER_DATA_AGE 1
 #define CLUSTER_CANT_FAILOVER_WAITING_DELAY 2
 #define CLUSTER_CANT_FAILOVER_EXPIRED 3
 #define CLUSTER_CANT_FAILOVER_WAITING_VOTES 4
 #define CLUSTER_CANT_FAILOVER_RELOG_PERIOD (60*5) /* seconds. */
 
+/* clusterState todo_before_sleep flags. */
+#define CLUSTER_TODO_HANDLE_FAILOVER (1<<0)
+#define CLUSTER_TODO_UPDATE_STATE (1<<1)
+#define CLUSTER_TODO_SAVE_CONFIG (1<<2)
+#define CLUSTER_TODO_FSYNC_CONFIG (1<<3)
+
+/* Message types.
+ *
+ * Note that the PING, PONG and MEET messages are actually the same exact
+ * kind of packet. PONG is the reply to ping, in the exact format as a PING,
+ * while MEET is a special PING that forces the receiver to add the sender
+ * as a node (if it is not already in the list). */
+#define CLUSTERMSG_TYPE_PING 0          /* Ping */
+#define CLUSTERMSG_TYPE_PONG 1          /* Pong (reply to Ping) */
+#define CLUSTERMSG_TYPE_MEET 2          /* Meet "let's join" message */
+#define CLUSTERMSG_TYPE_FAIL 3          /* Mark node xxx as failing */
+#define CLUSTERMSG_TYPE_PUBLISH 4       /* Pub/Sub Publish propagation */
+#define CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 /* May I failover? */
+#define CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     /* Yes, you have my vote */
+#define CLUSTERMSG_TYPE_UPDATE 7        /* Another node slots configuration */
+#define CLUSTERMSG_TYPE_MFSTART 8       /* Pause clients for manual failover */
+#define CLUSTERMSG_TYPE_COUNT 9         /* Total number of message types. */
+
 /* This structure represent elements of node->fail_reports. */
 typedef struct clusterNodeFailReport {
     struct clusterNode *node;  /* Node reporting the failure condition. */
     mstime_t time;             /* Time of the last report from this node. */
 } clusterNodeFailReport;
 
@@ -97,13 +120,14 @@
     mstime_t fail_time;      /* Unix time when FAIL flag was set */
     mstime_t voted_time;     /* Last time we voted for a slave of this master */
     mstime_t repl_offset_time;  /* Unix time we received offset for this node */
     mstime_t orphaned_time;     /* Starting time of orphaned master condition */
     long long repl_offset;      /* Last known repl offset for this node. */
     char ip[NET_IP_STR_LEN];  /* Latest known IP address of this node */
-    int port;                   /* Latest known port of this node */
+    int port;                   /* Latest known clients port of this node */
+    int cport;                  /* Latest known cluster port of this node. */
     clusterLink *link;          /* TCP/IP link with this node */
     list *fail_reports;         /* List of nodes signaling this as failing */
 } clusterNode;
 
 typedef struct clusterState {
     clusterNode *myself;  /* This node */
@@ -112,13 +136,14 @@
     int size;             /* Num of master nodes with at least one slot */
     dict *nodes;          /* Hash table of name -> clusterNode structures */
     dict *nodes_black_list; /* Nodes we don't re-add for a few seconds. */
     clusterNode *migrating_slots_to[CLUSTER_SLOTS];
     clusterNode *importing_slots_from[CLUSTER_SLOTS];
     clusterNode *slots[CLUSTER_SLOTS];
-    zskiplist *slots_to_keys;
+    uint64_t slots_keys_count[CLUSTER_SLOTS];
+    rax *slots_to_keys;
     /* The following fields are used to take the slave state on elections. */
     mstime_t failover_auth_time; /* Time of previous or next election. */
     int failover_auth_count;    /* Number of votes received so far. */
     int failover_auth_sent;     /* True if we already asked for votes. */
     int failover_auth_rank;     /* This slave rank for current auth request. */
     uint64_t failover_auth_epoch; /* Epoch of the current election. */
@@ -134,50 +159,33 @@
                                    or zero if stil not received. */
     int mf_can_start;           /* If non-zero signal that the manual failover
                                    can start requesting masters vote. */
     /* The followign fields are used by masters to take state on elections. */
     uint64_t lastVoteEpoch;     /* Epoch of the last vote granted. */
     int todo_before_sleep; /* Things to do in clusterBeforeSleep(). */
-    long long stats_bus_messages_sent;  /* Num of msg sent via cluster bus. */
-    long long stats_bus_messages_received; /* Num of msg rcvd via cluster bus.*/
+    /* Messages received and sent by type. */
+    long long stats_bus_messages_sent[CLUSTERMSG_TYPE_COUNT];
+    long long stats_bus_messages_received[CLUSTERMSG_TYPE_COUNT];
+    long long stats_pfail_nodes;    /* Number of nodes in PFAIL status,
+                                       excluding nodes without address. */
 } clusterState;
 
-/* clusterState todo_before_sleep flags. */
-#define CLUSTER_TODO_HANDLE_FAILOVER (1<<0)
-#define CLUSTER_TODO_UPDATE_STATE (1<<1)
-#define CLUSTER_TODO_SAVE_CONFIG (1<<2)
-#define CLUSTER_TODO_FSYNC_CONFIG (1<<3)
-
 /* Redis cluster messages header */
 
-/* Note that the PING, PONG and MEET messages are actually the same exact
- * kind of packet. PONG is the reply to ping, in the exact format as a PING,
- * while MEET is a special PING that forces the receiver to add the sender
- * as a node (if it is not already in the list). */
-#define CLUSTERMSG_TYPE_PING 0          /* Ping */
-#define CLUSTERMSG_TYPE_PONG 1          /* Pong (reply to Ping) */
-#define CLUSTERMSG_TYPE_MEET 2          /* Meet "let's join" message */
-#define CLUSTERMSG_TYPE_FAIL 3          /* Mark node xxx as failing */
-#define CLUSTERMSG_TYPE_PUBLISH 4       /* Pub/Sub Publish propagation */
-#define CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 5 /* May I failover? */
-#define CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 6     /* Yes, you have my vote */
-#define CLUSTERMSG_TYPE_UPDATE 7        /* Another node slots configuration */
-#define CLUSTERMSG_TYPE_MFSTART 8       /* Pause clients for manual failover */
-
 /* Initially we don't know our "name", but we'll find it once we connect
  * to the first node, using the getsockname() function. Then we'll use this
  * address for all the next messages. */
 typedef struct {
     char nodename[CLUSTER_NAMELEN];
     uint32_t ping_sent;
     uint32_t pong_received;
     char ip[NET_IP_STR_LEN];  /* IP address last time it was seen */
-    uint16_t port;              /* port last time it was seen */
+    uint16_t port;              /* base port last time it was seen */
+    uint16_t cport;             /* cluster port last time it was seen */
     uint16_t flags;             /* node->flags copy */
-    uint16_t notused1;          /* Some room for future improvements. */
-    uint32_t notused2;
+    uint32_t notused1;
 } clusterMsgDataGossip;
 
 typedef struct {
     char nodename[CLUSTER_NAMELEN];
 } clusterMsgDataFail;
 
@@ -216,33 +224,34 @@
     /* UPDATE */
     struct {
         clusterMsgDataUpdate nodecfg;
     } update;
 };
 
-#define CLUSTER_PROTO_VER 0 /* Cluster bus protocol version. */
+#define CLUSTER_PROTO_VER 1 /* Cluster bus protocol version. */
 
 typedef struct {
     char sig[4];        /* Siganture "RCmb" (Redis Cluster message bus). */
     uint32_t totlen;    /* Total length of this message */
-    uint16_t ver;       /* Protocol version, currently set to 0. */
-    uint16_t notused0;  /* 2 bytes not used. */
+    uint16_t ver;       /* Protocol version, currently set to 1. */
+    uint16_t port;      /* TCP base port number. */
     uint16_t type;      /* Message type */
     uint16_t count;     /* Only used for some kind of messages. */
     uint64_t currentEpoch;  /* The epoch accordingly to the sending node. */
     uint64_t configEpoch;   /* The config epoch if it's a master, or the last
                                epoch advertised by its master if it is a
                                slave. */
     uint64_t offset;    /* Master replication offset if node is a master or
                            processed replication offset if node is a slave. */
     char sender[CLUSTER_NAMELEN]; /* Name of the sender node */
     unsigned char myslots[CLUSTER_SLOTS/8];
     char slaveof[CLUSTER_NAMELEN];
-    char notused1[32];  /* 32 bytes reserved for future usage. */
-    uint16_t port;      /* Sender TCP base port */
-    uint16_t flags;     /* Sender node flags */
+    char myip[NET_IP_STR_LEN];    /* Sender IP, if not all zeroed. */
+    char notused1[34];  /* 34 bytes reserved for future usage. */
+    uint16_t cport;      /* Sender TCP cluster bus port */
+    uint16_t flags;      /* Sender node flags */
     unsigned char state; /* Cluster state from the POV of the sender */
     unsigned char mflags[3]; /* Message flags: CLUSTERMSG_FLAG[012]_... */
     union clusterMsgData data;
 } clusterMsg;
 
 #define CLUSTERMSG_MIN_LEN (sizeof(clusterMsg)-sizeof(union clusterMsgData))
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/compile_commands.json /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/compile_commands.json
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/compile_commands.json	2017-09-27 22:54:19.822949305 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/compile_commands.json	2017-09-27 23:07:10.114921075 +0800
@@ -1,1351 +1,1411 @@
 [
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -MM adlist.c ae.c ae_epoll.c ae_evport.c ae_kqueue.c ae_select.c anet.c aof.c bio.c bitops.c blocked.c childinfo.c cluster.c config.c crc16.c crc64.c db.c debug.c defrag.c dict.c endianconv.c evict.c expire.c geo.c geohash.c geohash_helper.c hyperloglog.c intset.c latency.c lazyfree.c lzf_c.c lzf_d.c memtest.c module.c multi.c networking.c notify.c object.c pqsort.c pubsub.c quicklist.c rand.c rax.c rdb.c redis-benchmark.c redis-check-aof.c redis-check-rdb.c redis-cli.c release.c replication.c rio.c scripting.c sds.c sentinel.c server.c setproctitle.c sha1.c siphash.c slowlog.c sort.c sparkline.c syncio.c t_hash.c t_list.c t_set.c t_string.c t_zset.c util.c ziplist.c zipmap.c zmalloc.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb net.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb hiredis.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb sds.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis",
   "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb async.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis",
+  "command": "cc -std=c99 -pedantic -c -O3 -fPIC -Wall -W -Wstrict-prototypes -Wwrite-strings -g -ggdb read.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/read.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise",
   "command": "cc -Wall -Os -g -c linenoise.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise/linenoise.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise/linenoise.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lapi.o lapi.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lapi.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lapi.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lcode.o lcode.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lcode.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lcode.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldebug.o ldebug.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldebug.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldebug.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldo.o ldo.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldo.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldo.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldump.o ldump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldump.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldump.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lfunc.o lfunc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lfunc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lfunc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lgc.o lgc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lgc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lgc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o llex.o llex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/llex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/llex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lmem.o lmem.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmem.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmem.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lobject.o lobject.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lobject.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lobject.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lopcodes.o lopcodes.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lopcodes.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lopcodes.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lparser.o lparser.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lparser.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lparser.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstate.o lstate.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstate.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstate.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstring.o lstring.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstring.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstring.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltable.o ltable.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltable.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltable.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltm.o ltm.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltm.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltm.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lundump.o lundump.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lundump.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lundump.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lvm.o lvm.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lvm.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lvm.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lzio.o lzio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lzio.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lzio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o strbuf.o strbuf.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/strbuf.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/strbuf.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o fpconv.o fpconv.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/fpconv.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/fpconv.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lauxlib.o lauxlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lauxlib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lauxlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lbaselib.o lbaselib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lbaselib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lbaselib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ldblib.o ldblib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldblib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldblib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o liolib.o liolib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/liolib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/liolib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lmathlib.o lmathlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmathlib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmathlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o loslib.o loslib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loslib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loslib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o ltablib.o ltablib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltablib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltablib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lstrlib.o lstrlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstrlib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstrlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o loadlib.o loadlib.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loadlib.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loadlib.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o linit.o linit.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/linit.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/linit.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_cjson.o lua_cjson.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cjson.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cjson.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_struct.o lua_struct.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_struct.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_struct.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_cmsgpack.o lua_cmsgpack.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cmsgpack.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cmsgpack.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua_bit.o lua_bit.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_bit.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_bit.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o lua.o lua.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o luac.o luac.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/luac.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/luac.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src",
   "command": "cc -O2 -Wall -DLUA_ANSI -DENABLE_CJSON_GLOBAL -DREDIS_STATIC= -c -o print.o print.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/print.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/print.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int",
-  "command": "cc -Wall -O2 -g -c geohash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash.c"
-}
-,
-{
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int",
-  "command": "cc -Wall -O2 -g -c geohash_helper.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash_helper.c"
-}
-,
-{
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -g conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -E conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
-  "command": "cc -c -o /tmp/cg6oQxAn/dummy.o /tmp/cg6oQxAn/dummy.c",
-  "file": "/tmp/cg6oQxAn/dummy.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
+  "command": "cc -c -o /tmp/cgFqjaAd/dummy.o /tmp/cgFqjaAd/dummy.c",
+  "file": "/tmp/cgFqjaAd/dummy.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
-  "command": "cc -E /tmp/cg6oQxAn/dummy.c",
-  "file": "/tmp/cg6oQxAn/dummy.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
+  "command": "cc -E /tmp/cgFqjaAd/dummy.c",
+  "file": "/tmp/cgFqjaAd/dummy.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -E -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -Werror -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -E -D_GNU_SOURCE conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -o conftest -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c -lpthread",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -c -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -fvisibility=hidden -D_GNU_SOURCE -D_REENTRANT conftest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/jemalloc.o src/jemalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/jemalloc.o -o src/jemalloc.d src/jemalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/arena.o src/arena.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/arena.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/arena.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/arena.o -o src/arena.d src/arena.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/arena.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/arena.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/atomic.o src/atomic.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/atomic.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/atomic.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/atomic.o -o src/atomic.d src/atomic.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/atomic.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/atomic.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/base.o src/base.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/base.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/base.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/base.o -o src/base.d src/base.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/base.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/base.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/bitmap.o src/bitmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/bitmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/bitmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/bitmap.o -o src/bitmap.d src/bitmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/bitmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/bitmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk.o src/chunk.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk.o -o src/chunk.d src/chunk.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk_dss.o src/chunk_dss.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_dss.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_dss.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk_dss.o -o src/chunk_dss.d src/chunk_dss.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_dss.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_dss.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/chunk_mmap.o src/chunk_mmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_mmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_mmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/chunk_mmap.o -o src/chunk_mmap.d src/chunk_mmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_mmap.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_mmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ckh.o src/ckh.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ckh.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ckh.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ckh.o -o src/ckh.d src/ckh.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ckh.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ckh.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/ctl.o src/ctl.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ctl.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ctl.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/ctl.o -o src/ctl.d src/ctl.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ctl.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ctl.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/extent.o src/extent.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/extent.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/extent.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/extent.o -o src/extent.d src/extent.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/extent.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/extent.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/hash.o src/hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/hash.o -o src/hash.d src/hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/hash.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/huge.o src/huge.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/huge.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/huge.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/huge.o -o src/huge.d src/huge.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/huge.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/huge.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mb.o src/mb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/mb.o -o src/mb.d src/mb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mb.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/mutex.o src/mutex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mutex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mutex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/mutex.o -o src/mutex.d src/mutex.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mutex.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mutex.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/pages.o src/pages.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/pages.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/pages.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/pages.o -o src/pages.d src/pages.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/pages.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/pages.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/prof.o src/prof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/prof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/prof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/prof.o -o src/prof.d src/prof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/prof.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/prof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/quarantine.o src/quarantine.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/quarantine.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/quarantine.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/quarantine.o -o src/quarantine.d src/quarantine.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/quarantine.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/quarantine.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/rtree.o src/rtree.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/rtree.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/rtree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/rtree.o -o src/rtree.d src/rtree.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/rtree.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/rtree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/stats.o src/stats.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/stats.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/stats.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/stats.o -o src/stats.d src/stats.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/stats.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/stats.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tcache.o src/tcache.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tcache.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tcache.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/tcache.o -o src/tcache.d src/tcache.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tcache.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tcache.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/util.o src/util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/util.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/util.o -o src/util.d src/util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/util.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -std=gnu99 -Wall -pipe -g3 -O3 -funroll-loops -c -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -o src/tsd.o src/tsd.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tsd.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tsd.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc",
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc",
   "command": "gcc -MM -D_GNU_SOURCE -D_REENTRANT -Iinclude -Iinclude -MT src/tsd.o -o src/tsd.d src/tsd.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tsd.c"
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tsd.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c adlist.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c quicklist.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ae.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c anet.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c dict.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c server.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sds.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zmalloc.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_c.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_c.c"
+}
+,
+{
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_d.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_d.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c adlist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pqsort.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pqsort.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c quicklist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zipmap.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zipmap.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ae.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sha1.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sha1.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c anet.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ziplist.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c dict.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c release.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c server.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c networking.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sds.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c util.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zmalloc.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c object.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_c.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_c.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c db.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lzf_d.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_d.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c replication.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pqsort.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pqsort.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rdb.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c zipmap.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zipmap.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_string.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sha1.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sha1.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_list.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c ziplist.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_set.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c release.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_zset.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c networking.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_hash.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c util.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c config.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c object.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c aof.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c db.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pubsub.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pubsub.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c replication.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c multi.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rdb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c debug.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_string.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sort.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_list.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c intset.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_set.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c syncio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/syncio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_zset.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c cluster.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c t_hash.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc16.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc16.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c config.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c endianconv.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/endianconv.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c aof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c slowlog.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c pubsub.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pubsub.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c scripting.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c multi.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c debug.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rio.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sort.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rand.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rand.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c intset.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c memtest.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/memtest.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c syncio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/syncio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc64.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc64.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c cluster.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bitops.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc16.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc16.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sentinel.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c endianconv.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/endianconv.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c notify.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/notify.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c slowlog.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c setproctitle.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/setproctitle.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c scripting.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c blocked.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c hyperloglog.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rio.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c latency.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rand.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rand.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sparkline.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sparkline.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c memtest.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/memtest.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-rdb.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c crc64.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc64.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-aof.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c bitops.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c geo.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sentinel.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c lazyfree.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lazyfree.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c notify.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/notify.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c module.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/module.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c setproctitle.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/setproctitle.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c evict.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/evict.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c blocked.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c expire.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/expire.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c hyperloglog.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c geohash.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c latency.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c geohash_helper.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash_helper.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c sparkline.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sparkline.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c childinfo.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/childinfo.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-rdb.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c defrag.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/defrag.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c geo.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c siphash.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/siphash.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-cli.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c rax.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rax.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-benchmark.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-cli.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.c"
 }
 ,
 {
-  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src",
-  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-check-aof.c",
-  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.c"
+  "directory": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src",
+  "command": "cc -std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include -c redis-benchmark.c",
+  "file": "/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.c"
 }
 ]
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/compiled_files.def /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/compiled_files.def
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/compiled_files.def	2017-09-27 22:54:19.830949305 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/compiled_files.def	2017-09-27 23:07:10.130921074 +0800
@@ -1,127 +1,136 @@
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/net.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/hiredis.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/sds.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/hiredis/async.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/linenoise/linenoise.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lapi.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lcode.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldebug.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldo.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lfunc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lgc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/llex.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmem.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lobject.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lopcodes.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lparser.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstate.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstring.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltable.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltm.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lundump.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lvm.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lzio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/strbuf.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/fpconv.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lauxlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lbaselib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ldblib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/liolib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lmathlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loslib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/ltablib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lstrlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/loadlib.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/linit.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cjson.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_struct.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_cmsgpack.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua_bit.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/lua.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/luac.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/lua/src/print.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/geohash-int/geohash_helper.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/conftest.c
-/tmp/cg6oQxAn/dummy.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/jemalloc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/arena.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/atomic.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/base.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/bitmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_dss.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/chunk_mmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ckh.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/ctl.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/extent.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/hash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/huge.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/mutex.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/pages.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/prof.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/quarantine.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/rtree.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/stats.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tcache.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/util.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/deps/jemalloc/src/tsd.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/adlist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ae.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/anet.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_c.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_d.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pqsort.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zipmap.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sha1.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/aof.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pubsub.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/syncio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/cluster.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc16.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/endianconv.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rand.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/memtest.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc64.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/bitops.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/notify.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/setproctitle.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/blocked.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sparkline.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.c
-/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/adlist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/net.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/hiredis.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/sds.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/async.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/hiredis/read.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/linenoise/linenoise.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lapi.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lcode.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldebug.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldo.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lfunc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lgc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/llex.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmem.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lobject.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lopcodes.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lparser.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstate.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstring.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltable.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltm.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lundump.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lvm.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lzio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/strbuf.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/fpconv.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lauxlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lbaselib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ldblib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/liolib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lmathlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loslib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/ltablib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lstrlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/loadlib.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/linit.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cjson.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_struct.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_cmsgpack.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua_bit.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/lua.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/luac.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/lua/src/print.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/conftest.c
+/tmp/cgFqjaAd/dummy.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/jemalloc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/arena.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/atomic.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/base.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/bitmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_dss.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/chunk_mmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ckh.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/ctl.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/extent.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/hash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/huge.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/mutex.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/pages.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/prof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/quarantine.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/rtree.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/stats.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tcache.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/util.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/deps/jemalloc/src/tsd.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ae.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/anet.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_c.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_d.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pqsort.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zipmap.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sha1.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pubsub.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/syncio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/cluster.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc16.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/endianconv.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rand.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/memtest.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc64.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/bitops.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/notify.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/setproctitle.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/blocked.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sparkline.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lazyfree.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/module.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/evict.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/expire.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geohash_helper.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/childinfo.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/defrag.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/siphash.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rax.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.c
+/usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.c	2017-07-14 19:28:42.000000000 +0800
@@ -42,15 +42,17 @@
     const char *name;
     const int val;
 } configEnum;
 
 configEnum maxmemory_policy_enum[] = {
     {"volatile-lru", MAXMEMORY_VOLATILE_LRU},
+    {"volatile-lfu", MAXMEMORY_VOLATILE_LFU},
     {"volatile-random",MAXMEMORY_VOLATILE_RANDOM},
     {"volatile-ttl",MAXMEMORY_VOLATILE_TTL},
     {"allkeys-lru",MAXMEMORY_ALLKEYS_LRU},
+    {"allkeys-lfu",MAXMEMORY_ALLKEYS_LFU},
     {"allkeys-random",MAXMEMORY_ALLKEYS_RANDOM},
     {"noeviction",MAXMEMORY_NO_EVICTION},
     {NULL, 0}
 };
 
 configEnum syslog_facility_enum[] = {
@@ -150,12 +152,26 @@
 void resetServerSaveParams(void) {
     zfree(server.saveparams);
     server.saveparams = NULL;
     server.saveparamslen = 0;
 }
 
+void queueLoadModule(sds path, sds *argv, int argc) {
+    int i;
+    struct moduleLoadQueueEntry *loadmod;
+
+    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));
+    loadmod->argv = zmalloc(sizeof(robj*)*argc);
+    loadmod->path = sdsnew(path);
+    loadmod->argc = argc;
+    for (i = 0; i < argc; i++) {
+        loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
+    }
+    listAddNodeTail(server.loadmodule_queue,loadmod);
+}
+
 void loadServerConfigFromString(char *config) {
     char *err = NULL;
     int linenum = 0, totlines, i;
     int slaveof_linenum = 0;
     sds *lines;
 
@@ -264,12 +280,16 @@
                     err = sdscatprintf(sdsempty(),
                         "Can't open the log file: %s", strerror(errno));
                     goto loaderr;
                 }
                 fclose(logfp);
             }
+        } else if (!strcasecmp(argv[0],"always-show-logo") && argc == 2) {
+            if ((server.always_show_logo = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"syslog-enabled") && argc == 2) {
             if ((server.syslog_enabled = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"syslog-ident") && argc == 2) {
             if (server.syslog_ident) zfree(server.syslog_ident);
@@ -305,12 +325,24 @@
         } else if (!strcasecmp(argv[0],"maxmemory-samples") && argc == 2) {
             server.maxmemory_samples = atoi(argv[1]);
             if (server.maxmemory_samples <= 0) {
                 err = "maxmemory-samples must be 1 or greater";
                 goto loaderr;
             }
+        } else if (!strcasecmp(argv[0],"lfu-log-factor") && argc == 2) {
+            server.lfu_log_factor = atoi(argv[1]);
+            if (server.maxmemory_samples < 0) {
+                err = "lfu-log-factor must be 0 or greater";
+                goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"lfu-decay-time") && argc == 2) {
+            server.lfu_decay_time = atoi(argv[1]);
+            if (server.maxmemory_samples < 1) {
+                err = "lfu-decay-time must be 0 or greater";
+                goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"slaveof") && argc == 3) {
             slaveof_linenum = linenum;
             server.masterhost = sdsnew(argv[1]);
             server.masterport = atoi(argv[2]);
             server.repl_state = REPL_STATE_CONNECT;
         } else if (!strcasecmp(argv[0],"repl-ping-slave-period") && argc == 2) {
@@ -372,12 +404,32 @@
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"activerehashing") && argc == 2) {
             if ((server.activerehashing = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
+        } else if (!strcasecmp(argv[0],"lazyfree-lazy-eviction") && argc == 2) {
+            if ((server.lazyfree_lazy_eviction = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"lazyfree-lazy-expire") && argc == 2) {
+            if ((server.lazyfree_lazy_expire = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"lazyfree-lazy-server-del") && argc == 2){
+            if ((server.lazyfree_lazy_server_del = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"slave-lazy-flush") && argc == 2) {
+            if ((server.repl_slave_lazy_flush = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"activedefrag") && argc == 2) {
+            if ((server.active_defrag_enabled = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"daemonize") && argc == 2) {
             if ((server.daemonize = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"hz") && argc == 2) {
             server.hz = atoi(argv[1]);
@@ -428,12 +480,16 @@
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"aof-load-truncated") && argc == 2) {
             if ((server.aof_load_truncated = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
+        } else if (!strcasecmp(argv[0],"aof-use-rdb-preamble") && argc == 2) {
+            if ((server.aof_use_rdb_preamble = yesnotoi(argv[1])) == -1) {
+                err = "argument must be 'yes' or 'no'"; goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"requirepass") && argc == 2) {
             if (strlen(argv[1]) > CONFIG_AUTHPASS_MAX_LEN) {
                 err = "Password is longer than CONFIG_AUTHPASS_MAX_LEN";
                 goto loaderr;
             }
             server.requirepass = zstrdup(argv[1]);
@@ -444,12 +500,42 @@
             if (!pathIsBaseName(argv[1])) {
                 err = "dbfilename can't be a path, just a filename";
                 goto loaderr;
             }
             zfree(server.rdb_filename);
             server.rdb_filename = zstrdup(argv[1]);
+        } else if (!strcasecmp(argv[0],"active-defrag-threshold-lower") && argc == 2) {
+            server.active_defrag_threshold_lower = atoi(argv[1]);
+            if (server.active_defrag_threshold_lower < 0) {
+                err = "active-defrag-threshold-lower must be 0 or greater";
+                goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"active-defrag-threshold-upper") && argc == 2) {
+            server.active_defrag_threshold_upper = atoi(argv[1]);
+            if (server.active_defrag_threshold_upper < 0) {
+                err = "active-defrag-threshold-upper must be 0 or greater";
+                goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"active-defrag-ignore-bytes") && argc == 2) {
+            server.active_defrag_ignore_bytes = memtoll(argv[1], NULL);
+            if (server.active_defrag_ignore_bytes <= 0) {
+                err = "active-defrag-ignore-bytes must above 0";
+                goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"active-defrag-cycle-min") && argc == 2) {
+            server.active_defrag_cycle_min = atoi(argv[1]);
+            if (server.active_defrag_cycle_min < 1 || server.active_defrag_cycle_min > 99) {
+                err = "active-defrag-cycle-min must be between 1 and 99";
+                goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"active-defrag-cycle-max") && argc == 2) {
+            server.active_defrag_cycle_max = atoi(argv[1]);
+            if (server.active_defrag_cycle_max < 1 || server.active_defrag_cycle_max > 99) {
+                err = "active-defrag-cycle-max must be between 1 and 99";
+                goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"hash-max-ziplist-entries") && argc == 2) {
             server.hash_max_ziplist_entries = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"hash-max-ziplist-value") && argc == 2) {
             server.hash_max_ziplist_value = memtoll(argv[1], NULL);
         } else if (!strcasecmp(argv[0],"list-max-ziplist-entries") && argc == 2){
             /* DEAD OPTION */
@@ -495,12 +581,31 @@
             if ((server.cluster_enabled = yesnotoi(argv[1])) == -1) {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
             }
         } else if (!strcasecmp(argv[0],"cluster-config-file") && argc == 2) {
             zfree(server.cluster_configfile);
             server.cluster_configfile = zstrdup(argv[1]);
+        } else if (!strcasecmp(argv[0],"cluster-announce-ip") && argc == 2) {
+            zfree(server.cluster_announce_ip);
+            server.cluster_announce_ip = zstrdup(argv[1]);
+        } else if (!strcasecmp(argv[0],"cluster-announce-port") && argc == 2) {
+            server.cluster_announce_port = atoi(argv[1]);
+            if (server.cluster_announce_port < 0 ||
+                server.cluster_announce_port > 65535)
+            {
+                err = "Invalid port"; goto loaderr;
+            }
+        } else if (!strcasecmp(argv[0],"cluster-announce-bus-port") &&
+                   argc == 2)
+        {
+            server.cluster_announce_bus_port = atoi(argv[1]);
+            if (server.cluster_announce_bus_port < 0 ||
+                server.cluster_announce_bus_port > 65535)
+            {
+                err = "Invalid port"; goto loaderr;
+            }
         } else if (!strcasecmp(argv[0],"cluster-require-full-coverage") &&
                     argc == 2)
         {
             if ((server.cluster_require_full_coverage = yesnotoi(argv[1])) == -1)
             {
                 err = "argument must be 'yes' or 'no'"; goto loaderr;
@@ -605,12 +710,14 @@
 
             if (server.supervised_mode == INT_MIN) {
                 err = "Invalid option for 'supervised'. "
                     "Allowed values: 'upstart', 'systemd', 'auto', or 'no'";
                 goto loaderr;
             }
+        } else if (!strcasecmp(argv[0],"loadmodule") && argc >= 2) {
+            queueLoadModule(argv[1],&argv[2],argc-2);
         } else if (!strcasecmp(argv[0],"sentinel")) {
             /* argc == 1 is handled by main() as we need to enter the sentinel
              * mode ASAP. */
             if (argc != 1) {
                 if (!server.sentinel_mode) {
                     err = "sentinel directive while not in sentinel mode";
@@ -737,12 +844,15 @@
         if (sdslen(o->ptr) > CONFIG_AUTHPASS_MAX_LEN) goto badfmt;
         zfree(server.requirepass);
         server.requirepass = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
     } config_set_special_field("masterauth") {
         zfree(server.masterauth);
         server.masterauth = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
+    } config_set_special_field("cluster-announce-ip") {
+        zfree(server.cluster_announce_ip);
+        server.cluster_announce_ip = ((char*)o->ptr)[0] ? zstrdup(o->ptr) : NULL;
     } config_set_special_field("maxclients") {
         int orig_value = server.maxclients;
 
         if (getLongLongFromObject(o,&ll) == C_ERR || ll < 1) goto badfmt;
 
         /* Try to check if the OS is capable of supporting so many FDs. */
@@ -885,35 +995,73 @@
       "cluster-require-full-coverage",server.cluster_require_full_coverage) {
     } config_set_bool_field(
       "aof-rewrite-incremental-fsync",server.aof_rewrite_incremental_fsync) {
     } config_set_bool_field(
       "aof-load-truncated",server.aof_load_truncated) {
     } config_set_bool_field(
+      "aof-use-rdb-preamble",server.aof_use_rdb_preamble) {
+    } config_set_bool_field(
       "slave-serve-stale-data",server.repl_serve_stale_data) {
     } config_set_bool_field(
       "slave-read-only",server.repl_slave_ro) {
     } config_set_bool_field(
       "activerehashing",server.activerehashing) {
     } config_set_bool_field(
+      "activedefrag",server.active_defrag_enabled) {
+#ifndef HAVE_DEFRAG
+        if (server.active_defrag_enabled) {
+            server.active_defrag_enabled = 0;
+            addReplyError(c,
+                "Active defragmentation cannot be enabled: it requires a "
+                "Redis server compiled with a modified Jemalloc like the "
+                "one shipped by default with the Redis source distribution");
+            return;
+        }
+#endif
+    } config_set_bool_field(
       "protected-mode",server.protected_mode) {
     } config_set_bool_field(
       "stop-writes-on-bgsave-error",server.stop_writes_on_bgsave_err) {
     } config_set_bool_field(
+      "lazyfree-lazy-eviction",server.lazyfree_lazy_eviction) {
+    } config_set_bool_field(
+      "lazyfree-lazy-expire",server.lazyfree_lazy_expire) {
+    } config_set_bool_field(
+      "lazyfree-lazy-server-del",server.lazyfree_lazy_server_del) {
+    } config_set_bool_field(
+      "slave-lazy-flush",server.repl_slave_lazy_flush) {
+    } config_set_bool_field(
       "no-appendfsync-on-rewrite",server.aof_no_fsync_on_rewrite) {
 
     /* Numerical fields.
      * config_set_numerical_field(name,var,min,max) */
     } config_set_numerical_field(
       "tcp-keepalive",server.tcpkeepalive,0,LLONG_MAX) {
     } config_set_numerical_field(
       "maxmemory-samples",server.maxmemory_samples,1,LLONG_MAX) {
     } config_set_numerical_field(
+      "lfu-log-factor",server.lfu_log_factor,0,LLONG_MAX) {
+    } config_set_numerical_field(
+      "lfu-decay-time",server.lfu_decay_time,0,LLONG_MAX) {
+    } config_set_numerical_field(
       "timeout",server.maxidletime,0,LONG_MAX) {
     } config_set_numerical_field(
+      "active-defrag-threshold-lower",server.active_defrag_threshold_lower,0,1000) {
+    } config_set_numerical_field(
+      "active-defrag-threshold-upper",server.active_defrag_threshold_upper,0,1000) {
+    } config_set_memory_field(
+      "active-defrag-ignore-bytes",server.active_defrag_ignore_bytes) {
+    } config_set_numerical_field(
+      "active-defrag-cycle-min",server.active_defrag_cycle_min,1,99) {
+    } config_set_numerical_field(
+      "active-defrag-cycle-max",server.active_defrag_cycle_max,1,99) {
+    } config_set_numerical_field(
       "auto-aof-rewrite-percentage",server.aof_rewrite_perc,0,LLONG_MAX){
     } config_set_numerical_field(
+      "auto-aof-rewrite-min-size",server.aof_rewrite_min_size,0,LLONG_MAX) {
+    } config_set_numerical_field(
       "hash-max-ziplist-entries",server.hash_max_ziplist_entries,0,LLONG_MAX) {
     } config_set_numerical_field(
       "hash-max-ziplist-value",server.hash_max_ziplist_value,0,LLONG_MAX) {
     } config_set_numerical_field(
       "list-max-ziplist-size",server.list_max_ziplist_size,INT_MIN,INT_MAX) {
     } config_set_numerical_field(
@@ -954,12 +1102,16 @@
     } config_set_numerical_field(
       "min-slaves-max-lag",server.repl_min_slaves_max_lag,0,LLONG_MAX) {
         refreshGoodSlavesCount();
     } config_set_numerical_field(
       "cluster-node-timeout",server.cluster_node_timeout,0,LLONG_MAX) {
     } config_set_numerical_field(
+      "cluster-announce-port",server.cluster_announce_port,0,65535) {
+    } config_set_numerical_field(
+      "cluster-announce-bus-port",server.cluster_announce_bus_port,0,65535) {
+    } config_set_numerical_field(
       "cluster-migration-barrier",server.cluster_migration_barrier,0,LLONG_MAX){
     } config_set_numerical_field(
       "cluster-slave-validity-factor",server.cluster_slave_validity_factor,0,LLONG_MAX) {
     } config_set_numerical_field(
       "hz",server.hz,0,LLONG_MAX) {
         /* Hz is more an hint from the user, so we accept values out of range
@@ -981,14 +1133,12 @@
                 serverLog(LL_WARNING,"WARNING: the new maxmemory value set via CONFIG SET is smaller than the current memory usage. This will result in keys eviction and/or inability to accept new write commands depending on the maxmemory-policy.");
             }
             freeMemoryIfNeeded();
         }
     } config_set_memory_field("repl-backlog-size",ll) {
         resizeReplicationBacklog(ll);
-    } config_set_memory_field("auto-aof-rewrite-min-size",ll) {
-        server.aof_rewrite_min_size = ll;
 
     /* Enumeration fields.
      * config_set_enum_field(name,var,enum_var) */
     } config_set_enum_field(
       "loglevel",server.verbosity,loglevel_enum) {
     } config_set_enum_field(
@@ -1059,21 +1209,27 @@
     serverAssertWithInfo(c,o,sdsEncodedObject(o));
 
     /* String values */
     config_get_string_field("dbfilename",server.rdb_filename);
     config_get_string_field("requirepass",server.requirepass);
     config_get_string_field("masterauth",server.masterauth);
+    config_get_string_field("cluster-announce-ip",server.cluster_announce_ip);
     config_get_string_field("unixsocket",server.unixsocket);
     config_get_string_field("logfile",server.logfile);
     config_get_string_field("pidfile",server.pidfile);
     config_get_string_field("slave-announce-ip",server.slave_announce_ip);
 
     /* Numerical values */
     config_get_numerical_field("maxmemory",server.maxmemory);
     config_get_numerical_field("maxmemory-samples",server.maxmemory_samples);
     config_get_numerical_field("timeout",server.maxidletime);
+    config_get_numerical_field("active-defrag-threshold-lower",server.active_defrag_threshold_lower);
+    config_get_numerical_field("active-defrag-threshold-upper",server.active_defrag_threshold_upper);
+    config_get_numerical_field("active-defrag-ignore-bytes",server.active_defrag_ignore_bytes);
+    config_get_numerical_field("active-defrag-cycle-min",server.active_defrag_cycle_min);
+    config_get_numerical_field("active-defrag-cycle-max",server.active_defrag_cycle_max);
     config_get_numerical_field("auto-aof-rewrite-percentage",
             server.aof_rewrite_perc);
     config_get_numerical_field("auto-aof-rewrite-min-size",
             server.aof_rewrite_min_size);
     config_get_numerical_field("hash-max-ziplist-entries",
             server.hash_max_ziplist_entries);
@@ -1096,12 +1252,14 @@
             server.slowlog_log_slower_than);
     config_get_numerical_field("latency-monitor-threshold",
             server.latency_monitor_threshold);
     config_get_numerical_field("slowlog-max-len",
             server.slowlog_max_len);
     config_get_numerical_field("port",server.port);
+    config_get_numerical_field("cluster-announce-port",server.cluster_announce_port);
+    config_get_numerical_field("cluster-announce-bus-port",server.cluster_announce_bus_port);
     config_get_numerical_field("tcp-backlog",server.tcp_backlog);
     config_get_numerical_field("databases",server.dbnum);
     config_get_numerical_field("repl-ping-slave-period",server.repl_ping_slave_period);
     config_get_numerical_field("repl-timeout",server.repl_timeout);
     config_get_numerical_field("repl-backlog-size",server.repl_backlog_size);
     config_get_numerical_field("repl-backlog-ttl",server.repl_backlog_time_limit);
@@ -1130,21 +1288,32 @@
     config_get_bool_field("stop-writes-on-bgsave-error",
             server.stop_writes_on_bgsave_err);
     config_get_bool_field("daemonize", server.daemonize);
     config_get_bool_field("rdbcompression", server.rdb_compression);
     config_get_bool_field("rdbchecksum", server.rdb_checksum);
     config_get_bool_field("activerehashing", server.activerehashing);
+    config_get_bool_field("activedefrag", server.active_defrag_enabled);
     config_get_bool_field("protected-mode", server.protected_mode);
     config_get_bool_field("repl-disable-tcp-nodelay",
             server.repl_disable_tcp_nodelay);
     config_get_bool_field("repl-diskless-sync",
             server.repl_diskless_sync);
     config_get_bool_field("aof-rewrite-incremental-fsync",
             server.aof_rewrite_incremental_fsync);
     config_get_bool_field("aof-load-truncated",
             server.aof_load_truncated);
+    config_get_bool_field("aof-use-rdb-preamble",
+            server.aof_use_rdb_preamble);
+    config_get_bool_field("lazyfree-lazy-eviction",
+            server.lazyfree_lazy_eviction);
+    config_get_bool_field("lazyfree-lazy-expire",
+            server.lazyfree_lazy_expire);
+    config_get_bool_field("lazyfree-lazy-server-del",
+            server.lazyfree_lazy_server_del);
+    config_get_bool_field("slave-lazy-flush",
+            server.repl_slave_lazy_flush);
 
     /* Enum values */
     config_get_enum_field("maxmemory-policy",
             server.maxmemory_policy,maxmemory_policy_enum);
     config_get_enum_field("loglevel",
             server.verbosity,loglevel_enum);
@@ -1251,13 +1420,13 @@
 
 #define REDIS_CONFIG_REWRITE_SIGNATURE "# Generated by CONFIG REWRITE"
 
 /* We use the following dictionary type to store where a configuration
  * option is mentioned in the old configuration file, so it's
  * like "maxmemory" -> list of line numbers (first line is zero). */
-unsigned int dictSdsCaseHash(const void *key);
+uint64_t dictSdsCaseHash(const void *key);
 int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);
 void dictSdsDestructor(void *privdata, void *val);
 void dictListDestructor(void *privdata, void *val);
 
 /* Sentinel config rewriting is implemented inside sentinel.c by
  * rewriteConfigSentinelOption(). */
@@ -1778,12 +1947,14 @@
     /* Step 2: rewrite every single option, replacing or appending it inside
      * the rewrite state. */
 
     rewriteConfigYesNoOption(state,"daemonize",server.daemonize,0);
     rewriteConfigStringOption(state,"pidfile",server.pidfile,CONFIG_DEFAULT_PID_FILE);
     rewriteConfigNumericalOption(state,"port",server.port,CONFIG_DEFAULT_SERVER_PORT);
+    rewriteConfigNumericalOption(state,"cluster-announce-port",server.cluster_announce_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT);
+    rewriteConfigNumericalOption(state,"cluster-announce-bus-port",server.cluster_announce_bus_port,CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT);
     rewriteConfigNumericalOption(state,"tcp-backlog",server.tcp_backlog,CONFIG_DEFAULT_TCP_BACKLOG);
     rewriteConfigBindOption(state);
     rewriteConfigStringOption(state,"unixsocket",server.unixsocket,NULL);
     rewriteConfigOctalOption(state,"unixsocketperm",server.unixsocketperm,CONFIG_DEFAULT_UNIX_SOCKET_PERM);
     rewriteConfigNumericalOption(state,"timeout",server.maxidletime,CONFIG_DEFAULT_CLIENT_TIMEOUT);
     rewriteConfigNumericalOption(state,"tcp-keepalive",server.tcpkeepalive,CONFIG_DEFAULT_TCP_KEEPALIVE);
@@ -1800,12 +1971,13 @@
     rewriteConfigYesNoOption(state,"rdbchecksum",server.rdb_checksum,CONFIG_DEFAULT_RDB_CHECKSUM);
     rewriteConfigStringOption(state,"dbfilename",server.rdb_filename,CONFIG_DEFAULT_RDB_FILENAME);
     rewriteConfigDirOption(state);
     rewriteConfigSlaveofOption(state);
     rewriteConfigStringOption(state,"slave-announce-ip",server.slave_announce_ip,CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP);
     rewriteConfigStringOption(state,"masterauth",server.masterauth,NULL);
+    rewriteConfigStringOption(state,"cluster-announce-ip",server.cluster_announce_ip,NULL);
     rewriteConfigYesNoOption(state,"slave-serve-stale-data",server.repl_serve_stale_data,CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA);
     rewriteConfigYesNoOption(state,"slave-read-only",server.repl_slave_ro,CONFIG_DEFAULT_SLAVE_READ_ONLY);
     rewriteConfigNumericalOption(state,"repl-ping-slave-period",server.repl_ping_slave_period,CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD);
     rewriteConfigNumericalOption(state,"repl-timeout",server.repl_timeout,CONFIG_DEFAULT_REPL_TIMEOUT);
     rewriteConfigBytesOption(state,"repl-backlog-size",server.repl_backlog_size,CONFIG_DEFAULT_REPL_BACKLOG_SIZE);
     rewriteConfigBytesOption(state,"repl-backlog-ttl",server.repl_backlog_time_limit,CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT);
@@ -1817,12 +1989,17 @@
     rewriteConfigNumericalOption(state,"min-slaves-max-lag",server.repl_min_slaves_max_lag,CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG);
     rewriteConfigStringOption(state,"requirepass",server.requirepass,NULL);
     rewriteConfigNumericalOption(state,"maxclients",server.maxclients,CONFIG_DEFAULT_MAX_CLIENTS);
     rewriteConfigBytesOption(state,"maxmemory",server.maxmemory,CONFIG_DEFAULT_MAXMEMORY);
     rewriteConfigEnumOption(state,"maxmemory-policy",server.maxmemory_policy,maxmemory_policy_enum,CONFIG_DEFAULT_MAXMEMORY_POLICY);
     rewriteConfigNumericalOption(state,"maxmemory-samples",server.maxmemory_samples,CONFIG_DEFAULT_MAXMEMORY_SAMPLES);
+    rewriteConfigNumericalOption(state,"active-defrag-threshold-lower",server.active_defrag_threshold_lower,CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER);
+    rewriteConfigNumericalOption(state,"active-defrag-threshold-upper",server.active_defrag_threshold_upper,CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER);
+    rewriteConfigBytesOption(state,"active-defrag-ignore-bytes",server.active_defrag_ignore_bytes,CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES);
+    rewriteConfigNumericalOption(state,"active-defrag-cycle-min",server.active_defrag_cycle_min,CONFIG_DEFAULT_DEFRAG_CYCLE_MIN);
+    rewriteConfigNumericalOption(state,"active-defrag-cycle-max",server.active_defrag_cycle_max,CONFIG_DEFAULT_DEFRAG_CYCLE_MAX);
     rewriteConfigYesNoOption(state,"appendonly",server.aof_state != AOF_OFF,0);
     rewriteConfigStringOption(state,"appendfilename",server.aof_filename,CONFIG_DEFAULT_AOF_FILENAME);
     rewriteConfigEnumOption(state,"appendfsync",server.aof_fsync,aof_fsync_enum,CONFIG_DEFAULT_AOF_FSYNC);
     rewriteConfigYesNoOption(state,"no-appendfsync-on-rewrite",server.aof_no_fsync_on_rewrite,CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE);
     rewriteConfigNumericalOption(state,"auto-aof-rewrite-percentage",server.aof_rewrite_perc,AOF_REWRITE_PERC);
     rewriteConfigBytesOption(state,"auto-aof-rewrite-min-size",server.aof_rewrite_min_size,AOF_REWRITE_MIN_SIZE);
@@ -1843,18 +2020,24 @@
     rewriteConfigNumericalOption(state,"list-compress-depth",server.list_compress_depth,OBJ_LIST_COMPRESS_DEPTH);
     rewriteConfigNumericalOption(state,"set-max-intset-entries",server.set_max_intset_entries,OBJ_SET_MAX_INTSET_ENTRIES);
     rewriteConfigNumericalOption(state,"zset-max-ziplist-entries",server.zset_max_ziplist_entries,OBJ_ZSET_MAX_ZIPLIST_ENTRIES);
     rewriteConfigNumericalOption(state,"zset-max-ziplist-value",server.zset_max_ziplist_value,OBJ_ZSET_MAX_ZIPLIST_VALUE);
     rewriteConfigNumericalOption(state,"hll-sparse-max-bytes",server.hll_sparse_max_bytes,CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES);
     rewriteConfigYesNoOption(state,"activerehashing",server.activerehashing,CONFIG_DEFAULT_ACTIVE_REHASHING);
+    rewriteConfigYesNoOption(state,"activedefrag",server.active_defrag_enabled,CONFIG_DEFAULT_ACTIVE_DEFRAG);
     rewriteConfigYesNoOption(state,"protected-mode",server.protected_mode,CONFIG_DEFAULT_PROTECTED_MODE);
     rewriteConfigClientoutputbufferlimitOption(state);
     rewriteConfigNumericalOption(state,"hz",server.hz,CONFIG_DEFAULT_HZ);
     rewriteConfigYesNoOption(state,"aof-rewrite-incremental-fsync",server.aof_rewrite_incremental_fsync,CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC);
     rewriteConfigYesNoOption(state,"aof-load-truncated",server.aof_load_truncated,CONFIG_DEFAULT_AOF_LOAD_TRUNCATED);
+    rewriteConfigYesNoOption(state,"aof-use-rdb-preamble",server.aof_use_rdb_preamble,CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE);
     rewriteConfigEnumOption(state,"supervised",server.supervised_mode,supervised_mode_enum,SUPERVISED_NONE);
+    rewriteConfigYesNoOption(state,"lazyfree-lazy-eviction",server.lazyfree_lazy_eviction,CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION);
+    rewriteConfigYesNoOption(state,"lazyfree-lazy-expire",server.lazyfree_lazy_expire,CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE);
+    rewriteConfigYesNoOption(state,"lazyfree-lazy-server-del",server.lazyfree_lazy_server_del,CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL);
+    rewriteConfigYesNoOption(state,"slave-lazy-flush",server.repl_slave_lazy_flush,CONFIG_DEFAULT_SLAVE_LAZY_FLUSH);
 
     /* Rewrite Sentinel config if in Sentinel mode. */
     if (server.sentinel_mode) rewriteConfigSentinelOption(state);
 
     /* Step 3: remove all the orphaned lines in the old file, that is, lines
      * that were used by a config option and are no longer used, like in case
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.h	2017-07-14 19:28:42.000000000 +0800
@@ -203,7 +203,25 @@
 #if (GNUC_VERSION >= 40100 && __GLIBC_PREREQ(2, 6))
 #define HAVE_ATOMIC
 #endif
 #endif
 #endif
 
+/* Make sure we can test for ARM just checking for __arm__, since sometimes
+ * __arm is defined but __arm__ is not. */
+#if defined(__arm) && !defined(__arm__)
+#define __arm__
+#endif
+#if defined (__aarch64__) && !defined(__arm64__)
+#define __arm64__
+#endif
+
+/* Make sure we can test for SPARC just checking for __sparc__. */
+#if defined(__sparc) && !defined(__sparc__)
+#define __sparc__
+#endif
+
+#if defined(__sparc__) || defined(__arm__)
+#define USE_ALIGNED_ACCESS
+#endif
+
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/config.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/config.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc16.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc16.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc16.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc16.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc64.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc64.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/crc64.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/crc64.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.c	2017-07-14 19:28:42.000000000 +0800
@@ -26,20 +26,17 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "server.h"
 #include "cluster.h"
+#include "atomicvar.h"
 
 #include <signal.h>
 #include <ctype.h>
 
-void slotToKeyAdd(robj *key);
-void slotToKeyDel(robj *key);
-void slotToKeyFlush(void);
-
 /*-----------------------------------------------------------------------------
  * C-level DB API
  *----------------------------------------------------------------------------*/
 
 /* Low level key lookup API, not actually called directly from commands
  * implementations that should instead rely on lookupKeyRead(),
@@ -53,13 +50,19 @@
          * Don't do it if we have a saving child, as this will trigger
          * a copy on write madness. */
         if (server.rdb_child_pid == -1 &&
             server.aof_child_pid == -1 &&
             !(flags & LOOKUP_NOTOUCH))
         {
-            val->lru = LRU_CLOCK();
+            if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
+                unsigned long ldt = val->lru >> 8;
+                unsigned long counter = LFULogIncr(val->lru & 255);
+                val->lru = (ldt << 8) | counter;
+            } else {
+                val->lru = LRU_CLOCK();
+            }
         }
         return val;
     } else {
         return NULL;
     }
 }
@@ -169,21 +172,30 @@
  *
  * The program is aborted if the key was not already present. */
 void dbOverwrite(redisDb *db, robj *key, robj *val) {
     dictEntry *de = dictFind(db->dict,key->ptr);
 
     serverAssertWithInfo(NULL,key,de != NULL);
-    dictReplace(db->dict, key->ptr, val);
+    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
+        robj *old = dictGetVal(de);
+        int saved_lru = old->lru;
+        dictReplace(db->dict, key->ptr, val);
+        val->lru = saved_lru;
+    } else {
+        dictReplace(db->dict, key->ptr, val);
+    }
 }
 
 /* High level Set operation. This function can be used in order to set
  * a key, whatever it was existing or not, to a new object.
  *
  * 1) The ref count of the value object is incremented.
  * 2) clients WATCHing for the destination key notified.
- * 3) The expire time of the key is reset (the key is made persistent). */
+ * 3) The expire time of the key is reset (the key is made persistent).
+ *
+ * All the new keys in the database should be craeted via this interface. */
 void setKey(redisDb *db, robj *key, robj *val) {
     if (lookupKeyWrite(db,key) == NULL) {
         dbAdd(db,key,val);
     } else {
         dbOverwrite(db,key,val);
     }
@@ -220,24 +232,31 @@
         }
         return keyobj;
     }
 }
 
 /* Delete a key, value, and associated expiration entry if any, from the DB */
-int dbDelete(redisDb *db, robj *key) {
+int dbSyncDelete(redisDb *db, robj *key) {
     /* Deleting an entry from the expires dict will not free the sds of
      * the key, because it is shared with the main dictionary. */
     if (dictSize(db->expires) > 0) dictDelete(db->expires,key->ptr);
     if (dictDelete(db->dict,key->ptr) == DICT_OK) {
         if (server.cluster_enabled) slotToKeyDel(key);
         return 1;
     } else {
         return 0;
     }
 }
 
+/* This is a wrapper whose behavior depends on the Redis lazy free
+ * configuration. Deletes the key synchronously or asynchronously. */
+int dbDelete(redisDb *db, robj *key) {
+    return server.lazyfree_lazy_server_del ? dbAsyncDelete(db,key) :
+                                             dbSyncDelete(db,key);
+}
+
 /* Prepare the string object stored at 'key' to be modified destructively
  * to implement commands like SETBIT or APPEND.
  *
  * An object is usually ready to be modified unless one of the two conditions
  * are true:
  *
@@ -270,22 +289,53 @@
         decrRefCount(decoded);
         dbOverwrite(db,key,o);
     }
     return o;
 }
 
-long long emptyDb(void(callback)(void*)) {
-    int j;
+/* Remove all keys from all the databases in a Redis server.
+ * If callback is given the function is called from time to time to
+ * signal that work is in progress.
+ *
+ * The dbnum can be -1 if all teh DBs should be flushed, or the specified
+ * DB number if we want to flush only a single Redis database number.
+ *
+ * Flags are be EMPTYDB_NO_FLAGS if no special flags are specified or
+ * EMPTYDB_ASYNC if we want the memory to be freed in a different thread
+ * and the function to return ASAP.
+ *
+ * On success the fuction returns the number of keys removed from the
+ * database(s). Otherwise -1 is returned in the specific case the
+ * DB number is out of range, and errno is set to EINVAL. */
+long long emptyDb(int dbnum, int flags, void(callback)(void*)) {
+    int j, async = (flags & EMPTYDB_ASYNC);
     long long removed = 0;
 
+    if (dbnum < -1 || dbnum >= server.dbnum) {
+        errno = EINVAL;
+        return -1;
+    }
+
     for (j = 0; j < server.dbnum; j++) {
+        if (dbnum != -1 && dbnum != j) continue;
         removed += dictSize(server.db[j].dict);
-        dictEmpty(server.db[j].dict,callback);
-        dictEmpty(server.db[j].expires,callback);
+        if (async) {
+            emptyDbAsync(&server.db[j]);
+        } else {
+            dictEmpty(server.db[j].dict,callback);
+            dictEmpty(server.db[j].expires,callback);
+        }
     }
-    if (server.cluster_enabled) slotToKeyFlush();
+    if (server.cluster_enabled) {
+        if (async) {
+            slotToKeyFlushAsync();
+        } else {
+            slotToKeyFlush();
+        }
+    }
+    if (dbnum == -1) flushSlaveKeysWithExpireList();
     return removed;
 }
 
 int selectDb(client *c, int id) {
     if (id < 0 || id >= server.dbnum)
         return C_ERR;
@@ -311,53 +361,95 @@
 }
 
 /*-----------------------------------------------------------------------------
  * Type agnostic commands operating on the key space
  *----------------------------------------------------------------------------*/
 
+/* Return the set of flags to use for the emptyDb() call for FLUSHALL
+ * and FLUSHDB commands.
+ *
+ * Currently the command just attempts to parse the "ASYNC" option. It
+ * also checks if the command arity is wrong.
+ *
+ * On success C_OK is returned and the flags are stored in *flags, otherwise
+ * C_ERR is returned and the function sends an error to the client. */
+int getFlushCommandFlags(client *c, int *flags) {
+    /* Parse the optional ASYNC option. */
+    if (c->argc > 1) {
+        if (c->argc > 2 || strcasecmp(c->argv[1]->ptr,"async")) {
+            addReply(c,shared.syntaxerr);
+            return C_ERR;
+        }
+        *flags = EMPTYDB_ASYNC;
+    } else {
+        *flags = EMPTYDB_NO_FLAGS;
+    }
+    return C_OK;
+}
+
+/* FLUSHDB [ASYNC]
+ *
+ * Flushes the currently SELECTed Redis DB. */
 void flushdbCommand(client *c) {
-    server.dirty += dictSize(c->db->dict);
+    int flags;
+
+    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
     signalFlushedDb(c->db->id);
-    dictEmpty(c->db->dict,NULL);
-    dictEmpty(c->db->expires,NULL);
-    if (server.cluster_enabled) slotToKeyFlush();
+    server.dirty += emptyDb(c->db->id,flags,NULL);
     addReply(c,shared.ok);
 }
 
+/* FLUSHALL [ASYNC]
+ *
+ * Flushes the whole server data set. */
 void flushallCommand(client *c) {
+    int flags;
+
+    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
     signalFlushedDb(-1);
-    server.dirty += emptyDb(NULL);
+    server.dirty += emptyDb(-1,flags,NULL);
     addReply(c,shared.ok);
     if (server.rdb_child_pid != -1) {
         kill(server.rdb_child_pid,SIGUSR1);
         rdbRemoveTempFile(server.rdb_child_pid);
     }
     if (server.saveparamslen > 0) {
         /* Normally rdbSave() will reset dirty, but we don't want this here
          * as otherwise FLUSHALL will not be replicated nor put into the AOF. */
         int saved_dirty = server.dirty;
-        rdbSave(server.rdb_filename);
+        rdbSave(server.rdb_filename,NULL);
         server.dirty = saved_dirty;
     }
     server.dirty++;
 }
 
-void delCommand(client *c) {
-    int deleted = 0, j;
+/* This command implements DEL and LAZYDEL. */
+void delGenericCommand(client *c, int lazy) {
+    int numdel = 0, j;
 
     for (j = 1; j < c->argc; j++) {
         expireIfNeeded(c->db,c->argv[j]);
-        if (dbDelete(c->db,c->argv[j])) {
+        int deleted  = lazy ? dbAsyncDelete(c->db,c->argv[j]) :
+                              dbSyncDelete(c->db,c->argv[j]);
+        if (deleted) {
             signalModifiedKey(c->db,c->argv[j]);
             notifyKeyspaceEvent(NOTIFY_GENERIC,
                 "del",c->argv[j],c->db->id);
             server.dirty++;
-            deleted++;
+            numdel++;
         }
     }
-    addReplyLongLong(c,deleted);
+    addReplyLongLong(c,numdel);
+}
+
+void delCommand(client *c) {
+    delGenericCommand(c,0);
+}
+
+void unlinkCommand(client *c) {
+    delGenericCommand(c,1);
 }
 
 /* EXISTS key1 key2 ... key_N.
  * Return value is the number of keys existing. */
 void existsCommand(client *c) {
     long long count = 0;
@@ -379,13 +471,13 @@
 
     if (server.cluster_enabled && id != 0) {
         addReplyError(c,"SELECT is not allowed in cluster mode");
         return;
     }
     if (selectDb(c,id) == C_ERR) {
-        addReplyError(c,"invalid DB index");
+        addReplyError(c,"DB index is out of range");
     } else {
         addReply(c,shared.ok);
     }
 }
 
 void randomkeyCommand(client *c) {
@@ -436,22 +528,22 @@
     robj *key, *val = NULL;
 
     if (o == NULL) {
         sds sdskey = dictGetKey(de);
         key = createStringObject(sdskey, sdslen(sdskey));
     } else if (o->type == OBJ_SET) {
-        key = dictGetKey(de);
-        incrRefCount(key);
+        sds keysds = dictGetKey(de);
+        key = createStringObject(keysds,sdslen(keysds));
     } else if (o->type == OBJ_HASH) {
-        key = dictGetKey(de);
-        incrRefCount(key);
-        val = dictGetVal(de);
-        incrRefCount(val);
+        sds sdskey = dictGetKey(de);
+        sds sdsval = dictGetVal(de);
+        key = createStringObject(sdskey,sdslen(sdskey));
+        val = createStringObject(sdsval,sdslen(sdsval));
     } else if (o->type == OBJ_ZSET) {
-        key = dictGetKey(de);
-        incrRefCount(key);
+        sds sdskey = dictGetKey(de);
+        key = createStringObject(sdskey,sdslen(sdskey));
         val = createStringObjectFromLongDouble(*(double*)dictGetVal(de),0);
     } else {
         serverPanic("Type not handled in SCAN callback.");
     }
 
     listAddNodeTail(keys, key);
@@ -570,13 +662,13 @@
         /* We pass two pointers to the callback: the list to which it will
          * add new elements, and the object containing the dictionary so that
          * it is possible to fetch more data in a type-dependent way. */
         privdata[0] = keys;
         privdata[1] = o;
         do {
-            cursor = dictScan(ht, cursor, scanCallback, privdata);
+            cursor = dictScan(ht, cursor, scanCallback, NULL, privdata);
         } while (cursor &&
               maxiterations-- &&
               listLength(keys) < (unsigned long)count);
     } else if (o->type == OBJ_SET) {
         int pos = 0;
         int64_t ll;
@@ -691,12 +783,16 @@
         switch(o->type) {
         case OBJ_STRING: type = "string"; break;
         case OBJ_LIST: type = "list"; break;
         case OBJ_SET: type = "set"; break;
         case OBJ_ZSET: type = "zset"; break;
         case OBJ_HASH: type = "hash"; break;
+        case OBJ_MODULE: {
+            moduleValue *mv = o->ptr;
+            type = mv->type->name;
+        }; break;
         default: type = "unknown"; break;
         }
     }
     addReplyStatus(c,type);
 }
 
@@ -755,13 +851,13 @@
         }
         /* Overwrite: delete the old key before creating the new one
          * with the same name. */
         dbDelete(c->db,c->argv[2]);
     }
     dbAdd(c->db,c->argv[2],o);
-    if (expire != -1) setExpire(c->db,c->argv[2],expire);
+    if (expire != -1) setExpire(c,c->db,c->argv[2],expire);
     dbDelete(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[2]);
     notifyKeyspaceEvent(NOTIFY_GENERIC,"rename_from",
         c->argv[1],c->db->id);
     notifyKeyspaceEvent(NOTIFY_GENERIC,"rename_to",
@@ -821,40 +917,133 @@
     /* Return zero if the key already exists in the target DB */
     if (lookupKeyWrite(dst,c->argv[1]) != NULL) {
         addReply(c,shared.czero);
         return;
     }
     dbAdd(dst,c->argv[1],o);
-    if (expire != -1) setExpire(dst,c->argv[1],expire);
+    if (expire != -1) setExpire(c,dst,c->argv[1],expire);
     incrRefCount(o);
 
     /* OK! key moved, free the entry in the source DB */
     dbDelete(src,c->argv[1]);
     server.dirty++;
     addReply(c,shared.cone);
 }
 
+/* Helper function for dbSwapDatabases(): scans the list of keys that have
+ * one or more blocked clients for B[LR]POP or other list blocking commands
+ * and signal the keys are ready if they are lists. See the comment where
+ * the function is used for more info. */
+void scanDatabaseForReadyLists(redisDb *db) {
+    dictEntry *de;
+    dictIterator *di = dictGetSafeIterator(db->blocking_keys);
+    while((de = dictNext(di)) != NULL) {
+        robj *key = dictGetKey(de);
+        robj *value = lookupKey(db,key,LOOKUP_NOTOUCH);
+        if (value && value->type == OBJ_LIST)
+            signalListAsReady(db, key);
+    }
+    dictReleaseIterator(di);
+}
+
+/* Swap two databases at runtime so that all clients will magically see
+ * the new database even if already connected. Note that the client
+ * structure c->db points to a given DB, so we need to be smarter and
+ * swap the underlying referenced structures, otherwise we would need
+ * to fix all the references to the Redis DB structure.
+ *
+ * Returns C_ERR if at least one of the DB ids are out of range, otherwise
+ * C_OK is returned. */
+int dbSwapDatabases(int id1, int id2) {
+    if (id1 < 0 || id1 >= server.dbnum ||
+        id2 < 0 || id2 >= server.dbnum) return C_ERR;
+    if (id1 == id2) return C_OK;
+    redisDb aux = server.db[id1];
+    redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];
+
+    /* Swap hash tables. Note that we don't swap blocking_keys,
+     * ready_keys and watched_keys, since we want clients to
+     * remain in the same DB they were. */
+    db1->dict = db2->dict;
+    db1->expires = db2->expires;
+    db1->avg_ttl = db2->avg_ttl;
+
+    db2->dict = aux.dict;
+    db2->expires = aux.expires;
+    db2->avg_ttl = aux.avg_ttl;
+
+    /* Now we need to handle clients blocked on lists: as an effect
+     * of swapping the two DBs, a client that was waiting for list
+     * X in a given DB, may now actually be unblocked if X happens
+     * to exist in the new version of the DB, after the swap.
+     *
+     * However normally we only do this check for efficiency reasons
+     * in dbAdd() when a list is created. So here we need to rescan
+     * the list of clients blocked on lists and signal lists as ready
+     * if needed. */
+    scanDatabaseForReadyLists(db1);
+    scanDatabaseForReadyLists(db2);
+    return C_OK;
+}
+
+/* SWAPDB db1 db2 */
+void swapdbCommand(client *c) {
+    long id1, id2;
+
+    /* Not allowed in cluster mode: we have just DB 0 there. */
+    if (server.cluster_enabled) {
+        addReplyError(c,"SWAPDB is not allowed in cluster mode");
+        return;
+    }
+
+    /* Get the two DBs indexes. */
+    if (getLongFromObjectOrReply(c, c->argv[1], &id1,
+        "invalid first DB index") != C_OK)
+        return;
+
+    if (getLongFromObjectOrReply(c, c->argv[2], &id2,
+        "invalid second DB index") != C_OK)
+        return;
+
+    /* Swap... */
+    if (dbSwapDatabases(id1,id2) == C_ERR) {
+        addReplyError(c,"DB index is out of range");
+        return;
+    } else {
+        server.dirty++;
+        addReply(c,shared.ok);
+    }
+}
+
 /*-----------------------------------------------------------------------------
  * Expires API
  *----------------------------------------------------------------------------*/
 
 int removeExpire(redisDb *db, robj *key) {
     /* An expire may only be removed if there is a corresponding entry in the
      * main dict. Otherwise, the key will never be freed. */
     serverAssertWithInfo(NULL,key,dictFind(db->dict,key->ptr) != NULL);
     return dictDelete(db->expires,key->ptr) == DICT_OK;
 }
 
-void setExpire(redisDb *db, robj *key, long long when) {
+/* Set an expire to the specified key. If the expire is set in the context
+ * of an user calling a command 'c' is the client, otherwise 'c' is set
+ * to NULL. The 'when' parameter is the absolute unix time in milliseconds
+ * after which the key will no longer be considered valid. */
+void setExpire(client *c, redisDb *db, robj *key, long long when) {
     dictEntry *kde, *de;
 
     /* Reuse the sds from the main dict in the expire dict */
     kde = dictFind(db->dict,key->ptr);
     serverAssertWithInfo(NULL,key,kde != NULL);
-    de = dictReplaceRaw(db->expires,dictGetKey(kde));
+    de = dictAddOrFind(db->expires,dictGetKey(kde));
     dictSetSignedIntegerVal(de,when);
+
+    int writable_slave = server.masterhost && server.repl_slave_ro == 0;
+    if (c && writable_slave && !(c->flags & CLIENT_MASTER))
+        rememberSlaveKeyWithExpire(db,key);
 }
 
 /* Return the expire time of the specified key, or -1 if no expire
  * is associated with this key (i.e. the key is non volatile) */
 long long getExpire(redisDb *db, robj *key) {
     dictEntry *de;
@@ -874,16 +1063,16 @@
  * to all the slaves and the AOF file if enabled.
  *
  * This way the key expiry is centralized in one place, and since both
  * AOF and the master->slave link guarantee operation ordering, everything
  * will be consistent even if we allow write operations against expiring
  * keys. */
-void propagateExpire(redisDb *db, robj *key) {
+void propagateExpire(redisDb *db, robj *key, int lazy) {
     robj *argv[2];
 
-    argv[0] = shared.del;
+    argv[0] = lazy ? shared.unlink : shared.del;
     argv[1] = key;
     incrRefCount(argv[0]);
     incrRefCount(argv[1]);
 
     if (server.aof_state != AOF_OFF)
         feedAppendOnlyFile(server.delCommand,db->id,argv,2);
@@ -920,140 +1109,17 @@
 
     /* Return when this key has not expired */
     if (now <= when) return 0;
 
     /* Delete the key */
     server.stat_expiredkeys++;
-    propagateExpire(db,key);
+    propagateExpire(db,key,server.lazyfree_lazy_expire);
     notifyKeyspaceEvent(NOTIFY_EXPIRED,
         "expired",key,db->id);
-    return dbDelete(db,key);
-}
-
-/*-----------------------------------------------------------------------------
- * Expires Commands
- *----------------------------------------------------------------------------*/
-
-/* This is the generic command implementation for EXPIRE, PEXPIRE, EXPIREAT
- * and PEXPIREAT. Because the commad second argument may be relative or absolute
- * the "basetime" argument is used to signal what the base time is (either 0
- * for *AT variants of the command, or the current time for relative expires).
- *
- * unit is either UNIT_SECONDS or UNIT_MILLISECONDS, and is only used for
- * the argv[2] parameter. The basetime is always specified in milliseconds. */
-void expireGenericCommand(client *c, long long basetime, int unit) {
-    robj *key = c->argv[1], *param = c->argv[2];
-    long long when; /* unix time in milliseconds when the key will expire. */
-
-    if (getLongLongFromObjectOrReply(c, param, &when, NULL) != C_OK)
-        return;
-
-    if (unit == UNIT_SECONDS) when *= 1000;
-    when += basetime;
-
-    /* No key, return zero. */
-    if (lookupKeyWrite(c->db,key) == NULL) {
-        addReply(c,shared.czero);
-        return;
-    }
-
-    /* EXPIRE with negative TTL, or EXPIREAT with a timestamp into the past
-     * should never be executed as a DEL when load the AOF or in the context
-     * of a slave instance.
-     *
-     * Instead we take the other branch of the IF statement setting an expire
-     * (possibly in the past) and wait for an explicit DEL from the master. */
-    if (when <= mstime() && !server.loading && !server.masterhost) {
-        robj *aux;
-
-        serverAssertWithInfo(c,key,dbDelete(c->db,key));
-        server.dirty++;
-
-        /* Replicate/AOF this as an explicit DEL. */
-        aux = createStringObject("DEL",3);
-        rewriteClientCommandVector(c,2,aux,key);
-        decrRefCount(aux);
-        signalModifiedKey(c->db,key);
-        notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
-        addReply(c, shared.cone);
-        return;
-    } else {
-        setExpire(c->db,key,when);
-        addReply(c,shared.cone);
-        signalModifiedKey(c->db,key);
-        notifyKeyspaceEvent(NOTIFY_GENERIC,"expire",key,c->db->id);
-        server.dirty++;
-        return;
-    }
-}
-
-void expireCommand(client *c) {
-    expireGenericCommand(c,mstime(),UNIT_SECONDS);
-}
-
-void expireatCommand(client *c) {
-    expireGenericCommand(c,0,UNIT_SECONDS);
-}
-
-void pexpireCommand(client *c) {
-    expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);
-}
-
-void pexpireatCommand(client *c) {
-    expireGenericCommand(c,0,UNIT_MILLISECONDS);
-}
-
-void ttlGenericCommand(client *c, int output_ms) {
-    long long expire, ttl = -1;
-
-    /* If the key does not exist at all, return -2 */
-    if (lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH) == NULL) {
-        addReplyLongLong(c,-2);
-        return;
-    }
-    /* The key exists. Return -1 if it has no expire, or the actual
-     * TTL value otherwise. */
-    expire = getExpire(c->db,c->argv[1]);
-    if (expire != -1) {
-        ttl = expire-mstime();
-        if (ttl < 0) ttl = 0;
-    }
-    if (ttl == -1) {
-        addReplyLongLong(c,-1);
-    } else {
-        addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
-    }
-}
-
-void ttlCommand(client *c) {
-    ttlGenericCommand(c, 0);
-}
-
-void pttlCommand(client *c) {
-    ttlGenericCommand(c, 1);
-}
-
-void persistCommand(client *c) {
-    if (lookupKeyWrite(c->db,c->argv[1])) {
-        if (removeExpire(c->db,c->argv[1])) {
-            addReply(c,shared.cone);
-            server.dirty++;
-        } else {
-            addReply(c,shared.czero);
-        }
-    } else {
-        addReply(c,shared.czero);
-    }
-}
-
-/* TOUCH key1 [key2 key3 ... keyN] */
-void touchCommand(client *c) {
-    int touched = 0;
-    for (int j = 1; j < c->argc; j++)
-        if (lookupKeyRead(c->db,c->argv[j]) != NULL) touched++;
-    addReplyLongLong(c,touched);
+    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
+                                         dbSyncDelete(db,key);
 }
 
 /* -----------------------------------------------------------------------------
  * API to get key arguments from commands
  * ---------------------------------------------------------------------------*/
 
@@ -1064,17 +1130,30 @@
     UNUSED(argv);
 
     if (cmd->firstkey == 0) {
         *numkeys = 0;
         return NULL;
     }
+
     last = cmd->lastkey;
     if (last < 0) last = argc+last;
     keys = zmalloc(sizeof(int)*((last - cmd->firstkey)+1));
     for (j = cmd->firstkey; j <= last; j += cmd->keystep) {
-        serverAssert(j < argc);
+        if (j >= argc) {
+            /* Modules command do not have dispatch time arity checks, so
+             * we need to handle the case where the user passed an invalid
+             * number of arguments here. In this case we return no keys
+             * and expect the module command to report an arity error. */
+            if (cmd->flags & CMD_MODULE) {
+                zfree(keys);
+                *numkeys = 0;
+                return NULL;
+            } else {
+                serverPanic("Redis built-in command declared keys positions not matching the arity requirements.");
+            }
+        }
         keys[i++] = j;
     }
     *numkeys = i;
     return keys;
 }
 
@@ -1087,13 +1166,15 @@
  * 'cmd' must be point to the corresponding entry into the redisCommand
  * table, according to the command name in argv[0].
  *
  * This function uses the command table if a command-specific helper function
  * is not required, otherwise it calls the command-specific function. */
 int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {
-    if (cmd->getkeys_proc) {
+    if (cmd->flags & CMD_MODULE_GETKEYS) {
+        return moduleGetCommandKeysViaAPI(cmd,argv,argc,numkeys);
+    } else if (!(cmd->flags & CMD_MODULE) && cmd->getkeys_proc) {
         return cmd->getkeys_proc(cmd,argv,argc,numkeys);
     } else {
         return getKeysUsingCommandTable(cmd,argv,argc,numkeys);
     }
 }
 
@@ -1268,91 +1349,88 @@
     *numkeys = num; 
     return keys;
 }
 
 /* Slot to Key API. This is used by Redis Cluster in order to obtain in
  * a fast way a key that belongs to a specified hash slot. This is useful
- * while rehashing the cluster. */
-void slotToKeyAdd(robj *key) {
+ * while rehashing the cluster and in other conditions when we need to
+ * understand if we have keys for a given hash slot. */
+void slotToKeyUpdateKey(robj *key, int add) {
     unsigned int hashslot = keyHashSlot(key->ptr,sdslen(key->ptr));
+    unsigned char buf[64];
+    unsigned char *indexed = buf;
+    size_t keylen = sdslen(key->ptr);
+
+    server.cluster->slots_keys_count[hashslot] += add ? 1 : -1;
+    if (keylen+2 > 64) indexed = zmalloc(keylen+2);
+    indexed[0] = (hashslot >> 8) & 0xff;
+    indexed[1] = hashslot & 0xff;
+    memcpy(indexed+2,key->ptr,keylen);
+    if (add) {
+        raxInsert(server.cluster->slots_to_keys,indexed,keylen+2,NULL,NULL);
+    } else {
+        raxRemove(server.cluster->slots_to_keys,indexed,keylen+2,NULL);
+    }
+    if (indexed != buf) zfree(indexed);
+}
 
-    zslInsert(server.cluster->slots_to_keys,hashslot,key);
-    incrRefCount(key);
+void slotToKeyAdd(robj *key) {
+    slotToKeyUpdateKey(key,1);
 }
 
 void slotToKeyDel(robj *key) {
-    unsigned int hashslot = keyHashSlot(key->ptr,sdslen(key->ptr));
-
-    zslDelete(server.cluster->slots_to_keys,hashslot,key);
+    slotToKeyUpdateKey(key,0);
 }
 
 void slotToKeyFlush(void) {
-    zslFree(server.cluster->slots_to_keys);
-    server.cluster->slots_to_keys = zslCreate();
+    raxFree(server.cluster->slots_to_keys);
+    server.cluster->slots_to_keys = raxNew();
+    memset(server.cluster->slots_keys_count,0,
+           sizeof(server.cluster->slots_keys_count));
 }
 
+/* Pupulate the specified array of objects with keys in the specified slot.
+ * New objects are returned to represent keys, it's up to the caller to
+ * decrement the reference count to release the keys names. */
 unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count) {
-    zskiplistNode *n;
-    zrangespec range;
+    raxIterator iter;
     int j = 0;
+    unsigned char indexed[2];
 
-    range.min = range.max = hashslot;
-    range.minex = range.maxex = 0;
-
-    n = zslFirstInRange(server.cluster->slots_to_keys, &range);
-    while(n && n->score == hashslot && count--) {
-        keys[j++] = n->obj;
-        n = n->level[0].forward;
+    indexed[0] = (hashslot >> 8) & 0xff;
+    indexed[1] = hashslot & 0xff;
+    raxStart(&iter,server.cluster->slots_to_keys);
+    raxSeek(&iter,">=",indexed,2);
+    while(count-- && raxNext(&iter)) {
+        if (iter.key[0] != indexed[0] || iter.key[1] != indexed[1]) break;
+        keys[j++] = createStringObject((char*)iter.key+2,iter.key_len-2);
     }
+    raxStop(&iter);
     return j;
 }
 
 /* Remove all the keys in the specified hash slot.
  * The number of removed items is returned. */
 unsigned int delKeysInSlot(unsigned int hashslot) {
-    zskiplistNode *n;
-    zrangespec range;
+    raxIterator iter;
     int j = 0;
+    unsigned char indexed[2];
 
-    range.min = range.max = hashslot;
-    range.minex = range.maxex = 0;
+    indexed[0] = (hashslot >> 8) & 0xff;
+    indexed[1] = hashslot & 0xff;
+    raxStart(&iter,server.cluster->slots_to_keys);
+    while(server.cluster->slots_keys_count[hashslot]) {
+        raxSeek(&iter,">=",indexed,2);
+        raxNext(&iter);
 
-    n = zslFirstInRange(server.cluster->slots_to_keys, &range);
-    while(n && n->score == hashslot) {
-        robj *key = n->obj;
-        n = n->level[0].forward; /* Go to the next item before freeing it. */
-        incrRefCount(key); /* Protect the object while freeing it. */
+        robj *key = createStringObject((char*)iter.key+2,iter.key_len-2);
         dbDelete(&server.db[0],key);
         decrRefCount(key);
         j++;
     }
+    raxStop(&iter);
     return j;
 }
 
 unsigned int countKeysInSlot(unsigned int hashslot) {
-    zskiplist *zsl = server.cluster->slots_to_keys;
-    zskiplistNode *zn;
-    zrangespec range;
-    int rank, count = 0;
-
-    range.min = range.max = hashslot;
-    range.minex = range.maxex = 0;
-
-    /* Find first element in range */
-    zn = zslFirstInRange(zsl, &range);
-
-    /* Use rank of first element, if any, to determine preliminary count */
-    if (zn != NULL) {
-        rank = zslGetRank(zsl, zn->score, zn->obj);
-        count = (zsl->length - (rank - 1));
-
-        /* Find last element in range */
-        zn = zslLastInRange(zsl, &range);
-
-        /* Use rank of last element, if any, to determine the actual count */
-        if (zn != NULL) {
-            rank = zslGetRank(zsl, zn->score, zn->obj);
-            count -= (zsl->length - rank);
-        }
-    }
-    return count;
+    return server.cluster->slots_keys_count[hashslot];
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/db.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/db.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.c	2017-07-14 19:28:42.000000000 +0800
@@ -30,20 +30,20 @@
 #include "server.h"
 #include "sha1.h"   /* SHA1 is used for DEBUG DIGEST */
 #include "crc64.h"
 
 #include <arpa/inet.h>
 #include <signal.h>
+#include <dlfcn.h>
 
 #ifdef HAVE_BACKTRACE
 #include <execinfo.h>
 #include <ucontext.h>
 #include <fcntl.h>
 #include "bio.h"
 #include <unistd.h>
-#include <dlfcn.h>
 #endif /* HAVE_BACKTRACE */
 
 #ifdef __CYGWIN__
 #ifndef SA_ONSTACK
 #define SA_ONSTACK 0x08000000
 #endif
@@ -162,16 +162,16 @@
                     mixObjectDigest(digest,eleobj);
                     decrRefCount(eleobj);
                 }
                 listTypeReleaseIterator(li);
             } else if (o->type == OBJ_SET) {
                 setTypeIterator *si = setTypeInitIterator(o);
-                robj *ele;
-                while((ele = setTypeNextObject(si)) != NULL) {
-                    xorObjectDigest(digest,ele);
-                    decrRefCount(ele);
+                sds sdsele;
+                while((sdsele = setTypeNextObject(si)) != NULL) {
+                    xorDigest(digest,sdsele,sdslen(sdsele));
+                    sdsfree(sdsele);
                 }
                 setTypeReleaseIterator(si);
             } else if (o->type == OBJ_ZSET) {
                 unsigned char eledigest[20];
 
                 if (o->encoding == OBJ_ENCODING_ZIPLIST) {
@@ -207,43 +207,50 @@
                 } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
                     zset *zs = o->ptr;
                     dictIterator *di = dictGetIterator(zs->dict);
                     dictEntry *de;
 
                     while((de = dictNext(di)) != NULL) {
-                        robj *eleobj = dictGetKey(de);
+                        sds sdsele = dictGetKey(de);
                         double *score = dictGetVal(de);
 
                         snprintf(buf,sizeof(buf),"%.17g",*score);
                         memset(eledigest,0,20);
-                        mixObjectDigest(eledigest,eleobj);
+                        mixDigest(eledigest,sdsele,sdslen(sdsele));
                         mixDigest(eledigest,buf,strlen(buf));
                         xorDigest(digest,eledigest,20);
                     }
                     dictReleaseIterator(di);
                 } else {
                     serverPanic("Unknown sorted set encoding");
                 }
             } else if (o->type == OBJ_HASH) {
-                hashTypeIterator *hi;
-                robj *obj;
-
-                hi = hashTypeInitIterator(o);
+                hashTypeIterator *hi = hashTypeInitIterator(o);
                 while (hashTypeNext(hi) != C_ERR) {
                     unsigned char eledigest[20];
+                    sds sdsele;
 
                     memset(eledigest,0,20);
-                    obj = hashTypeCurrentObject(hi,OBJ_HASH_KEY);
-                    mixObjectDigest(eledigest,obj);
-                    decrRefCount(obj);
-                    obj = hashTypeCurrentObject(hi,OBJ_HASH_VALUE);
-                    mixObjectDigest(eledigest,obj);
-                    decrRefCount(obj);
+                    sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
+                    mixDigest(eledigest,sdsele,sdslen(sdsele));
+                    sdsfree(sdsele);
+                    sdsele = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
+                    mixDigest(eledigest,sdsele,sdslen(sdsele));
+                    sdsfree(sdsele);
                     xorDigest(digest,eledigest,20);
                 }
                 hashTypeReleaseIterator(hi);
+            } else if (o->type == OBJ_MODULE) {
+                RedisModuleDigest md;
+                moduleValue *mv = o->ptr;
+                moduleType *mt = mv->type;
+                moduleInitDigestContext(md);
+                if (mt->digest) {
+                    mt->digest(&md,mv->value);
+                    xorDigest(digest,md.x,sizeof(md.x));
+                }
             } else {
                 serverPanic("Unknown object type");
             }
             /* If the key has an expire, add it to the mix */
             if (expiretime != -1) xorDigest(digest,"!!expire!!",10);
             /* We can finally xor the key-val digest to the final digest */
@@ -251,20 +258,12 @@
             decrRefCount(keyobj);
         }
         dictReleaseIterator(di);
     }
 }
 
-#if defined(USE_JEMALLOC)
-void inputCatSds(void *result, const char *str) {
-    /* result is actually a (sds *), so re-cast it here */
-    sds *info = (sds *)result;
-    *info = sdscat(*info, str);
-}
-#endif
-
 void debugCommand(client *c) {
     if (c->argc == 1) {
         addReplyError(c,"You must specify a subcommand for DEBUG. Try DEBUG HELP for info.");
         return;
     }
 
@@ -273,12 +272,14 @@
         int blen = 0;
         blen++; addReplyStatus(c,
         "DEBUG <subcommand> arg arg ... arg. Subcommands:");
         blen++; addReplyStatus(c,
         "segfault -- Crash the server with sigsegv.");
         blen++; addReplyStatus(c,
+        "panic -- Crash the server simulating a panic.");
+        blen++; addReplyStatus(c,
         "restart  -- Graceful restart: save config, db, restart.");
         blen++; addReplyStatus(c,
         "crash-and-recovery <milliseconds> -- Hard crash and restart after <milliseconds> delay.");
         blen++; addReplyStatus(c,
         "assert   -- Crash by assertion failed.");
         blen++; addReplyStatus(c,
@@ -287,13 +288,15 @@
         "loadaof  -- Flush the AOF buffers on disk and reload the AOF in memory.");
         blen++; addReplyStatus(c,
         "object <key> -- Show low level info about key and associated value.");
         blen++; addReplyStatus(c,
         "sdslen <key> -- Show low level SDS string info representing key and value.");
         blen++; addReplyStatus(c,
-        "populate <count> [prefix] -- Create <count> string keys named key:<num>. If a prefix is specified is used instead of the 'key' prefix.");
+        "ziplist <key> -- Show low level info about the ziplist encoding.");
+        blen++; addReplyStatus(c,
+        "populate <count> [prefix] [size] -- Create <count> string keys named key:<num>. If a prefix is specified is used instead of the 'key' prefix.");
         blen++; addReplyStatus(c,
         "digest   -- Outputs an hex signature representing the current DB content.");
         blen++; addReplyStatus(c,
         "sleep <seconds> -- Stop the server for <seconds>. Decimals allowed.");
         blen++; addReplyStatus(c,
         "set-active-expire (0|1) -- Setting it to 0 disables expiring keys in background when they are not accessed (otherwise the Redis behavior). Setting it to 1 reenables back the default.");
@@ -302,19 +305,17 @@
         blen++; addReplyStatus(c,
         "error <string> -- Return a Redis protocol error with <string> as message. Useful for clients unit tests to simulate Redis errors.");
         blen++; addReplyStatus(c,
         "structsize -- Return the size of different Redis core C structures.");
         blen++; addReplyStatus(c,
         "htstats <dbid> -- Return hash table statistics of the specified Redis database.");
-        blen++; addReplyStatus(c,
-        "jemalloc info  -- Show internal jemalloc statistics.");
-        blen++; addReplyStatus(c,
-        "jemalloc purge -- Force jemalloc to release unused memory.");
         setDeferredMultiBulkLength(c,blenp,blen);
     } else if (!strcasecmp(c->argv[1]->ptr,"segfault")) {
         *((char*)-1) = 'x';
+    } else if (!strcasecmp(c->argv[1]->ptr,"panic")) {
+        serverPanic("DEBUG PANIC called at Unix time %ld", time(NULL));
     } else if (!strcasecmp(c->argv[1]->ptr,"restart") ||
                !strcasecmp(c->argv[1]->ptr,"crash-and-recover"))
     {
         long long delay = 0;
         if (c->argc >= 3) {
             if (getLongLongFromObjectOrReply(c, c->argv[2], &delay, NULL)
@@ -331,26 +332,26 @@
         zfree(ptr);
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"assert")) {
         if (c->argc >= 3) c->argv[2] = tryObjectEncoding(c->argv[2]);
         serverAssertWithInfo(c,c->argv[0],1 == 2);
     } else if (!strcasecmp(c->argv[1]->ptr,"reload")) {
-        if (rdbSave(server.rdb_filename) != C_OK) {
+        if (rdbSave(server.rdb_filename,NULL) != C_OK) {
             addReply(c,shared.err);
             return;
         }
-        emptyDb(NULL);
-        if (rdbLoad(server.rdb_filename) != C_OK) {
+        emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
+        if (rdbLoad(server.rdb_filename,NULL) != C_OK) {
             addReplyError(c,"Error trying to load the RDB dump");
             return;
         }
         serverLog(LL_WARNING,"DB reloaded by DEBUG RELOAD");
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"loadaof")) {
         if (server.aof_state == AOF_ON) flushAppendOnlyFile(1);
-        emptyDb(NULL);
+        emptyDb(-1,EMPTYDB_NO_FLAGS,NULL);
         if (loadAppendOnlyFile(server.aof_filename) != C_OK) {
             addReply(c,shared.err);
             return;
         }
         server.dirty = 0; /* Prevent AOF / replication */
         serverLog(LL_WARNING,"Append Only File loaded by DEBUG LOADAOF");
@@ -420,38 +421,62 @@
         key = dictGetKey(de);
 
         if (val->type != OBJ_STRING || !sdsEncodedObject(val)) {
             addReplyError(c,"Not an sds encoded string.");
         } else {
             addReplyStatusFormat(c,
-                "key_sds_len:%lld, key_sds_avail:%lld, "
-                "val_sds_len:%lld, val_sds_avail:%lld",
+                "key_sds_len:%lld, key_sds_avail:%lld, key_zmalloc: %lld, "
+                "val_sds_len:%lld, val_sds_avail:%lld, val_zmalloc: %lld",
                 (long long) sdslen(key),
                 (long long) sdsavail(key),
+                (long long) sdsZmallocSize(key),
                 (long long) sdslen(val->ptr),
-                (long long) sdsavail(val->ptr));
+                (long long) sdsavail(val->ptr),
+                (long long) getStringObjectSdsUsedMemory(val));
+        }
+    } else if (!strcasecmp(c->argv[1]->ptr,"ziplist") && c->argc == 3) {
+        robj *o;
+
+        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nokeyerr))
+                == NULL) return;
+
+        if (o->encoding != OBJ_ENCODING_ZIPLIST) {
+            addReplyError(c,"Not an sds encoded string.");
+        } else {
+            ziplistRepr(o->ptr);
+            addReplyStatus(c,"Ziplist structure printed on stdout");
         }
     } else if (!strcasecmp(c->argv[1]->ptr,"populate") &&
-               (c->argc == 3 || c->argc == 4)) {
+               c->argc >= 3 && c->argc <= 5) {
         long keys, j;
         robj *key, *val;
         char buf[128];
 
         if (getLongFromObjectOrReply(c, c->argv[2], &keys, NULL) != C_OK)
             return;
         dictExpand(c->db->dict,keys);
         for (j = 0; j < keys; j++) {
+            long valsize = 0;
             snprintf(buf,sizeof(buf),"%s:%lu",
                 (c->argc == 3) ? "key" : (char*)c->argv[3]->ptr, j);
             key = createStringObject(buf,strlen(buf));
+            if (c->argc == 5)
+                if (getLongFromObjectOrReply(c, c->argv[4], &valsize, NULL) != C_OK)
+                    return;
             if (lookupKeyWrite(c->db,key) != NULL) {
                 decrRefCount(key);
                 continue;
             }
             snprintf(buf,sizeof(buf),"value:%lu",j);
-            val = createStringObject(buf,strlen(buf));
+            if (valsize==0)
+                val = createStringObject(buf,strlen(buf));
+            else {
+                int buflen = strlen(buf);
+                val = createStringObject(NULL,valsize);
+                memcpy(val->ptr, buf, valsize<=buflen? valsize: buflen);
+            }
             dbAdd(c->db,key,val);
             signalModifiedKey(c->db,key);
             decrRefCount(key);
         }
         addReply(c,shared.ok);
     } else if (!strcasecmp(c->argv[1]->ptr,"digest") && c->argc == 2) {
@@ -519,58 +544,34 @@
 
         stats = sdscatprintf(stats,"[Expires HT]\n");
         dictGetStats(buf,sizeof(buf),server.db[dbid].expires);
         stats = sdscat(stats,buf);
 
         addReplyBulkSds(c,stats);
-    } else if (!strcasecmp(c->argv[1]->ptr,"jemalloc") && c->argc == 3) {
-#if defined(USE_JEMALLOC)
-        if (!strcasecmp(c->argv[2]->ptr, "info")) {
-            sds info = sdsempty();
-            je_malloc_stats_print(inputCatSds, &info, NULL);
-            addReplyBulkSds(c, info);
-        } else if (!strcasecmp(c->argv[2]->ptr, "purge")) {
-            char tmp[32];
-            unsigned narenas = 0;
-            size_t sz = sizeof(unsigned);
-            if (!je_mallctl("arenas.narenas", &narenas, &sz, NULL, 0)) {
-                sprintf(tmp, "arena.%d.purge", narenas);
-                if (!je_mallctl(tmp, NULL, 0, NULL, 0)) {
-                    addReply(c, shared.ok);
-                    return;
-                }
-            }
-            addReplyError(c, "Error purging dirty pages");
-        } else {
-            addReplyErrorFormat(c, "Valid jemalloc debug fields: info, purge");
-        }
-#else
-        addReplyErrorFormat(c, "jemalloc support not available");
-#endif
     } else {
         addReplyErrorFormat(c, "Unknown DEBUG subcommand or wrong number of arguments for '%s'",
             (char*)c->argv[1]->ptr);
     }
 }
 
 /* =========================== Crash handling  ============================== */
 
-void _serverAssert(char *estr, char *file, int line) {
+void _serverAssert(const char *estr, const char *file, int line) {
     bugReportStart();
     serverLog(LL_WARNING,"=== ASSERTION FAILED ===");
     serverLog(LL_WARNING,"==> %s:%d '%s' is not true",file,line,estr);
 #ifdef HAVE_BACKTRACE
     server.assert_failed = estr;
     server.assert_file = file;
     server.assert_line = line;
     serverLog(LL_WARNING,"(forcing SIGSEGV to print the bug report.)");
 #endif
     *((char*)-1) = 'x';
 }
 
-void _serverAssertPrintClientInfo(client *c) {
+void _serverAssertPrintClientInfo(const client *c) {
     int j;
 
     bugReportStart();
     serverLog(LL_WARNING,"=== ASSERTION FAILED CLIENT CONTEXT ===");
     serverLog(LL_WARNING,"client->flags = %d", c->flags);
     serverLog(LL_WARNING,"client->fd = %d", c->fd);
@@ -588,13 +589,13 @@
         }
         serverLog(LL_WARNING,"client->argv[%d] = \"%s\" (refcount: %d)",
             j, arg, c->argv[j]->refcount);
     }
 }
 
-void serverLogObjectDebugInfo(robj *o) {
+void serverLogObjectDebugInfo(const robj *o) {
     serverLog(LL_WARNING,"Object type: %d", o->type);
     serverLog(LL_WARNING,"Object encoding: %d", o->encoding);
     serverLog(LL_WARNING,"Object refcount: %d", o->refcount);
     if (o->type == OBJ_STRING && sdsEncodedObject(o)) {
         serverLog(LL_WARNING,"Object raw string len: %zu", sdslen(o->ptr));
         if (sdslen(o->ptr) < 4096) {
@@ -608,33 +609,39 @@
         serverLog(LL_WARNING,"Set size: %d", (int) setTypeSize(o));
     } else if (o->type == OBJ_HASH) {
         serverLog(LL_WARNING,"Hash size: %d", (int) hashTypeLength(o));
     } else if (o->type == OBJ_ZSET) {
         serverLog(LL_WARNING,"Sorted set size: %d", (int) zsetLength(o));
         if (o->encoding == OBJ_ENCODING_SKIPLIST)
-            serverLog(LL_WARNING,"Skiplist level: %d", (int) ((zset*)o->ptr)->zsl->level);
+            serverLog(LL_WARNING,"Skiplist level: %d", (int) ((const zset*)o->ptr)->zsl->level);
     }
 }
 
-void _serverAssertPrintObject(robj *o) {
+void _serverAssertPrintObject(const robj *o) {
     bugReportStart();
     serverLog(LL_WARNING,"=== ASSERTION FAILED OBJECT CONTEXT ===");
     serverLogObjectDebugInfo(o);
 }
 
-void _serverAssertWithInfo(client *c, robj *o, char *estr, char *file, int line) {
+void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {
     if (c) _serverAssertPrintClientInfo(c);
     if (o) _serverAssertPrintObject(o);
     _serverAssert(estr,file,line);
 }
 
-void _serverPanic(char *msg, char *file, int line) {
+void _serverPanic(const char *file, int line, const char *msg, ...) {
+    va_list ap;
+    va_start(ap,msg);
+    char fmtmsg[256];
+    vsnprintf(fmtmsg,sizeof(fmtmsg),msg,ap);
+    va_end(ap);
+
     bugReportStart();
     serverLog(LL_WARNING,"------------------------------------------------");
     serverLog(LL_WARNING,"!!! Software Failure. Press left mouse button to continue");
-    serverLog(LL_WARNING,"Guru Meditation: %s #%s:%d",msg,file,line);
+    serverLog(LL_WARNING,"Guru Meditation: %s #%s:%d",fmtmsg,file,line);
 #ifdef HAVE_BACKTRACE
     serverLog(LL_WARNING,"(forcing SIGSEGV in order to print the stack trace)");
 #endif
     serverLog(LL_WARNING,"------------------------------------------------");
     *((char*)-1) = 'x';
 }
@@ -1028,14 +1035,12 @@
     serverLogRaw(LL_WARNING|LL_RAW, "\n------ STACK TRACE ------\n");
     logStackTrace(uc);
 
     /* Log INFO and CLIENT LIST */
     serverLogRaw(LL_WARNING|LL_RAW, "\n------ INFO OUTPUT ------\n");
     infostring = genRedisInfoString("all");
-    infostring = sdscatprintf(infostring, "hash_init_value: %u\n",
-        dictGetHashFunctionSeed());
     serverLogRaw(LL_WARNING|LL_RAW, infostring);
     serverLogRaw(LL_WARNING|LL_RAW, "\n------ CLIENT LIST OUTPUT ------\n");
     clients = getAllClientsInfoString();
     serverLogRaw(LL_WARNING|LL_RAW, clients);
     sdsfree(infostring);
     sdsfree(clients);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/debug.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/debug.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: defrag.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: defrag.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: defrag.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.c	2017-07-14 19:28:42.000000000 +0800
@@ -34,21 +34,25 @@
  */
 
 #include "fmacros.h"
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <string.h>
 #include <stdarg.h>
 #include <limits.h>
 #include <sys/time.h>
-#include <ctype.h>
 
 #include "dict.h"
 #include "zmalloc.h"
+#ifndef DICT_BENCHMARK_MAIN
 #include "redisassert.h"
+#else
+#include <assert.h>
+#endif
 
 /* Using dictEnableResize() / dictDisableResize() we make possible to
  * enable/disable resizing of the hash table as needed. This is very important
  * for Redis, as we use copy-on-write and don't want to move too much memory
  * around when there is a child performing saving operations.
  *
@@ -59,100 +63,39 @@
 static unsigned int dict_force_resize_ratio = 5;
 
 /* -------------------------- private prototypes ---------------------------- */
 
 static int _dictExpandIfNeeded(dict *ht);
 static unsigned long _dictNextPower(unsigned long size);
-static int _dictKeyIndex(dict *ht, const void *key);
+static int _dictKeyIndex(dict *ht, const void *key, unsigned int hash, dictEntry **existing);
 static int _dictInit(dict *ht, dictType *type, void *privDataPtr);
 
 /* -------------------------- hash functions -------------------------------- */
 
-/* Thomas Wang's 32 bit Mix Function */
-unsigned int dictIntHashFunction(unsigned int key)
-{
-    key += ~(key << 15);
-    key ^=  (key >> 10);
-    key +=  (key << 3);
-    key ^=  (key >> 6);
-    key += ~(key << 11);
-    key ^=  (key >> 16);
-    return key;
-}
-
-static uint32_t dict_hash_function_seed = 5381;
+static uint8_t dict_hash_function_seed[16];
 
-void dictSetHashFunctionSeed(uint32_t seed) {
-    dict_hash_function_seed = seed;
+void dictSetHashFunctionSeed(uint8_t *seed) {
+    memcpy(dict_hash_function_seed,seed,sizeof(dict_hash_function_seed));
 }
 
-uint32_t dictGetHashFunctionSeed(void) {
+uint8_t *dictGetHashFunctionSeed(void) {
     return dict_hash_function_seed;
 }
 
-/* MurmurHash2, by Austin Appleby
- * Note - This code makes a few assumptions about how your machine behaves -
- * 1. We can read a 4-byte value from any address without crashing
- * 2. sizeof(int) == 4
- *
- * And it has a few limitations -
- *
- * 1. It will not work incrementally.
- * 2. It will not produce the same results on little-endian and big-endian
- *    machines.
- */
-unsigned int dictGenHashFunction(const void *key, int len) {
-    /* 'm' and 'r' are mixing constants generated offline.
-     They're not really 'magic', they just happen to work well.  */
-    uint32_t seed = dict_hash_function_seed;
-    const uint32_t m = 0x5bd1e995;
-    const int r = 24;
-
-    /* Initialize the hash to a 'random' value */
-    uint32_t h = seed ^ len;
-
-    /* Mix 4 bytes at a time into the hash */
-    const unsigned char *data = (const unsigned char *)key;
-
-    while(len >= 4) {
-        uint32_t k = *(uint32_t*)data;
-
-        k *= m;
-        k ^= k >> r;
-        k *= m;
-
-        h *= m;
-        h ^= k;
-
-        data += 4;
-        len -= 4;
-    }
-
-    /* Handle the last few bytes of the input array  */
-    switch(len) {
-    case 3: h ^= data[2] << 16;
-    case 2: h ^= data[1] << 8;
-    case 1: h ^= data[0]; h *= m;
-    };
+/* The default hashing function uses SipHash implementation
+ * in siphash.c. */
 
-    /* Do a few final mixes of the hash to ensure the last few
-     * bytes are well-incorporated. */
-    h ^= h >> 13;
-    h *= m;
-    h ^= h >> 15;
+uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k);
+uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k);
 
-    return (unsigned int)h;
+uint64_t dictGenHashFunction(const void *key, int len) {
+    return siphash(key,len,dict_hash_function_seed);
 }
 
-/* And a case insensitive hash function (based on djb hash) */
-unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) {
-    unsigned int hash = (unsigned int)dict_hash_function_seed;
-
-    while (len--)
-        hash = ((hash << 5) + hash) + (tolower(*buf++)); /* hash * 33 + c */
-    return hash;
+uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len) {
+    return siphash_nocase(buf,len,dict_hash_function_seed);
 }
 
 /* ----------------------------- API implementation ------------------------- */
 
 /* Reset a hash table already initialized with ht_init().
  * NOTE: This function should only be called by ht_destroy(). */
@@ -318,45 +261,48 @@
     if (d->iterators == 0) dictRehash(d,1);
 }
 
 /* Add an element to the target hash table */
 int dictAdd(dict *d, void *key, void *val)
 {
-    dictEntry *entry = dictAddRaw(d,key);
+    dictEntry *entry = dictAddRaw(d,key,NULL);
 
     if (!entry) return DICT_ERR;
     dictSetVal(d, entry, val);
     return DICT_OK;
 }
 
-/* Low level add. This function adds the entry but instead of setting
- * a value returns the dictEntry structure to the user, that will make
- * sure to fill the value field as he wishes.
+/* Low level add or find:
+ * This function adds the entry but instead of setting a value returns the
+ * dictEntry structure to the user, that will make sure to fill the value
+ * field as he wishes.
  *
  * This function is also directly exposed to the user API to be called
  * mainly in order to store non-pointers inside the hash value, example:
  *
- * entry = dictAddRaw(dict,mykey);
+ * entry = dictAddRaw(dict,mykey,NULL);
  * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);
  *
  * Return values:
  *
- * If key already exists NULL is returned.
+ * If key already exists NULL is returned, and "*existing" is populated
+ * with the existing entry if existing is not NULL.
+ *
  * If key was added, the hash entry is returned to be manipulated by the caller.
  */
-dictEntry *dictAddRaw(dict *d, void *key)
+dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
 {
     int index;
     dictEntry *entry;
     dictht *ht;
 
     if (dictIsRehashing(d)) _dictRehashStep(d);
 
     /* Get the index of the new element, or -1 if
      * the element already exists. */
-    if ((index = _dictKeyIndex(d, key)) == -1)
+    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
         return NULL;
 
     /* Allocate the memory and store the new entry.
      * Insert the element in top, with the assumption that in a database
      * system it is more likely that recently added entries are accessed
      * more frequently. */
@@ -368,57 +314,63 @@
 
     /* Set the hash entry fields. */
     dictSetKey(d, entry, key);
     return entry;
 }
 
-/* Add an element, discarding the old if the key already exists.
+/* Add or Overwrite:
+ * Add an element, discarding the old value if the key already exists.
  * Return 1 if the key was added from scratch, 0 if there was already an
  * element with such key and dictReplace() just performed a value update
  * operation. */
 int dictReplace(dict *d, void *key, void *val)
 {
-    dictEntry *entry, auxentry;
+    dictEntry *entry, *existing, auxentry;
 
     /* Try to add the element. If the key
      * does not exists dictAdd will suceed. */
-    if (dictAdd(d, key, val) == DICT_OK)
+    entry = dictAddRaw(d,key,&existing);
+    if (entry) {
+        dictSetVal(d, entry, val);
         return 1;
-    /* It already exists, get the entry */
-    entry = dictFind(d, key);
+    }
+
     /* Set the new value and free the old one. Note that it is important
      * to do that in this order, as the value may just be exactly the same
      * as the previous one. In this context, think to reference counting,
      * you want to increment (set), and then decrement (free), and not the
      * reverse. */
-    auxentry = *entry;
-    dictSetVal(d, entry, val);
+    auxentry = *existing;
+    dictSetVal(d, existing, val);
     dictFreeVal(d, &auxentry);
     return 0;
 }
 
-/* dictReplaceRaw() is simply a version of dictAddRaw() that always
+/* Add or Find:
+ * dictAddOrFind() is simply a version of dictAddRaw() that always
  * returns the hash entry of the specified key, even if the key already
  * exists and can't be added (in that case the entry of the already
  * existing key is returned.)
  *
  * See dictAddRaw() for more information. */
-dictEntry *dictReplaceRaw(dict *d, void *key) {
-    dictEntry *entry = dictFind(d,key);
-
-    return entry ? entry : dictAddRaw(d,key);
+dictEntry *dictAddOrFind(dict *d, void *key) {
+    dictEntry *entry, *existing;
+    entry = dictAddRaw(d,key,&existing);
+    return entry ? entry : existing;
 }
 
-/* Search and remove an element */
-static int dictGenericDelete(dict *d, const void *key, int nofree)
-{
+/* Search and remove an element. This is an helper function for
+ * dictDelete() and dictUnlink(), please check the top comment
+ * of those functions. */
+static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
     unsigned int h, idx;
     dictEntry *he, *prevHe;
     int table;
 
-    if (d->ht[0].size == 0) return DICT_ERR; /* d->ht[0].table is NULL */
+    if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;
+
     if (dictIsRehashing(d)) _dictRehashStep(d);
     h = dictHashKey(d, key);
 
     for (table = 0; table <= 1; table++) {
         idx = h & d->ht[table].sizemask;
         he = d->ht[table].table[idx];
@@ -430,33 +382,65 @@
                     prevHe->next = he->next;
                 else
                     d->ht[table].table[idx] = he->next;
                 if (!nofree) {
                     dictFreeKey(d, he);
                     dictFreeVal(d, he);
+                    zfree(he);
                 }
-                zfree(he);
                 d->ht[table].used--;
-                return DICT_OK;
+                return he;
             }
             prevHe = he;
             he = he->next;
         }
         if (!dictIsRehashing(d)) break;
     }
-    return DICT_ERR; /* not found */
+    return NULL; /* not found */
 }
 
+/* Remove an element, returning DICT_OK on success or DICT_ERR if the
+ * element was not found. */
 int dictDelete(dict *ht, const void *key) {
-    return dictGenericDelete(ht,key,0);
+    return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
 }
 
-int dictDeleteNoFree(dict *ht, const void *key) {
+/* Remove an element from the table, but without actually releasing
+ * the key, value and dictionary entry. The dictionary entry is returned
+ * if the element was found (and unlinked from the table), and the user
+ * should later call `dictFreeUnlinkedEntry()` with it in order to release it.
+ * Otherwise if the key is not found, NULL is returned.
+ *
+ * This function is useful when we want to remove something from the hash
+ * table but want to use its value before actually deleting the entry.
+ * Without this function the pattern would require two lookups:
+ *
+ *  entry = dictFind(...);
+ *  // Do something with entry
+ *  dictDelete(dictionary,entry);
+ *
+ * Thanks to this function it is possible to avoid this, and use
+ * instead:
+ *
+ * entry = dictUnlink(dictionary,entry);
+ * // Do something with entry
+ * dictFreeUnlinkedEntry(entry); // <- This does not need to lookup again.
+ */
+dictEntry *dictUnlink(dict *ht, const void *key) {
     return dictGenericDelete(ht,key,1);
 }
 
+/* You need to call this function to really free the entry after a call
+ * to dictUnlink(). It's safe to call this function with 'he' = NULL. */
+void dictFreeUnlinkedEntry(dict *d, dictEntry *he) {
+    if (he == NULL) return;
+    dictFreeKey(d, he);
+    dictFreeVal(d, he);
+    zfree(he);
+}
+
 /* Destroy an entire dictionary */
 int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {
     unsigned long i;
 
     /* Free all the elements */
     for (i = 0; i < ht->size && ht->used > 0; i++) {
@@ -849,29 +833,32 @@
  * 3) The reverse cursor is somewhat hard to understand at first, but this
  *    comment is supposed to help.
  */
 unsigned long dictScan(dict *d,
                        unsigned long v,
                        dictScanFunction *fn,
+                       dictScanBucketFunction* bucketfn,
                        void *privdata)
 {
     dictht *t0, *t1;
-    const dictEntry *de;
+    const dictEntry *de, *next;
     unsigned long m0, m1;
 
     if (dictSize(d) == 0) return 0;
 
     if (!dictIsRehashing(d)) {
         t0 = &(d->ht[0]);
         m0 = t0->sizemask;
 
         /* Emit entries at cursor */
+        if (bucketfn) bucketfn(privdata, &t0->table[v & m0]);
         de = t0->table[v & m0];
         while (de) {
+            next = de->next;
             fn(privdata, de);
-            de = de->next;
+            de = next;
         }
 
     } else {
         t0 = &d->ht[0];
         t1 = &d->ht[1];
 
@@ -882,26 +869,30 @@
         }
 
         m0 = t0->sizemask;
         m1 = t1->sizemask;
 
         /* Emit entries at cursor */
+        if (bucketfn) bucketfn(privdata, &t0->table[v & m0]);
         de = t0->table[v & m0];
         while (de) {
+            next = de->next;
             fn(privdata, de);
-            de = de->next;
+            de = next;
         }
 
         /* Iterate over indices in larger table that are the expansion
          * of the index pointed to by the cursor in the smaller table */
         do {
             /* Emit entries at cursor */
+            if (bucketfn) bucketfn(privdata, &t1->table[v & m1]);
             de = t1->table[v & m1];
             while (de) {
+                next = de->next;
                 fn(privdata, de);
-                de = de->next;
+                de = next;
             }
 
             /* Increment bits not covered by the smaller mask */
             v = (((v | m0) + 1) & ~m0) | (v & m0);
 
             /* Continue while bits covered by mask difference is non-zero */
@@ -956,33 +947,35 @@
         i *= 2;
     }
 }
 
 /* Returns the index of a free slot that can be populated with
  * a hash entry for the given 'key'.
- * If the key already exists, -1 is returned.
+ * If the key already exists, -1 is returned
+ * and the optional output parameter may be filled.
  *
  * Note that if we are in the process of rehashing the hash table, the
  * index is always returned in the context of the second (new) hash table. */
-static int _dictKeyIndex(dict *d, const void *key)
+static int _dictKeyIndex(dict *d, const void *key, unsigned int hash, dictEntry **existing)
 {
-    unsigned int h, idx, table;
+    unsigned int idx, table;
     dictEntry *he;
+    if (existing) *existing = NULL;
 
     /* Expand the hash table if needed */
     if (_dictExpandIfNeeded(d) == DICT_ERR)
         return -1;
-    /* Compute the key hash value */
-    h = dictHashKey(d, key);
     for (table = 0; table <= 1; table++) {
-        idx = h & d->ht[table].sizemask;
+        idx = hash & d->ht[table].sizemask;
         /* Search if this slot does not already contain the given key */
         he = d->ht[table].table[idx];
         while(he) {
-            if (key==he->key || dictCompareKeys(d, key, he->key))
+            if (key==he->key || dictCompareKeys(d, key, he->key)) {
+                if (existing) *existing = he;
                 return -1;
+            }
             he = he->next;
         }
         if (!dictIsRehashing(d)) break;
     }
     return idx;
 }
@@ -999,12 +992,41 @@
 }
 
 void dictDisableResize(void) {
     dict_can_resize = 0;
 }
 
+unsigned int dictGetHash(dict *d, const void *key) {
+    return dictHashKey(d, key);
+}
+
+/* Finds the dictEntry reference by using pointer and pre-calculated hash.
+ * oldkey is a dead pointer and should not be accessed.
+ * the hash value should be provided using dictGetHash.
+ * no string / key comparison is performed.
+ * return value is the reference to the dictEntry if found, or NULL if not found. */
+dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, unsigned int hash) {
+    dictEntry *he, **heref;
+    unsigned int idx, table;
+
+    if (d->ht[0].used + d->ht[1].used == 0) return NULL; /* dict is empty */
+    for (table = 0; table <= 1; table++) {
+        idx = hash & d->ht[table].sizemask;
+        heref = &d->ht[table].table[idx];
+        he = *heref;
+        while(he) {
+            if (oldptr==he->key)
+                return heref;
+            heref = &he->next;
+            he = *heref;
+        }
+        if (!dictIsRehashing(d)) return NULL;
+    }
+    return NULL;
+}
+
 /* ------------------------------- Debugging ---------------------------------*/
 
 #define DICT_STATS_VECTLEN 50
 size_t _dictGetStatsHt(char *buf, size_t bufsize, dictht *ht, int tableid) {
     unsigned long i, slots = 0, chainlen, maxchainlen = 0;
     unsigned long totchainlen = 0;
@@ -1077,6 +1099,123 @@
     if (dictIsRehashing(d) && bufsize > 0) {
         _dictGetStatsHt(buf,bufsize,&d->ht[1],1);
     }
     /* Make sure there is a NULL term at the end. */
     if (orig_bufsize) orig_buf[orig_bufsize-1] = '\0';
 }
+
+/* ------------------------------- Benchmark ---------------------------------*/
+
+#ifdef DICT_BENCHMARK_MAIN
+
+#include "sds.h"
+
+uint64_t hashCallback(const void *key) {
+    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
+}
+
+int compareCallback(void *privdata, const void *key1, const void *key2) {
+    int l1,l2;
+    DICT_NOTUSED(privdata);
+
+    l1 = sdslen((sds)key1);
+    l2 = sdslen((sds)key2);
+    if (l1 != l2) return 0;
+    return memcmp(key1, key2, l1) == 0;
+}
+
+void freeCallback(void *privdata, void *val) {
+    DICT_NOTUSED(privdata);
+
+    sdsfree(val);
+}
+
+dictType BenchmarkDictType = {
+    hashCallback,
+    NULL,
+    NULL,
+    compareCallback,
+    freeCallback,
+    NULL
+};
+
+#define start_benchmark() start = timeInMilliseconds()
+#define end_benchmark(msg) do { \
+    elapsed = timeInMilliseconds()-start; \
+    printf(msg ": %ld items in %lld ms\n", count, elapsed); \
+} while(0);
+
+/* dict-benchmark [count] */
+int main(int argc, char **argv) {
+    long j;
+    long long start, elapsed;
+    dict *dict = dictCreate(&BenchmarkDictType,NULL);
+    long count = 0;
+
+    if (argc == 2) {
+        count = strtol(argv[1],NULL,10);
+    } else {
+        count = 5000000;
+    }
+
+    start_benchmark();
+    for (j = 0; j < count; j++) {
+        int retval = dictAdd(dict,sdsfromlonglong(j),(void*)j);
+        assert(retval == DICT_OK);
+    }
+    end_benchmark("Inserting");
+    assert((long)dictSize(dict) == count);
+
+    /* Wait for rehashing. */
+    while (dictIsRehashing(dict)) {
+        dictRehashMilliseconds(dict,100);
+    }
+
+    start_benchmark();
+    for (j = 0; j < count; j++) {
+        sds key = sdsfromlonglong(j);
+        dictEntry *de = dictFind(dict,key);
+        assert(de != NULL);
+        sdsfree(key);
+    }
+    end_benchmark("Linear access of existing elements");
+
+    start_benchmark();
+    for (j = 0; j < count; j++) {
+        sds key = sdsfromlonglong(j);
+        dictEntry *de = dictFind(dict,key);
+        assert(de != NULL);
+        sdsfree(key);
+    }
+    end_benchmark("Linear access of existing elements (2nd round)");
+
+    start_benchmark();
+    for (j = 0; j < count; j++) {
+        sds key = sdsfromlonglong(rand() % count);
+        dictEntry *de = dictFind(dict,key);
+        assert(de != NULL);
+        sdsfree(key);
+    }
+    end_benchmark("Random access of existing elements");
+
+    start_benchmark();
+    for (j = 0; j < count; j++) {
+        sds key = sdsfromlonglong(rand() % count);
+        key[0] = 'X';
+        dictEntry *de = dictFind(dict,key);
+        assert(de == NULL);
+        sdsfree(key);
+    }
+    end_benchmark("Accessing missing");
+
+    start_benchmark();
+    for (j = 0; j < count; j++) {
+        sds key = sdsfromlonglong(j);
+        int retval = dictDelete(dict,key);
+        assert(retval == DICT_OK);
+        key[0] += 17; /* Change first number to letter. */
+        retval = dictAdd(dict,key,(void*)j);
+        assert(retval == DICT_OK);
+    }
+    end_benchmark("Removing and adding");
+}
+#endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.h	2017-07-14 19:28:42.000000000 +0800
@@ -53,13 +53,13 @@
         double d;
     } v;
     struct dictEntry *next;
 } dictEntry;
 
 typedef struct dictType {
-    unsigned int (*hashFunction)(const void *key);
+    uint64_t (*hashFunction)(const void *key);
     void *(*keyDup)(void *privdata, const void *key);
     void *(*valDup)(void *privdata, const void *obj);
     int (*keyCompare)(void *privdata, const void *key1, const void *key2);
     void (*keyDestructor)(void *privdata, void *key);
     void (*valDestructor)(void *privdata, void *obj);
 } dictType;
@@ -75,13 +75,13 @@
 
 typedef struct dict {
     dictType *type;
     void *privdata;
     dictht ht[2];
     long rehashidx; /* rehashing not in progress if rehashidx == -1 */
-    int iterators; /* number of iterators currently running */
+    unsigned long iterators; /* number of iterators currently running */
 } dict;
 
 /* If safe is set to 1 this is a safe iterator, that means, you can call
  * dictAdd, dictFind, and other functions against the dictionary even while
  * iterating. Otherwise it is a non safe iterator, and only dictNext()
  * should be called while iterating. */
@@ -92,46 +92,47 @@
     dictEntry *entry, *nextEntry;
     /* unsafe iterator fingerprint for misuse detection. */
     long long fingerprint;
 } dictIterator;
 
 typedef void (dictScanFunction)(void *privdata, const dictEntry *de);
+typedef void (dictScanBucketFunction)(void *privdata, dictEntry **bucketref);
 
 /* This is the initial size of every hash table */
 #define DICT_HT_INITIAL_SIZE     4
 
 /* ------------------------------- Macros ------------------------------------*/
 #define dictFreeVal(d, entry) \
     if ((d)->type->valDestructor) \
         (d)->type->valDestructor((d)->privdata, (entry)->v.val)
 
 #define dictSetVal(d, entry, _val_) do { \
     if ((d)->type->valDup) \
-        entry->v.val = (d)->type->valDup((d)->privdata, _val_); \
+        (entry)->v.val = (d)->type->valDup((d)->privdata, _val_); \
     else \
-        entry->v.val = (_val_); \
+        (entry)->v.val = (_val_); \
 } while(0)
 
 #define dictSetSignedIntegerVal(entry, _val_) \
-    do { entry->v.s64 = _val_; } while(0)
+    do { (entry)->v.s64 = _val_; } while(0)
 
 #define dictSetUnsignedIntegerVal(entry, _val_) \
-    do { entry->v.u64 = _val_; } while(0)
+    do { (entry)->v.u64 = _val_; } while(0)
 
 #define dictSetDoubleVal(entry, _val_) \
-    do { entry->v.d = _val_; } while(0)
+    do { (entry)->v.d = _val_; } while(0)
 
 #define dictFreeKey(d, entry) \
     if ((d)->type->keyDestructor) \
         (d)->type->keyDestructor((d)->privdata, (entry)->key)
 
 #define dictSetKey(d, entry, _key_) do { \
     if ((d)->type->keyDup) \
-        entry->key = (d)->type->keyDup((d)->privdata, _key_); \
+        (entry)->key = (d)->type->keyDup((d)->privdata, _key_); \
     else \
-        entry->key = (_key_); \
+        (entry)->key = (_key_); \
 } while(0)
 
 #define dictCompareKeys(d, key1, key2) \
     (((d)->type->keyCompare) ? \
         (d)->type->keyCompare((d)->privdata, key1, key2) : \
         (key1) == (key2))
@@ -147,38 +148,41 @@
 #define dictIsRehashing(d) ((d)->rehashidx != -1)
 
 /* API */
 dict *dictCreate(dictType *type, void *privDataPtr);
 int dictExpand(dict *d, unsigned long size);
 int dictAdd(dict *d, void *key, void *val);
-dictEntry *dictAddRaw(dict *d, void *key);
+dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing);
+dictEntry *dictAddOrFind(dict *d, void *key);
 int dictReplace(dict *d, void *key, void *val);
-dictEntry *dictReplaceRaw(dict *d, void *key);
 int dictDelete(dict *d, const void *key);
-int dictDeleteNoFree(dict *d, const void *key);
+dictEntry *dictUnlink(dict *ht, const void *key);
+void dictFreeUnlinkedEntry(dict *d, dictEntry *he);
 void dictRelease(dict *d);
 dictEntry * dictFind(dict *d, const void *key);
 void *dictFetchValue(dict *d, const void *key);
 int dictResize(dict *d);
 dictIterator *dictGetIterator(dict *d);
 dictIterator *dictGetSafeIterator(dict *d);
 dictEntry *dictNext(dictIterator *iter);
 void dictReleaseIterator(dictIterator *iter);
 dictEntry *dictGetRandomKey(dict *d);
 unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);
 void dictGetStats(char *buf, size_t bufsize, dict *d);
-unsigned int dictGenHashFunction(const void *key, int len);
-unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len);
+uint64_t dictGenHashFunction(const void *key, int len);
+uint64_t dictGenCaseHashFunction(const unsigned char *buf, int len);
 void dictEmpty(dict *d, void(callback)(void*));
 void dictEnableResize(void);
 void dictDisableResize(void);
 int dictRehash(dict *d, int n);
 int dictRehashMilliseconds(dict *d, int ms);
-void dictSetHashFunctionSeed(unsigned int initval);
-unsigned int dictGetHashFunctionSeed(void);
-unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, void *privdata);
+void dictSetHashFunctionSeed(uint8_t *seed);
+uint8_t *dictGetHashFunctionSeed(void);
+unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, dictScanBucketFunction *bucketfn, void *privdata);
+unsigned int dictGetHash(dict *d, const void *key);
+dictEntry **dictFindEntryRefByPtrAndHash(dict *d, const void *oldptr, unsigned int hash);
 
 /* Hash table types */
 extern dictType dictTypeHeapStringCopyKey;
 extern dictType dictTypeHeapStrings;
 extern dictType dictTypeHeapStringCopyKeyValue;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/dict.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/dict.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/endianconv.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/endianconv.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/endianconv.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/endianconv.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: evict.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: evict.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: evict.o
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: expire.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: expire.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: expire.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.c	2017-07-14 19:28:42.000000000 +0800
@@ -110,13 +110,13 @@
 /* Input Argument Helper */
 /* Decode lat/long from a zset member's score.
  * Returns C_OK on successful decoding, otherwise C_ERR is returned. */
 int longLatFromMember(robj *zobj, robj *member, double *xy) {
     double score = 0;
 
-    if (zsetScore(zobj, member, &score) == C_ERR) return C_ERR;
+    if (zsetScore(zobj, member->ptr, &score) == C_ERR) return C_ERR;
     if (!decodeGeohash(score, xy)) return C_ERR;
     return C_OK;
 }
 
 /* Check that the unit argument matches one of the known units, and returns
  * the conversion factor to meters (you need to divide meters by the conversion
@@ -158,13 +158,13 @@
     }
 
     if (distance < 0) {
         addReplyError(c,"radius cannot be negative");
         return -1;
     }
-    
+
     double to_meters = extractUnitOrReply(c,argv[1]);
     if (to_meters < 0) {
         return -1;
     }
 
     if (conversion) *conversion = to_meters;
@@ -266,22 +266,20 @@
         if ((ln = zslFirstInRange(zsl, &range)) == NULL) {
             /* Nothing exists starting at our min.  No results. */
             return 0;
         }
 
         while (ln) {
-            robj *o = ln->obj;
+            sds ele = ln->ele;
             /* Abort when the node is no longer in range. */
             if (!zslValueLteMax(ln->score, &range))
                 break;
 
-            member = (o->encoding == OBJ_ENCODING_INT) ?
-                        sdsfromlonglong((long)o->ptr) :
-                        sdsdup(o->ptr);
-            if (geoAppendIfWithinRadius(ga,lon,lat,radius,ln->score,member)
-                == C_ERR) sdsfree(member);
+            ele = sdsdup(ele);
+            if (geoAppendIfWithinRadius(ga,lon,lat,radius,ln->score,ele)
+                == C_ERR) sdsfree(ele);
             ln = ln->level[0].forward;
         }
     }
     return ga->used - origincount;
 }
 
@@ -349,13 +347,13 @@
         }
 
         /* Debugging info. */
         if (debugmsg) {
             GeoHashRange long_range, lat_range;
             geohashGetCoordRange(&long_range,&lat_range);
-            GeoHashArea myarea = {{0,0},{0,0},{0,0}};
+            GeoHashArea myarea = {{0}};
             geohashDecode(long_range, lat_range, neighbors[i], &myarea);
 
             /* Dump center square. */
             D("neighbors[%d]:\n",i);
             D("area.longitude.min: %f\n", myarea.longitude.min);
             D("area.longitude.max: %f\n", myarea.longitude.max);
@@ -647,19 +645,16 @@
         for (i = 0; i < returned_items; i++) {
             zskiplistNode *znode;
             geoPoint *gp = ga->array+i;
             gp->dist /= conversion; /* Fix according to unit. */
             double score = storedist ? gp->dist : gp->score;
             size_t elelen = sdslen(gp->member);
-            robj *ele = createObject(OBJ_STRING,gp->member);
 
             if (maxelelen < elelen) maxelelen = elelen;
-            incrRefCount(ele); /* Set refcount to 2 since we reference the
-                                  object both in the skiplist and dict. */
-            znode = zslInsert(zs->zsl,score,ele);
-            serverAssert(dictAdd(zs->dict,ele,&znode->score) == DICT_OK);
+            znode = zslInsert(zs->zsl,score,gp->member);
+            serverAssert(dictAdd(zs->dict,gp->member,&znode->score) == DICT_OK);
             gp->member = NULL;
         }
 
         if (returned_items) {
             zsetConvertToZiplistIfNeeded(zobj,maxelelen);
             setKey(c->db,storekey,zobj);
@@ -703,22 +698,21 @@
  * position of the specified elements. */
 void geohashCommand(client *c) {
     char *geoalphabet= "0123456789bcdefghjkmnpqrstuvwxyz";
     int j;
 
     /* Look up the requested zset */
-    robj *zobj = NULL;
-    if ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.emptymultibulk))
-        == NULL || checkType(c, zobj, OBJ_ZSET)) return;
+    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
+    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
 
     /* Geohash elements one after the other, using a null bulk reply for
      * missing elements. */
     addReplyMultiBulkLen(c,c->argc-2);
     for (j = 2; j < c->argc; j++) {
         double score;
-        if (zsetScore(zobj, c->argv[j], &score) == C_ERR) {
+        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
             addReply(c,shared.nullbulk);
         } else {
             /* The internal format we use for geocoding is a bit different
              * than the standard, since we use as initial latitude range
              * -85,85, while the normal geohashing algorithm uses -90,90.
              * So we have to decode our position and re-encode using the
@@ -757,22 +751,21 @@
  * Returns an array of two-items arrays representing the x,y position of each
  * element specified in the arguments. For missing elements NULL is returned. */
 void geoposCommand(client *c) {
     int j;
 
     /* Look up the requested zset */
-    robj *zobj = NULL;
-    if ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.emptymultibulk))
-        == NULL || checkType(c, zobj, OBJ_ZSET)) return;
+    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
+    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
 
     /* Report elements one after the other, using a null bulk reply for
      * missing elements. */
     addReplyMultiBulkLen(c,c->argc-2);
     for (j = 2; j < c->argc; j++) {
         double score;
-        if (zsetScore(zobj, c->argv[j], &score) == C_ERR) {
+        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
             addReply(c,shared.nullmultibulk);
         } else {
             /* Decode... */
             double xy[2];
             if (!decodeGeohash(score,xy)) {
                 addReply(c,shared.nullmultibulk);
@@ -801,19 +794,19 @@
         addReply(c,shared.syntaxerr);
         return;
     }
 
     /* Look up the requested zset */
     robj *zobj = NULL;
-    if ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.emptybulk))
+    if ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.nullbulk))
         == NULL || checkType(c, zobj, OBJ_ZSET)) return;
 
     /* Get the scores. We need both otherwise NULL is returned. */
     double score1, score2, xyxy[4];
-    if (zsetScore(zobj, c->argv[2], &score1) == C_ERR ||
-        zsetScore(zobj, c->argv[3], &score2) == C_ERR)
+    if (zsetScore(zobj, c->argv[2]->ptr, &score1) == C_ERR ||
+        zsetScore(zobj, c->argv[3]->ptr, &score2) == C_ERR)
     {
         addReply(c,shared.nullbulk);
         return;
     }
 
     /* Decode & compute the distance. */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.c.bc differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: geohash.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: geohash.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: geohash.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: geohash_helper.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: geohash_helper.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: geohash_helper.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: geohash_helper.o
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: geohash.o
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/geo.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/geo.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.c	2017-07-14 19:28:42.000000000 +0800
@@ -398,13 +398,17 @@
     const uint8_t *end = data + (len-(len&7));
 
     while(data != end) {
         uint64_t k;
 
 #if (BYTE_ORDER == LITTLE_ENDIAN)
+	#ifdef USE_ALIGNED_ACCESS
+	memcpy(&k,data,sizeof(uint64_t));
+	#else
         k = *((uint64_t*)data);
+	#endif
 #else
         k = (uint64_t) data[0];
         k |= (uint64_t) data[1] << 8;
         k |= (uint64_t) data[2] << 16;
         k |= (uint64_t) data[3] << 24;
         k |= (uint64_t) data[4] << 32;
@@ -991,38 +995,27 @@
     } else if (hdr->encoding == HLL_RAW) {
         E = hllRawSum(hdr->registers,PE,&ez);
     } else {
         serverPanic("Unknown HyperLogLog encoding in hllCount()");
     }
 
-    /* Muliply the inverse of E for alpha_m * m^2 to have the raw estimate. */
-    E = (1/E)*alpha*m*m;
+    /* Apply loglog-beta to the raw estimate. See:
+     * "LogLog-Beta and More: A New Algorithm for Cardinality Estimation
+     * Based on LogLog Counting" Jason Qin, Denys Kim, Yumei Tung
+     * arXiv:1612.02284 */
+    double zl = log(ez + 1);
+    double beta = -0.370393911*ez +
+                   0.070471823*zl +
+                   0.17393686*pow(zl,2) +
+                   0.16339839*pow(zl,3) +
+                  -0.09237745*pow(zl,4) +
+                   0.03738027*pow(zl,5) +
+                  -0.005384159*pow(zl,6) +
+                   0.00042419*pow(zl,7);
 
-    /* Use the LINEARCOUNTING algorithm for small cardinalities.
-     * For larger values but up to 72000 HyperLogLog raw approximation is
-     * used since linear counting error starts to increase. However HyperLogLog
-     * shows a strong bias in the range 2.5*16384 - 72000, so we try to
-     * compensate for it. */
-    if (E < m*2.5 && ez != 0) {
-        E = m*log(m/ez); /* LINEARCOUNTING() */
-    } else if (m == 16384 && E < 72000) {
-        /* We did polynomial regression of the bias for this range, this
-         * way we can compute the bias for a given cardinality and correct
-         * according to it. Only apply the correction for P=14 that's what
-         * we use and the value the correction was verified with. */
-        double bias = 5.9119*1.0e-18*(E*E*E*E)
-                      -1.4253*1.0e-12*(E*E*E)+
-                      1.2940*1.0e-7*(E*E)
-                      -5.2921*1.0e-3*E+
-                      83.3216;
-        E -= E*(bias/100);
-    }
-    /* We don't apply the correction for E > 1/30 of 2^32 since we use
-     * a 64 bit function and 6 bit counters. To apply the correction for
-     * 1/30 of 2^64 is not needed since it would require a huge set
-     * to approach such a value. */
+    E  = llroundl(alpha*m*(m-ez)*(1/(E+beta)));
     return (uint64_t) E;
 }
 
 /* Call hllDenseAdd() or hllSparseAdd() according to the HLL encoding. */
 int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
     struct hllhdr *hdr = o->ptr;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/hyperloglog.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/hyperloglog.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.c	2017-07-14 19:28:42.000000000 +0800
@@ -258,24 +258,24 @@
 
 /* Return random member */
 int64_t intsetRandom(intset *is) {
     return _intsetGet(is,rand()%intrev32ifbe(is->length));
 }
 
-/* Sets the value to the value at the given position. When this position is
+/* Get the value at the given position. When this position is
  * out of range the function returns 0, when in range it returns 1. */
 uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {
     if (pos < intrev32ifbe(is->length)) {
         *value = _intsetGet(is,pos);
         return 1;
     }
     return 0;
 }
 
 /* Return intset length */
-uint32_t intsetLen(intset *is) {
+uint32_t intsetLen(const intset *is) {
     return intrev32ifbe(is->length);
 }
 
 /* Return intset blob size in bytes. */
 size_t intsetBlobLen(intset *is) {
     return sizeof(intset)+intrev32ifbe(is->length)*intrev32ifbe(is->encoding);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.h	2017-07-14 19:28:42.000000000 +0800
@@ -41,13 +41,13 @@
 intset *intsetNew(void);
 intset *intsetAdd(intset *is, int64_t value, uint8_t *success);
 intset *intsetRemove(intset *is, int64_t value, int *success);
 uint8_t intsetFind(intset *is, int64_t value);
 int64_t intsetRandom(intset *is);
 uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);
-uint32_t intsetLen(intset *is);
+uint32_t intsetLen(const intset *is);
 size_t intsetBlobLen(intset *is);
 
 #ifdef REDIS_TEST
 int intsetTest(int argc, char *argv[]);
 #endif
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/intset.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/intset.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.c	2017-07-14 19:28:42.000000000 +0800
@@ -38,13 +38,13 @@
 /* Dictionary type for latency events. */
 int dictStringKeyCompare(void *privdata, const void *key1, const void *key2) {
     UNUSED(privdata);
     return strcmp(key1,key2) == 0;
 }
 
-unsigned int dictStringHash(const void *key) {
+uint64_t dictStringHash(const void *key) {
     return dictGenHashFunction(key, strlen(key));
 }
 
 void dictVanillaFree(void *privdata, void *val);
 
 dictType latencyTimeSeriesDictType = {
@@ -76,13 +76,13 @@
 #endif
 
 /* Report the amount of AnonHugePages in smap, in bytes. If the return
  * value of the function is non-zero, the process is being targeted by
  * THP support, and is likely to have memory usage / latency issues. */
 int THPGetAnonHugePagesSize(void) {
-    return zmalloc_get_smap_bytes_by_field("AnonHugePages:");
+    return zmalloc_get_smap_bytes_by_field("AnonHugePages:",-1);
 }
 
 /* ---------------------------- Latency API --------------------------------- */
 
 /* Latency monitor initialization. We just need to create the dictionary
  * of time series, each time serie is craeted on demand in order to avoid
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/latency.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/latency.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: lazyfree.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: lazyfree.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: lazyfree.o
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_c.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_c.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_c.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_c.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_d.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_d.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/lzf_d.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/lzf_d.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/Makefile	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/Makefile	2017-07-14 19:28:42.000000000 +0800
@@ -11,29 +11,39 @@
 #
 # Dependencies are stored in the Makefile.dep file. To rebuild this file
 # Just use 'make dep', but this is only needed by developers.
 
 release_hdr := $(shell sh -c './mkreleasehdr.sh')
 uname_S := $(shell sh -c 'uname -s 2>/dev/null || echo not')
+uname_M := $(shell sh -c 'uname -m 2>/dev/null || echo not')
 OPTIMIZATION?=-O2
-DEPENDENCY_TARGETS=hiredis linenoise lua geohash-int
+DEPENDENCY_TARGETS=hiredis linenoise lua
+NODEPS:=clean distclean
 
 # Default settings
 STD=-std=c99 -pedantic -DREDIS_STATIC=''
-WARN=-Wall -W
+WARN=-Wall -W -Wno-missing-field-initializers
 OPT=$(OPTIMIZATION)
 
 PREFIX?=/usr/local
 INSTALL_BIN=$(PREFIX)/bin
 INSTALL=install
 
-# Default allocator
+# Default allocator defaults to Jemalloc if it's not an ARM
+MALLOC=libc
+ifneq ($(uname_M),armv6l)
+ifneq ($(uname_M),armv7l)
 ifeq ($(uname_S),Linux)
 	MALLOC=jemalloc
-else
-	MALLOC=libc
+endif
+endif
+endif
+
+# To get ARM stack traces if Redis crashes we need a special C flag.
+ifneq (,$(findstring armv,$(uname_M)))
+        CFLAGS+=-funwind-tables
 endif
 
 # Backwards compatibility for selecting an allocator
 ifeq ($(USE_TCMALLOC),yes)
 	MALLOC=tcmalloc
 endif
@@ -50,19 +60,26 @@
 	MALLOC=libc
 endif
 
 # Override default settings if possible
 -include .make-settings
 
-FINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS) -I../deps/geohash-int
+FINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)
 FINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)
 FINAL_LIBS=-lm
 DEBUG=-g -ggdb
 
 ifeq ($(uname_S),SunOS)
 	# SunOS
+        ifneq ($(@@),32bit)
+		CFLAGS+= -m64
+		LDFLAGS+= -m64
+	endif
+	DEBUG=-g
+	DEBUG_FLAGS=-g
+	export CFLAGS LDFLAGS DEBUG DEBUG_FLAGS
 	INSTALL=cp -pf
 	FINAL_CFLAGS+= -D__EXTENSIONS__ -D_XPG6
 	FINAL_LIBS+= -ldl -lnsl -lsocket -lresolv -lpthread -lrt
 else
 ifeq ($(uname_S),Darwin)
 	# Darwin
@@ -124,36 +141,33 @@
 QUIET_LINK = @printf '    %b %b\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
 QUIET_INSTALL = @printf '    %b %b\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;
 endif
 
 REDIS_SERVER_NAME=redis-server
 REDIS_SENTINEL_NAME=redis-sentinel
-REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o geo.o
-REDIS_GEOHASH_OBJ=../deps/geohash-int/geohash.o ../deps/geohash-int/geohash_helper.o
+REDIS_SERVER_OBJ=adlist.o quicklist.o ae.o anet.o dict.o server.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o redis-check-rdb.o redis-check-aof.o geo.o lazyfree.o module.o evict.o expire.o geohash.o geohash_helper.o childinfo.o defrag.o siphash.o rax.o
 REDIS_CLI_NAME=redis-cli
 REDIS_CLI_OBJ=anet.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o
 REDIS_BENCHMARK_NAME=redis-benchmark
 REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o adlist.o zmalloc.o redis-benchmark.o
 REDIS_CHECK_RDB_NAME=redis-check-rdb
 REDIS_CHECK_AOF_NAME=redis-check-aof
-REDIS_CHECK_AOF_OBJ=redis-check-aof.o
 
 all: $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME)
 	@echo ""
 	@echo "Hint: It's a good idea to run 'make test' ;)"
 	@echo ""
 
-.PHONY: all
-
-# Deps (use make dep to generate this)
-include Makefile.dep
+Makefile.dep:
+	-$(REDIS_CC) -MM *.c > Makefile.dep 2> /dev/null || true
 
-dep:
-	$(REDIS_CC) -MM *.c > Makefile.dep
+ifeq (0, $(words $(findstring $(MAKECMDGOALS), $(NODEPS))))
+-include Makefile.dep
+endif
 
-.PHONY: dep
+.PHONY: all
 
 persist-settings: distclean
 	echo STD=$(STD) >> .make-settings
 	echo WARN=$(WARN) >> .make-settings
 	echo OPT=$(OPT) >> .make-settings
 	echo MALLOC=$(MALLOC) >> .make-settings
@@ -179,42 +193,45 @@
 ifneq ($(strip $(PREV_FINAL_LDFLAGS)), $(strip $(FINAL_LDFLAGS)))
 .make-prerequisites: persist-settings
 endif
 
 # redis-server
 $(REDIS_SERVER_NAME): $(REDIS_SERVER_OBJ)
-	$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a $(REDIS_GEOHASH_OBJ) $(FINAL_LIBS)
+	$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/lua/src/liblua.a $(FINAL_LIBS)
 
 # redis-sentinel
 $(REDIS_SENTINEL_NAME): $(REDIS_SERVER_NAME)
 	$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME)
 
 # redis-check-rdb
 $(REDIS_CHECK_RDB_NAME): $(REDIS_SERVER_NAME)
 	$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_RDB_NAME)
 
+# redis-check-aof
+$(REDIS_CHECK_AOF_NAME): $(REDIS_SERVER_NAME)
+	$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(REDIS_CHECK_AOF_NAME)
+
 # redis-cli
 $(REDIS_CLI_NAME): $(REDIS_CLI_OBJ)
 	$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a ../deps/linenoise/linenoise.o $(FINAL_LIBS)
 
 # redis-benchmark
 $(REDIS_BENCHMARK_NAME): $(REDIS_BENCHMARK_OBJ)
 	$(REDIS_LD) -o $@ $^ ../deps/hiredis/libhiredis.a $(FINAL_LIBS)
 
-# redis-check-aof
-$(REDIS_CHECK_AOF_NAME): $(REDIS_CHECK_AOF_OBJ)
-	$(REDIS_LD) -o $@ $^ $(FINAL_LIBS)
+dict-benchmark: dict.c zmalloc.c sds.c siphash.c
+	$(REDIS_CC) $(FINAL_CFLAGS) $^ -D DICT_BENCHMARK_MAIN -o $@ $(FINAL_LIBS)
 
 # Because the jemalloc.h header is generated as a part of the jemalloc build,
 # building it should complete before building any other object. Instead of
 # depending on a single artifact, build all dependencies first.
 %.o: %.c .make-prerequisites
 	$(REDIS_CC) -c $<
 
 clean:
-	rm -rf $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME) *.o *.gcda *.gcno *.gcov redis.info lcov-html
+	rm -rf $(REDIS_SERVER_NAME) $(REDIS_SENTINEL_NAME) $(REDIS_CLI_NAME) $(REDIS_BENCHMARK_NAME) $(REDIS_CHECK_RDB_NAME) $(REDIS_CHECK_AOF_NAME) *.o *.gcda *.gcno *.gcov redis.info lcov-html Makefile.dep dict-benchmark
 
 .PHONY: clean
 
 distclean: clean
 	-(cd ../deps && $(MAKE) distclean)
 	-(rm -f .make-*)
@@ -233,13 +250,13 @@
 	$(MAKE) gcov
 	@(set -e; cd ..; ./runtest --clients 1)
 	@geninfo -o redis.info .
 	@genhtml --legend -o lcov-html redis.info
 
 test-sds: sds.c sds.h
-	$(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN -o /tmp/sds_test
+	$(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test
 	/tmp/sds_test
 
 .PHONY: lcov
 
 bench: $(REDIS_BENCHMARK_NAME)
 	./$(REDIS_BENCHMARK_NAME)
@@ -256,12 +273,15 @@
 noopt:
 	$(MAKE) OPTIMIZATION="-O0"
 
 valgrind:
 	$(MAKE) OPTIMIZATION="-O0" MALLOC="libc"
 
+helgrind:
+	$(MAKE) OPTIMIZATION="-O0" MALLOC="libc" CFLAGS="-D__ATOMIC_VAR_FORCE_SYNC_MACROS"
+
 src/help.h:
 	@../utils/generate-command-help.rb > help.h
 
 install: all
 	@mkdir -p $(INSTALL_BIN)
 	$(REDIS_INSTALL) $(REDIS_SERVER_NAME) $(INSTALL_BIN)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src: Makefile.dep
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/.make-settings /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/.make-settings
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/.make-settings	2017-09-27 22:53:52.330950313 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/.make-settings	2017-09-27 23:06:40.490922160 +0800
@@ -1,10 +1,10 @@
 STD=-std=c99 -pedantic -DREDIS_STATIC=
-WARN=-Wall -W
+WARN=-Wall -W -Wno-missing-field-initializers
 OPT=-O2
 MALLOC=jemalloc
 CFLAGS=
 LDFLAGS=
 REDIS_CFLAGS=
 REDIS_LDFLAGS=
-PREV_FINAL_CFLAGS=-std=c99 -pedantic -DREDIS_STATIC= -Wall -W -O2 -g -ggdb -I../deps/geohash-int -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include
+PREV_FINAL_CFLAGS=-std=c99 -pedantic -DREDIS_STATIC= -Wall -W -Wno-missing-field-initializers -O2 -g -ggdb -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include
 PREV_FINAL_LDFLAGS= -g -ggdb -rdynamic
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/memtest.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/memtest.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/memtest.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/memtest.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: module.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: module.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: module.o
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: modules
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.c	2017-07-14 19:28:42.000000000 +0800
@@ -114,12 +114,13 @@
 void execCommand(client *c) {
     int j;
     robj **orig_argv;
     int orig_argc;
     struct redisCommand *orig_cmd;
     int must_propagate = 0; /* Need to propagate MULTI/EXEC to AOF / slaves? */
+    int was_master = server.masterhost == NULL;
 
     if (!(c->flags & CLIENT_MULTI)) {
         addReplyError(c,"EXEC without MULTI");
         return;
     }
 
@@ -144,17 +145,18 @@
     addReplyMultiBulkLen(c,c->mstate.count);
     for (j = 0; j < c->mstate.count; j++) {
         c->argc = c->mstate.commands[j].argc;
         c->argv = c->mstate.commands[j].argv;
         c->cmd = c->mstate.commands[j].cmd;
 
-        /* Propagate a MULTI request once we encounter the first write op.
+        /* Propagate a MULTI request once we encounter the first command which
+         * is not readonly nor an administrative one.
          * This way we'll deliver the MULTI/..../EXEC block as a whole and
          * both the AOF and the replication link will have the same consistency
          * and atomicity guarantees. */
-        if (!must_propagate && !(c->cmd->flags & CMD_READONLY)) {
+        if (!must_propagate && !(c->cmd->flags & (CMD_READONLY|CMD_ADMIN))) {
             execCommandPropagateMulti(c);
             must_propagate = 1;
         }
 
         call(c,CMD_CALL_FULL);
 
@@ -164,15 +166,28 @@
         c->mstate.commands[j].cmd = c->cmd;
     }
     c->argv = orig_argv;
     c->argc = orig_argc;
     c->cmd = orig_cmd;
     discardTransaction(c);
+
     /* Make sure the EXEC command will be propagated as well if MULTI
      * was already propagated. */
-    if (must_propagate) server.dirty++;
+    if (must_propagate) {
+        int is_master = server.masterhost == NULL;
+        server.dirty++;
+        /* If inside the MULTI/EXEC block this instance was suddenly
+         * switched from master to slave (using the SLAVEOF command), the
+         * initial MULTI was propagated into the replication backlog, but the
+         * rest was not. We need to make sure to at least terminate the
+         * backlog with the final EXEC. */
+        if (server.repl_backlog && was_master && !is_master) {
+            char *execcmd = "*1\r\n$4\r\nEXEC\r\n";
+            feedReplicationBacklog(execcmd,strlen(execcmd));
+        }
+    }
 
 handle_monitor:
     /* Send EXEC to clients waiting data from MONITOR. We do it here
      * since the natural order of commands execution is actually:
      * MUTLI, EXEC, ... commands inside transaction ...
      * Instead EXEC is flagged as CMD_SKIP_MONITOR in the command
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/multi.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/multi.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.c	2017-07-14 19:28:42.000000000 +0800
@@ -25,16 +25,18 @@
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "server.h"
+#include "atomicvar.h"
 #include <sys/uio.h>
 #include <math.h>
+#include <ctype.h>
 
-static void setProtocolError(client *c, int pos);
+static void setProtocolError(const char *errstr, client *c, int pos);
 
 /* Return the size consumed from the allocator, for the specified SDS string,
  * including internal fragmentation. This function is used in order to compute
  * the client output buffer size. */
 size_t sdsZmallocSize(sds s) {
     void *sh = sdsAllocPtr(s);
@@ -49,15 +51,19 @@
     case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
     case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
     default: return 0; /* Just integer encoding for now. */
     }
 }
 
+/* Client.reply list dup and free methods. */
 void *dupClientReplyValue(void *o) {
-    incrRefCount((robj*)o);
-    return o;
+    return sdsdup(o);
+}
+
+void freeClientReplyValue(void *o) {
+    sdsfree(o);
 }
 
 int listMatchObjects(void *a, void *b) {
     return equalStringObjects(a,b);
 }
 
@@ -80,17 +86,20 @@
             zfree(c);
             return NULL;
         }
     }
 
     selectDb(c,0);
-    c->id = server.next_client_id++;
+    uint64_t client_id;
+    atomicGetIncr(server.next_client_id,client_id,1);
+    c->id = client_id;
     c->fd = fd;
     c->name = NULL;
     c->bufpos = 0;
     c->querybuf = sdsempty();
+    c->pending_querybuf = sdsempty();
     c->querybuf_peak = 0;
     c->reqtype = 0;
     c->argc = 0;
     c->argv = NULL;
     c->cmd = c->lastcmd = NULL;
     c->multibulklen = 0;
@@ -99,31 +108,32 @@
     c->flags = 0;
     c->ctime = c->lastinteraction = server.unixtime;
     c->authenticated = 0;
     c->replstate = REPL_STATE_NONE;
     c->repl_put_online_on_ack = 0;
     c->reploff = 0;
+    c->read_reploff = 0;
     c->repl_ack_off = 0;
     c->repl_ack_time = 0;
     c->slave_listening_port = 0;
     c->slave_ip[0] = '\0';
     c->slave_capa = SLAVE_CAPA_NONE;
     c->reply = listCreate();
     c->reply_bytes = 0;
     c->obuf_soft_limit_reached_time = 0;
-    listSetFreeMethod(c->reply,decrRefCountVoid);
+    listSetFreeMethod(c->reply,freeClientReplyValue);
     listSetDupMethod(c->reply,dupClientReplyValue);
     c->btype = BLOCKED_NONE;
     c->bpop.timeout = 0;
-    c->bpop.keys = dictCreate(&setDictType,NULL);
+    c->bpop.keys = dictCreate(&objectKeyPointerValueDictType,NULL);
     c->bpop.target = NULL;
     c->bpop.numreplicas = 0;
     c->bpop.reploffset = 0;
     c->woff = 0;
     c->watched_keys = listCreate();
-    c->pubsub_channels = dictCreate(&setDictType,NULL);
+    c->pubsub_channels = dictCreate(&objectKeyPointerValueDictType,NULL);
     c->pubsub_patterns = listCreate();
     c->peerid = NULL;
     listSetFreeMethod(c->pubsub_patterns,decrRefCountVoid);
     listSetMatchMethod(c->pubsub_patterns,listMatchObjects);
     if (fd != -1) listAddNodeTail(server.clients,c);
     initClientMultiState(c);
@@ -142,23 +152,23 @@
  * handler failed, the function returns C_ERR.
  *
  * The function may return C_OK without actually installing the write
  * event handler in the following cases:
  *
  * 1) The event handler should already be installed since the output buffer
- *    already contained something.
+ *    already contains something.
  * 2) The client is a slave but not yet online, so we want to just accumulate
  *    writes in the buffer but not actually sending them yet.
  *
  * Typically gets called every time a reply is built, before adding more
  * data to the clients output buffers. If the function returns C_ERR no
  * data should be appended to the output buffers. */
 int prepareClientToWrite(client *c) {
     /* If it's the Lua client we always return ok without installing any
      * handler since there is no socket at all. */
-    if (c->flags & CLIENT_LUA) return C_OK;
+    if (c->flags & (CLIENT_LUA|CLIENT_MODULE)) return C_OK;
 
     /* CLIENT REPLY OFF / SKIP handling: don't send replies. */
     if (c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) return C_ERR;
 
     /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
      * is set. */
@@ -187,28 +197,12 @@
     }
 
     /* Authorize the caller to queue in the output buffer of this client. */
     return C_OK;
 }
 
-/* Create a duplicate of the last object in the reply list when
- * it is not exclusively owned by the reply list. */
-robj *dupLastObjectIfNeeded(list *reply) {
-    robj *new, *cur;
-    listNode *ln;
-    serverAssert(listLength(reply) > 0);
-    ln = listLast(reply);
-    cur = listNodeValue(ln);
-    if (cur->refcount > 1) {
-        new = dupStringObject(cur);
-        decrRefCount(cur);
-        listNodeValue(ln) = new;
-    }
-    return listNodeValue(ln);
-}
-
 /* -----------------------------------------------------------------------------
  * Low level functions to add more data to output buffers.
  * -------------------------------------------------------------------------- */
 
 int _addReplyToBuffer(client *c, const char *s, size_t len) {
     size_t available = sizeof(c->buf)-c->bufpos;
@@ -225,100 +219,88 @@
     memcpy(c->buf+c->bufpos,s,len);
     c->bufpos+=len;
     return C_OK;
 }
 
 void _addReplyObjectToList(client *c, robj *o) {
-    robj *tail;
-
     if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
 
     if (listLength(c->reply) == 0) {
-        incrRefCount(o);
-        listAddNodeTail(c->reply,o);
-        c->reply_bytes += getStringObjectSdsUsedMemory(o);
+        sds s = sdsdup(o->ptr);
+        listAddNodeTail(c->reply,s);
+        c->reply_bytes += sdslen(s);
     } else {
-        tail = listNodeValue(listLast(c->reply));
+        listNode *ln = listLast(c->reply);
+        sds tail = listNodeValue(ln);
 
-        /* Append to this object when possible. */
-        if (tail->ptr != NULL &&
-            tail->encoding == OBJ_ENCODING_RAW &&
-            sdslen(tail->ptr)+sdslen(o->ptr) <= PROTO_REPLY_CHUNK_BYTES)
-        {
-            c->reply_bytes -= sdsZmallocSize(tail->ptr);
-            tail = dupLastObjectIfNeeded(c->reply);
-            tail->ptr = sdscatlen(tail->ptr,o->ptr,sdslen(o->ptr));
-            c->reply_bytes += sdsZmallocSize(tail->ptr);
+        /* Append to this object when possible. If tail == NULL it was
+         * set via addDeferredMultiBulkLength(). */
+        if (tail && sdslen(tail)+sdslen(o->ptr) <= PROTO_REPLY_CHUNK_BYTES) {
+            tail = sdscatsds(tail,o->ptr);
+            listNodeValue(ln) = tail;
+            c->reply_bytes += sdslen(o->ptr);
         } else {
-            incrRefCount(o);
-            listAddNodeTail(c->reply,o);
-            c->reply_bytes += getStringObjectSdsUsedMemory(o);
+            sds s = sdsdup(o->ptr);
+            listAddNodeTail(c->reply,s);
+            c->reply_bytes += sdslen(s);
         }
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
 }
 
 /* This method takes responsibility over the sds. When it is no longer
  * needed it will be free'd, otherwise it ends up in a robj. */
 void _addReplySdsToList(client *c, sds s) {
-    robj *tail;
-
     if (c->flags & CLIENT_CLOSE_AFTER_REPLY) {
         sdsfree(s);
         return;
     }
 
     if (listLength(c->reply) == 0) {
-        listAddNodeTail(c->reply,createObject(OBJ_STRING,s));
-        c->reply_bytes += sdsZmallocSize(s);
+        listAddNodeTail(c->reply,s);
+        c->reply_bytes += sdslen(s);
     } else {
-        tail = listNodeValue(listLast(c->reply));
+        listNode *ln = listLast(c->reply);
+        sds tail = listNodeValue(ln);
 
-        /* Append to this object when possible. */
-        if (tail->ptr != NULL && tail->encoding == OBJ_ENCODING_RAW &&
-            sdslen(tail->ptr)+sdslen(s) <= PROTO_REPLY_CHUNK_BYTES)
-        {
-            c->reply_bytes -= sdsZmallocSize(tail->ptr);
-            tail = dupLastObjectIfNeeded(c->reply);
-            tail->ptr = sdscatlen(tail->ptr,s,sdslen(s));
-            c->reply_bytes += sdsZmallocSize(tail->ptr);
+        /* Append to this object when possible. If tail == NULL it was
+         * set via addDeferredMultiBulkLength(). */
+        if (tail && sdslen(tail)+sdslen(s) <= PROTO_REPLY_CHUNK_BYTES) {
+            tail = sdscatsds(tail,s);
+            listNodeValue(ln) = tail;
+            c->reply_bytes += sdslen(s);
             sdsfree(s);
         } else {
-            listAddNodeTail(c->reply,createObject(OBJ_STRING,s));
-            c->reply_bytes += sdsZmallocSize(s);
+            listAddNodeTail(c->reply,s);
+            c->reply_bytes += sdslen(s);
         }
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
 }
 
 void _addReplyStringToList(client *c, const char *s, size_t len) {
-    robj *tail;
-
     if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;
 
     if (listLength(c->reply) == 0) {
-        robj *o = createStringObject(s,len);
-
-        listAddNodeTail(c->reply,o);
-        c->reply_bytes += getStringObjectSdsUsedMemory(o);
+        sds node = sdsnewlen(s,len);
+        listAddNodeTail(c->reply,node);
+        c->reply_bytes += len;
     } else {
-        tail = listNodeValue(listLast(c->reply));
+        listNode *ln = listLast(c->reply);
+        sds tail = listNodeValue(ln);
 
-        /* Append to this object when possible. */
-        if (tail->ptr != NULL && tail->encoding == OBJ_ENCODING_RAW &&
-            sdslen(tail->ptr)+len <= PROTO_REPLY_CHUNK_BYTES)
-        {
-            c->reply_bytes -= sdsZmallocSize(tail->ptr);
-            tail = dupLastObjectIfNeeded(c->reply);
-            tail->ptr = sdscatlen(tail->ptr,s,len);
-            c->reply_bytes += sdsZmallocSize(tail->ptr);
+        /* Append to this object when possible. If tail == NULL it was
+         * set via addDeferredMultiBulkLength(). */
+        if (tail && sdslen(tail)+len <= PROTO_REPLY_CHUNK_BYTES) {
+            tail = sdscatlen(tail,s,len);
+            listNodeValue(ln) = tail;
+            c->reply_bytes += len;
         } else {
-            robj *o = createStringObject(s,len);
-
-            listAddNodeTail(c->reply,o);
-            c->reply_bytes += getStringObjectSdsUsedMemory(o);
+            sds node = sdsnewlen(s,len);
+            listAddNodeTail(c->reply,node);
+            c->reply_bytes += len;
         }
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
 }
 
 /* -----------------------------------------------------------------------------
@@ -373,12 +355,20 @@
     } else {
         /* This method free's the sds when it is no longer needed. */
         _addReplySdsToList(c,s);
     }
 }
 
+/* This low level function just adds whatever protocol you send it to the
+ * client buffer, trying the static buffer initially, and using the string
+ * of objects if not possible.
+ *
+ * It is efficient because does not create an SDS object nor an Redis object
+ * if not needed. The object will only be created by calling
+ * _addReplyStringToList() if we fail to extend the existing tail object
+ * in the list of objects. */
 void addReplyString(client *c, const char *s, size_t len) {
     if (prepareClientToWrite(c) != C_OK) return;
     if (_addReplyToBuffer(c,s,len) != C_OK)
         _addReplyStringToList(c,s,len);
 }
 
@@ -431,38 +421,38 @@
  * length, which is not known when this function is called. */
 void *addDeferredMultiBulkLength(client *c) {
     /* Note that we install the write event here even if the object is not
      * ready to be sent, since we are sure that before returning to the
      * event loop setDeferredMultiBulkLength() will be called. */
     if (prepareClientToWrite(c) != C_OK) return NULL;
-    listAddNodeTail(c->reply,createObject(OBJ_STRING,NULL));
+    listAddNodeTail(c->reply,NULL); /* NULL is our placeholder. */
     return listLast(c->reply);
 }
 
 /* Populate the length object and try gluing it to the next chunk. */
 void setDeferredMultiBulkLength(client *c, void *node, long length) {
     listNode *ln = (listNode*)node;
-    robj *len, *next;
+    sds len, next;
 
-    /* Abort when *node is NULL (see addDeferredMultiBulkLength). */
+    /* Abort when *node is NULL: when the client should not accept writes
+     * we return NULL in addDeferredMultiBulkLength() */
     if (node == NULL) return;
 
-    len = listNodeValue(ln);
-    len->ptr = sdscatprintf(sdsempty(),"*%ld\r\n",length);
-    len->encoding = OBJ_ENCODING_RAW; /* in case it was an EMBSTR. */
-    c->reply_bytes += sdsZmallocSize(len->ptr);
+    len = sdscatprintf(sdsnewlen("*",1),"%ld\r\n",length);
+    listNodeValue(ln) = len;
+    c->reply_bytes += sdslen(len);
     if (ln->next != NULL) {
         next = listNodeValue(ln->next);
 
         /* Only glue when the next node is non-NULL (an sds in this case) */
-        if (next->ptr != NULL) {
-            c->reply_bytes -= sdsZmallocSize(len->ptr);
-            c->reply_bytes -= getStringObjectSdsUsedMemory(next);
-            len->ptr = sdscatlen(len->ptr,next->ptr,sdslen(next->ptr));
-            c->reply_bytes += sdsZmallocSize(len->ptr);
+        if (next != NULL) {
+            len = sdscatsds(len,next);
             listDelNode(c->reply,ln->next);
+            listNodeValue(ln) = len;
+            /* No need to update c->reply_bytes: we are just moving the same
+             * amount of bytes from one node to another. */
         }
     }
     asyncCloseClientOnOutputBufferLimitReached(c);
 }
 
 /* Add a double as a bulk reply */
@@ -568,14 +558,13 @@
     addReplyString(c,p,len);
     addReply(c,shared.crlf);
 }
 
 /* Add sds to reply (takes ownership of sds and frees it) */
 void addReplyBulkSds(client *c, sds s)  {
-    addReplySds(c,sdscatfmt(sdsempty(),"$%u\r\n",
-        (unsigned long)sdslen(s)));
+    addReplyLongLongWithPrefix(c,sdslen(s),'$');
     addReplySds(c,s);
     addReply(c,shared.crlf);
 }
 
 /* Add a C nul term string as bulk reply */
 void addReplyBulkCString(client *c, const char *s) {
@@ -808,12 +797,13 @@
         serverLog(LL_WARNING,"Connection with slave %s lost.",
             replicationGetSlaveName(c));
     }
 
     /* Free the query buffer */
     sdsfree(c->querybuf);
+    sdsfree(c->pending_querybuf);
     c->querybuf = NULL;
 
     /* Deallocate structures used to block on blocking ops. */
     if (c->flags & CLIENT_BLOCKED) unblockClient(c);
     dictRelease(c->bpop.keys);
 
@@ -899,14 +889,13 @@
 
 /* Write data in output buffers to client. Return C_OK if the client
  * is still valid after the call, C_ERR if it was freed. */
 int writeToClient(int fd, client *c, int handler_installed) {
     ssize_t nwritten = 0, totwritten = 0;
     size_t objlen;
-    size_t objmem;
-    robj *o;
+    sds o;
 
     while(clientHasPendingReplies(c)) {
         if (c->bufpos > 0) {
             nwritten = write(fd,c->buf+c->sentlen,c->bufpos-c->sentlen);
             if (nwritten <= 0) break;
             c->sentlen += nwritten;
@@ -917,31 +906,33 @@
             if ((int)c->sentlen == c->bufpos) {
                 c->bufpos = 0;
                 c->sentlen = 0;
             }
         } else {
             o = listNodeValue(listFirst(c->reply));
-            objlen = sdslen(o->ptr);
-            objmem = getStringObjectSdsUsedMemory(o);
+            objlen = sdslen(o);
 
             if (objlen == 0) {
                 listDelNode(c->reply,listFirst(c->reply));
-                c->reply_bytes -= objmem;
                 continue;
             }
 
-            nwritten = write(fd, ((char*)o->ptr)+c->sentlen,objlen-c->sentlen);
+            nwritten = write(fd, o + c->sentlen, objlen - c->sentlen);
             if (nwritten <= 0) break;
             c->sentlen += nwritten;
             totwritten += nwritten;
 
             /* If we fully sent the object on head go to the next one */
             if (c->sentlen == objlen) {
                 listDelNode(c->reply,listFirst(c->reply));
                 c->sentlen = 0;
-                c->reply_bytes -= objmem;
+                c->reply_bytes -= objlen;
+                /* If there are no longer objects in the list, we expect
+                 * the count of reply bytes to be exactly zero. */
+                if (listLength(c->reply) == 0)
+                    serverAssert(c->reply_bytes == 0);
             }
         }
         /* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT
          * bytes, in a single threaded server it's a good idea to serve
          * other clients as well, even if a very large request comes from
          * super fast link that is always able to accept data (in real world
@@ -1042,12 +1033,19 @@
     if (c->flags & CLIENT_REPLY_SKIP_NEXT) {
         c->flags |= CLIENT_REPLY_SKIP;
         c->flags &= ~CLIENT_REPLY_SKIP_NEXT;
     }
 }
 
+/* Like processMultibulkBuffer(), but for the inline protocol instead of RESP,
+ * this function consumes the client query buffer and creates a command ready
+ * to be executed inside the client structure. Returns C_OK if the command
+ * is ready to be executed, or C_ERR if there is still protocol to read to
+ * have a well formed command. The function also returns C_ERR when there is
+ * a protocol error: in such a case the client structure is setup to reply
+ * with the error and close the connection. */
 int processInlineBuffer(client *c) {
     char *newline;
     int argc, j;
     sds *argv, aux;
     size_t querylen;
 
@@ -1055,13 +1053,13 @@
     newline = strchr(c->querybuf,'\n');
 
     /* Nothing to do without a \r\n */
     if (newline == NULL) {
         if (sdslen(c->querybuf) > PROTO_INLINE_MAX_SIZE) {
             addReplyError(c,"Protocol error: too big inline request");
-            setProtocolError(c,0);
+            setProtocolError("too big inline request",c,0);
         }
         return C_ERR;
     }
 
     /* Handle the \r\n case. */
     if (newline && newline != c->querybuf && *(newline-1) == '\r')
@@ -1071,13 +1069,13 @@
     querylen = newline-(c->querybuf);
     aux = sdsnewlen(c->querybuf,querylen);
     argv = sdssplitargs(aux,&argc);
     sdsfree(aux);
     if (argv == NULL) {
         addReplyError(c,"Protocol error: unbalanced quotes in request");
-        setProtocolError(c,0);
+        setProtocolError("unbalanced quotes in inline request",c,0);
         return C_ERR;
     }
 
     /* Newline from slaves can be used to refresh the last ACK time.
      * This is useful for a slave to ping back while loading a big
      * RDB file. */
@@ -1105,23 +1103,52 @@
     zfree(argv);
     return C_OK;
 }
 
 /* Helper function. Trims query buffer to make the function that processes
  * multi bulk requests idempotent. */
-static void setProtocolError(client *c, int pos) {
+#define PROTO_DUMP_LEN 128
+static void setProtocolError(const char *errstr, client *c, int pos) {
     if (server.verbosity <= LL_VERBOSE) {
         sds client = catClientInfoString(sdsempty(),c);
+
+        /* Sample some protocol to given an idea about what was inside. */
+        char buf[256];
+        if (sdslen(c->querybuf) < PROTO_DUMP_LEN) {
+            snprintf(buf,sizeof(buf),"Query buffer during protocol error: '%s'", c->querybuf);
+        } else {
+            snprintf(buf,sizeof(buf),"Query buffer during protocol error: '%.*s' (... more %zu bytes ...) '%.*s'", PROTO_DUMP_LEN/2, c->querybuf, sdslen(c->querybuf)-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2);
+        }
+
+        /* Remove non printable chars. */
+        char *p = buf;
+        while (*p != '\0') {
+            if (!isprint(*p)) *p = '.';
+            p++;
+        }
+
+        /* Log all the client and protocol info. */
         serverLog(LL_VERBOSE,
-            "Protocol error from client: %s", client);
+            "Protocol error (%s) from client: %s. %s", errstr, client, buf);
         sdsfree(client);
     }
     c->flags |= CLIENT_CLOSE_AFTER_REPLY;
     sdsrange(c->querybuf,pos,-1);
 }
 
+/* Process the query buffer for client 'c', setting up the client argument
+ * vector for command execution. Returns C_OK if after running the function
+ * the client has a well-formed ready to be processed command, otherwise
+ * C_ERR if there is still to read more buffer to get the full command.
+ * The function also returns C_ERR when there is a protocol error: in such a
+ * case the client structure is setup to reply with the error and close
+ * the connection.
+ *
+ * This function is called if processInputBuffer() detects that the next
+ * command is in RESP format, so the first byte in the command is found
+ * to be '*'. Otherwise for inline commands processInlineBuffer() is called. */
 int processMultibulkBuffer(client *c) {
     char *newline = NULL;
     int pos = 0, ok;
     long long ll;
 
     if (c->multibulklen == 0) {
@@ -1130,13 +1157,13 @@
 
         /* Multi bulk length cannot be read without a \r\n */
         newline = strchr(c->querybuf,'\r');
         if (newline == NULL) {
             if (sdslen(c->querybuf) > PROTO_INLINE_MAX_SIZE) {
                 addReplyError(c,"Protocol error: too big mbulk count string");
-                setProtocolError(c,0);
+                setProtocolError("too big mbulk count string",c,0);
             }
             return C_ERR;
         }
 
         /* Buffer should also contain \n */
         if (newline-(c->querybuf) > ((signed)sdslen(c->querybuf)-2))
@@ -1145,13 +1172,13 @@
         /* We know for sure there is a whole line since newline != NULL,
          * so go ahead and find out the multi bulk length. */
         serverAssertWithInfo(c,NULL,c->querybuf[0] == '*');
         ok = string2ll(c->querybuf+1,newline-(c->querybuf+1),&ll);
         if (!ok || ll > 1024*1024) {
             addReplyError(c,"Protocol error: invalid multibulk length");
-            setProtocolError(c,pos);
+            setProtocolError("invalid mbulk count",c,pos);
             return C_ERR;
         }
 
         pos = (newline-c->querybuf)+2;
         if (ll <= 0) {
             sdsrange(c->querybuf,pos,-1);
@@ -1171,13 +1198,13 @@
         if (c->bulklen == -1) {
             newline = strchr(c->querybuf+pos,'\r');
             if (newline == NULL) {
                 if (sdslen(c->querybuf) > PROTO_INLINE_MAX_SIZE) {
                     addReplyError(c,
                         "Protocol error: too big bulk count string");
-                    setProtocolError(c,0);
+                    setProtocolError("too big bulk count string",c,0);
                     return C_ERR;
                 }
                 break;
             }
 
             /* Buffer should also contain \n */
@@ -1185,20 +1212,20 @@
                 break;
 
             if (c->querybuf[pos] != '$') {
                 addReplyErrorFormat(c,
                     "Protocol error: expected '$', got '%c'",
                     c->querybuf[pos]);
-                setProtocolError(c,pos);
+                setProtocolError("expected $ but got something else",c,pos);
                 return C_ERR;
             }
 
             ok = string2ll(c->querybuf+pos+1,newline-(c->querybuf+pos+1),&ll);
             if (!ok || ll < 0 || ll > 512*1024*1024) {
                 addReplyError(c,"Protocol error: invalid bulk length");
-                setProtocolError(c,pos);
+                setProtocolError("invalid bulk length",c,pos);
                 return C_ERR;
             }
 
             pos += newline-(c->querybuf+pos)+2;
             if (ll >= PROTO_MBULK_BIG_ARG) {
                 size_t qblen;
@@ -1250,16 +1277,20 @@
     /* Trim to pos */
     if (pos) sdsrange(c->querybuf,pos,-1);
 
     /* We're done when c->multibulk == 0 */
     if (c->multibulklen == 0) return C_OK;
 
-    /* Still not read to process the command */
+    /* Still not ready to process the command */
     return C_ERR;
 }
 
+/* This function is called every time, in the client structure 'c', there is
+ * more query buffer to process, because we read more data from the socket
+ * or because a client was blocked and later reactivated, so there could be
+ * pending query buffer, already representing a full command, to process. */
 void processInputBuffer(client *c) {
     server.current_client = c;
     /* Keep processing while there is something in the input buffer */
     while(sdslen(c->querybuf)) {
         /* Return if clients are paused. */
         if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;
@@ -1293,16 +1324,28 @@
 
         /* Multibulk processing could see a <= 0 length. */
         if (c->argc == 0) {
             resetClient(c);
         } else {
             /* Only reset the client when the command was executed. */
-            if (processCommand(c) == C_OK)
-                resetClient(c);
-            /* freeMemoryIfNeeded may flush slave output buffers. This may result
-             * into a slave, that may be the active client, to be freed. */
+            if (processCommand(c) == C_OK) {
+                if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {
+                    /* Update the applied replication offset of our master. */
+                    c->reploff = c->read_reploff - sdslen(c->querybuf);
+                }
+
+                /* Don't reset the client structure for clients blocked in a
+                 * module blocking command, so that the reply callback will
+                 * still be able to access the client argv and argc field.
+                 * The client will be reset in unblockClientFromModule(). */
+                if (!(c->flags & CLIENT_BLOCKED) || c->btype != BLOCKED_MODULE)
+                    resetClient(c);
+            }
+            /* freeMemoryIfNeeded may flush slave output buffers. This may
+             * result into a slave, that may be the active client, to be
+             * freed. */
             if (server.current_client == NULL) break;
         }
     }
     server.current_client = NULL;
 }
 
@@ -1341,29 +1384,53 @@
             return;
         }
     } else if (nread == 0) {
         serverLog(LL_VERBOSE, "Client closed connection");
         freeClient(c);
         return;
+    } else if (c->flags & CLIENT_MASTER) {
+        /* Append the query buffer to the pending (not applied) buffer
+         * of the master. We'll use this buffer later in order to have a
+         * copy of the string applied by the last command executed. */
+        c->pending_querybuf = sdscatlen(c->pending_querybuf,
+                                        c->querybuf+qblen,nread);
     }
 
     sdsIncrLen(c->querybuf,nread);
     c->lastinteraction = server.unixtime;
-    if (c->flags & CLIENT_MASTER) c->reploff += nread;
+    if (c->flags & CLIENT_MASTER) c->read_reploff += nread;
     server.stat_net_input_bytes += nread;
     if (sdslen(c->querybuf) > server.client_max_querybuf_len) {
         sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();
 
         bytes = sdscatrepr(bytes,c->querybuf,64);
         serverLog(LL_WARNING,"Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)", ci, bytes);
         sdsfree(ci);
         sdsfree(bytes);
         freeClient(c);
         return;
     }
-    processInputBuffer(c);
+
+    /* Time to process the buffer. If the client is a master we need to
+     * compute the difference between the applied offset before and after
+     * processing the buffer, to understand how much of the replication stream
+     * was actually applied to the master state: this quantity, and its
+     * corresponding part of the replication stream, will be propagated to
+     * the sub-slaves and to the replication backlog. */
+    if (!(c->flags & CLIENT_MASTER)) {
+        processInputBuffer(c);
+    } else {
+        size_t prev_offset = c->reploff;
+        processInputBuffer(c);
+        size_t applied = c->reploff - prev_offset;
+        if (applied) {
+            replicationFeedSlavesFromMasterStream(server.slaves,
+                    c->pending_querybuf, applied);
+            sdsrange(c->pending_querybuf,applied,-1);
+        }
+    }
 }
 
 void getClientsMaxBuffers(unsigned long *longest_output_list,
                           unsigned long *biggest_input_buffer) {
     client *c;
     listNode *ln;
@@ -1741,13 +1808,15 @@
  * is allocated anyway.
  *
  * Note: this function is very fast so can be called as many time as
  * the caller wishes. The main usage of this function currently is
  * enforcing the client output length limits. */
 unsigned long getClientOutputBufferMemoryUsage(client *c) {
-    unsigned long list_item_size = sizeof(listNode)+sizeof(robj);
+    unsigned long list_item_size = sizeof(listNode)+5;
+    /* The +5 above means we assume an sds16 hdr, may not be true
+     * but is not going to be a problem. */
 
     return c->reply_bytes + (list_item_size*listLength(c->reply));
 }
 
 /* Get the class of a client, used in order to enforce limits to different
  * classes of clients.
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/networking.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/networking.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/notify.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/notify.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/notify.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/notify.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.c	2017-07-14 19:28:42.000000000 +0800
@@ -33,28 +33,52 @@
 #include <ctype.h>
 
 #ifdef __CYGWIN__
 #define strtold(a,b) ((long double)strtod((a),(b)))
 #endif
 
+/* ===================== Creation and parsing of objects ==================== */
+
 robj *createObject(int type, void *ptr) {
     robj *o = zmalloc(sizeof(*o));
     o->type = type;
     o->encoding = OBJ_ENCODING_RAW;
     o->ptr = ptr;
     o->refcount = 1;
 
-    /* Set the LRU to the current lruclock (minutes resolution). */
-    o->lru = LRU_CLOCK();
+    /* Set the LRU to the current lruclock (minutes resolution), or
+     * alternatively the LFU counter. */
+    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
+        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
+    } else {
+        o->lru = LRU_CLOCK();
+    }
+    return o;
+}
+
+/* Set a special refcount in the object to make it "shared":
+ * incrRefCount and decrRefCount() will test for this special refcount
+ * and will not touch the object. This way it is free to access shared
+ * objects such as small integers from different threads without any
+ * mutex.
+ *
+ * A common patter to create shared objects:
+ *
+ * robj *myobject = makeObjectShared(createObject(...));
+ *
+ */
+robj *makeObjectShared(robj *o) {
+    serverAssert(o->refcount == 1);
+    o->refcount = OBJ_SHARED_REFCOUNT;
     return o;
 }
 
 /* Create a string object with encoding OBJ_ENCODING_RAW, that is a plain
  * string object where o->ptr points to a proper sds string. */
 robj *createRawStringObject(const char *ptr, size_t len) {
-    return createObject(OBJ_STRING,sdsnewlen(ptr,len));
+    return createObject(OBJ_STRING, sdsnewlen(ptr,len));
 }
 
 /* Create a string object with encoding OBJ_ENCODING_EMBSTR, that is
  * an object where the sds string is actually an unmodifiable string
  * allocated in the same chunk as the object itself. */
 robj *createEmbeddedStringObject(const char *ptr, size_t len) {
@@ -62,13 +86,17 @@
     struct sdshdr8 *sh = (void*)(o+1);
 
     o->type = OBJ_STRING;
     o->encoding = OBJ_ENCODING_EMBSTR;
     o->ptr = sh+1;
     o->refcount = 1;
-    o->lru = LRU_CLOCK();
+    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
+        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;
+    } else {
+        o->lru = LRU_CLOCK();
+    }
 
     sh->len = len;
     sh->alloc = len;
     sh->flags = SDS_TYPE_8;
     if (ptr) {
         memcpy(sh->buf,ptr,len);
@@ -77,13 +105,13 @@
         memset(sh->buf,0,len+1);
     }
     return o;
 }
 
 /* Create a string object with EMBSTR encoding if it is smaller than
- * REIDS_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is
+ * OBJ_ENCODING_EMBSTR_SIZE_LIMIT, otherwise the RAW encoding is
  * used.
  *
  * The current limit of 39 is chosen so that the biggest string object
  * we allocate as EMBSTR will still fit into the 64 byte arena of jemalloc. */
 #define OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44
 robj *createStringObject(const char *ptr, size_t len) {
@@ -115,55 +143,25 @@
  * however this results in loss of precision. Otherwise exp format is used
  * and the output of snprintf() is not modified.
  *
  * The 'humanfriendly' option is used for INCRBYFLOAT and HINCRBYFLOAT. */
 robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {
     char buf[256];
-    int len;
-
-    if (isinf(value)) {
-        /* Libc in odd systems (Hi Solaris!) will format infinite in a
-         * different way, so better to handle it in an explicit way. */
-        if (value > 0) {
-            memcpy(buf,"inf",3);
-            len = 3;
-        } else {
-            memcpy(buf,"-inf",4);
-            len = 4;
-        }
-    } else if (humanfriendly) {
-        /* We use 17 digits precision since with 128 bit floats that precision
-         * after rounding is able to represent most small decimal numbers in a
-         * way that is "non surprising" for the user (that is, most small
-         * decimal numbers will be represented in a way that when converted
-         * back into a string are exactly the same as what the user typed.) */
-        len = snprintf(buf,sizeof(buf),"%.17Lf", value);
-        /* Now remove trailing zeroes after the '.' */
-        if (strchr(buf,'.') != NULL) {
-            char *p = buf+len-1;
-            while(*p == '0') {
-                p--;
-                len--;
-            }
-            if (*p == '.') len--;
-        }
-    } else {
-        len = snprintf(buf,sizeof(buf),"%.17Lg", value);
-    }
+    int len = ld2string(buf,sizeof(buf),value,humanfriendly);
     return createStringObject(buf,len);
 }
 
 /* Duplicate a string object, with the guarantee that the returned object
  * has the same encoding as the original one.
  *
  * This function also guarantees that duplicating a small integere object
  * (or a string object that contains a representation of a small integer)
  * will always result in a fresh object that is unshared (refcount == 1).
  *
  * The resulting object always has refcount set to 1. */
-robj *dupStringObject(robj *o) {
+robj *dupStringObject(const robj *o) {
     robj *d;
 
     serverAssert(o->type == OBJ_STRING);
 
     switch(o->encoding) {
     case OBJ_ENCODING_RAW:
@@ -231,12 +229,19 @@
     unsigned char *zl = ziplistNew();
     robj *o = createObject(OBJ_ZSET,zl);
     o->encoding = OBJ_ENCODING_ZIPLIST;
     return o;
 }
 
+robj *createModuleObject(moduleType *mt, void *value) {
+    moduleValue *mv = zmalloc(sizeof(*mv));
+    mv->type = mt;
+    mv->value = value;
+    return createObject(OBJ_MODULE,mv);
+}
+
 void freeStringObject(robj *o) {
     if (o->encoding == OBJ_ENCODING_RAW) {
         sdsfree(o->ptr);
     }
 }
 
@@ -289,30 +294,37 @@
     default:
         serverPanic("Unknown hash encoding type");
         break;
     }
 }
 
+void freeModuleObject(robj *o) {
+    moduleValue *mv = o->ptr;
+    mv->type->free(mv->value);
+    zfree(mv);
+}
+
 void incrRefCount(robj *o) {
-    o->refcount++;
+    if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount++;
 }
 
 void decrRefCount(robj *o) {
-    if (o->refcount <= 0) serverPanic("decrRefCount against refcount <= 0");
     if (o->refcount == 1) {
         switch(o->type) {
         case OBJ_STRING: freeStringObject(o); break;
         case OBJ_LIST: freeListObject(o); break;
         case OBJ_SET: freeSetObject(o); break;
         case OBJ_ZSET: freeZsetObject(o); break;
         case OBJ_HASH: freeHashObject(o); break;
+        case OBJ_MODULE: freeModuleObject(o); break;
         default: serverPanic("Unknown object type"); break;
         }
         zfree(o);
     } else {
-        o->refcount--;
+        if (o->refcount <= 0) serverPanic("decrRefCount against refcount <= 0");
+        if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount--;
     }
 }
 
 /* This variant of decrRefCount() gets its argument as void, and is useful
  * as free method in data structures that expect a 'void free_object(void*)'
  * prototype for the free method. */
@@ -342,19 +354,23 @@
         addReply(c,shared.wrongtypeerr);
         return 1;
     }
     return 0;
 }
 
+int isSdsRepresentableAsLongLong(sds s, long long *llval) {
+    return string2ll(s,sdslen(s),llval) ? C_OK : C_ERR;
+}
+
 int isObjectRepresentableAsLongLong(robj *o, long long *llval) {
     serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
     if (o->encoding == OBJ_ENCODING_INT) {
         if (llval) *llval = (long) o->ptr;
         return C_OK;
     } else {
-        return string2ll(o->ptr,sdslen(o->ptr),llval) ? C_OK : C_ERR;
+        return isSdsRepresentableAsLongLong(o->ptr,llval);
     }
 }
 
 /* Try to encode a string object in order to save space */
 robj *tryObjectEncoding(robj *o) {
     long value;
@@ -384,14 +400,13 @@
     if (len <= 20 && string2l(s,len,&value)) {
         /* This object is encodable as a long. Try to use a shared object.
          * Note that we avoid using shared integers when maxmemory is used
          * because every object needs to have a private LRU field for the LRU
          * algorithm to work well. */
         if ((server.maxmemory == 0 ||
-             (server.maxmemory_policy != MAXMEMORY_VOLATILE_LRU &&
-              server.maxmemory_policy != MAXMEMORY_ALLKEYS_LRU)) &&
+            !(server.maxmemory_policy & MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &&
             value >= 0 &&
             value < OBJ_SHARED_INTEGERS)
         {
             decrRefCount(o);
             incrRefCount(shared.integers[value]);
             return shared.integers[value];
@@ -529,24 +544,24 @@
         return sdslen(o->ptr);
     } else {
         return sdigits10((long)o->ptr);
     }
 }
 
-int getDoubleFromObject(robj *o, double *target) {
+int getDoubleFromObject(const robj *o, double *target) {
     double value;
     char *eptr;
 
     if (o == NULL) {
         value = 0;
     } else {
         serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
         if (sdsEncodedObject(o)) {
             errno = 0;
             value = strtod(o->ptr, &eptr);
-            if (isspace(((char*)o->ptr)[0]) ||
+            if (isspace(((const char*)o->ptr)[0]) ||
                 eptr[0] != '\0' ||
                 (errno == ERANGE &&
                     (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||
                 errno == EINVAL ||
                 isnan(value))
                 return C_ERR;
@@ -672,24 +687,313 @@
     case OBJ_ENCODING_SKIPLIST: return "skiplist";
     case OBJ_ENCODING_EMBSTR: return "embstr";
     default: return "unknown";
     }
 }
 
-/* Given an object returns the min number of milliseconds the object was never
- * requested, using an approximated LRU algorithm. */
-unsigned long long estimateObjectIdleTime(robj *o) {
-    unsigned long long lruclock = LRU_CLOCK();
-    if (lruclock >= o->lru) {
-        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;
+/* =========================== Memory introspection ========================== */
+
+/* Returns the size in bytes consumed by the key's value in RAM.
+ * Note that the returned value is just an approximation, especially in the
+ * case of aggregated data types where only "sample_size" elements
+ * are checked and averaged to estimate the total size. */
+#define OBJ_COMPUTE_SIZE_DEF_SAMPLES 5 /* Default sample size. */
+size_t objectComputeSize(robj *o, size_t sample_size) {
+    sds ele, ele2;
+    dict *d;
+    dictIterator *di;
+    struct dictEntry *de;
+    size_t asize = 0, elesize = 0, samples = 0;
+
+    if (o->type == OBJ_STRING) {
+        if(o->encoding == OBJ_ENCODING_INT) {
+            asize = sizeof(*o);
+        } else if(o->encoding == OBJ_ENCODING_RAW) {
+            asize = sdsAllocSize(o->ptr)+sizeof(*o);
+        } else if(o->encoding == OBJ_ENCODING_EMBSTR) {
+            asize = sdslen(o->ptr)+2+sizeof(*o);
+        } else {
+            serverPanic("Unknown string encoding");
+        }
+    } else if (o->type == OBJ_LIST) {
+        if (o->encoding == OBJ_ENCODING_QUICKLIST) {
+            quicklist *ql = o->ptr;
+            quicklistNode *node = ql->head;
+            asize = sizeof(*o)+sizeof(quicklist);
+            do {
+                elesize += sizeof(quicklistNode)+ziplistBlobLen(node->zl);
+                samples++;
+            } while ((node = node->next) && samples < sample_size);
+            asize += (double)elesize/samples*listTypeLength(o);
+        } else if (o->encoding == OBJ_ENCODING_ZIPLIST) {
+            asize = sizeof(*o)+ziplistBlobLen(o->ptr);
+        } else {
+            serverPanic("Unknown list encoding");
+        }
+    } else if (o->type == OBJ_SET) {
+        if (o->encoding == OBJ_ENCODING_HT) {
+            d = o->ptr;
+            di = dictGetIterator(d);
+            asize = sizeof(*o)+sizeof(dict)+(sizeof(struct dictEntry*)*dictSlots(d));
+            while((de = dictNext(di)) != NULL && samples < sample_size) {
+                ele = dictGetKey(de);
+                elesize += sizeof(struct dictEntry) + sdsAllocSize(ele);
+                samples++;
+            }
+            dictReleaseIterator(di);
+            if (samples) asize += (double)elesize/samples*dictSize(d);
+        } else if (o->encoding == OBJ_ENCODING_INTSET) {
+            intset *is = o->ptr;
+            asize = sizeof(*o)+sizeof(*is)+is->encoding*is->length;
+        } else {
+            serverPanic("Unknown set encoding");
+        }
+    } else if (o->type == OBJ_ZSET) {
+        if (o->encoding == OBJ_ENCODING_ZIPLIST) {
+            asize = sizeof(*o)+(ziplistBlobLen(o->ptr));
+        } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
+            d = ((zset*)o->ptr)->dict;
+            zskiplist *zsl = ((zset*)o->ptr)->zsl;
+            zskiplistNode *znode = zsl->header->level[0].forward;
+            asize = sizeof(*o)+sizeof(zset)+(sizeof(struct dictEntry*)*dictSlots(d));
+            while(znode != NULL && samples < sample_size) {
+                elesize += sdsAllocSize(znode->ele);
+                elesize += sizeof(struct dictEntry) + zmalloc_size(znode);
+                samples++;
+                znode = znode->level[0].forward;
+            }
+            if (samples) asize += (double)elesize/samples*dictSize(d);
+        } else {
+            serverPanic("Unknown sorted set encoding");
+        }
+    } else if (o->type == OBJ_HASH) {
+        if (o->encoding == OBJ_ENCODING_ZIPLIST) {
+            asize = sizeof(*o)+(ziplistBlobLen(o->ptr));
+        } else if (o->encoding == OBJ_ENCODING_HT) {
+            d = o->ptr;
+            di = dictGetIterator(d);
+            asize = sizeof(*o)+sizeof(dict)+(sizeof(struct dictEntry*)*dictSlots(d));
+            while((de = dictNext(di)) != NULL && samples < sample_size) {
+                ele = dictGetKey(de);
+                ele2 = dictGetVal(de);
+                elesize += sdsAllocSize(ele) + sdsAllocSize(ele2);
+                elesize += sizeof(struct dictEntry);
+                samples++;
+            }
+            dictReleaseIterator(di);
+            if (samples) asize += (double)elesize/samples*dictSize(d);
+        } else {
+            serverPanic("Unknown hash encoding");
+        }
+    } else if (o->type == OBJ_MODULE) {
+        moduleValue *mv = o->ptr;
+        moduleType *mt = mv->type;
+        if (mt->mem_usage != NULL) {
+            asize = mt->mem_usage(mv->value);
+        } else {
+            asize = 0;
+        }
     } else {
-        return (lruclock + (LRU_CLOCK_MAX - o->lru)) *
-                    LRU_CLOCK_RESOLUTION;
+        serverPanic("Unknown object type");
     }
+    return asize;
 }
 
+/* Release data obtained with getMemoryOverheadData(). */
+void freeMemoryOverheadData(struct redisMemOverhead *mh) {
+    zfree(mh->db);
+    zfree(mh);
+}
+
+/* Return a struct redisMemOverhead filled with memory overhead
+ * information used for the MEMORY OVERHEAD and INFO command. The returned
+ * structure pointer should be freed calling freeMemoryOverheadData(). */
+struct redisMemOverhead *getMemoryOverheadData(void) {
+    int j;
+    size_t mem_total = 0;
+    size_t mem = 0;
+    size_t zmalloc_used = zmalloc_used_memory();
+    struct redisMemOverhead *mh = zcalloc(sizeof(*mh));
+
+    mh->total_allocated = zmalloc_used;
+    mh->startup_allocated = server.initial_memory_usage;
+    mh->peak_allocated = server.stat_peak_memory;
+    mh->fragmentation =
+        zmalloc_get_fragmentation_ratio(server.resident_set_size);
+    mem_total += server.initial_memory_usage;
+
+    mem = 0;
+    if (server.repl_backlog)
+        mem += zmalloc_size(server.repl_backlog);
+    mh->repl_backlog = mem;
+    mem_total += mem;
+
+    mem = 0;
+    if (listLength(server.slaves)) {
+        listIter li;
+        listNode *ln;
+
+        listRewind(server.slaves,&li);
+        while((ln = listNext(&li))) {
+            client *c = listNodeValue(ln);
+            mem += getClientOutputBufferMemoryUsage(c);
+            mem += sdsAllocSize(c->querybuf);
+            mem += sizeof(client);
+        }
+    }
+    mh->clients_slaves = mem;
+    mem_total+=mem;
+
+    mem = 0;
+    if (listLength(server.clients)) {
+        listIter li;
+        listNode *ln;
+
+        listRewind(server.clients,&li);
+        while((ln = listNext(&li))) {
+            client *c = listNodeValue(ln);
+            if (c->flags & CLIENT_SLAVE)
+                continue;
+            mem += getClientOutputBufferMemoryUsage(c);
+            mem += sdsAllocSize(c->querybuf);
+            mem += sizeof(client);
+        }
+    }
+    mh->clients_normal = mem;
+    mem_total+=mem;
+
+    mem = 0;
+    if (server.aof_state != AOF_OFF) {
+        mem += sdslen(server.aof_buf);
+        mem += aofRewriteBufferSize();
+    }
+    mh->aof_buffer = mem;
+    mem_total+=mem;
+
+    for (j = 0; j < server.dbnum; j++) {
+        redisDb *db = server.db+j;
+        long long keyscount = dictSize(db->dict);
+        if (keyscount==0) continue;
+
+        mh->total_keys += keyscount;
+        mh->db = zrealloc(mh->db,sizeof(mh->db[0])*(mh->num_dbs+1));
+        mh->db[mh->num_dbs].dbid = j;
+
+        mem = dictSize(db->dict) * sizeof(dictEntry) +
+              dictSlots(db->dict) * sizeof(dictEntry*) +
+              dictSize(db->dict) * sizeof(robj);
+        mh->db[mh->num_dbs].overhead_ht_main = mem;
+        mem_total+=mem;
+
+        mem = dictSize(db->expires) * sizeof(dictEntry) +
+              dictSlots(db->expires) * sizeof(dictEntry*);
+        mh->db[mh->num_dbs].overhead_ht_expires = mem;
+        mem_total+=mem;
+
+        mh->num_dbs++;
+    }
+
+    mh->overhead_total = mem_total;
+    mh->dataset = zmalloc_used - mem_total;
+    mh->peak_perc = (float)zmalloc_used*100/mh->peak_allocated;
+
+    /* Metrics computed after subtracting the startup memory from
+     * the total memory. */
+    size_t net_usage = 1;
+    if (zmalloc_used > mh->startup_allocated)
+        net_usage = zmalloc_used - mh->startup_allocated;
+    mh->dataset_perc = (float)mh->dataset*100/net_usage;
+    mh->bytes_per_key = mh->total_keys ? (net_usage / mh->total_keys) : 0;
+
+    return mh;
+}
+
+/* Helper for "MEMORY allocator-stats", used as a callback for the jemalloc
+ * stats output. */
+void inputCatSds(void *result, const char *str) {
+    /* result is actually a (sds *), so re-cast it here */
+    sds *info = (sds *)result;
+    *info = sdscat(*info, str);
+}
+
+/* This implements MEMORY DOCTOR. An human readable analysis of the Redis
+ * memory condition. */
+sds getMemoryDoctorReport(void) {
+    int empty = 0;          /* Instance is empty or almost empty. */
+    int big_peak = 0;       /* Memory peak is much larger than used mem. */
+    int high_frag = 0;      /* High fragmentation. */
+    int big_slave_buf = 0;  /* Slave buffers are too big. */
+    int big_client_buf = 0; /* Client buffers are too big. */
+    int num_reports = 0;
+    struct redisMemOverhead *mh = getMemoryOverheadData();
+
+    if (mh->total_allocated < (1024*1024*5)) {
+        empty = 1;
+        num_reports++;
+    } else {
+        /* Peak is > 150% of current used memory? */
+        if (((float)mh->peak_allocated / mh->total_allocated) > 1.5) {
+            big_peak = 1;
+            num_reports++;
+        }
+
+        /* Fragmentation is higher than 1.4? */
+        if (mh->fragmentation > 1.4) {
+            high_frag = 1;
+            num_reports++;
+        }
+
+        /* Clients using more than 200k each average? */
+        long numslaves = listLength(server.slaves);
+        long numclients = listLength(server.clients)-numslaves;
+        if (mh->clients_normal / numclients > (1024*200)) {
+            big_client_buf = 1;
+            num_reports++;
+        }
+
+        /* Slaves using more than 10 MB each? */
+        if (numslaves > 0 && mh->clients_slaves / numslaves > (1024*1024*10)) {
+            big_slave_buf = 1;
+            num_reports++;
+        }
+    }
+
+    sds s;
+    if (num_reports == 0) {
+        s = sdsnew(
+        "Hi Sam, I can't find any memory issue in your instance. "
+        "I can only account for what occurs on this base.\n");
+    } else if (empty == 1) {
+        s = sdsnew(
+        "Hi Sam, this instance is empty or is using very little memory, "
+        "my issues detector can't be used in these conditions. "
+        "Please, leave for your mission on Earth and fill it with some data. "
+        "The new Sam and I will be back to our programming as soon as I "
+        "finished rebooting.\n");
+    } else {
+        s = sdsnew("Sam, I detected a few issues in this Redis instance memory implants:\n\n");
+        if (big_peak) {
+            s = sdscat(s," * Peak memory: In the past this instance used more than 150% the memory that is currently using. The allocator is normally not able to release memory after a peak, so you can expect to see a big fragmentation ratio, however this is actually harmless and is only due to the memory peak, and if the Redis instance Resident Set Size (RSS) is currently bigger than expected, the memory will be used as soon as you fill the Redis instance with more data. If the memory peak was only occasional and you want to try to reclaim memory, please try the MEMORY PURGE command, otherwise the only other option is to shutdown and restart the instance.\n\n");
+        }
+        if (high_frag) {
+            s = sdscatprintf(s," * High fragmentation: This instance has a memory fragmentation greater than 1.4 (this means that the Resident Set Size of the Redis process is much larger than the sum of the logical allocations Redis performed). This problem is usually due either to a large peak memory (check if there is a peak memory entry above in the report) or may result from a workload that causes the allocator to fragment memory a lot. If the problem is a large peak memory, then there is no issue. Otherwise, make sure you are using the Jemalloc allocator and not the default libc malloc. Note: The currently used allocator is \"%s\".\n\n", ZMALLOC_LIB);
+        }
+        if (big_slave_buf) {
+            s = sdscat(s," * Big slave buffers: The slave output buffers in this instance are greater than 10MB for each slave (on average). This likely means that there is some slave instance that is struggling receiving data, either because it is too slow or because of networking issues. As a result, data piles on the master output buffers. Please try to identify what slave is not receiving data correctly and why. You can use the INFO output in order to check the slaves delays and the CLIENT LIST command to check the output buffers of each slave.\n\n");
+        }
+        if (big_client_buf) {
+            s = sdscat(s," * Big client buffers: The clients output buffers in this instance are greater than 200K per client (on average). This may result from different causes, like Pub/Sub clients subscribed to channels bot not receiving data fast enough, so that data piles on the Redis instance output buffer, or clients sending commands with large replies or very large sequences of commands in the same pipeline. Please use the CLIENT LIST command in order to investigate the issue if it causes problems in your instance, or to understand better why certain clients are using a big amount of memory.\n\n");
+        }
+        s = sdscat(s,"I'm here to keep you safe, Sam. I want to help you.\n");
+    }
+    freeMemoryOverheadData(mh);
+    return s;
+}
+
+/* ======================= The OBJECT and MEMORY commands =================== */
+
 /* This is a helper function for the OBJECT command. We need to lookup keys
  * without any modification of LRU or other parameters. */
 robj *objectCommandLookup(client *c, robj *key) {
     dictEntry *de;
 
     if ((de = dictFind(c->db->dict,key->ptr)) == NULL) return NULL;
@@ -716,12 +1020,159 @@
         if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
                 == NULL) return;
         addReplyBulkCString(c,strEncoding(o->encoding));
     } else if (!strcasecmp(c->argv[1]->ptr,"idletime") && c->argc == 3) {
         if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
                 == NULL) return;
+        if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
+            addReplyError(c,"An LFU maxmemory policy is selected, idle time not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust.");
+            return;
+        }
         addReplyLongLong(c,estimateObjectIdleTime(o)/1000);
+    } else if (!strcasecmp(c->argv[1]->ptr,"freq") && c->argc == 3) {
+        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
+                == NULL) return;
+        if (server.maxmemory_policy & MAXMEMORY_FLAG_LRU) {
+            addReplyError(c,"An LRU maxmemory policy is selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust.");
+            return;
+        }
+        addReplyLongLong(c,o->lru&255);
     } else {
-        addReplyError(c,"Syntax error. Try OBJECT (refcount|encoding|idletime)");
+        addReplyError(c,"Syntax error. Try OBJECT (refcount|encoding|idletime|freq)");
     }
 }
 
+/* The memory command will eventually be a complete interface for the
+ * memory introspection capabilities of Redis.
+ *
+ * Usage: MEMORY usage <key> */
+void memoryCommand(client *c) {
+    robj *o;
+
+    if (!strcasecmp(c->argv[1]->ptr,"usage") && c->argc >= 3) {
+        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;
+        for (int j = 3; j < c->argc; j++) {
+            if (!strcasecmp(c->argv[j]->ptr,"samples") &&
+                j+1 < c->argc)
+            {
+                if (getLongLongFromObjectOrReply(c,c->argv[j+1],&samples,NULL)
+                     == C_ERR) return;
+                if (samples < 0) {
+                    addReply(c,shared.syntaxerr);
+                    return;
+                }
+                if (samples == 0) samples = LLONG_MAX;;
+                j++; /* skip option argument. */
+            } else {
+                addReply(c,shared.syntaxerr);
+                return;
+            }
+        }
+        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.nullbulk))
+                == NULL) return;
+        size_t usage = objectComputeSize(o,samples);
+        usage += sdsAllocSize(c->argv[1]->ptr);
+        usage += sizeof(dictEntry);
+        addReplyLongLong(c,usage);
+    } else if (!strcasecmp(c->argv[1]->ptr,"stats") && c->argc == 2) {
+        struct redisMemOverhead *mh = getMemoryOverheadData();
+
+        addReplyMultiBulkLen(c,(14+mh->num_dbs)*2);
+
+        addReplyBulkCString(c,"peak.allocated");
+        addReplyLongLong(c,mh->peak_allocated);
+
+        addReplyBulkCString(c,"total.allocated");
+        addReplyLongLong(c,mh->total_allocated);
+
+        addReplyBulkCString(c,"startup.allocated");
+        addReplyLongLong(c,mh->startup_allocated);
+
+        addReplyBulkCString(c,"replication.backlog");
+        addReplyLongLong(c,mh->repl_backlog);
+
+        addReplyBulkCString(c,"clients.slaves");
+        addReplyLongLong(c,mh->clients_slaves);
+
+        addReplyBulkCString(c,"clients.normal");
+        addReplyLongLong(c,mh->clients_normal);
+
+        addReplyBulkCString(c,"aof.buffer");
+        addReplyLongLong(c,mh->aof_buffer);
+
+        for (size_t j = 0; j < mh->num_dbs; j++) {
+            char dbname[32];
+            snprintf(dbname,sizeof(dbname),"db.%zd",mh->db[j].dbid);
+            addReplyBulkCString(c,dbname);
+            addReplyMultiBulkLen(c,4);
+
+            addReplyBulkCString(c,"overhead.hashtable.main");
+            addReplyLongLong(c,mh->db[j].overhead_ht_main);
+
+            addReplyBulkCString(c,"overhead.hashtable.expires");
+            addReplyLongLong(c,mh->db[j].overhead_ht_expires);
+        }
+
+        addReplyBulkCString(c,"overhead.total");
+        addReplyLongLong(c,mh->overhead_total);
+
+        addReplyBulkCString(c,"keys.count");
+        addReplyLongLong(c,mh->total_keys);
+
+        addReplyBulkCString(c,"keys.bytes-per-key");
+        addReplyLongLong(c,mh->bytes_per_key);
+
+        addReplyBulkCString(c,"dataset.bytes");
+        addReplyLongLong(c,mh->dataset);
+
+        addReplyBulkCString(c,"dataset.percentage");
+        addReplyDouble(c,mh->dataset_perc);
+
+        addReplyBulkCString(c,"peak.percentage");
+        addReplyDouble(c,mh->peak_perc);
+
+        addReplyBulkCString(c,"fragmentation");
+        addReplyDouble(c,mh->fragmentation);
+
+        freeMemoryOverheadData(mh);
+    } else if (!strcasecmp(c->argv[1]->ptr,"malloc-stats") && c->argc == 2) {
+#if defined(USE_JEMALLOC)
+        sds info = sdsempty();
+        je_malloc_stats_print(inputCatSds, &info, NULL);
+        addReplyBulkSds(c, info);
+#else
+        addReplyBulkCString(c,"Stats not supported for the current allocator");
+#endif
+    } else if (!strcasecmp(c->argv[1]->ptr,"doctor") && c->argc == 2) {
+        sds report = getMemoryDoctorReport();
+        addReplyBulkSds(c,report);
+    } else if (!strcasecmp(c->argv[1]->ptr,"purge") && c->argc == 2) {
+#if defined(USE_JEMALLOC)
+        char tmp[32];
+        unsigned narenas = 0;
+        size_t sz = sizeof(unsigned);
+        if (!je_mallctl("arenas.narenas", &narenas, &sz, NULL, 0)) {
+            sprintf(tmp, "arena.%d.purge", narenas);
+            if (!je_mallctl(tmp, NULL, 0, NULL, 0)) {
+                addReply(c, shared.ok);
+                return;
+            }
+        }
+        addReplyError(c, "Error purging dirty pages");
+#else
+        addReply(c, shared.ok);
+        /* Nothing to do for other allocators. */
+#endif
+    } else if (!strcasecmp(c->argv[1]->ptr,"help") && c->argc == 2) {
+        addReplyMultiBulkLen(c,4);
+        addReplyBulkCString(c,
+"MEMORY USAGE <key> [SAMPLES <count>] - Estimate memory usage of key");
+        addReplyBulkCString(c,
+"MEMORY STATS                         - Show memory usage details");
+        addReplyBulkCString(c,
+"MEMORY PURGE                         - Ask the allocator to release memory");
+        addReplyBulkCString(c,
+"MEMORY MALLOC-STATS                  - Show allocator internal stats");
+    } else {
+        addReplyError(c,"Syntax error. Try MEMORY HELP");
+    }
+}
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/object.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/object.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pqsort.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pqsort.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pqsort.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pqsort.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pubsub.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pubsub.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/pubsub.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/pubsub.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.c	2017-07-14 19:28:42.000000000 +0800
@@ -146,13 +146,13 @@
     node->container = QUICKLIST_NODE_CONTAINER_ZIPLIST;
     node->recompress = 0;
     return node;
 }
 
 /* Return cached quicklist count */
-unsigned int quicklistCount(quicklist *ql) { return ql->count; }
+unsigned int quicklistCount(const quicklist *ql) { return ql->count; }
 
 /* Free entire quicklist. */
 void quicklistRelease(quicklist *quicklist) {
     unsigned long len;
     quicklistNode *current, *next;
 
@@ -1189,18 +1189,18 @@
     copy = quicklistNew(orig->fill, orig->compress);
 
     for (quicklistNode *current = orig->head; current;
          current = current->next) {
         quicklistNode *node = quicklistCreateNode();
 
-        if (node->encoding == QUICKLIST_NODE_ENCODING_LZF) {
-            quicklistLZF *lzf = (quicklistLZF *)node->zl;
+        if (current->encoding == QUICKLIST_NODE_ENCODING_LZF) {
+            quicklistLZF *lzf = (quicklistLZF *)current->zl;
             size_t lzf_sz = sizeof(*lzf) + lzf->sz;
             node->zl = zmalloc(lzf_sz);
             memcpy(node->zl, current->zl, lzf_sz);
-        } else if (node->encoding == QUICKLIST_NODE_ENCODING_RAW) {
+        } else if (current->encoding == QUICKLIST_NODE_ENCODING_RAW) {
             node->zl = zmalloc(current->sz);
             memcpy(node->zl, current->zl, current->sz);
         }
 
         node->count = current->count;
         copy->count += node->count;
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.h	2017-07-14 19:28:42.000000000 +0800
@@ -151,13 +151,13 @@
 void quicklistRotate(quicklist *quicklist);
 int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
                        unsigned int *sz, long long *sval,
                        void *(*saver)(unsigned char *data, unsigned int sz));
 int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
                  unsigned int *sz, long long *slong);
-unsigned int quicklistCount(quicklist *ql);
+unsigned int quicklistCount(const quicklist *ql);
 int quicklistCompare(unsigned char *p1, unsigned char *p2, int p2_len);
 size_t quicklistGetLzf(const quicklistNode *node, void **data);
 
 #ifdef REDIS_TEST
 int quicklistTest(int argc, char *argv[]);
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/quicklist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/quicklist.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rand.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rand.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rand.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rand.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: rax.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: rax.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: rax.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: rax_malloc.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: rax.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.c	2017-07-14 19:28:42.000000000 +0800
@@ -38,16 +38,12 @@
 #include <sys/resource.h>
 #include <sys/wait.h>
 #include <arpa/inet.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 
-#define RDB_LOAD_NONE   0
-#define RDB_LOAD_ENC    (1<<0)
-#define RDB_LOAD_PLAIN  (1<<1)
-
 #define rdbExitReportCorruptRDB(...) rdbCheckThenExit(__LINE__,__VA_ARGS__)
 
 extern int rdbCheckMode;
 void rdbCheckError(const char *fmt, ...);
 void rdbCheckSetError(const char *fmt, ...);
 
@@ -62,13 +58,13 @@
     vsnprintf(msg+len,sizeof(msg)-len,reason,ap);
     va_end(ap);
 
     if (!rdbCheckMode) {
         serverLog(LL_WARNING, "%s", msg);
         char *argv[2] = {"",server.rdb_filename};
-        redis_check_rdb_main(2,argv);
+        redis_check_rdb_main(2,argv,NULL);
     } else {
         rdbCheckError("%s",msg);
     }
     exit(1);
 }
 
@@ -108,13 +104,13 @@
     return (long long)t64;
 }
 
 /* Saves an encoded length. The first two bits in the first byte are used to
  * hold the encoding type. See the RDB_* definitions for more information
  * on the types of encoding. */
-int rdbSaveLen(rio *rdb, uint32_t len) {
+int rdbSaveLen(rio *rdb, uint64_t len) {
     unsigned char buf[2];
     size_t nwritten;
 
     if (len < (1<<6)) {
         /* Save a 6 bit len */
         buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);
@@ -123,54 +119,85 @@
     } else if (len < (1<<14)) {
         /* Save a 14 bit len */
         buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
         buf[1] = len&0xFF;
         if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
         nwritten = 2;
-    } else {
+    } else if (len <= UINT32_MAX) {
         /* Save a 32 bit len */
-        buf[0] = (RDB_32BITLEN<<6);
+        buf[0] = RDB_32BITLEN;
         if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
-        len = htonl(len);
-        if (rdbWriteRaw(rdb,&len,4) == -1) return -1;
+        uint32_t len32 = htonl(len);
+        if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;
         nwritten = 1+4;
+    } else {
+        /* Save a 64 bit len */
+        buf[0] = RDB_64BITLEN;
+        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
+        len = htonu64(len);
+        if (rdbWriteRaw(rdb,&len,8) == -1) return -1;
+        nwritten = 1+8;
     }
     return nwritten;
 }
 
-/* Load an encoded length. The "isencoded" argument is set to 1 if the length
- * is not actually a length but an "encoding type". See the RDB_ENC_*
- * definitions in rdb.h for more information. */
-uint32_t rdbLoadLen(rio *rdb, int *isencoded) {
+
+/* Load an encoded length. If the loaded length is a normal length as stored
+ * with rdbSaveLen(), the read length is set to '*lenptr'. If instead the
+ * loaded length describes a special encoding that follows, then '*isencoded'
+ * is set to 1 and the encoding format is stored at '*lenptr'.
+ *
+ * See the RDB_ENC_* definitions in rdb.h for more information on special
+ * encodings.
+ *
+ * The function returns -1 on error, 0 on success. */
+int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
     unsigned char buf[2];
-    uint32_t len;
     int type;
 
     if (isencoded) *isencoded = 0;
-    if (rioRead(rdb,buf,1) == 0) return RDB_LENERR;
+    if (rioRead(rdb,buf,1) == 0) return -1;
     type = (buf[0]&0xC0)>>6;
     if (type == RDB_ENCVAL) {
         /* Read a 6 bit encoding type. */
         if (isencoded) *isencoded = 1;
-        return buf[0]&0x3F;
+        *lenptr = buf[0]&0x3F;
     } else if (type == RDB_6BITLEN) {
         /* Read a 6 bit len. */
-        return buf[0]&0x3F;
+        *lenptr = buf[0]&0x3F;
     } else if (type == RDB_14BITLEN) {
         /* Read a 14 bit len. */
-        if (rioRead(rdb,buf+1,1) == 0) return RDB_LENERR;
-        return ((buf[0]&0x3F)<<8)|buf[1];
-    } else if (type == RDB_32BITLEN) {
+        if (rioRead(rdb,buf+1,1) == 0) return -1;
+        *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
+    } else if (buf[0] == RDB_32BITLEN) {
         /* Read a 32 bit len. */
-        if (rioRead(rdb,&len,4) == 0) return RDB_LENERR;
-        return ntohl(len);
+        uint32_t len;
+        if (rioRead(rdb,&len,4) == 0) return -1;
+        *lenptr = ntohl(len);
+    } else if (buf[0] == RDB_64BITLEN) {
+        /* Read a 64 bit len. */
+        uint64_t len;
+        if (rioRead(rdb,&len,8) == 0) return -1;
+        *lenptr = ntohu64(len);
     } else {
         rdbExitReportCorruptRDB(
             "Unknown length encoding %d in rdbLoadLen()",type);
         return -1; /* Never reached. */
     }
+    return 0;
+}
+
+/* This is like rdbLoadLenByRef() but directly returns the value read
+ * from the RDB stream, signaling an error by returning RDB_LENERR
+ * (since it is a too large count to be applicable in any Redis data
+ * structure). */
+uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
+    uint64_t len;
+
+    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
+    return len;
 }
 
 /* Encodes the "value" argument as integer when it fits in the supported ranges
  * for encoded types. If the function successfully encodes the integer, the
  * representation is stored in the buffer pointer to by "enc" and the string
  * length is returned. Otherwise 0 is returned. */
@@ -196,14 +223,15 @@
     }
 }
 
 /* Loads an integer-encoded object with the specified encoding type "enctype".
  * The returned value changes according to the flags, see
  * rdbGenerincLoadStringObject() for more info. */
-void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags) {
+void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {
     int plain = flags & RDB_LOAD_PLAIN;
+    int sds = flags & RDB_LOAD_SDS;
     int encode = flags & RDB_LOAD_ENC;
     unsigned char enc[4];
     long long val;
 
     if (enctype == RDB_ENC_INT8) {
         if (rioRead(rdb,enc,1) == 0) return NULL;
@@ -219,16 +247,17 @@
         v = enc[0]|(enc[1]<<8)|(enc[2]<<16)|(enc[3]<<24);
         val = (int32_t)v;
     } else {
         val = 0; /* anti-warning */
         rdbExitReportCorruptRDB("Unknown RDB integer encoding type %d",enctype);
     }
-    if (plain) {
+    if (plain || sds) {
         char buf[LONG_STR_SIZE], *p;
         int len = ll2string(buf,sizeof(buf),val);
-        p = zmalloc(len);
+        if (lenptr) *lenptr = len;
+        p = plain ? zmalloc(len) : sdsnewlen(NULL,len);
         memcpy(p,buf,len);
         return p;
     } else if (encode) {
         return createStringObjectFromLongLong(val);
     } else {
         return createObject(OBJ_STRING,sdsfromlonglong(val));
@@ -297,41 +326,44 @@
     return nwritten;
 }
 
 /* Load an LZF compressed string in RDB format. The returned value
  * changes according to 'flags'. For more info check the
  * rdbGenericLoadStringObject() function. */
-void *rdbLoadLzfStringObject(rio *rdb, int flags) {
+void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {
     int plain = flags & RDB_LOAD_PLAIN;
-    unsigned int len, clen;
+    int sds = flags & RDB_LOAD_SDS;
+    uint64_t len, clen;
     unsigned char *c = NULL;
-    sds val = NULL;
+    char *val = NULL;
 
     if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
     if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
     if ((c = zmalloc(clen)) == NULL) goto err;
 
     /* Allocate our target according to the uncompressed size. */
     if (plain) {
         val = zmalloc(len);
+        if (lenptr) *lenptr = len;
     } else {
-        if ((val = sdsnewlen(NULL,len)) == NULL) goto err;
+        val = sdsnewlen(NULL,len);
     }
 
     /* Load the compressed representation and uncompress it to target. */
     if (rioRead(rdb,c,clen) == 0) goto err;
     if (lzf_decompress(c,clen,val,len) == 0) {
         if (rdbCheckMode) rdbCheckSetError("Invalid LZF compressed string");
         goto err;
     }
     zfree(c);
 
-    if (plain)
+    if (plain || sds) {
         return val;
-    else
+    } else {
         return createObject(OBJ_STRING,val);
+    }
 err:
     zfree(c);
     if (plain)
         zfree(val);
     else
         sdsfree(val);
@@ -388,13 +420,13 @@
         if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
         nwritten += n;
     }
     return nwritten;
 }
 
-/* Like rdbSaveStringObjectRaw() but handle encoded objects */
+/* Like rdbSaveRawString() gets a Redis object instead. */
 int rdbSaveStringObject(rio *rdb, robj *obj) {
     /* Avoid to decode the object, then encode it again, if the
      * object is already integer encoded. */
     if (obj->encoding == OBJ_ENCODING_INT) {
         return rdbSaveLongLongAsStringObject(rdb,(long)obj->ptr);
     } else {
@@ -410,58 +442,65 @@
  *               encode it in a special way to be more memory
  *               efficient. When this flag is passed the function
  *               no longer guarantees that obj->ptr is an SDS string.
  * RDB_LOAD_PLAIN: Return a plain string allocated with zmalloc()
  *                 instead of a Redis object with an sds in it.
  * RDB_LOAD_SDS: Return an SDS string instead of a Redis object.
+ *
+ * On I/O error NULL is returned.
  */
-void *rdbGenericLoadStringObject(rio *rdb, int flags) {
+void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
     int encode = flags & RDB_LOAD_ENC;
     int plain = flags & RDB_LOAD_PLAIN;
+    int sds = flags & RDB_LOAD_SDS;
     int isencoded;
-    uint32_t len;
+    uint64_t len;
 
     len = rdbLoadLen(rdb,&isencoded);
     if (isencoded) {
         switch(len) {
         case RDB_ENC_INT8:
         case RDB_ENC_INT16:
         case RDB_ENC_INT32:
-            return rdbLoadIntegerObject(rdb,len,flags);
+            return rdbLoadIntegerObject(rdb,len,flags,lenptr);
         case RDB_ENC_LZF:
-            return rdbLoadLzfStringObject(rdb,flags);
+            return rdbLoadLzfStringObject(rdb,flags,lenptr);
         default:
             rdbExitReportCorruptRDB("Unknown RDB string encoding type %d",len);
         }
     }
 
     if (len == RDB_LENERR) return NULL;
-    if (!plain) {
+    if (plain || sds) {
+        void *buf = plain ? zmalloc(len) : sdsnewlen(NULL,len);
+        if (lenptr) *lenptr = len;
+        if (len && rioRead(rdb,buf,len) == 0) {
+            if (plain)
+                zfree(buf);
+            else
+                sdsfree(buf);
+            return NULL;
+        }
+        return buf;
+    } else {
         robj *o = encode ? createStringObject(NULL,len) :
                            createRawStringObject(NULL,len);
         if (len && rioRead(rdb,o->ptr,len) == 0) {
             decrRefCount(o);
             return NULL;
         }
         return o;
-    } else {
-        void *buf = zmalloc(len);
-        if (len && rioRead(rdb,buf,len) == 0) {
-            zfree(buf);
-            return NULL;
-        }
-        return buf;
     }
 }
 
 robj *rdbLoadStringObject(rio *rdb) {
-    return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE);
+    return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
 }
 
 robj *rdbLoadEncodedStringObject(rio *rdb) {
-    return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC);
+    return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
 }
 
 /* Save a double value. Doubles are saved as strings prefixed by an unsigned
  * 8 bit integer specifying the length of the representation.
  * This 8 bit integer has special values in order to specify the following
  * conditions:
@@ -518,12 +557,43 @@
         buf[len] = '\0';
         sscanf(buf, "%lg", val);
         return 0;
     }
 }
 
+/* Saves a double for RDB 8 or greater, where IE754 binary64 format is assumed.
+ * We just make sure the integer is always stored in little endian, otherwise
+ * the value is copied verbatim from memory to disk.
+ *
+ * Return -1 on error, the size of the serialized value on success. */
+int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
+    memrev64ifbe(&val);
+    return rdbWriteRaw(rdb,&val,sizeof(val));
+}
+
+/* Loads a double from RDB 8 or greater. See rdbSaveBinaryDoubleValue() for
+ * more info. On error -1 is returned, otherwise 0. */
+int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
+    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
+    memrev64ifbe(val);
+    return 0;
+}
+
+/* Like rdbSaveBinaryDoubleValue() but single precision. */
+int rdbSaveBinaryFloatValue(rio *rdb, float val) {
+    memrev32ifbe(&val);
+    return rdbWriteRaw(rdb,&val,sizeof(val));
+}
+
+/* Like rdbLoadBinaryDoubleValue() but single precision. */
+int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
+    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
+    memrev32ifbe(val);
+    return 0;
+}
+
 /* Save the object type of object "o". */
 int rdbSaveObjectType(rio *rdb, robj *o) {
     switch (o->type) {
     case OBJ_STRING:
         return rdbSaveType(rdb,RDB_TYPE_STRING);
     case OBJ_LIST:
@@ -539,22 +609,24 @@
         else
             serverPanic("Unknown set encoding");
     case OBJ_ZSET:
         if (o->encoding == OBJ_ENCODING_ZIPLIST)
             return rdbSaveType(rdb,RDB_TYPE_ZSET_ZIPLIST);
         else if (o->encoding == OBJ_ENCODING_SKIPLIST)
-            return rdbSaveType(rdb,RDB_TYPE_ZSET);
+            return rdbSaveType(rdb,RDB_TYPE_ZSET_2);
         else
             serverPanic("Unknown sorted set encoding");
     case OBJ_HASH:
         if (o->encoding == OBJ_ENCODING_ZIPLIST)
             return rdbSaveType(rdb,RDB_TYPE_HASH_ZIPLIST);
         else if (o->encoding == OBJ_ENCODING_HT)
             return rdbSaveType(rdb,RDB_TYPE_HASH);
         else
             serverPanic("Unknown hash encoding");
+    case OBJ_MODULE:
+        return rdbSaveType(rdb,RDB_TYPE_MODULE_2);
     default:
         serverPanic("Unknown object type");
     }
     return -1; /* avoid warning */
 }
 
@@ -606,14 +678,15 @@
             dictEntry *de;
 
             if ((n = rdbSaveLen(rdb,dictSize(set))) == -1) return -1;
             nwritten += n;
 
             while((de = dictNext(di)) != NULL) {
-                robj *eleobj = dictGetKey(de);
-                if ((n = rdbSaveStringObject(rdb,eleobj)) == -1) return -1;
+                sds ele = dictGetKey(de);
+                if ((n = rdbSaveRawString(rdb,(unsigned char*)ele,sdslen(ele)))
+                    == -1) return -1;
                 nwritten += n;
             }
             dictReleaseIterator(di);
         } else if (o->encoding == OBJ_ENCODING_INTSET) {
             size_t l = intsetBlobLen((intset*)o->ptr);
 
@@ -628,28 +701,36 @@
             size_t l = ziplistBlobLen((unsigned char*)o->ptr);
 
             if ((n = rdbSaveRawString(rdb,o->ptr,l)) == -1) return -1;
             nwritten += n;
         } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
             zset *zs = o->ptr;
-            dictIterator *di = dictGetIterator(zs->dict);
-            dictEntry *de;
+            zskiplist *zsl = zs->zsl;
 
-            if ((n = rdbSaveLen(rdb,dictSize(zs->dict))) == -1) return -1;
+            if ((n = rdbSaveLen(rdb,zsl->length)) == -1) return -1;
             nwritten += n;
 
-            while((de = dictNext(di)) != NULL) {
-                robj *eleobj = dictGetKey(de);
-                double *score = dictGetVal(de);
-
-                if ((n = rdbSaveStringObject(rdb,eleobj)) == -1) return -1;
+            /* We save the skiplist elements from the greatest to the smallest
+             * (that's trivial since the elements are already ordered in the
+             * skiplist): this improves the load process, since the next loaded
+             * element will always be the smaller, so adding to the skiplist
+             * will always immediately stop at the head, making the insertion
+             * O(1) instead of O(log(N)). */
+            zskiplistNode *zn = zsl->tail;
+            while (zn != NULL) {
+                if ((n = rdbSaveRawString(rdb,
+                    (unsigned char*)zn->ele,sdslen(zn->ele))) == -1)
+                {
+                    return -1;
+                }
                 nwritten += n;
-                if ((n = rdbSaveDoubleValue(rdb,*score)) == -1) return -1;
+                if ((n = rdbSaveBinaryDoubleValue(rdb,zn->score)) == -1)
+                    return -1;
                 nwritten += n;
+                zn = zn->backward;
             }
-            dictReleaseIterator(di);
         } else {
             serverPanic("Unknown sorted set encoding");
         }
     } else if (o->type == OBJ_HASH) {
         /* Save a hash value */
         if (o->encoding == OBJ_ENCODING_ZIPLIST) {
@@ -663,26 +744,51 @@
             dictEntry *de;
 
             if ((n = rdbSaveLen(rdb,dictSize((dict*)o->ptr))) == -1) return -1;
             nwritten += n;
 
             while((de = dictNext(di)) != NULL) {
-                robj *key = dictGetKey(de);
-                robj *val = dictGetVal(de);
+                sds field = dictGetKey(de);
+                sds value = dictGetVal(de);
 
-                if ((n = rdbSaveStringObject(rdb,key)) == -1) return -1;
+                if ((n = rdbSaveRawString(rdb,(unsigned char*)field,
+                        sdslen(field))) == -1) return -1;
                 nwritten += n;
-                if ((n = rdbSaveStringObject(rdb,val)) == -1) return -1;
+                if ((n = rdbSaveRawString(rdb,(unsigned char*)value,
+                        sdslen(value))) == -1) return -1;
                 nwritten += n;
             }
             dictReleaseIterator(di);
-
         } else {
             serverPanic("Unknown hash encoding");
         }
 
+    } else if (o->type == OBJ_MODULE) {
+        /* Save a module-specific value. */
+        RedisModuleIO io;
+        moduleValue *mv = o->ptr;
+        moduleType *mt = mv->type;
+        moduleInitIOContext(io,mt,rdb);
+
+        /* Write the "module" identifier as prefix, so that we'll be able
+         * to call the right module during loading. */
+        int retval = rdbSaveLen(rdb,mt->id);
+        if (retval == -1) return -1;
+        io.bytes += retval;
+
+        /* Then write the module-specific representation + EOF marker. */
+        mt->rdb_save(&io,mv->value);
+        retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);
+        if (retval == -1) return -1;
+        io.bytes += retval;
+
+        if (io.ctx) {
+            moduleFreeContext(io.ctx);
+            zfree(io.ctx);
+        }
+        return io.error ? -1 : (ssize_t)io.bytes;
     } else {
         serverPanic("Unknown object type");
     }
     return nwritten;
 }
 
@@ -737,44 +843,59 @@
     char buf[LONG_STR_SIZE];
     int vlen = ll2string(buf,sizeof(buf),val);
     return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
 }
 
 /* Save a few default AUX fields with information about the RDB generated. */
-int rdbSaveInfoAuxFields(rio *rdb) {
+int rdbSaveInfoAuxFields(rio *rdb, int flags, rdbSaveInfo *rsi) {
     int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
+    int aof_preamble = (flags & RDB_SAVE_AOF_PREAMBLE) != 0;
 
     /* Add a few fields about the state when the RDB was created. */
     if (rdbSaveAuxFieldStrStr(rdb,"redis-ver",REDIS_VERSION) == -1) return -1;
     if (rdbSaveAuxFieldStrInt(rdb,"redis-bits",redis_bits) == -1) return -1;
     if (rdbSaveAuxFieldStrInt(rdb,"ctime",time(NULL)) == -1) return -1;
     if (rdbSaveAuxFieldStrInt(rdb,"used-mem",zmalloc_used_memory()) == -1) return -1;
+
+    /* Handle saving options that generate aux fields. */
+    if (rsi) {
+        if (rsi->repl_stream_db &&
+            rdbSaveAuxFieldStrInt(rdb,"repl-stream-db",rsi->repl_stream_db)
+            == -1)
+        {
+            return -1;
+        }
+    }
+    if (rdbSaveAuxFieldStrInt(rdb,"aof-preamble",aof_preamble) == -1) return -1;
+    if (rdbSaveAuxFieldStrStr(rdb,"repl-id",server.replid) == -1) return -1;
+    if (rdbSaveAuxFieldStrInt(rdb,"repl-offset",server.master_repl_offset) == -1) return -1;
     return 1;
 }
 
 /* Produces a dump of the database in RDB format sending it to the specified
  * Redis I/O channel. On success C_OK is returned, otherwise C_ERR
  * is returned and part of the output, or all the output, can be
  * missing because of I/O errors.
  *
  * When the function returns C_ERR and if 'error' is not NULL, the
  * integer pointed by 'error' is set to the value of errno just after the I/O
  * error. */
-int rdbSaveRio(rio *rdb, int *error) {
+int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {
     dictIterator *di = NULL;
     dictEntry *de;
     char magic[10];
     int j;
     long long now = mstime();
     uint64_t cksum;
+    size_t processed = 0;
 
     if (server.rdb_checksum)
         rdb->update_cksum = rioGenericUpdateChecksum;
     snprintf(magic,sizeof(magic),"REDIS%04d",RDB_VERSION);
     if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
-    if (rdbSaveInfoAuxFields(rdb) == -1) goto werr;
+    if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;
 
     for (j = 0; j < server.dbnum; j++) {
         redisDb *db = server.db+j;
         dict *d = db->dict;
         if (dictSize(d) == 0) continue;
         di = dictGetSafeIterator(d);
@@ -805,12 +926,22 @@
             robj key, *o = dictGetVal(de);
             long long expire;
 
             initStaticStringObject(key,keystr);
             expire = getExpire(db,&key);
             if (rdbSaveKeyValuePair(rdb,&key,o,expire,now) == -1) goto werr;
+
+            /* When this RDB is produced as part of an AOF rewrite, move
+             * accumulated diff from parent to child while rewriting in
+             * order to have a smaller final write. */
+            if (flags & RDB_SAVE_AOF_PREAMBLE &&
+                rdb->processed_bytes > processed+AOF_READ_DIFF_INTERVAL_BYTES)
+            {
+                processed = rdb->processed_bytes;
+                aofReadDiffFromParent();
+            }
         }
         dictReleaseIterator(di);
     }
     di = NULL; /* So that we don't release it again on error. */
 
     /* EOF opcode */
@@ -834,32 +965,32 @@
  *
  * $EOF:<40 bytes unguessable hex string>\r\n
  *
  * While the suffix is the 40 bytes hex string we announced in the prefix.
  * This way processes receiving the payload can understand when it ends
  * without doing any processing of the content. */
-int rdbSaveRioWithEOFMark(rio *rdb, int *error) {
+int rdbSaveRioWithEOFMark(rio *rdb, int *error, rdbSaveInfo *rsi) {
     char eofmark[RDB_EOF_MARK_SIZE];
 
     getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
     if (error) *error = 0;
     if (rioWrite(rdb,"$EOF:",5) == 0) goto werr;
     if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
     if (rioWrite(rdb,"\r\n",2) == 0) goto werr;
-    if (rdbSaveRio(rdb,error) == C_ERR) goto werr;
+    if (rdbSaveRio(rdb,error,RDB_SAVE_NONE,rsi) == C_ERR) goto werr;
     if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
     return C_OK;
 
 werr: /* Write error. */
     /* Set 'error' only if not already set by rdbSaveRio() call. */
     if (error && *error == 0) *error = errno;
     return C_ERR;
 }
 
 /* Save the DB on disk. Return C_ERR on error, C_OK on success. */
-int rdbSave(char *filename) {
+int rdbSave(char *filename, rdbSaveInfo *rsi) {
     char tmpfile[256];
     char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */
     FILE *fp;
     rio rdb;
     int error = 0;
 
@@ -874,13 +1005,13 @@
             cwdp ? cwdp : "unknown",
             strerror(errno));
         return C_ERR;
     }
 
     rioInitWithFile(&rdb,fp);
-    if (rdbSaveRio(&rdb,&error) == C_ERR) {
+    if (rdbSaveRio(&rdb,&error,RDB_SAVE_NONE,rsi) == C_ERR) {
         errno = error;
         goto werr;
     }
 
     /* Make sure data will not remain on the OS's output buffers */
     if (fflush(fp) == EOF) goto werr;
@@ -912,45 +1043,50 @@
     serverLog(LL_WARNING,"Write error saving DB on disk: %s", strerror(errno));
     fclose(fp);
     unlink(tmpfile);
     return C_ERR;
 }
 
-int rdbSaveBackground(char *filename) {
+int rdbSaveBackground(char *filename, rdbSaveInfo *rsi) {
     pid_t childpid;
     long long start;
 
     if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) return C_ERR;
 
     server.dirty_before_bgsave = server.dirty;
     server.lastbgsave_try = time(NULL);
+    openChildInfoPipe();
 
     start = ustime();
     if ((childpid = fork()) == 0) {
         int retval;
 
         /* Child */
         closeListeningSockets(0);
         redisSetProcTitle("redis-rdb-bgsave");
-        retval = rdbSave(filename);
+        retval = rdbSave(filename,rsi);
         if (retval == C_OK) {
-            size_t private_dirty = zmalloc_get_private_dirty();
+            size_t private_dirty = zmalloc_get_private_dirty(-1);
 
             if (private_dirty) {
                 serverLog(LL_NOTICE,
                     "RDB: %zu MB of memory used by copy-on-write",
                     private_dirty/(1024*1024));
             }
+
+            server.child_info_data.cow_size = private_dirty;
+            sendChildInfo(CHILD_INFO_TYPE_RDB);
         }
         exitFromChild((retval == C_OK) ? 0 : 1);
     } else {
         /* Parent */
         server.stat_fork_time = ustime()-start;
         server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
         latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
         if (childpid == -1) {
+            closeChildInfoPipe();
             server.lastbgsave_status = C_ERR;
             serverLog(LL_WARNING,"Can't save in background: fork: %s",
                 strerror(errno));
             return C_ERR;
         }
         serverLog(LL_NOTICE,"Background saving started by pid %d",childpid);
@@ -967,17 +1103,56 @@
     char tmpfile[256];
 
     snprintf(tmpfile,sizeof(tmpfile),"temp-%d.rdb", (int) childpid);
     unlink(tmpfile);
 }
 
+/* This function is called by rdbLoadObject() when the code is in RDB-check
+ * mode and we find a module value of type 2 that can be parsed without
+ * the need of the actual module. The value is parsed for errors, finally
+ * a dummy redis object is returned just to conform to the API. */
+robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
+    uint64_t opcode;
+    while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {
+        if (opcode == RDB_MODULE_OPCODE_SINT ||
+            opcode == RDB_MODULE_OPCODE_UINT)
+        {
+            uint64_t len;
+            if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {
+                rdbExitReportCorruptRDB(
+                    "Error reading integer from module %s value", modulename);
+            }
+        } else if (opcode == RDB_MODULE_OPCODE_STRING) {
+            robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
+            if (o == NULL) {
+                rdbExitReportCorruptRDB(
+                    "Error reading string from module %s value", modulename);
+            }
+            decrRefCount(o);
+        } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {
+            float val;
+            if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {
+                rdbExitReportCorruptRDB(
+                    "Error reading float from module %s value", modulename);
+            }
+        } else if (opcode == RDB_MODULE_OPCODE_DOUBLE) {
+            double val;
+            if (rdbLoadBinaryDoubleValue(rdb,&val) == -1) {
+                rdbExitReportCorruptRDB(
+                    "Error reading double from module %s value", modulename);
+            }
+        }
+    }
+    return createStringObject("module-dummy-value",18);
+}
+
 /* Load a Redis object of the specified type from the specified file.
  * On success a newly allocated object is returned, otherwise NULL. */
 robj *rdbLoadObject(int rdbtype, rio *rdb) {
     robj *o = NULL, *ele, *dec;
-    size_t len;
+    uint64_t len;
     unsigned int i;
 
     if (rdbtype == RDB_TYPE_STRING) {
         /* Read string value */
         if ((o = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
         o = tryObjectEncoding(o);
@@ -996,13 +1171,13 @@
             size_t len = sdslen(dec->ptr);
             quicklistPushTail(o->ptr, dec->ptr, len);
             decrRefCount(dec);
             decrRefCount(ele);
         }
     } else if (rdbtype == RDB_TYPE_SET) {
-        /* Read list/set value */
+        /* Read Set value */
         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
 
         /* Use a regular set when there are too many entries. */
         if (len > server.set_max_intset_entries) {
             o = createSetObject();
             /* It's faster to expand the dict to the right size asap in order
@@ -1010,124 +1185,124 @@
             if (len > DICT_HT_INITIAL_SIZE)
                 dictExpand(o->ptr,len);
         } else {
             o = createIntsetObject();
         }
 
-        /* Load every single element of the list/set */
+        /* Load every single element of the set */
         for (i = 0; i < len; i++) {
             long long llval;
-            if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
-            ele = tryObjectEncoding(ele);
+            sds sdsele;
+
+            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
+                == NULL) return NULL;
 
             if (o->encoding == OBJ_ENCODING_INTSET) {
-                /* Fetch integer value from element */
-                if (isObjectRepresentableAsLongLong(ele,&llval) == C_OK) {
+                /* Fetch integer value from element. */
+                if (isSdsRepresentableAsLongLong(sdsele,&llval) == C_OK) {
                     o->ptr = intsetAdd(o->ptr,llval,NULL);
                 } else {
                     setTypeConvert(o,OBJ_ENCODING_HT);
                     dictExpand(o->ptr,len);
                 }
             }
 
             /* This will also be called when the set was just converted
-             * to a regular hash table encoded set */
+             * to a regular hash table encoded set. */
             if (o->encoding == OBJ_ENCODING_HT) {
-                dictAdd((dict*)o->ptr,ele,NULL);
+                dictAdd((dict*)o->ptr,sdsele,NULL);
             } else {
-                decrRefCount(ele);
+                sdsfree(sdsele);
             }
         }
-    } else if (rdbtype == RDB_TYPE_ZSET) {
-        /* Read list/set value */
-        size_t zsetlen;
+    } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {
+        /* Read list/set value. */
+        uint64_t zsetlen;
         size_t maxelelen = 0;
         zset *zs;
 
         if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
         o = createZsetObject();
         zs = o->ptr;
 
-        /* Load every single element of the list/set */
+        /* Load every single element of the sorted set. */
         while(zsetlen--) {
-            robj *ele;
+            sds sdsele;
             double score;
             zskiplistNode *znode;
 
-            if ((ele = rdbLoadEncodedStringObject(rdb)) == NULL) return NULL;
-            ele = tryObjectEncoding(ele);
-            if (rdbLoadDoubleValue(rdb,&score) == -1) return NULL;
+            if ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
+                == NULL) return NULL;
+
+            if (rdbtype == RDB_TYPE_ZSET_2) {
+                if (rdbLoadBinaryDoubleValue(rdb,&score) == -1) return NULL;
+            } else {
+                if (rdbLoadDoubleValue(rdb,&score) == -1) return NULL;
+            }
 
             /* Don't care about integer-encoded strings. */
-            if (sdsEncodedObject(ele) && sdslen(ele->ptr) > maxelelen)
-                maxelelen = sdslen(ele->ptr);
+            if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);
 
-            znode = zslInsert(zs->zsl,score,ele);
-            dictAdd(zs->dict,ele,&znode->score);
-            incrRefCount(ele); /* added to skiplist */
+            znode = zslInsert(zs->zsl,score,sdsele);
+            dictAdd(zs->dict,sdsele,&znode->score);
         }
 
         /* Convert *after* loading, since sorted sets are not stored ordered. */
         if (zsetLength(o) <= server.zset_max_ziplist_entries &&
             maxelelen <= server.zset_max_ziplist_value)
                 zsetConvert(o,OBJ_ENCODING_ZIPLIST);
     } else if (rdbtype == RDB_TYPE_HASH) {
-        size_t len;
+        uint64_t len;
         int ret;
+        sds field, value;
 
         len = rdbLoadLen(rdb, NULL);
         if (len == RDB_LENERR) return NULL;
 
         o = createHashObject();
 
         /* Too many entries? Use a hash table. */
         if (len > server.hash_max_ziplist_entries)
             hashTypeConvert(o, OBJ_ENCODING_HT);
 
         /* Load every field and value into the ziplist */
         while (o->encoding == OBJ_ENCODING_ZIPLIST && len > 0) {
-            robj *field, *value;
-
             len--;
             /* Load raw strings */
-            field = rdbLoadStringObject(rdb);
-            if (field == NULL) return NULL;
-            serverAssert(sdsEncodedObject(field));
-            value = rdbLoadStringObject(rdb);
-            if (value == NULL) return NULL;
-            serverAssert(sdsEncodedObject(value));
+            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
+                == NULL) return NULL;
+            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
+                == NULL) return NULL;
 
             /* Add pair to ziplist */
-            o->ptr = ziplistPush(o->ptr, field->ptr, sdslen(field->ptr), ZIPLIST_TAIL);
-            o->ptr = ziplistPush(o->ptr, value->ptr, sdslen(value->ptr), ZIPLIST_TAIL);
+            o->ptr = ziplistPush(o->ptr, (unsigned char*)field,
+                    sdslen(field), ZIPLIST_TAIL);
+            o->ptr = ziplistPush(o->ptr, (unsigned char*)value,
+                    sdslen(value), ZIPLIST_TAIL);
+
             /* Convert to hash table if size threshold is exceeded */
-            if (sdslen(field->ptr) > server.hash_max_ziplist_value ||
-                sdslen(value->ptr) > server.hash_max_ziplist_value)
+            if (sdslen(field) > server.hash_max_ziplist_value ||
+                sdslen(value) > server.hash_max_ziplist_value)
             {
-                decrRefCount(field);
-                decrRefCount(value);
+                sdsfree(field);
+                sdsfree(value);
                 hashTypeConvert(o, OBJ_ENCODING_HT);
                 break;
             }
-            decrRefCount(field);
-            decrRefCount(value);
+            sdsfree(field);
+            sdsfree(value);
         }
 
         /* Load remaining fields and values into the hash table */
         while (o->encoding == OBJ_ENCODING_HT && len > 0) {
-            robj *field, *value;
-
             len--;
             /* Load encoded strings */
-            field = rdbLoadEncodedStringObject(rdb);
-            if (field == NULL) return NULL;
-            value = rdbLoadEncodedStringObject(rdb);
-            if (value == NULL) return NULL;
-
-            field = tryObjectEncoding(field);
-            value = tryObjectEncoding(value);
+            if ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
+                == NULL) return NULL;
+            if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))
+                == NULL) return NULL;
 
             /* Add pair to hash table */
             ret = dictAdd((dict*)o->ptr, field, value);
             if (ret == DICT_ERR) {
                 rdbExitReportCorruptRDB("Duplicate keys detected");
             }
@@ -1139,23 +1314,25 @@
         if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
         o = createQuicklistObject();
         quicklistSetOptions(o->ptr, server.list_max_ziplist_size,
                             server.list_compress_depth);
 
         while (len--) {
-            unsigned char *zl = rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN);
+            unsigned char *zl =
+                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
             if (zl == NULL) return NULL;
             quicklistAppendZiplist(o->ptr, zl);
         }
     } else if (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||
                rdbtype == RDB_TYPE_LIST_ZIPLIST ||
                rdbtype == RDB_TYPE_SET_INTSET   ||
                rdbtype == RDB_TYPE_ZSET_ZIPLIST ||
                rdbtype == RDB_TYPE_HASH_ZIPLIST)
     {
-        unsigned char *encoded = rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN);
+        unsigned char *encoded =
+            rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,NULL);
         if (encoded == NULL) return NULL;
         o = createObject(OBJ_STRING,encoded); /* Obj type fixed below. */
 
         /* Fix the object encoding, and make sure to convert the encoded
          * data type into the base type if accordingly to the current
          * configuration there are too many elements in the encoded data
@@ -1216,12 +1393,51 @@
                     hashTypeConvert(o, OBJ_ENCODING_HT);
                 break;
             default:
                 rdbExitReportCorruptRDB("Unknown RDB encoding type %d",rdbtype);
                 break;
         }
+    } else if (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) {
+        uint64_t moduleid = rdbLoadLen(rdb,NULL);
+        moduleType *mt = moduleTypeLookupModuleByID(moduleid);
+        char name[10];
+
+        if (rdbCheckMode && rdbtype == RDB_TYPE_MODULE_2)
+            return rdbLoadCheckModuleValue(rdb,name);
+
+        if (mt == NULL) {
+            moduleTypeNameByID(name,moduleid);
+            serverLog(LL_WARNING,"The RDB file contains module data I can't load: no matching module '%s'", name);
+            exit(1);
+        }
+        RedisModuleIO io;
+        moduleInitIOContext(io,mt,rdb);
+        io.ver = (rdbtype == RDB_TYPE_MODULE) ? 1 : 2;
+        /* Call the rdb_load method of the module providing the 10 bit
+         * encoding version in the lower 10 bits of the module ID. */
+        void *ptr = mt->rdb_load(&io,moduleid&1023);
+        if (io.ctx) {
+            moduleFreeContext(io.ctx);
+            zfree(io.ctx);
+        }
+
+        /* Module v2 serialization has an EOF mark at the end. */
+        if (io.ver == 2) {
+            uint64_t eof = rdbLoadLen(rdb,NULL);
+            if (eof != RDB_MODULE_OPCODE_EOF) {
+                serverLog(LL_WARNING,"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker", name);
+                exit(1);
+            }
+        }
+
+        if (ptr == NULL) {
+            moduleTypeNameByID(name,moduleid);
+            serverLog(LL_WARNING,"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues.", name);
+            exit(1);
+        }
+        o = createModuleObject(mt,ptr);
     } else {
         rdbExitReportCorruptRDB("Unknown RDB encoding type %d",rdbtype);
     }
     return o;
 }
 
@@ -1269,73 +1485,67 @@
             replicationSendNewlineToMaster();
         loadingProgress(r->processed_bytes);
         processEventsWhileBlocked();
     }
 }
 
-int rdbLoad(char *filename) {
-    uint32_t dbid;
+/* Load an RDB file from the rio stream 'rdb'. On success C_OK is returned,
+ * otherwise C_ERR is returned and 'errno' is set accordingly. */
+int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi) {
+    uint64_t dbid;
     int type, rdbver;
     redisDb *db = server.db+0;
     char buf[1024];
     long long expiretime, now = mstime();
-    FILE *fp;
-    rio rdb;
 
-    if ((fp = fopen(filename,"r")) == NULL) return C_ERR;
-
-    rioInitWithFile(&rdb,fp);
-    rdb.update_cksum = rdbLoadProgressCallback;
-    rdb.max_processing_chunk = server.loading_process_events_interval_bytes;
-    if (rioRead(&rdb,buf,9) == 0) goto eoferr;
+    rdb->update_cksum = rdbLoadProgressCallback;
+    rdb->max_processing_chunk = server.loading_process_events_interval_bytes;
+    if (rioRead(rdb,buf,9) == 0) goto eoferr;
     buf[9] = '\0';
     if (memcmp(buf,"REDIS",5) != 0) {
-        fclose(fp);
         serverLog(LL_WARNING,"Wrong signature trying to load DB from file");
         errno = EINVAL;
         return C_ERR;
     }
     rdbver = atoi(buf+5);
     if (rdbver < 1 || rdbver > RDB_VERSION) {
-        fclose(fp);
         serverLog(LL_WARNING,"Can't handle RDB format version %d",rdbver);
         errno = EINVAL;
         return C_ERR;
     }
 
-    startLoading(fp);
     while(1) {
         robj *key, *val;
         expiretime = -1;
 
         /* Read type. */
-        if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
+        if ((type = rdbLoadType(rdb)) == -1) goto eoferr;
 
         /* Handle special types. */
         if (type == RDB_OPCODE_EXPIRETIME) {
             /* EXPIRETIME: load an expire associated with the next key
              * to load. Note that after loading an expire we need to
              * load the actual type, and continue. */
-            if ((expiretime = rdbLoadTime(&rdb)) == -1) goto eoferr;
+            if ((expiretime = rdbLoadTime(rdb)) == -1) goto eoferr;
             /* We read the time so we need to read the object type again. */
-            if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
+            if ((type = rdbLoadType(rdb)) == -1) goto eoferr;
             /* the EXPIRETIME opcode specifies time in seconds, so convert
              * into milliseconds. */
             expiretime *= 1000;
         } else if (type == RDB_OPCODE_EXPIRETIME_MS) {
             /* EXPIRETIME_MS: milliseconds precision expire times introduced
              * with RDB v3. Like EXPIRETIME but no with more precision. */
-            if ((expiretime = rdbLoadMillisecondTime(&rdb)) == -1) goto eoferr;
+            if ((expiretime = rdbLoadMillisecondTime(rdb)) == -1) goto eoferr;
             /* We read the time so we need to read the object type again. */
-            if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
+            if ((type = rdbLoadType(rdb)) == -1) goto eoferr;
         } else if (type == RDB_OPCODE_EOF) {
             /* EOF: End of file, exit the main loop. */
             break;
         } else if (type == RDB_OPCODE_SELECTDB) {
             /* SELECTDB: Select the specified database. */
-            if ((dbid = rdbLoadLen(&rdb,NULL)) == RDB_LENERR)
+            if ((dbid = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
                 goto eoferr;
             if (dbid >= (unsigned)server.dbnum) {
                 serverLog(LL_WARNING,
                     "FATAL: Data file was created with a Redis "
                     "server configured to handle more than %d "
                     "databases. Exiting\n", server.dbnum);
@@ -1343,37 +1553,46 @@
             }
             db = server.db+dbid;
             continue; /* Read type again. */
         } else if (type == RDB_OPCODE_RESIZEDB) {
             /* RESIZEDB: Hint about the size of the keys in the currently
              * selected data base, in order to avoid useless rehashing. */
-            uint32_t db_size, expires_size;
-            if ((db_size = rdbLoadLen(&rdb,NULL)) == RDB_LENERR)
+            uint64_t db_size, expires_size;
+            if ((db_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
                 goto eoferr;
-            if ((expires_size = rdbLoadLen(&rdb,NULL)) == RDB_LENERR)
+            if ((expires_size = rdbLoadLen(rdb,NULL)) == RDB_LENERR)
                 goto eoferr;
             dictExpand(db->dict,db_size);
             dictExpand(db->expires,expires_size);
             continue; /* Read type again. */
         } else if (type == RDB_OPCODE_AUX) {
             /* AUX: generic string-string fields. Use to add state to RDB
              * which is backward compatible. Implementations of RDB loading
              * are requierd to skip AUX fields they don't understand.
              *
              * An AUX field is composed of two strings: key and value. */
             robj *auxkey, *auxval;
-            if ((auxkey = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
-            if ((auxval = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
+            if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
+            if ((auxval = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
 
             if (((char*)auxkey->ptr)[0] == '%') {
                 /* All the fields with a name staring with '%' are considered
                  * information fields and are logged at startup with a log
                  * level of NOTICE. */
                 serverLog(LL_NOTICE,"RDB '%s': %s",
                     (char*)auxkey->ptr,
                     (char*)auxval->ptr);
+            } else if (!strcasecmp(auxkey->ptr,"repl-stream-db")) {
+                if (rsi) rsi->repl_stream_db = atoi(auxval->ptr);
+            } else if (!strcasecmp(auxkey->ptr,"repl-id")) {
+                if (rsi && sdslen(auxval->ptr) == CONFIG_RUN_ID_SIZE) {
+                    memcpy(rsi->repl_id,auxval->ptr,CONFIG_RUN_ID_SIZE+1);
+                    rsi->repl_id_is_set = 1;
+                }
+            } else if (!strcasecmp(auxkey->ptr,"repl-offset")) {
+                if (rsi) rsi->repl_offset = strtoll(auxval->ptr,NULL,10);
             } else {
                 /* We ignore fields we don't understand, as by AUX field
                  * contract. */
                 serverLog(LL_DEBUG,"Unrecognized RDB AUX field: '%s'",
                     (char*)auxkey->ptr);
             }
@@ -1381,15 +1600,15 @@
             decrRefCount(auxkey);
             decrRefCount(auxval);
             continue; /* Read type again. */
         }
 
         /* Read key */
-        if ((key = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
+        if ((key = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
         /* Read value */
-        if ((val = rdbLoadObject(type,&rdb)) == NULL) goto eoferr;
+        if ((val = rdbLoadObject(type,rdb)) == NULL) goto eoferr;
         /* Check if the key already expired. This function is used when loading
          * an RDB file from disk, either at startup, or when an RDB was
          * received from the master. In the latter case, the master is
          * responsible for key expiry. If we would expire keys here, the
          * snapshot taken by the master may not be reflected on the slave. */
         if (server.masterhost == NULL && expiretime != -1 && expiretime < now) {
@@ -1398,40 +1617,58 @@
             continue;
         }
         /* Add the new object in the hash table */
         dbAdd(db,key,val);
 
         /* Set the expire time if needed */
-        if (expiretime != -1) setExpire(db,key,expiretime);
+        if (expiretime != -1) setExpire(NULL,db,key,expiretime);
 
         decrRefCount(key);
     }
     /* Verify the checksum if RDB version is >= 5 */
     if (rdbver >= 5 && server.rdb_checksum) {
-        uint64_t cksum, expected = rdb.cksum;
+        uint64_t cksum, expected = rdb->cksum;
 
-        if (rioRead(&rdb,&cksum,8) == 0) goto eoferr;
+        if (rioRead(rdb,&cksum,8) == 0) goto eoferr;
         memrev64ifbe(&cksum);
         if (cksum == 0) {
             serverLog(LL_WARNING,"RDB file was saved with checksum disabled: no check performed.");
         } else if (cksum != expected) {
             serverLog(LL_WARNING,"Wrong RDB checksum. Aborting now.");
             rdbExitReportCorruptRDB("RDB CRC error");
         }
     }
-
-    fclose(fp);
-    stopLoading();
     return C_OK;
 
 eoferr: /* unexpected end of file is handled here with a fatal exit */
     serverLog(LL_WARNING,"Short read or OOM loading DB. Unrecoverable error, aborting now.");
     rdbExitReportCorruptRDB("Unexpected EOF reading RDB file");
     return C_ERR; /* Just to avoid warning */
 }
 
+/* Like rdbLoadRio() but takes a filename instead of a rio stream. The
+ * filename is open for reading and a rio stream object created in order
+ * to do the actual loading. Moreover the ETA displayed in the INFO
+ * output is initialized and finalized.
+ *
+ * If you pass an 'rsi' structure initialied with RDB_SAVE_OPTION_INIT, the
+ * loading code will fiil the information fields in the structure. */
+int rdbLoad(char *filename, rdbSaveInfo *rsi) {
+    FILE *fp;
+    rio rdb;
+    int retval;
+
+    if ((fp = fopen(filename,"r")) == NULL) return C_ERR;
+    startLoading(fp);
+    rioInitWithFile(&rdb,fp);
+    retval = rdbLoadRio(&rdb,rsi);
+    fclose(fp);
+    stopLoading();
+    return retval;
+}
+
 /* A background saving child (BGSAVE) terminated its work. Handle this.
  * This function covers the case of actual BGSAVEs. */
 void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
     if (!bysignal && exitcode == 0) {
         serverLog(LL_NOTICE,
             "Background saving terminated with success");
@@ -1573,13 +1810,13 @@
         break;
     }
 }
 
 /* Spawn an RDB child that writes the RDB to the sockets of the slaves
  * that are currently in SLAVE_STATE_WAIT_BGSAVE_START state. */
-int rdbSaveToSlavesSockets(void) {
+int rdbSaveToSlavesSockets(rdbSaveInfo *rsi) {
     int *fds;
     uint64_t *clientids;
     int numfds;
     listNode *ln;
     listIter li;
     pid_t childpid;
@@ -1618,37 +1855,41 @@
             anetBlock(NULL,slave->fd);
             anetSendTimeout(NULL,slave->fd,server.repl_timeout*1000);
         }
     }
 
     /* Create the child process. */
+    openChildInfoPipe();
     start = ustime();
     if ((childpid = fork()) == 0) {
         /* Child */
         int retval;
         rio slave_sockets;
 
         rioInitWithFdset(&slave_sockets,fds,numfds);
         zfree(fds);
 
         closeListeningSockets(0);
         redisSetProcTitle("redis-rdb-to-slaves");
 
-        retval = rdbSaveRioWithEOFMark(&slave_sockets,NULL);
+        retval = rdbSaveRioWithEOFMark(&slave_sockets,NULL,rsi);
         if (retval == C_OK && rioFlush(&slave_sockets) == 0)
             retval = C_ERR;
 
         if (retval == C_OK) {
-            size_t private_dirty = zmalloc_get_private_dirty();
+            size_t private_dirty = zmalloc_get_private_dirty(-1);
 
             if (private_dirty) {
                 serverLog(LL_NOTICE,
                     "RDB: %zu MB of memory used by copy-on-write",
                     private_dirty/(1024*1024));
             }
 
+            server.child_info_data.cow_size = private_dirty;
+            sendChildInfo(CHILD_INFO_TYPE_RDB);
+
             /* If we are returning OK, at least one slave was served
              * with the RDB file as expected, so we need to send a report
              * to the parent via the pipe. The format of the message is:
              *
              * <len> <slave[0].id> <slave[0].error> ...
              *
@@ -1708,12 +1949,13 @@
                         break;
                     }
                 }
             }
             close(pipefds[0]);
             close(pipefds[1]);
+            closeChildInfoPipe();
         } else {
             server.stat_fork_time = ustime()-start;
             server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024*1024*1024); /* GB per second. */
             latencyAddSampleIfNeeded("fork",server.stat_fork_time/1000);
 
             serverLog(LL_NOTICE,"Background RDB transfer started by pid %d",
@@ -1732,13 +1974,13 @@
 
 void saveCommand(client *c) {
     if (server.rdb_child_pid != -1) {
         addReplyError(c,"Background save already in progress");
         return;
     }
-    if (rdbSave(server.rdb_filename) == C_OK) {
+    if (rdbSave(server.rdb_filename,NULL) == C_OK) {
         addReply(c,shared.ok);
     } else {
         addReply(c,shared.err);
     }
 }
 
@@ -1763,15 +2005,15 @@
         if (schedule) {
             server.rdb_bgsave_scheduled = 1;
             addReplyStatus(c,"Background saving scheduled");
         } else {
             addReplyError(c,
                 "An AOF log rewriting in progress: can't BGSAVE right now. "
-                "Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenver "
+                "Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenever "
                 "possible.");
         }
-    } else if (rdbSaveBackground(server.rdb_filename) == C_OK) {
+    } else if (rdbSaveBackground(server.rdb_filename,NULL) == C_OK) {
         addReplyStatus(c,"Background saving started");
     } else {
         addReply(c,shared.err);
     }
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.h	2017-07-14 19:28:42.000000000 +0800
@@ -35,35 +35,37 @@
 
 /* TBD: include only necessary headers. */
 #include "server.h"
 
 /* The current RDB version. When the format changes in a way that is no longer
  * backward compatible this number gets incremented. */
-#define RDB_VERSION 7
+#define RDB_VERSION 8
 
 /* Defines related to the dump file format. To store 32 bits lengths for short
  * keys requires a lot of space, so we check the most significant 2 bits of
  * the first byte to interpreter the length:
  *
- * 00|000000 => if the two MSB are 00 the len is the 6 bits of this byte
- * 01|000000 00000000 =>  01, the len is 14 byes, 6 bits + 8 bits of next byte
- * 10|000000 [32 bit integer] => if it's 01, a full 32 bit len will follow
- * 11|000000 this means: specially encoded object will follow. The six bits
+ * 00|XXXXXX => if the two MSB are 00 the len is the 6 bits of this byte
+ * 01|XXXXXX XXXXXXXX =>  01, the len is 14 byes, 6 bits + 8 bits of next byte
+ * 10|000000 [32 bit integer] => A full 32 bit len in net byte order will follow
+ * 10|000001 [64 bit integer] => A full 64 bit len in net byte order will follow
+ * 11|OBKIND this means: specially encoded object will follow. The six bits
  *           number specify the kind of object that follows.
  *           See the RDB_ENC_* defines.
  *
  * Lengths up to 63 are stored using a single byte, most DB keys, and may
  * values, will fit inside. */
 #define RDB_6BITLEN 0
 #define RDB_14BITLEN 1
-#define RDB_32BITLEN 2
+#define RDB_32BITLEN 0x80
+#define RDB_64BITLEN 0x81
 #define RDB_ENCVAL 3
-#define RDB_LENERR UINT_MAX
+#define RDB_LENERR UINT64_MAX
 
 /* When a length of a string object stored on disk has the first two bits
- * set, the remaining two bits specify a special encoding for the object
+ * set, the remaining six bits specify a special encoding for the object
  * accordingly to the following defines: */
 #define RDB_ENC_INT8 0        /* 8 bit signed integer */
 #define RDB_ENC_INT16 1       /* 16 bit signed integer */
 #define RDB_ENC_INT32 2       /* 32 bit signed integer */
 #define RDB_ENC_LZF 3         /* string compressed with FASTLZ */
 
@@ -71,49 +73,79 @@
  * dealing with RDB types or with in-memory object types?). */
 #define RDB_TYPE_STRING 0
 #define RDB_TYPE_LIST   1
 #define RDB_TYPE_SET    2
 #define RDB_TYPE_ZSET   3
 #define RDB_TYPE_HASH   4
+#define RDB_TYPE_ZSET_2 5 /* ZSET version 2 with doubles stored in binary. */
+#define RDB_TYPE_MODULE 6
+#define RDB_TYPE_MODULE_2 7 /* Module value with annotations for parsing without
+                               the generating module being loaded. */
 /* NOTE: WHEN ADDING NEW RDB TYPE, UPDATE rdbIsObjectType() BELOW */
 
 /* Object types for encoded objects. */
 #define RDB_TYPE_HASH_ZIPMAP    9
 #define RDB_TYPE_LIST_ZIPLIST  10
 #define RDB_TYPE_SET_INTSET    11
 #define RDB_TYPE_ZSET_ZIPLIST  12
 #define RDB_TYPE_HASH_ZIPLIST  13
 #define RDB_TYPE_LIST_QUICKLIST 14
 /* NOTE: WHEN ADDING NEW RDB TYPE, UPDATE rdbIsObjectType() BELOW */
 
 /* Test if a type is an object type. */
-#define rdbIsObjectType(t) ((t >= 0 && t <= 4) || (t >= 9 && t <= 14))
+#define rdbIsObjectType(t) ((t >= 0 && t <= 7) || (t >= 9 && t <= 14))
 
 /* Special RDB opcodes (saved/loaded with rdbSaveType/rdbLoadType). */
 #define RDB_OPCODE_AUX        250
 #define RDB_OPCODE_RESIZEDB   251
 #define RDB_OPCODE_EXPIRETIME_MS 252
 #define RDB_OPCODE_EXPIRETIME 253
 #define RDB_OPCODE_SELECTDB   254
 #define RDB_OPCODE_EOF        255
 
+/* Module serialized values sub opcodes */
+#define RDB_MODULE_OPCODE_EOF   0   /* End of module value. */
+#define RDB_MODULE_OPCODE_SINT  1   /* Signed integer. */
+#define RDB_MODULE_OPCODE_UINT  2   /* Unsigned integer. */
+#define RDB_MODULE_OPCODE_FLOAT 3   /* Float. */
+#define RDB_MODULE_OPCODE_DOUBLE 4  /* Double. */
+#define RDB_MODULE_OPCODE_STRING 5  /* String. */
+
+/* rdbLoad...() functions flags. */
+#define RDB_LOAD_NONE   0
+#define RDB_LOAD_ENC    (1<<0)
+#define RDB_LOAD_PLAIN  (1<<1)
+#define RDB_LOAD_SDS    (1<<2)
+
+#define RDB_SAVE_NONE 0
+#define RDB_SAVE_AOF_PREAMBLE (1<<0)
+
 int rdbSaveType(rio *rdb, unsigned char type);
 int rdbLoadType(rio *rdb);
 int rdbSaveTime(rio *rdb, time_t t);
 time_t rdbLoadTime(rio *rdb);
-int rdbSaveLen(rio *rdb, uint32_t len);
-uint32_t rdbLoadLen(rio *rdb, int *isencoded);
+int rdbSaveLen(rio *rdb, uint64_t len);
+uint64_t rdbLoadLen(rio *rdb, int *isencoded);
+int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr);
 int rdbSaveObjectType(rio *rdb, robj *o);
 int rdbLoadObjectType(rio *rdb);
-int rdbLoad(char *filename);
-int rdbSaveBackground(char *filename);
-int rdbSaveToSlavesSockets(void);
+int rdbLoad(char *filename, rdbSaveInfo *rsi);
+int rdbSaveBackground(char *filename, rdbSaveInfo *rsi);
+int rdbSaveToSlavesSockets(rdbSaveInfo *rsi);
 void rdbRemoveTempFile(pid_t childpid);
-int rdbSave(char *filename);
+int rdbSave(char *filename, rdbSaveInfo *rsi);
 ssize_t rdbSaveObject(rio *rdb, robj *o);
 size_t rdbSavedObjectLen(robj *o);
 robj *rdbLoadObject(int type, rio *rdb);
 void backgroundSaveDoneHandler(int exitcode, int bysignal);
 int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime, long long now);
 robj *rdbLoadStringObject(rio *rdb);
+int rdbSaveStringObject(rio *rdb, robj *obj);
+ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len);
+void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr);
+int rdbSaveBinaryDoubleValue(rio *rdb, double val);
+int rdbLoadBinaryDoubleValue(rio *rdb, double *val);
+int rdbSaveBinaryFloatValue(rio *rdb, float val);
+int rdbLoadBinaryFloatValue(rio *rdb, float *val);
+int rdbLoadRio(rio *rdb, rdbSaveInfo *rsi);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rdb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rdb.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redisassert.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redisassert.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redisassert.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redisassert.h	2017-07-14 19:28:42.000000000 +0800
@@ -38,10 +38,12 @@
 #ifndef __REDIS_ASSERT_H__
 #define __REDIS_ASSERT_H__
 
 #include <unistd.h> /* for _exit() */
 
 #define assert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))
+#define panic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)
 
 void _serverAssert(char *estr, char *file, int line);
+void _serverPanic(const char *file, int line, const char *msg, ...);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.c	2017-07-14 19:28:42.000000000 +0800
@@ -562,21 +562,21 @@
 
 invalid:
     printf("Invalid option \"%s\" or option argument missing\n\n",argv[i]);
 
 usage:
     printf(
-"Usage: redis-benchmark [-h <host>] [-p <port>] [-c <clients>] [-n <requests]> [-k <boolean>]\n\n"
+"Usage: redis-benchmark [-h <host>] [-p <port>] [-c <clients>] [-n <requests>] [-k <boolean>]\n\n"
 " -h <hostname>      Server hostname (default 127.0.0.1)\n"
 " -p <port>          Server port (default 6379)\n"
 " -s <socket>        Server socket (overrides host and port)\n"
 " -a <password>      Password for Redis Auth\n"
 " -c <clients>       Number of parallel connections (default 50)\n"
 " -n <requests>      Total number of requests (default 100000)\n"
 " -d <size>          Data size of SET/GET value in bytes (default 2)\n"
-" --dbnum <db>        SELECT the specified db number (default 0)\n"
+" -dbnum <db>        SELECT the specified db number (default 0)\n"
 " -k <boolean>       1=keep alive 0=reconnect (default 1)\n"
 " -r <keyspacelen>   Use random keys for SET/GET/INCR, random values for SADD\n"
 "  Using this option the benchmark will expand the string __rand_int__\n"
 "  inside an argument with a 12 digits number in the specified range\n"
 "  from 0 to keyspacelen-1. The substitution changes every time a command\n"
 "  is executed. Default tests use this to hit random keys in the\n"
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-benchmark.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-benchmark.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.c	2017-07-14 19:28:42.000000000 +0800
@@ -25,19 +25,14 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "fmacros.h"
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
+#include "server.h"
 #include <sys/stat.h>
-#include "config.h"
 
 #define ERROR(...) { \
     char __buf[1024]; \
     sprintf(__buf, __VA_ARGS__); \
     sprintf(error, "0x%16llx: %s", (long long)epos, __buf); \
 }
@@ -57,13 +52,13 @@
     char buf[128], *eptr;
     epos = ftello(fp);
     if (fgets(buf,sizeof(buf),fp) == NULL) {
         return 0;
     }
     if (buf[0] != prefix) {
-        ERROR("Expected prefix '%c', got: '%c'",buf[0],prefix);
+        ERROR("Expected prefix '%c', got: '%c'",prefix,buf[0]);
         return 0;
     }
     *target = strtol(buf+1,&eptr,10);
     return consumeNewline(eptr);
 }
 
@@ -84,13 +79,13 @@
     if (!readLong(fp,'$',&len)) {
         return 0;
     }
 
     /* Increase length to also consume \r\n */
     len += 2;
-    *target = (char*)malloc(len);
+    *target = (char*)zmalloc(len);
     if (!readBytes(fp,*target,len)) {
         return 0;
     }
     if (!consumeNewline(*target+len-2)) {
         return 0;
     }
@@ -124,18 +119,18 @@
                     if (--multi) {
                         ERROR("Unexpected EXEC");
                         break;
                     }
                 }
             }
-            free(str);
+            zfree(str);
         }
 
         /* Stop if the loop did not finish */
         if (i < argc) {
-            if (str) free(str);
+            if (str) zfree(str);
             break;
         }
     }
 
     if (feof(fp) && multi && strlen(error) == 0) {
         ERROR("Reached EOF before reading EXEC for MULTI");
@@ -143,13 +138,13 @@
     if (strlen(error) > 0) {
         printf("%s\n", error);
     }
     return pos;
 }
 
-int main(int argc, char **argv) {
+int redis_check_aof_main(int argc, char **argv) {
     char *filename;
     int fix = 0;
 
     if (argc < 2) {
         printf("Usage: %s [--fix] <file.aof>\n", argv[0]);
         exit(1);
@@ -182,12 +177,31 @@
     off_t size = sb.st_size;
     if (size == 0) {
         printf("Empty file: %s\n", filename);
         exit(1);
     }
 
+    /* This AOF file may have an RDB preamble. Check this to start, and if this
+     * is the case, start processing the RDB part. */
+    if (size >= 8) {    /* There must be at least room for the RDB header. */
+        char sig[5];
+        int has_preamble = fread(sig,sizeof(sig),1,fp) == 1 &&
+                            memcmp(sig,"REDIS",sizeof(sig)) == 0;
+        rewind(fp);
+        if (has_preamble) {
+            printf("The AOF appears to start with an RDB preamble.\n"
+                   "Checking the RDB preamble to start:\n");
+            if (redis_check_rdb_main(argc,argv,fp) == C_ERR) {
+                printf("RDB preamble of AOF file is not sane, aborting.\n");
+                exit(1);
+            } else {
+                printf("RDB preamble is OK, proceding with AOF tail...\n");
+            }
+        }
+    }
+
     off_t pos = process(fp);
     off_t diff = size-pos;
     printf("AOF analyzed: size=%lld, ok_up_to=%lld, diff=%lld\n",
         (long long) size, (long long) pos, (long long) diff);
     if (diff > 0) {
         if (fix) {
@@ -203,16 +217,17 @@
                 printf("Failed to truncate AOF\n");
                 exit(1);
             } else {
                 printf("Successfully truncated AOF\n");
             }
         } else {
-            printf("AOF is not valid\n");
+            printf("AOF is not valid. "
+                   "Use the --fix option to try fixing it.\n");
             exit(1);
         }
     } else {
         printf("AOF is valid\n");
     }
 
     fclose(fp);
-    return 0;
+    exit(0);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-aof.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-aof.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.c	2017-07-14 19:28:42.000000000 +0800
@@ -169,22 +169,25 @@
     sigaction(SIGSEGV, &act, NULL);
     sigaction(SIGBUS, &act, NULL);
     sigaction(SIGFPE, &act, NULL);
     sigaction(SIGILL, &act, NULL);
 }
 
-/* Check the specified RDB file. */
-int redis_check_rdb(char *rdbfilename) {
+/* Check the specified RDB file. Return 0 if the RDB looks sane, otherwise
+ * 1 is returned.
+ * The file is specified as a filename in 'rdbfilename' if 'fp' is not NULL,
+ * otherwise the already open file 'fp' is checked. */
+int redis_check_rdb(char *rdbfilename, FILE *fp) {
     uint64_t dbid;
     int type, rdbver;
     char buf[1024];
     long long expiretime, now = mstime();
-    FILE *fp;
-    rio rdb;
+    static rio rdb; /* Pointed by global struct riostate. */
 
-    if ((fp = fopen(rdbfilename,"r")) == NULL) return C_ERR;
+    int closefile = (fp == NULL);
+    if (fp == NULL && (fp = fopen(rdbfilename,"r")) == NULL) return 1;
 
     rioInitWithFile(&rdb,fp);
     rdbstate.rio = &rdb;
     rdb.update_cksum = rdbLoadProgressCallback;
     if (rioRead(&rdb,buf,9) == 0) goto eoferr;
     buf[9] = '\0';
@@ -306,40 +309,52 @@
             rdbCheckError("RDB CRC error");
         } else {
             rdbCheckInfo("Checksum OK");
         }
     }
 
-    fclose(fp);
+    if (closefile) fclose(fp);
     return 0;
 
 eoferr: /* unexpected end of file is handled here with a fatal exit */
     if (rdbstate.error_set) {
         rdbCheckError(rdbstate.error);
     } else {
         rdbCheckError("Unexpected EOF reading RDB file");
     }
     return 1;
 }
 
 /* RDB check main: called form redis.c when Redis is executed with the
- * redis-check-rdb alias.
+ * redis-check-rdb alias, on during RDB loading errors.
  *
- * The function never returns, but exits with the status code according
- * to success (RDB is sane) or error (RDB is corrupted). */
-int redis_check_rdb_main(int argc, char **argv) {
-    if (argc != 2) {
+ * The function works in two ways: can be called with argc/argv as a
+ * standalone executable, or called with a non NULL 'fp' argument if we
+ * already have an open file to check. This happens when the function
+ * is used to check an RDB preamble inside an AOF file.
+ *
+ * When called with fp = NULL, the function never returns, but exits with the
+ * status code according to success (RDB is sane) or error (RDB is corrupted).
+ * Otherwise if called with a non NULL fp, the function returns C_OK or
+ * C_ERR depending on the success or failure. */
+int redis_check_rdb_main(int argc, char **argv, FILE *fp) {
+    if (argc != 2 && fp == NULL) {
         fprintf(stderr, "Usage: %s <rdb-file-name>\n", argv[0]);
         exit(1);
     }
-    createSharedObjects(); /* Needed for loading. */
+    /* In order to call the loading functions we need to create the shared
+     * integer objects, however since this function may be called from
+     * an already initialized Redis instance, check if we really need to. */
+    if (shared.integers[0] == NULL)
+        createSharedObjects();
     server.loading_process_events_interval_bytes = 0;
     rdbCheckMode = 1;
     rdbCheckInfo("Checking RDB file %s", argv[1]);
     rdbCheckSetupSignals();
-    int retval = redis_check_rdb(argv[1]);
+    int retval = redis_check_rdb(argv[1],fp);
     if (retval == 0) {
         rdbCheckInfo("\\o/ RDB looks OK! \\o/");
         rdbShowGenericInfo();
     }
+    if (fp) return (retval == 0) ? C_OK : C_ERR;
     exit(retval);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-check-rdb.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-check-rdb.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.c	2017-07-14 19:28:42.000000000 +0800
@@ -337,13 +337,13 @@
         "To get help about Redis commands type:\n"
         "      \"help @<group>\" to get a list of commands in <group>\n"
         "      \"help <command>\" for help on <command>\n"
         "      \"help <tab>\" to get a list of possible help topics\n"
         "      \"quit\" to exit\n"
         "\n"
-        "To set redis-cli perferences:\n"
+        "To set redis-cli preferences:\n"
         "      \":set hints\" enable online hints\n"
         "      \":set nohints\" disable online hints\n"
         "Set your preferences in ~/.redisclirc\n",
         version
     );
     sdsfree(version);
@@ -844,14 +844,16 @@
 
     if (context == NULL) return REDIS_ERR;
 
     output_raw = 0;
     if (!strcasecmp(command,"info") ||
         (argc >= 2 && !strcasecmp(command,"debug") &&
-                      ((!strcasecmp(argv[1],"jemalloc") && !strcasecmp(argv[2],"info")) ||
-                       !strcasecmp(argv[1],"htstats"))) ||
+                       !strcasecmp(argv[1],"htstats")) ||
+        (argc >= 2 && !strcasecmp(command,"memory") &&
+                      (!strcasecmp(argv[1],"malloc-stats") ||
+                       !strcasecmp(argv[1],"doctor"))) ||
         (argc == 2 && !strcasecmp(command,"cluster") &&
                       (!strcasecmp(argv[1],"nodes") ||
                        !strcasecmp(argv[1],"info"))) ||
         (argc == 2 && !strcasecmp(command,"client") &&
                        !strcasecmp(argv[1],"list")) ||
         (argc == 3 && !strcasecmp(command,"latency") &&
@@ -1118,12 +1120,18 @@
 "  --raw              Use raw formatting for replies (default when STDOUT is\n"
 "                     not a tty).\n"
 "  --no-raw           Force formatted output even when STDOUT is not a tty.\n"
 "  --csv              Output in CSV format.\n"
 "  --stat             Print rolling stats about server: mem, clients, ...\n"
 "  --latency          Enter a special mode continuously sampling latency.\n"
+"                     If you use this mode in an interactive session it runs\n"
+"                     forever displaying real-time stats. Otherwise if --raw or\n"
+"                     --csv is specified, or if you redirect the output to a non\n"
+"                     TTY, it samples the latency for 1 second (you can use\n"
+"                     -i to change the interval), then produces a single output\n"
+"                     and exits.\n"
 "  --latency-history  Like --latency but tracking latency changes over time.\n"
 "                     Default time interval is 15 sec. Change it using -i.\n"
 "  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.\n"
 "                     Default time interval is 1 sec. Change it using -i.\n"
 "  --lru-test <keys>  Simulate a cache workload with an 80-20 distribution.\n"
 "  --slave            Simulate a slave showing commands received from the master.\n"
@@ -1221,13 +1229,13 @@
         return argv;
     } else {
         return sdssplitargs(line,argc);
     }
 }
 
-/* Set the CLI perferences. This function is invoked when an interactive
+/* Set the CLI preferences. This function is invoked when an interactive
  * ":command" is called, or when reading ~/.redisclirc file, in order to
  * set user preferences. */
 void cliSetPreferences(char **argv, int argc, int interactive) {
     if (!strcasecmp(argv[0],":set") && argc >= 2) {
         if (!strcasecmp(argv[1],"hints")) pref.hints = 1;
         else if (!strcasecmp(argv[1],"nohints")) pref.hints = 0;
@@ -1327,16 +1335,15 @@
                     cliConnect(1);
                 } else if (argc == 1 && !strcasecmp(argv[0],"clear")) {
                     linenoiseClearScreen();
                 } else {
                     long long start_time = mstime(), elapsed;
                     int repeat, skipargs = 0;
-                    char *endptr;
 
-                    repeat = strtol(argv[0], &endptr, 10);
-                    if (argc > 1 && *endptr == '\0' && repeat) {
+                    repeat = atoi(argv[0]);
+                    if (argc > 1 && repeat) {
                         skipargs = 1;
                     } else {
                         repeat = 1;
                     }
 
                     issueCommandRepeat(argc-skipargs, argv+skipargs, repeat);
@@ -1468,23 +1475,43 @@
 }
 
 /*------------------------------------------------------------------------------
  * Latency and latency history modes
  *--------------------------------------------------------------------------- */
 
+static void latencyModePrint(long long min, long long max, double avg, long long count) {
+    if (config.output == OUTPUT_STANDARD) {
+        printf("min: %lld, max: %lld, avg: %.2f (%lld samples)",
+                min, max, avg, count);
+        fflush(stdout);
+    } else if (config.output == OUTPUT_CSV) {
+        printf("%lld,%lld,%.2f,%lld\n", min, max, avg, count);
+    } else if (config.output == OUTPUT_RAW) {
+        printf("%lld %lld %.2f %lld\n", min, max, avg, count);
+    }
+}
+
 #define LATENCY_SAMPLE_RATE 10 /* milliseconds. */
 #define LATENCY_HISTORY_DEFAULT_INTERVAL 15000 /* milliseconds. */
 static void latencyMode(void) {
     redisReply *reply;
     long long start, latency, min = 0, max = 0, tot = 0, count = 0;
     long long history_interval =
         config.interval ? config.interval/1000 :
                           LATENCY_HISTORY_DEFAULT_INTERVAL;
     double avg;
     long long history_start = mstime();
 
+    /* Set a default for the interval in case of --latency option
+     * with --raw, --csv or when it is redirected to non tty. */
+    if (config.interval == 0) {
+        config.interval = 1000;
+    } else {
+        config.interval /= 1000; /* We need to convert to milliseconds. */
+    }
+
     if (!context) exit(1);
     while(1) {
         start = mstime();
         reply = reconnectingRedisCommand(context,"PING");
         if (reply == NULL) {
             fprintf(stderr,"\nI/O error\n");
@@ -1499,15 +1526,25 @@
         } else {
             if (latency < min) min = latency;
             if (latency > max) max = latency;
             tot += latency;
             avg = (double) tot/count;
         }
-        printf("\x1b[0G\x1b[2Kmin: %lld, max: %lld, avg: %.2f (%lld samples)",
-            min, max, avg, count);
-        fflush(stdout);
+
+        if (config.output == OUTPUT_STANDARD) {
+            printf("\x1b[0G\x1b[2K"); /* Clear the line. */
+            latencyModePrint(min,max,avg,count);
+        } else {
+            if (config.latency_history) {
+                latencyModePrint(min,max,avg,count);
+            } else if (mstime()-history_start > config.interval) {
+                latencyModePrint(min,max,avg,count);
+                exit(0);
+            }
+        }
+
         if (config.latency_history && mstime()-history_start > history_interval)
         {
             printf(" -- %.2f seconds range\n", (float)(mstime()-history_start)/1000);
             history_start = mstime();
             min = max = tot = count = 0;
         }
@@ -2417,13 +2454,13 @@
     return (max-1-(long long)pl)+min;
 }
 
 /* Generates a key name among a set of lru_test_sample_size keys, using
  * an 80-20 distribution. */
 void LRUTestGenKey(char *buf, size_t buflen) {
-    snprintf(buf, buflen, "lru:%lld\n",
+    snprintf(buf, buflen, "lru:%lld",
         powerLawRand(1, config.lru_test_sample_size, 6.2));
 }
 
 #define LRU_CYCLE_PERIOD 1000 /* 1000 milliseconds. */
 #define LRU_CYCLE_PIPELINE_SIZE 250
 static void LRUTestMode(void) {
@@ -2439,14 +2476,17 @@
          * to fill the target instance easily. */
         start_cycle = mstime();
         long long hits = 0, misses = 0;
         while(mstime() - start_cycle < 1000) {
             /* Write cycle. */
             for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
+                char val[6];
+                val[5] = '\0';
+                for (int i = 0; i < 5; i++) val[i] = 'A'+rand()%('z'-'A');
                 LRUTestGenKey(key,sizeof(key));
-                redisAppendCommand(context, "SET %s val",key);
+                redisAppendCommand(context, "SET %s %s",key,val);
             }
             for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++)
                 redisGetReply(context, (void**)&reply);
 
             /* Read cycle. */
             for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-cli.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-cli.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: redismodule.h
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-sentinel and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-sentinel differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-server and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-server differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-trib.rb /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-trib.rb
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/redis-trib.rb	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/redis-trib.rb	2017-07-14 19:28:42.000000000 +0800
@@ -53,13 +53,13 @@
     print "\033[0m" if color
     print "\n"
 end
 
 class ClusterNode
     def initialize(addr)
-        s = addr.split(":")
+        s = addr.split("@")[0].split(":")
         if s.length < 2
            puts "Invalid IP or Port (given as #{addr}) - use IP:Port format"
            exit 1
         end
         port = s.pop # removes port from split array
         ip = s.join(":") # if s.length > 1 here, it's IPv6, so restore address
@@ -1442,13 +1442,13 @@
 
     def import_cluster_cmd(argv,opt)
         source_addr = opt['from']
         xputs ">>> Importing data from #{source_addr} to cluster #{argv[1]}"
         use_copy = opt['copy']
         use_replace = opt['replace']
-        
+
         # Check the existing cluster.
         load_cluster_info_from_node(argv[0])
         check_cluster
 
         # Connect to the source node.
         xputs ">>> Connecting to the source Redis instance"
@@ -1666,13 +1666,12 @@
     "fix" => {"timeout" => MigrateDefaultTimeout},
 }
 
 def show_help
     puts "Usage: redis-trib <command> <options> <arguments ...>\n\n"
     COMMANDS.each{|k,v|
-        o = ""
         puts "  #{k.ljust(15)} #{v[2]}"
         if ALLOWED_OPTIONS[k]
             ALLOWED_OPTIONS[k].each{|optname,has_arg|
                 puts "                  --#{optname}" + (has_arg ? " <arg>" : "")
             }
         end
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.h	2017-09-27 22:53:52.278950315 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.h	2017-09-27 23:06:39.522922196 +0800
@@ -1,3 +1,3 @@
 #define REDIS_GIT_SHA1 "00000000"
 #define REDIS_GIT_DIRTY "0"
-#define REDIS_BUILD_ID "sarah-Erazer-X310-1506524032"
+#define REDIS_BUILD_ID "sarah-Erazer-X310-1506524799"
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/release.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/release.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.c	2017-07-14 19:28:42.000000000 +0800
@@ -76,17 +76,12 @@
 
 void createReplicationBacklog(void) {
     serverAssert(server.repl_backlog == NULL);
     server.repl_backlog = zmalloc(server.repl_backlog_size);
     server.repl_backlog_histlen = 0;
     server.repl_backlog_idx = 0;
-    /* When a new backlog buffer is created, we increment the replication
-     * offset by one to make sure we'll not be able to PSYNC with any
-     * previous slave. This is needed because we avoid incrementing the
-     * master_repl_offset if no backlog exists nor slaves are attached. */
-    server.master_repl_offset++;
 
     /* We don't have any data inside our buffer, but virtually the first
      * byte we have is the next byte that will be generated for the
      * replication stream. */
     server.repl_backlog_off = server.master_repl_offset+1;
 }
@@ -124,13 +119,13 @@
     server.repl_backlog = NULL;
 }
 
 /* Add data to the replication backlog.
  * This function also increments the global replication offset stored at
  * server.master_repl_offset, because there is no case where we want to feed
- * the backlog without incrementing the buffer. */
+ * the backlog without incrementing the offset. */
 void feedReplicationBacklog(void *ptr, size_t len) {
     unsigned char *p = ptr;
 
     server.master_repl_offset += len;
 
     /* This is a circular buffer, so write as much data we can at every
@@ -167,18 +162,30 @@
         len = sdslen(o->ptr);
         p = o->ptr;
     }
     feedReplicationBacklog(p,len);
 }
 
+/* Propagate write commands to slaves, and populate the replication backlog
+ * as well. This function is used if the instance is a master: we use
+ * the commands received by our clients in order to create the replication
+ * stream. Instead if the instance is a slave and has sub-slaves attached,
+ * we use replicationFeedSlavesFromMaster() */
 void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
     listNode *ln;
     listIter li;
     int j, len;
     char llstr[LONG_STR_SIZE];
 
+    /* If the instance is not a top level master, return ASAP: we'll just proxy
+     * the stream of data we receive from our master instead, in order to
+     * propagate *identical* replication stream. In this way this slave can
+     * advertise the same replication ID as the master (since it shares the
+     * master replication history and has the same backlog and offsets). */
+    if (server.masterhost != NULL) return;
+
     /* If there aren't slaves, and there is no backlog buffer to populate,
      * we can return ASAP. */
     if (server.repl_backlog == NULL && listLength(slaves) == 0) return;
 
     /* We can't have slaves attached and no backlog. */
     serverAssert(!(listLength(slaves) != 0 && server.repl_backlog == NULL));
@@ -241,13 +248,13 @@
             feedReplicationBacklogWithObject(argv[j]);
             feedReplicationBacklog(aux+len+1,2);
         }
     }
 
     /* Write the command to every slave. */
-    listRewind(server.slaves,&li);
+    listRewind(slaves,&li);
     while((ln = listNext(&li))) {
         client *slave = ln->value;
 
         /* Don't feed slaves that are still waiting for BGSAVE to start */
         if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
 
@@ -262,12 +269,40 @@
          * static buffer if any (from j to argc). */
         for (j = 0; j < argc; j++)
             addReplyBulk(slave,argv[j]);
     }
 }
 
+/* This function is used in order to proxy what we receive from our master
+ * to our sub-slaves. */
+#include <ctype.h>
+void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen) {
+    listNode *ln;
+    listIter li;
+
+    /* Debugging: this is handy to see the stream sent from master
+     * to slaves. Disabled with if(0). */
+    if (0) {
+        printf("%zu:",buflen);
+        for (size_t j = 0; j < buflen; j++) {
+            printf("%c", isprint(buf[j]) ? buf[j] : '.');
+        }
+        printf("\n");
+    }
+
+    if (server.repl_backlog) feedReplicationBacklog(buf,buflen);
+    listRewind(slaves,&li);
+    while((ln = listNext(&li))) {
+        client *slave = ln->value;
+
+        /* Don't feed slaves that are still waiting for BGSAVE to start */
+        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) continue;
+        addReplyString(slave,buf,buflen);
+    }
+}
+
 void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
     listNode *ln;
     listIter li;
     int j;
     sds cmdrepr = sdsnew("+");
     robj *cmdobj;
@@ -326,13 +361,13 @@
              server.repl_backlog_idx);
 
     /* Compute the amount of bytes we need to discard. */
     skip = offset - server.repl_backlog_off;
     serverLog(LL_DEBUG, "[PSYNC] Skipping: %lld", skip);
 
-    /* Point j to the oldest byte, that is actaully our
+    /* Point j to the oldest byte, that is actually our
      * server.repl_backlog_off byte. */
     j = (server.repl_backlog_idx +
         (server.repl_backlog_size-server.repl_backlog_histlen)) %
         server.repl_backlog_size;
     serverLog(LL_DEBUG, "[PSYNC] Index of first byte: %lld", j);
 
@@ -358,24 +393,20 @@
 
 /* Return the offset to provide as reply to the PSYNC command received
  * from the slave. The returned value is only valid immediately after
  * the BGSAVE process started and before executing any other command
  * from clients. */
 long long getPsyncInitialOffset(void) {
-    long long psync_offset = server.master_repl_offset;
-    /* Add 1 to psync_offset if it the replication backlog does not exists
-     * as when it will be created later we'll increment the offset by one. */
-    if (server.repl_backlog == NULL) psync_offset++;
-    return psync_offset;
+    return server.master_repl_offset;
 }
 
 /* Send a FULLRESYNC reply in the specific case of a full resynchronization,
  * as a side effect setup the slave for a full sync in different ways:
  *
- * 1) Remember, into the slave client structure, the offset we sent
- *    here, so that if new slaves will later attach to the same
+ * 1) Remember, into the slave client structure, the replication offset
+ *    we sent here, so that if new slaves will later attach to the same
  *    background RDB saving process (by duplicating this client output
  *    buffer), we can get the right offset from this slave.
  * 2) Set the replication state of the slave to WAIT_BGSAVE_END so that
  *    we start accumulating differences from this point.
  * 3) Force the replication stream to re-emit a SELECT statement so
  *    the new slave incremental differences will start selecting the
@@ -389,20 +420,20 @@
     int buflen;
 
     slave->psync_initial_offset = offset;
     slave->replstate = SLAVE_STATE_WAIT_BGSAVE_END;
     /* We are going to accumulate the incremental changes for this
      * slave as well. Set slaveseldb to -1 in order to force to re-emit
-     * a SLEECT statement in the replication stream. */
+     * a SELECT statement in the replication stream. */
     server.slaveseldb = -1;
 
     /* Don't send this reply to slaves that approached us with
      * the old SYNC command. */
     if (!(slave->flags & CLIENT_PRE_PSYNC)) {
         buflen = snprintf(buf,sizeof(buf),"+FULLRESYNC %s %lld\r\n",
-                          server.runid,offset);
+                          server.replid,offset);
         if (write(slave->fd,buf,buflen) != buflen) {
             freeClientAsync(slave);
             return C_ERR;
         }
     }
     return C_OK;
@@ -412,35 +443,54 @@
  * master receiving a request for partial resynchronization.
  *
  * On success return C_OK, otherwise C_ERR is returned and we proceed
  * with the usual full resync. */
 int masterTryPartialResynchronization(client *c) {
     long long psync_offset, psync_len;
-    char *master_runid = c->argv[1]->ptr;
+    char *master_replid = c->argv[1]->ptr;
     char buf[128];
     int buflen;
 
-    /* Is the runid of this master the same advertised by the wannabe slave
-     * via PSYNC? If runid changed this master is a different instance and
-     * there is no way to continue. */
-    if (strcasecmp(master_runid, server.runid)) {
+    /* Parse the replication offset asked by the slave. Go to full sync
+     * on parse error: this should never happen but we try to handle
+     * it in a robust way compared to aborting. */
+    if (getLongLongFromObjectOrReply(c,c->argv[2],&psync_offset,NULL) !=
+       C_OK) goto need_full_resync;
+
+    /* Is the replication ID of this master the same advertised by the wannabe
+     * slave via PSYNC? If the replication ID changed this master has a
+     * different replication history, and there is no way to continue.
+     *
+     * Note that there are two potentially valid replication IDs: the ID1
+     * and the ID2. The ID2 however is only valid up to a specific offset. */
+    if (strcasecmp(master_replid, server.replid) &&
+        (strcasecmp(master_replid, server.replid2) ||
+         psync_offset > server.second_replid_offset))
+    {
         /* Run id "?" is used by slaves that want to force a full resync. */
-        if (master_runid[0] != '?') {
-            serverLog(LL_NOTICE,"Partial resynchronization not accepted: "
-                "Runid mismatch (Client asked for runid '%s', my runid is '%s')",
-                master_runid, server.runid);
+        if (master_replid[0] != '?') {
+            if (strcasecmp(master_replid, server.replid) &&
+                strcasecmp(master_replid, server.replid2))
+            {
+                serverLog(LL_NOTICE,"Partial resynchronization not accepted: "
+                    "Replication ID mismatch (Slave asked for '%s', my "
+                    "replication IDs are '%s' and '%s')",
+                    master_replid, server.replid, server.replid2);
+            } else {
+                serverLog(LL_NOTICE,"Partial resynchronization not accepted: "
+                    "Requested offset for second ID was %lld, but I can reply "
+                    "up to %lld", psync_offset, server.second_replid_offset);
+            }
         } else {
             serverLog(LL_NOTICE,"Full resync requested by slave %s",
                 replicationGetSlaveName(c));
         }
         goto need_full_resync;
     }
 
     /* We still have the data our slave is asking for? */
-    if (getLongLongFromObjectOrReply(c,c->argv[2],&psync_offset,NULL) !=
-       C_OK) goto need_full_resync;
     if (!server.repl_backlog ||
         psync_offset < server.repl_backlog_off ||
         psync_offset > (server.repl_backlog_off + server.repl_backlog_histlen))
     {
         serverLog(LL_NOTICE,
             "Unable to partial resync with slave %s for lack of backlog (Slave request was: %lld).", replicationGetSlaveName(c), psync_offset);
@@ -460,13 +510,17 @@
     c->repl_ack_time = server.unixtime;
     c->repl_put_online_on_ack = 0;
     listAddNodeTail(server.slaves,c);
     /* We can't use the connection buffers since they are used to accumulate
      * new commands at this stage. But we are sure the socket send buffer is
      * empty so this write will never fail actually. */
-    buflen = snprintf(buf,sizeof(buf),"+CONTINUE\r\n");
+    if (c->slave_capa & SLAVE_CAPA_PSYNC2) {
+        buflen = snprintf(buf,sizeof(buf),"+CONTINUE %s\r\n", server.replid);
+    } else {
+        buflen = snprintf(buf,sizeof(buf),"+CONTINUE\r\n");
+    }
     if (write(c->fd,buf,buflen) != buflen) {
         freeClientAsync(c);
         return C_OK;
     }
     psync_len = addReplyReplicationBacklog(c,psync_offset);
     serverLog(LL_NOTICE,
@@ -512,16 +566,24 @@
     listIter li;
     listNode *ln;
 
     serverLog(LL_NOTICE,"Starting BGSAVE for SYNC with target: %s",
         socket_target ? "slaves sockets" : "disk");
 
+    rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
+    /* If we are saving for a chained slave (that is, if we are,
+     * in turn, a slave of another instance), make sure after
+     * loadig the RDB, our slaves select the right DB: we'll just
+     * send the replication stream we receive from our master, so
+     * no way to send SELECT commands. */
+    if (server.master) rsi.repl_stream_db = server.master->db->id;
+
     if (socket_target)
-        retval = rdbSaveToSlavesSockets();
+        retval = rdbSaveToSlavesSockets(&rsi);
     else
-        retval = rdbSaveBackground(server.rdb_filename);
+        retval = rdbSaveBackground(server.rdb_filename,&rsi);
 
     /* If we failed to BGSAVE, remove the slaves waiting for a full
      * resynchorinization from the list of salves, inform them with
      * an error about what happened, close the connection ASAP. */
     if (retval == C_ERR) {
         serverLog(LL_WARNING,"BGSAVE for replication failed");
@@ -565,13 +627,13 @@
     /* ignore SYNC if already slave or in monitor mode */
     if (c->flags & CLIENT_SLAVE) return;
 
     /* Refuse SYNC requests if we are a slave but the link with our master
      * is not ok... */
     if (server.masterhost && server.repl_state != REPL_STATE_CONNECTED) {
-        addReplyError(c,"Can't SYNC while not connected with my master");
+        addReplySds(c,sdsnew("-NOMASTERLINK Can't SYNC while not connected with my master\r\n"));
         return;
     }
 
     /* SYNC can't be issued when the server has pending data to send to
      * the client about already issued commands. We need a fresh reply
      * buffer registering the differences between the BGSAVE and the current
@@ -586,28 +648,28 @@
 
     /* Try a partial resynchronization if this is a PSYNC command.
      * If it fails, we continue with usual full resynchronization, however
      * when this happens masterTryPartialResynchronization() already
      * replied with:
      *
-     * +FULLRESYNC <runid> <offset>
+     * +FULLRESYNC <replid> <offset>
      *
-     * So the slave knows the new runid and offset to try a PSYNC later
+     * So the slave knows the new replid and offset to try a PSYNC later
      * if the connection with the master is lost. */
     if (!strcasecmp(c->argv[0]->ptr,"psync")) {
         if (masterTryPartialResynchronization(c) == C_OK) {
             server.stat_sync_partial_ok++;
             return; /* No full resync needed, return. */
         } else {
-            char *master_runid = c->argv[1]->ptr;
+            char *master_replid = c->argv[1]->ptr;
 
             /* Increment stats for failed PSYNCs, but only if the
-             * runid is not "?", as this is used by slaves to force a full
+             * replid is not "?", as this is used by slaves to force a full
              * resync on purpose when they are not albe to partially
              * resync. */
-            if (master_runid[0] != '?') server.stat_sync_partial_err++;
+            if (master_replid[0] != '?') server.stat_sync_partial_err++;
         }
     } else {
         /* If a slave uses SYNC, we are dealing with an old implementation
          * of the replication protocol (like redis-cli --slave). Flag the client
          * so that we don't expect to receive REPLCONF ACK feedbacks. */
         c->flags |= CLIENT_PRE_PSYNC;
@@ -622,12 +684,22 @@
     if (server.repl_disable_tcp_nodelay)
         anetDisableTcpNoDelay(NULL, c->fd); /* Non critical if it fails. */
     c->repldbfd = -1;
     c->flags |= CLIENT_SLAVE;
     listAddNodeTail(server.slaves,c);
 
+    /* Create the replication backlog if needed. */
+    if (listLength(server.slaves) == 1 && server.repl_backlog == NULL) {
+        /* When we create the backlog from scratch, we always use a new
+         * replication ID and clear the ID2, since there is no valid
+         * past history. */
+        changeReplicationId();
+        clearReplicationId2();
+        createReplicationBacklog();
+    }
+
     /* CASE 1: BGSAVE is in progress, with disk target. */
     if (server.rdb_child_pid != -1 &&
         server.rdb_child_type == RDB_CHILD_TYPE_DISK)
     {
         /* Ok a background save is in progress. Let's check if it is a good
          * one for replication, i.e. if there is another slave that is
@@ -682,15 +754,12 @@
                 serverLog(LL_NOTICE,
                     "No BGSAVE in progress, but an AOF rewrite is active. "
                     "BGSAVE for replication delayed");
             }
         }
     }
-
-    if (listLength(server.slaves) == 1 && server.repl_backlog == NULL)
-        createReplicationBacklog();
     return;
 }
 
 /* REPLCONF <option> <value> <option> <value> ...
  * This command is used by a slave in order to configure the replication
  * process before starting it with the SYNC command.
@@ -732,12 +801,14 @@
                 return;
             }
         } else if (!strcasecmp(c->argv[j]->ptr,"capa")) {
             /* Ignore capabilities not understood by this master. */
             if (!strcasecmp(c->argv[j+1]->ptr,"eof"))
                 c->slave_capa |= SLAVE_CAPA_EOF;
+            else if (!strcasecmp(c->argv[j+1]->ptr,"psync2"))
+                c->slave_capa |= SLAVE_CAPA_PSYNC2;
         } else if (!strcasecmp(c->argv[j]->ptr,"ack")) {
             /* REPLCONF ACK is used by slave to inform the master the amount
              * of replication stream that it processed so far. It is an
              * internal only command that normal clients should never use. */
             long long offset;
 
@@ -755,13 +826,13 @@
             /* Note: this command does not reply anything! */
             return;
         } else if (!strcasecmp(c->argv[j]->ptr,"getack")) {
             /* REPLCONF GETACK is used in order to request an ACK ASAP
              * to the slave. */
             if (server.masterhost && server.master) replicationSendAck();
-            /* Note: this command does not reply anything! */
+            return;
         } else {
             addReplyErrorFormat(c,"Unrecognized REPLCONF option: %s",
                 (char*)c->argv[j]->ptr);
             return;
         }
     }
@@ -925,12 +996,49 @@
             }
         }
     }
     if (startbgsave) startBgsaveForReplication(mincapa);
 }
 
+/* Change the current instance replication ID with a new, random one.
+ * This will prevent successful PSYNCs between this master and other
+ * slaves, so the command should be called when something happens that
+ * alters the current story of the dataset. */
+void changeReplicationId(void) {
+    getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
+    server.replid[CONFIG_RUN_ID_SIZE] = '\0';
+}
+
+/* Clear (invalidate) the secondary replication ID. This happens, for
+ * example, after a full resynchronization, when we start a new replication
+ * history. */
+void clearReplicationId2(void) {
+    memset(server.replid2,'0',sizeof(server.replid));
+    server.replid2[CONFIG_RUN_ID_SIZE] = '\0';
+    server.second_replid_offset = -1;
+}
+
+/* Use the current replication ID / offset as secondary replication
+ * ID, and change the current one in order to start a new history.
+ * This should be used when an instance is switched from slave to master
+ * so that it can serve PSYNC requests performed using the master
+ * replication ID. */
+void shiftReplicationId(void) {
+    memcpy(server.replid2,server.replid,sizeof(server.replid));
+    /* We set the second replid offset to the master offset + 1, since
+     * the slave will ask for the first byte it has not yet received, so
+     * we need to add one to the offset: for example if, as a slave, we are
+     * sure we have the same history as the master for 50 bytes, after we
+     * are turned into a master, we can accept a PSYNC request with offset
+     * 51, since the slave asking has the same history up to the 50th
+     * byte, and is asking for the new bytes starting at offset 51. */
+    server.second_replid_offset = server.master_repl_offset+1;
+    changeReplicationId();
+    serverLog(LL_WARNING,"Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s", server.replid2, server.second_replid_offset, server.replid);
+}
+
 /* ----------------------------------- SLAVE -------------------------------- */
 
 /* Returns 1 if the given replication state is a handshake state,
  * 0 otherwise. */
 int slaveIsInHandshakeState(void) {
     return server.repl_state >= REPL_STATE_RECEIVE_PONG &&
@@ -962,24 +1070,37 @@
     replicationSendNewlineToMaster();
 }
 
 /* Once we have a link with the master and the synchroniziation was
  * performed, this function materializes the master client we store
  * at server.master, starting from the specified file descriptor. */
-void replicationCreateMasterClient(int fd) {
+void replicationCreateMasterClient(int fd, int dbid) {
     server.master = createClient(fd);
     server.master->flags |= CLIENT_MASTER;
     server.master->authenticated = 1;
-    server.repl_state = REPL_STATE_CONNECTED;
-    server.master->reploff = server.repl_master_initial_offset;
-    memcpy(server.master->replrunid, server.repl_master_runid,
-        sizeof(server.repl_master_runid));
+    server.master->reploff = server.master_initial_offset;
+    server.master->read_reploff = server.master->reploff;
+    memcpy(server.master->replid, server.master_replid,
+        sizeof(server.master_replid));
     /* If master offset is set to -1, this master is old and is not
      * PSYNC capable, so we flag it accordingly. */
     if (server.master->reploff == -1)
         server.master->flags |= CLIENT_PRE_PSYNC;
+    if (dbid != -1) selectDb(server.master,dbid);
+}
+
+void restartAOF() {
+    int retry = 10;
+    while (retry-- && startAppendOnly() == C_ERR) {
+        serverLog(LL_WARNING,"Failed enabling the AOF after successful master synchronization! Trying it again in one second.");
+        sleep(1);
+    }
+    if (!retry) {
+        serverLog(LL_WARNING,"FATAL: this slave instance finished the synchronization with its master, but the AOF can't be turned on. Exiting now.");
+        exit(1);
+    }
 }
 
 /* Asynchronously read the SYNC payload we receive from a master */
 #define REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) /* 8 MB */
 void readSyncBulkPayload(aeEventLoop *el, int fd, void *privdata, int mask) {
     char buf[4096];
@@ -1117,54 +1238,66 @@
     if (!usemark) {
         if (server.repl_transfer_read == server.repl_transfer_size)
             eof_reached = 1;
     }
 
     if (eof_reached) {
+        int aof_is_enabled = server.aof_state != AOF_OFF;
+
         if (rename(server.repl_transfer_tmpfile,server.rdb_filename) == -1) {
             serverLog(LL_WARNING,"Failed trying to rename the temp DB into dump.rdb in MASTER <-> SLAVE synchronization: %s", strerror(errno));
             cancelReplicationHandshake();
             return;
         }
         serverLog(LL_NOTICE, "MASTER <-> SLAVE sync: Flushing old data");
+        /* We need to stop any AOFRW fork before flusing and parsing
+         * RDB, otherwise we'll create a copy-on-write disaster. */
+        if(aof_is_enabled) stopAppendOnly();
         signalFlushedDb(-1);
-        emptyDb(replicationEmptyDbCallback);
+        emptyDb(
+            -1,
+            server.repl_slave_lazy_flush ? EMPTYDB_ASYNC : EMPTYDB_NO_FLAGS,
+            replicationEmptyDbCallback);
         /* Before loading the DB into memory we need to delete the readable
          * handler, otherwise it will get called recursively since
          * rdbLoad() will call the event loop to process events from time to
          * time for non blocking loading. */
         aeDeleteFileEvent(server.el,server.repl_transfer_s,AE_READABLE);
         serverLog(LL_NOTICE, "MASTER <-> SLAVE sync: Loading DB in memory");
-        if (rdbLoad(server.rdb_filename) != C_OK) {
+        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
+        if (rdbLoad(server.rdb_filename,&rsi) != C_OK) {
             serverLog(LL_WARNING,"Failed trying to load the MASTER synchronization DB from disk");
             cancelReplicationHandshake();
+            /* Re-enable the AOF if we disabled it earlier, in order to restore
+             * the original configuration. */
+            if (aof_is_enabled) restartAOF();
             return;
         }
         /* Final setup of the connected slave <- master link */
         zfree(server.repl_transfer_tmpfile);
         close(server.repl_transfer_fd);
-        replicationCreateMasterClient(server.repl_transfer_s);
+        replicationCreateMasterClient(server.repl_transfer_s,rsi.repl_stream_db);
+        server.repl_state = REPL_STATE_CONNECTED;
+        /* After a full resynchroniziation we use the replication ID and
+         * offset of the master. The secondary ID / offset are cleared since
+         * we are starting a new history. */
+        memcpy(server.replid,server.master->replid,sizeof(server.replid));
+        server.master_repl_offset = server.master->reploff;
+        clearReplicationId2();
+        /* Let's create the replication backlog if needed. Slaves need to
+         * accumulate the backlog regardless of the fact they have sub-slaves
+         * or not, in order to behave correctly if they are promoted to
+         * masters after a failover. */
+        if (server.repl_backlog == NULL) createReplicationBacklog();
+
         serverLog(LL_NOTICE, "MASTER <-> SLAVE sync: Finished with success");
         /* Restart the AOF subsystem now that we finished the sync. This
          * will trigger an AOF rewrite, and when done will start appending
          * to the new file. */
-        if (server.aof_state != AOF_OFF) {
-            int retry = 10;
-
-            stopAppendOnly();
-            while (retry-- && startAppendOnly() == C_ERR) {
-                serverLog(LL_WARNING,"Failed enabling the AOF after successful master synchronization! Trying it again in one second.");
-                sleep(1);
-            }
-            if (!retry) {
-                serverLog(LL_WARNING,"FATAL: this slave instance finished the synchronization with its master, but the AOF can't be turned on. Exiting now.");
-                exit(1);
-            }
-        }
+        if (aof_is_enabled) restartAOF();
     }
-
     return;
 
 error:
     cancelReplicationHandshake();
     return;
 }
@@ -1257,55 +1390,57 @@
  * PSYNC_CONTINUE: If the PSYNC command succeded and we can continue.
  * PSYNC_FULLRESYNC: If PSYNC is supported but a full resync is needed.
  *                   In this case the master run_id and global replication
  *                   offset is saved.
  * PSYNC_NOT_SUPPORTED: If the server does not understand PSYNC at all and
  *                      the caller should fall back to SYNC.
- * PSYNC_WRITE_ERR: There was an error writing the command to the socket.
+ * PSYNC_WRITE_ERROR: There was an error writing the command to the socket.
  * PSYNC_WAIT_REPLY: Call again the function with read_reply set to 1.
+ * PSYNC_TRY_LATER: Master is currently in a transient error condition.
  *
  * Notable side effects:
  *
  * 1) As a side effect of the function call the function removes the readable
  *    event handler from "fd", unless the return value is PSYNC_WAIT_REPLY.
- * 2) server.repl_master_initial_offset is set to the right value according
+ * 2) server.master_initial_offset is set to the right value according
  *    to the master reply. This will be used to populate the 'server.master'
  *    structure replication offset.
  */
 
 #define PSYNC_WRITE_ERROR 0
 #define PSYNC_WAIT_REPLY 1
 #define PSYNC_CONTINUE 2
 #define PSYNC_FULLRESYNC 3
 #define PSYNC_NOT_SUPPORTED 4
+#define PSYNC_TRY_LATER 5
 int slaveTryPartialResynchronization(int fd, int read_reply) {
-    char *psync_runid;
+    char *psync_replid;
     char psync_offset[32];
     sds reply;
 
     /* Writing half */
     if (!read_reply) {
-        /* Initially set repl_master_initial_offset to -1 to mark the current
+        /* Initially set master_initial_offset to -1 to mark the current
          * master run_id and offset as not valid. Later if we'll be able to do
          * a FULL resync using the PSYNC command we'll set the offset at the
          * right value, so that this information will be propagated to the
          * client structure representing the master into server.master. */
-        server.repl_master_initial_offset = -1;
+        server.master_initial_offset = -1;
 
         if (server.cached_master) {
-            psync_runid = server.cached_master->replrunid;
+            psync_replid = server.cached_master->replid;
             snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);
-            serverLog(LL_NOTICE,"Trying a partial resynchronization (request %s:%s).", psync_runid, psync_offset);
+            serverLog(LL_NOTICE,"Trying a partial resynchronization (request %s:%s).", psync_replid, psync_offset);
         } else {
             serverLog(LL_NOTICE,"Partial resynchronization not possible (no cached master)");
-            psync_runid = "?";
+            psync_replid = "?";
             memcpy(psync_offset,"-1",3);
         }
 
         /* Issue the PSYNC command */
-        reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"PSYNC",psync_runid,psync_offset,NULL);
+        reply = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"PSYNC",psync_replid,psync_offset,NULL);
         if (reply != NULL) {
             serverLog(LL_WARNING,"Unable to send PSYNC to master: %s",reply);
             sdsfree(reply);
             aeDeleteFileEvent(server.el,fd,AE_READABLE);
             return PSYNC_WRITE_ERROR;
         }
@@ -1321,56 +1456,103 @@
         return PSYNC_WAIT_REPLY;
     }
 
     aeDeleteFileEvent(server.el,fd,AE_READABLE);
 
     if (!strncmp(reply,"+FULLRESYNC",11)) {
-        char *runid = NULL, *offset = NULL;
+        char *replid = NULL, *offset = NULL;
 
         /* FULL RESYNC, parse the reply in order to extract the run id
          * and the replication offset. */
-        runid = strchr(reply,' ');
-        if (runid) {
-            runid++;
-            offset = strchr(runid,' ');
+        replid = strchr(reply,' ');
+        if (replid) {
+            replid++;
+            offset = strchr(replid,' ');
             if (offset) offset++;
         }
-        if (!runid || !offset || (offset-runid-1) != CONFIG_RUN_ID_SIZE) {
+        if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {
             serverLog(LL_WARNING,
                 "Master replied with wrong +FULLRESYNC syntax.");
             /* This is an unexpected condition, actually the +FULLRESYNC
              * reply means that the master supports PSYNC, but the reply
              * format seems wrong. To stay safe we blank the master
-             * runid to make sure next PSYNCs will fail. */
-            memset(server.repl_master_runid,0,CONFIG_RUN_ID_SIZE+1);
+             * replid to make sure next PSYNCs will fail. */
+            memset(server.master_replid,0,CONFIG_RUN_ID_SIZE+1);
         } else {
-            memcpy(server.repl_master_runid, runid, offset-runid-1);
-            server.repl_master_runid[CONFIG_RUN_ID_SIZE] = '\0';
-            server.repl_master_initial_offset = strtoll(offset,NULL,10);
+            memcpy(server.master_replid, replid, offset-replid-1);
+            server.master_replid[CONFIG_RUN_ID_SIZE] = '\0';
+            server.master_initial_offset = strtoll(offset,NULL,10);
             serverLog(LL_NOTICE,"Full resync from master: %s:%lld",
-                server.repl_master_runid,
-                server.repl_master_initial_offset);
+                server.master_replid,
+                server.master_initial_offset);
         }
         /* We are going to full resync, discard the cached master structure. */
         replicationDiscardCachedMaster();
         sdsfree(reply);
         return PSYNC_FULLRESYNC;
     }
 
     if (!strncmp(reply,"+CONTINUE",9)) {
-        /* Partial resync was accepted, set the replication state accordingly */
+        /* Partial resync was accepted. */
         serverLog(LL_NOTICE,
             "Successful partial resynchronization with master.");
+
+        /* Check the new replication ID advertised by the master. If it
+         * changed, we need to set the new ID as primary ID, and set or
+         * secondary ID as the old master ID up to the current offset, so
+         * that our sub-slaves will be able to PSYNC with us after a
+         * disconnection. */
+        char *start = reply+10;
+        char *end = reply+9;
+        while(end[0] != '\r' && end[0] != '\n' && end[0] != '\0') end++;
+        if (end-start == CONFIG_RUN_ID_SIZE) {
+            char new[CONFIG_RUN_ID_SIZE+1];
+            memcpy(new,start,CONFIG_RUN_ID_SIZE);
+            new[CONFIG_RUN_ID_SIZE] = '\0';
+
+            if (strcmp(new,server.cached_master->replid)) {
+                /* Master ID changed. */
+                serverLog(LL_WARNING,"Master replication ID changed to %s",new);
+
+                /* Set the old ID as our ID2, up to the current offset+1. */
+                memcpy(server.replid2,server.cached_master->replid,
+                    sizeof(server.replid2));
+                server.second_replid_offset = server.master_repl_offset+1;
+
+                /* Update the cached master ID and our own primary ID to the
+                 * new one. */
+                memcpy(server.replid,new,sizeof(server.replid));
+                memcpy(server.cached_master->replid,new,sizeof(server.replid));
+
+                /* Disconnect all the sub-slaves: they need to be notified. */
+                disconnectSlaves();
+            }
+        }
+
+        /* Setup the replication to continue. */
         sdsfree(reply);
         replicationResurrectCachedMaster(fd);
         return PSYNC_CONTINUE;
     }
 
-    /* If we reach this point we received either an error since the master does
-     * not understand PSYNC, or an unexpected reply from the master.
-     * Return PSYNC_NOT_SUPPORTED to the caller in both cases. */
+    /* If we reach this point we received either an error (since the master does
+     * not understand PSYNC or because it is in a special state and cannot
+     * serve our request), or an unexpected reply from the master.
+     *
+     * Return PSYNC_NOT_SUPPORTED on errors we don't understand, otherwise
+     * return PSYNC_TRY_LATER if we believe this is a transient error. */
+
+    if (!strncmp(reply,"-NOMASTERLINK",13) ||
+        !strncmp(reply,"-LOADING",8))
+    {
+        serverLog(LL_NOTICE,
+            "Master is currently unable to PSYNC "
+            "but should be in the future: %s", reply);
+        sdsfree(reply);
+        return PSYNC_TRY_LATER;
+    }
 
     if (strncmp(reply,"-ERR",4)) {
         /* If it's not an error, log the unexpected event. */
         serverLog(LL_WARNING,
             "Unexpected reply to PSYNC from master: %s", reply);
     } else {
@@ -1380,12 +1562,14 @@
     }
     sdsfree(reply);
     replicationDiscardCachedMaster();
     return PSYNC_NOT_SUPPORTED;
 }
 
+/* This handler fires when the non blocking connect was able to
+ * establish a connection with the master. */
 void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {
     char tmpfile[256], *err = NULL;
     int dfd = -1, maxtries = 5;
     int sockerr = 0, psync_result;
     socklen_t errlen = sizeof(sockerr);
     UNUSED(el);
@@ -1396,13 +1580,14 @@
      * with SLAVEOF NO ONE we must just return ASAP. */
     if (server.repl_state == REPL_STATE_NONE) {
         close(fd);
         return;
     }
 
-    /* Check for errors in the socket. */
+    /* Check for errors in the socket: after a non blocking connect() we
+     * may find that the socket is in error state. */
     if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)
         sockerr = errno;
     if (sockerr) {
         serverLog(LL_WARNING,"Error condition on socket for SYNC: %s",
             strerror(sockerr));
         goto error;
@@ -1525,19 +1710,21 @@
                                 "REPLCONF ip-address: %s", err);
         }
         sdsfree(err);
         server.repl_state = REPL_STATE_SEND_CAPA;
     }
 
-    /* Inform the master of our capabilities. While we currently send
-     * just one capability, it is possible to chain new capabilities here
-     * in the form of REPLCONF capa X capa Y capa Z ...
+    /* Inform the master of our (slave) capabilities.
+     *
+     * EOF: supports EOF-style RDB transfer for diskless replication.
+     * PSYNC2: supports PSYNC v2, so understands +CONTINUE <new repl ID>.
+     *
      * The master will ignore capabilities it does not understand. */
     if (server.repl_state == REPL_STATE_SEND_CAPA) {
         err = sendSynchronousCommand(SYNC_CMD_WRITE,fd,"REPLCONF",
-                "capa","eof",NULL);
+                "capa","eof","capa","psync2",NULL);
         if (err) goto write_error;
         sdsfree(err);
         server.repl_state = REPL_STATE_RECEIVE_CAPA;
         return;
     }
 
@@ -1576,29 +1763,35 @@
         goto error;
     }
 
     psync_result = slaveTryPartialResynchronization(fd,1);
     if (psync_result == PSYNC_WAIT_REPLY) return; /* Try again later... */
 
+    /* If the master is in an transient error, we should try to PSYNC
+     * from scratch later, so go to the error path. This happens when
+     * the server is loading the dataset or is not connected with its
+     * master and so forth. */
+    if (psync_result == PSYNC_TRY_LATER) goto error;
+
     /* Note: if PSYNC does not return WAIT_REPLY, it will take care of
      * uninstalling the read handler from the file descriptor. */
 
     if (psync_result == PSYNC_CONTINUE) {
         serverLog(LL_NOTICE, "MASTER <-> SLAVE sync: Master accepted a Partial Resynchronization.");
         return;
     }
 
     /* PSYNC failed or is not supported: we want our slaves to resync with us
-     * as well, if we have any (chained replication case). The mater may
-     * transfer us an entirely different data set and we have no way to
-     * incrementally feed our slaves after that. */
+     * as well, if we have any sub-slaves. The master may transfer us an
+     * entirely different data set and we have no way to incrementally feed
+     * our slaves after that. */
     disconnectSlaves(); /* Force our slaves to resync with us as well. */
     freeReplicationBacklog(); /* Don't allow our chained slaves to PSYNC. */
 
     /* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC
-     * and the server.repl_master_runid and repl_master_initial_offset are
+     * and the server.master_replid and master_initial_offset are
      * already populated. */
     if (psync_result == PSYNC_NOT_SUPPORTED) {
         serverLog(LL_NOTICE,"Retrying with SYNC...");
         if (syncWrite(fd,"SYNC\r\n",6,server.repl_syncio_timeout*1000) == -1) {
             serverLog(LL_WARNING,"I/O error writing to MASTER: %s",
                 strerror(errno));
@@ -1722,45 +1915,58 @@
     }
     return 1;
 }
 
 /* Set replication to the specified master address and port. */
 void replicationSetMaster(char *ip, int port) {
+    int was_master = server.masterhost == NULL;
+
     sdsfree(server.masterhost);
     server.masterhost = sdsnew(ip);
     server.masterport = port;
-    if (server.master) freeClient(server.master);
+    if (server.master) {
+        freeClient(server.master);
+    }
     disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */
-    disconnectSlaves(); /* Force our slaves to resync with us as well. */
-    replicationDiscardCachedMaster(); /* Don't try a PSYNC. */
-    freeReplicationBacklog(); /* Don't allow our chained slaves to PSYNC. */
+
+    /* Force our slaves to resync with us as well. They may hopefully be able
+     * to partially resync with us, but we can notify the replid change. */
+    disconnectSlaves();
     cancelReplicationHandshake();
+    /* Before destroying our master state, create a cached master using
+     * our own parameters, to later PSYNC with the new master. */
+    if (was_master) replicationCacheMasterUsingMyself();
     server.repl_state = REPL_STATE_CONNECT;
-    server.master_repl_offset = 0;
     server.repl_down_since = 0;
 }
 
 /* Cancel replication, setting the instance as a master itself. */
 void replicationUnsetMaster(void) {
     if (server.masterhost == NULL) return; /* Nothing to do. */
     sdsfree(server.masterhost);
     server.masterhost = NULL;
-    if (server.master) {
-        if (listLength(server.slaves) == 0) {
-            /* If this instance is turned into a master and there are no
-             * slaves, it inherits the replication offset from the master.
-             * Under certain conditions this makes replicas comparable by
-             * replication offset to understand what is the most updated. */
-            server.master_repl_offset = server.master->reploff;
-            freeReplicationBacklog();
-        }
-        freeClient(server.master);
-    }
+    /* When a slave is turned into a master, the current replication ID
+     * (that was inherited from the master at synchronization time) is
+     * used as secondary ID up to the current offset, and a new replication
+     * ID is created to continue with a new replication history. */
+    shiftReplicationId();
+    if (server.master) freeClient(server.master);
     replicationDiscardCachedMaster();
     cancelReplicationHandshake();
+    /* Disconnecting all the slaves is required: we need to inform slaves
+     * of the replication ID change (see shiftReplicationId() call). However
+     * the slaves will be able to partially resync with us, so it will be
+     * a very fast reconnection. */
+    disconnectSlaves();
     server.repl_state = REPL_STATE_NONE;
+
+    /* We need to make sure the new master will start the replication stream
+     * with a SELECT statement. This is forced after a full resync, but
+     * with PSYNC version 2, there is no need for full resync after a
+     * master switch. */
+    server.slaveseldb = -1;
 }
 
 /* This function is called when the slave lose the connection with the
  * master into an unexpected way. */
 void replicationHandleMasterDisconnection(void) {
     server.master = NULL;
@@ -1910,12 +2116,24 @@
     serverAssert(server.master != NULL && server.cached_master == NULL);
     serverLog(LL_NOTICE,"Caching the disconnected master state.");
 
     /* Unlink the client from the server structures. */
     unlinkClient(c);
 
+    /* Reset the master client so that's ready to accept new commands:
+     * we want to discard te non processed query buffers and non processed
+     * offsets, including pending transactions, already populated arguments,
+     * pending outputs to the master. */
+    sdsclear(server.master->querybuf);
+    sdsclear(server.master->pending_querybuf);
+    server.master->read_reploff = server.master->reploff;
+    if (c->flags & CLIENT_MULTI) discardTransaction(c);
+    listEmpty(c->reply);
+    c->bufpos = 0;
+    resetClient(c);
+
     /* Save the master. Server.master will be set to null later by
      * replicationHandleMasterDisconnection(). */
     server.cached_master = server.master;
 
     /* Invalidate the Peer ID cache. */
     if (c->peerid) {
@@ -1926,12 +2144,37 @@
     /* Caching the master happens instead of the actual freeClient() call,
      * so make sure to adjust the replication state. This function will
      * also set server.master to NULL. */
     replicationHandleMasterDisconnection();
 }
 
+/* This function is called when a master is turend into a slave, in order to
+ * create from scratch a cached master for the new client, that will allow
+ * to PSYNC with the slave that was promoted as the new master after a
+ * failover.
+ *
+ * Assuming this instance was previously the master instance of the new master,
+ * the new master will accept its replication ID, and potentiall also the
+ * current offset if no data was lost during the failover. So we use our
+ * current replication ID and offset in order to synthesize a cached master. */
+void replicationCacheMasterUsingMyself(void) {
+    /* The master client we create can be set to any DBID, because
+     * the new master will start its replication stream with SELECT. */
+    server.master_initial_offset = server.master_repl_offset;
+    replicationCreateMasterClient(-1,-1);
+
+    /* Use our own ID / offset. */
+    memcpy(server.master->replid, server.replid, sizeof(server.replid));
+
+    /* Set as cached master. */
+    unlinkClient(server.master);
+    server.cached_master = server.master;
+    server.master = NULL;
+    serverLog(LL_NOTICE,"Before turning into a slave, using my master parameters to synthesize a cached master: I may be able to synchronize with the new master with just a partial transfer.");
+}
+
 /* Free a cached master, called when there are no longer the conditions for
  * a partial resync on reconnection. */
 void replicationDiscardCachedMaster(void) {
     if (server.cached_master == NULL) return;
 
     serverLog(LL_NOTICE,"Discarding previously cached master state.");
@@ -2137,12 +2380,17 @@
  * write command (and all the previous commands). */
 void waitCommand(client *c) {
     mstime_t timeout;
     long numreplicas, ackreplicas;
     long long offset = c->woff;
 
+    if (server.masterhost) {
+        addReplyError(c,"WAIT cannot be used with slave instances. Please also note that since Redis 4.0 if a slave is configured to be writable (which is not the default) writes to slaves are just local and are not propagated.");
+        return;
+    }
+
     /* Argument parsing. */
     if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
         return;
     if (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,UNIT_MILLISECONDS)
         != C_OK) return;
 
@@ -2285,35 +2533,47 @@
      * will not actually go down. */
     listIter li;
     listNode *ln;
     robj *ping_argv[1];
 
     /* First, send PING according to ping_slave_period. */
-    if ((replication_cron_loops % server.repl_ping_slave_period) == 0) {
+    if ((replication_cron_loops % server.repl_ping_slave_period) == 0 &&
+        listLength(server.slaves))
+    {
         ping_argv[0] = createStringObject("PING",4);
         replicationFeedSlaves(server.slaves, server.slaveseldb,
             ping_argv, 1);
         decrRefCount(ping_argv[0]);
     }
 
     /* Second, send a newline to all the slaves in pre-synchronization
      * stage, that is, slaves waiting for the master to create the RDB file.
+     *
+     * Also send the a newline to all the chained slaves we have, if we lost
+     * connection from our master, to keep the slaves aware that their
+     * master is online. This is needed since sub-slaves only receive proxied
+     * data from top-level masters, so there is no explicit pinging in order
+     * to avoid altering the replication offsets. This special out of band
+     * pings (newlines) can be sent, they will have no effect in the offset.
+     *
      * The newline will be ignored by the slave but will refresh the
-     * last-io timer preventing a timeout. In this case we ignore the
+     * last interaction timer preventing a timeout. In this case we ignore the
      * ping period and refresh the connection once per second since certain
      * timeouts are set at a few seconds (example: PSYNC response). */
     listRewind(server.slaves,&li);
     while((ln = listNext(&li))) {
         client *slave = ln->value;
 
-        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
+        int is_presync =
+            (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
             (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END &&
-             server.rdb_child_type != RDB_CHILD_TYPE_SOCKET))
-        {
+             server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));
+
+        if (is_presync) {
             if (write(slave->fd, "\n", 1) == -1) {
-                /* Don't worry, it's just a ping. */
+                /* Don't worry about socket errors, it's just a ping. */
             }
         }
     }
 
     /* Disconnect timedout slaves. */
     if (listLength(server.slaves)) {
@@ -2332,16 +2592,20 @@
                     replicationGetSlaveName(slave));
                 freeClient(slave);
             }
         }
     }
 
-    /* If we have no attached slaves and there is a replication backlog
-     * using memory, free it after some (configured) time. */
+    /* If this is a master without attached slaves and there is a replication
+     * backlog active, in order to reclaim memory we can free it after some
+     * (configured) time. Note that this cannot be done for slaves: slaves
+     * without sub-slaves attached should still accumulate data into the
+     * backlog, in order to reply to PSYNC queries if they are turned into
+     * masters after a failover. */
     if (listLength(server.slaves) == 0 && server.repl_backlog_time_limit &&
-        server.repl_backlog)
+        server.repl_backlog && server.masterhost == NULL)
     {
         time_t idle = server.unixtime - server.repl_no_slaves_since;
 
         if (idle > server.repl_backlog_time_limit) {
             freeReplicationBacklog();
             serverLog(LL_NOTICE,
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/replication.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/replication.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.h	2017-07-14 19:28:42.000000000 +0800
@@ -132,10 +132,13 @@
 
 size_t rioWriteBulkCount(rio *r, char prefix, int count);
 size_t rioWriteBulkString(rio *r, const char *buf, size_t len);
 size_t rioWriteBulkLongLong(rio *r, long long l);
 size_t rioWriteBulkDouble(rio *r, double d);
 
+struct redisObject;
+int rioWriteBulkObject(rio *r, struct redisObject *obj);
+
 void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len);
 void rioSetAutoSync(rio *r, off_t bytes);
 
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/rio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/rio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.c	2017-07-14 19:28:42.000000000 +0800
@@ -440,13 +440,12 @@
     if (ldb.active && ldb.step) {
         sds cmdlog = sdsnew("<redis>");
         for (j = 0; j < c->argc; j++) {
             if (j == 10) {
                 cmdlog = sdscatprintf(cmdlog," ... (%d more)",
                     c->argc-j-1);
-                break;
             } else {
                 cmdlog = sdscatlen(cmdlog," ",1);
                 cmdlog = sdscatsds(cmdlog,c->argv[j]->ptr);
             }
         }
         ldbLog(cmdlog);
@@ -564,15 +563,15 @@
         reply = c->buf;
         c->bufpos = 0;
     } else {
         reply = sdsnewlen(c->buf,c->bufpos);
         c->bufpos = 0;
         while(listLength(c->reply)) {
-            robj *o = listNodeValue(listFirst(c->reply));
+            sds o = listNodeValue(listFirst(c->reply));
 
-            reply = sdscatlen(reply,o->ptr,sdslen(o->ptr));
+            reply = sdscatsds(reply,o);
             listDelNode(c->reply,listFirst(c->reply));
         }
     }
     if (raise_error && reply[0] != '-') raise_error = 0;
     redisProtocolToLuaType(lua,reply);
 
@@ -867,13 +866,13 @@
     s[j++]="    end\n";
     s[j++]="  end\n";
     s[j++]="  rawset(t, n, v)\n";
     s[j++]="end\n";
     s[j++]="mt.__index = function (t, n)\n";
     s[j++]="  if dbg.getinfo(2) and dbg.getinfo(2, \"S\").what ~= \"C\" then\n";
-    s[j++]="    error(\"Script attempted to access unexisting global variable '\"..tostring(n)..\"'\", 2)\n";
+    s[j++]="    error(\"Script attempted to access nonexistent global variable '\"..tostring(n)..\"'\", 2)\n";
     s[j++]="  end\n";
     s[j++]="  return rawget(t, n)\n";
     s[j++]="end\n";
     s[j++]="debug = nil\n";
     s[j++]=NULL;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/scripting.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/scripting.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.c	2017-07-14 19:28:42.000000000 +0800
@@ -32,12 +32,13 @@
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <assert.h>
+#include <limits.h>
 #include "sds.h"
 #include "sdsalloc.h"
 
 static inline int sdsHdrSize(char type) {
     switch(type&SDS_TYPE_MASK) {
         case SDS_TYPE_5:
@@ -58,14 +59,16 @@
     if (string_size < 1<<5)
         return SDS_TYPE_5;
     if (string_size < 1<<8)
         return SDS_TYPE_8;
     if (string_size < 1<<16)
         return SDS_TYPE_16;
+#if (LONG_MAX == LLONG_MAX)
     if (string_size < 1ll<<32)
         return SDS_TYPE_32;
+#endif
     return SDS_TYPE_64;
 }
 
 /* Create a new sds string with the content specified by the 'init' pointer
  * and 'initlen'.
  * If NULL is used for 'init' the string is initialized with zero bytes.
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sds.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sds.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.c	2017-07-14 19:28:42.000000000 +0800
@@ -376,13 +376,13 @@
 int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master);
 sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid);
 void sentinelSimFailureCrash(void);
 
 /* ========================= Dictionary types =============================== */
 
-unsigned int dictSdsHash(const void *key);
+uint64_t dictSdsHash(const void *key);
 int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
 void releaseSentinelRedisInstance(sentinelRedisInstance *ri);
 
 void dictInstancesValDestructor (void *privdata, void *obj) {
     UNUSED(privdata);
     releaseSentinelRedisInstance(obj);
@@ -3637,21 +3637,21 @@
     unsigned long votes;
 };
 
 /* Helper function for sentinelGetLeader, increment the counter
  * relative to the specified runid. */
 int sentinelLeaderIncr(dict *counters, char *runid) {
-    dictEntry *de = dictFind(counters,runid);
+    dictEntry *existing, *de;
     uint64_t oldval;
 
-    if (de) {
-        oldval = dictGetUnsignedIntegerVal(de);
-        dictSetUnsignedIntegerVal(de,oldval+1);
+    de = dictAddRaw(counters,runid,&existing);
+    if (existing) {
+        oldval = dictGetUnsignedIntegerVal(existing);
+        dictSetUnsignedIntegerVal(existing,oldval+1);
         return oldval+1;
     } else {
-        de = dictAddRaw(counters,runid);
         serverAssert(de != NULL);
         dictSetUnsignedIntegerVal(de,1);
         return 1;
     }
 }
 
@@ -3671,13 +3671,13 @@
     uint64_t leader_epoch;
     uint64_t max_votes = 0;
 
     serverAssert(master->flags & (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
     counters = dictCreate(&leaderVotesDictType,NULL);
 
-    voters = dictSize(master->sentinels)+1; /* All the other sentinels and me. */
+    voters = dictSize(master->sentinels)+1; /* All the other sentinels and me.*/
 
     /* Count other sentinels votes */
     di = dictGetIterator(master->sentinels);
     while((de = dictNext(di)) != NULL) {
         sentinelRedisInstance *ri = dictGetVal(de);
         if (ri->leader != NULL && ri->leader_epoch == sentinel.current_epoch)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sentinel.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sentinel.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.c	2017-07-14 19:28:42.000000000 +0800
@@ -1,8 +1,8 @@
 /*
- * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2009-2016, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  *   * Redistributions of source code must retain the above copyright notice,
@@ -29,12 +29,13 @@
 
 #include "server.h"
 #include "cluster.h"
 #include "slowlog.h"
 #include "bio.h"
 #include "latency.h"
+#include "atomicvar.h"
 
 #include <time.h>
 #include <signal.h>
 #include <sys/wait.h>
 #include <errno.h>
 #include <assert.h>
@@ -65,13 +66,14 @@
 
 double R_Zero, R_PosInf, R_NegInf, R_Nan;
 
 /*================================= Globals ================================= */
 
 /* Global vars */
-struct redisServer server; /* server global state */
+struct redisServer server; /* Server global state */
+volatile unsigned long lru_clock; /* Server global current LRU time. */
 
 /* Our command table.
  *
  * Every entry is composed of the following fields:
  *
  * name: a string representing the command name.
@@ -120,34 +122,36 @@
  * F: Fast command: O(1) or O(log(N)) command that should never delay
  *    its execution as long as the kernel scheduler is giving us time.
  *    Note that commands that may trigger a DEL as a side effect (like SET)
  *    are not fast commands.
  */
 struct redisCommand redisCommandTable[] = {
+    {"module",moduleCommand,-2,"as",0,NULL,1,1,1,0,0},
     {"get",getCommand,2,"rF",0,NULL,1,1,1,0,0},
     {"set",setCommand,-3,"wm",0,NULL,1,1,1,0,0},
     {"setnx",setnxCommand,3,"wmF",0,NULL,1,1,1,0,0},
     {"setex",setexCommand,4,"wm",0,NULL,1,1,1,0,0},
     {"psetex",psetexCommand,4,"wm",0,NULL,1,1,1,0,0},
     {"append",appendCommand,3,"wm",0,NULL,1,1,1,0,0},
     {"strlen",strlenCommand,2,"rF",0,NULL,1,1,1,0,0},
     {"del",delCommand,-2,"w",0,NULL,1,-1,1,0,0},
+    {"unlink",unlinkCommand,-2,"wF",0,NULL,1,-1,1,0,0},
     {"exists",existsCommand,-2,"rF",0,NULL,1,-1,1,0,0},
     {"setbit",setbitCommand,4,"wm",0,NULL,1,1,1,0,0},
     {"getbit",getbitCommand,3,"rF",0,NULL,1,1,1,0,0},
     {"bitfield",bitfieldCommand,-2,"wm",0,NULL,1,1,1,0,0},
     {"setrange",setrangeCommand,4,"wm",0,NULL,1,1,1,0,0},
     {"getrange",getrangeCommand,4,"r",0,NULL,1,1,1,0,0},
     {"substr",getrangeCommand,4,"r",0,NULL,1,1,1,0,0},
     {"incr",incrCommand,2,"wmF",0,NULL,1,1,1,0,0},
     {"decr",decrCommand,2,"wmF",0,NULL,1,1,1,0,0},
-    {"mget",mgetCommand,-2,"r",0,NULL,1,-1,1,0,0},
+    {"mget",mgetCommand,-2,"rF",0,NULL,1,-1,1,0,0},
     {"rpush",rpushCommand,-3,"wmF",0,NULL,1,1,1,0,0},
     {"lpush",lpushCommand,-3,"wmF",0,NULL,1,1,1,0,0},
-    {"rpushx",rpushxCommand,3,"wmF",0,NULL,1,1,1,0,0},
-    {"lpushx",lpushxCommand,3,"wmF",0,NULL,1,1,1,0,0},
+    {"rpushx",rpushxCommand,-3,"wmF",0,NULL,1,1,1,0,0},
+    {"lpushx",lpushxCommand,-3,"wmF",0,NULL,1,1,1,0,0},
     {"linsert",linsertCommand,5,"wm",0,NULL,1,1,1,0,0},
     {"rpop",rpopCommand,2,"wF",0,NULL,1,1,1,0,0},
     {"lpop",lpopCommand,2,"wF",0,NULL,1,1,1,0,0},
     {"brpop",brpopCommand,-3,"ws",0,NULL,1,-2,1,0,0},
     {"brpoplpush",brpoplpushCommand,4,"wms",0,NULL,1,2,1,0,0},
     {"blpop",blpopCommand,-3,"ws",0,NULL,1,-2,1,0,0},
@@ -191,17 +195,17 @@
     {"zrevrange",zrevrangeCommand,-4,"r",0,NULL,1,1,1,0,0},
     {"zcard",zcardCommand,2,"rF",0,NULL,1,1,1,0,0},
     {"zscore",zscoreCommand,3,"rF",0,NULL,1,1,1,0,0},
     {"zrank",zrankCommand,3,"rF",0,NULL,1,1,1,0,0},
     {"zrevrank",zrevrankCommand,3,"rF",0,NULL,1,1,1,0,0},
     {"zscan",zscanCommand,-3,"rR",0,NULL,1,1,1,0,0},
-    {"hset",hsetCommand,4,"wmF",0,NULL,1,1,1,0,0},
+    {"hset",hsetCommand,-4,"wmF",0,NULL,1,1,1,0,0},
     {"hsetnx",hsetnxCommand,4,"wmF",0,NULL,1,1,1,0,0},
     {"hget",hgetCommand,3,"rF",0,NULL,1,1,1,0,0},
-    {"hmset",hmsetCommand,-4,"wm",0,NULL,1,1,1,0,0},
-    {"hmget",hmgetCommand,-3,"r",0,NULL,1,1,1,0,0},
+    {"hmset",hsetCommand,-4,"wmF",0,NULL,1,1,1,0,0},
+    {"hmget",hmgetCommand,-3,"rF",0,NULL,1,1,1,0,0},
     {"hincrby",hincrbyCommand,4,"wmF",0,NULL,1,1,1,0,0},
     {"hincrbyfloat",hincrbyfloatCommand,4,"wmF",0,NULL,1,1,1,0,0},
     {"hdel",hdelCommand,-3,"wF",0,NULL,1,1,1,0,0},
     {"hlen",hlenCommand,2,"rF",0,NULL,1,1,1,0,0},
     {"hstrlen",hstrlenCommand,3,"rF",0,NULL,1,1,1,0,0},
     {"hkeys",hkeysCommand,2,"rS",0,NULL,1,1,1,0,0},
@@ -214,12 +218,13 @@
     {"incrbyfloat",incrbyfloatCommand,3,"wmF",0,NULL,1,1,1,0,0},
     {"getset",getsetCommand,3,"wm",0,NULL,1,1,1,0,0},
     {"mset",msetCommand,-3,"wm",0,NULL,1,-1,2,0,0},
     {"msetnx",msetnxCommand,-3,"wm",0,NULL,1,-1,2,0,0},
     {"randomkey",randomkeyCommand,1,"rR",0,NULL,0,0,0,0,0},
     {"select",selectCommand,2,"lF",0,NULL,0,0,0,0,0},
+    {"swapdb",swapdbCommand,3,"wF",0,NULL,0,0,0,0,0},
     {"move",moveCommand,3,"wF",0,NULL,1,1,1,0,0},
     {"rename",renameCommand,3,"w",0,NULL,1,2,1,0,0},
     {"renamenx",renamenxCommand,3,"wF",0,NULL,1,2,1,0,0},
     {"expire",expireCommand,3,"wF",0,NULL,1,1,1,0,0},
     {"expireat",expireatCommand,3,"wF",0,NULL,1,1,1,0,0},
     {"pexpire",pexpireCommand,3,"wF",0,NULL,1,1,1,0,0},
@@ -239,14 +244,14 @@
     {"multi",multiCommand,1,"sF",0,NULL,0,0,0,0,0},
     {"exec",execCommand,1,"sM",0,NULL,0,0,0,0,0},
     {"discard",discardCommand,1,"sF",0,NULL,0,0,0,0,0},
     {"sync",syncCommand,1,"ars",0,NULL,0,0,0,0,0},
     {"psync",syncCommand,3,"ars",0,NULL,0,0,0,0,0},
     {"replconf",replconfCommand,-1,"aslt",0,NULL,0,0,0,0,0},
-    {"flushdb",flushdbCommand,1,"w",0,NULL,0,0,0,0,0},
-    {"flushall",flushallCommand,1,"w",0,NULL,0,0,0,0,0},
+    {"flushdb",flushdbCommand,-1,"w",0,NULL,0,0,0,0,0},
+    {"flushall",flushallCommand,-1,"w",0,NULL,0,0,0,0,0},
     {"sort",sortCommand,-2,"wm",0,sortGetKeys,1,1,1,0,0},
     {"info",infoCommand,-1,"lt",0,NULL,0,0,0,0,0},
     {"monitor",monitorCommand,1,"as",0,NULL,0,0,0,0,0},
     {"ttl",ttlCommand,2,"rF",0,NULL,1,1,1,0,0},
     {"touch",touchCommand,-2,"rF",0,NULL,1,1,1,0,0},
     {"pttl",pttlCommand,2,"rF",0,NULL,1,1,1,0,0},
@@ -269,12 +274,13 @@
     {"migrate",migrateCommand,-6,"w",0,migrateGetKeys,0,0,0,0,0},
     {"asking",askingCommand,1,"F",0,NULL,0,0,0,0,0},
     {"readonly",readonlyCommand,1,"F",0,NULL,0,0,0,0,0},
     {"readwrite",readwriteCommand,1,"F",0,NULL,0,0,0,0,0},
     {"dump",dumpCommand,2,"r",0,NULL,1,1,1,0,0},
     {"object",objectCommand,3,"r",0,NULL,2,2,2,0,0},
+    {"memory",memoryCommand,-2,"r",0,NULL,0,0,0,0,0},
     {"client",clientCommand,-2,"as",0,NULL,0,0,0,0,0},
     {"eval",evalCommand,-3,"s",0,evalGetKeys,0,0,0,0,0},
     {"evalsha",evalShaCommand,-3,"s",0,evalGetKeys,0,0,0,0,0},
     {"slowlog",slowlogCommand,-2,"a",0,NULL,0,0,0,0,0},
     {"script",scriptCommand,-2,"s",0,NULL,0,0,0,0,0},
     {"time",timeCommand,1,"RF",0,NULL,0,0,0,0,0},
@@ -298,14 +304,12 @@
     {"pfdebug",pfdebugCommand,-3,"w",0,NULL,0,0,0,0,0},
     {"post",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
     {"host:",securityWarningCommand,-1,"lt",0,NULL,0,0,0,0,0},
     {"latency",latencyCommand,-2,"aslt",0,NULL,0,0,0,0,0}
 };
 
-struct evictionPoolEntry *evictionPoolAlloc(void);
-
 /*============================ Utility functions ============================ */
 
 /* Low level logging. To use only for very big messages, otherwise
  * serverLog() is to prefer. */
 void serverLogRaw(int level, const char *msg) {
     const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };
@@ -461,13 +465,13 @@
 }
 
 void dictObjectDestructor(void *privdata, void *val)
 {
     DICT_NOTUSED(privdata);
 
-    if (val == NULL) return; /* Values of swapped out keys as set to NULL */
+    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
     decrRefCount(val);
 }
 
 void dictSdsDestructor(void *privdata, void *val)
 {
     DICT_NOTUSED(privdata);
@@ -479,22 +483,22 @@
         const void *key2)
 {
     const robj *o1 = key1, *o2 = key2;
     return dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
 }
 
-unsigned int dictObjHash(const void *key) {
+uint64_t dictObjHash(const void *key) {
     const robj *o = key;
     return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
 }
 
-unsigned int dictSdsHash(const void *key) {
+uint64_t dictSdsHash(const void *key) {
     return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
-unsigned int dictSdsCaseHash(const void *key) {
+uint64_t dictSdsCaseHash(const void *key) {
     return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));
 }
 
 int dictEncObjKeyCompare(void *privdata, const void *key1,
         const void *key2)
 {
@@ -510,52 +514,63 @@
     cmp = dictSdsKeyCompare(privdata,o1->ptr,o2->ptr);
     decrRefCount(o1);
     decrRefCount(o2);
     return cmp;
 }
 
-unsigned int dictEncObjHash(const void *key) {
+uint64_t dictEncObjHash(const void *key) {
     robj *o = (robj*) key;
 
     if (sdsEncodedObject(o)) {
         return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
     } else {
         if (o->encoding == OBJ_ENCODING_INT) {
             char buf[32];
             int len;
 
             len = ll2string(buf,32,(long)o->ptr);
             return dictGenHashFunction((unsigned char*)buf, len);
         } else {
-            unsigned int hash;
+            uint64_t hash;
 
             o = getDecodedObject(o);
             hash = dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
             decrRefCount(o);
             return hash;
         }
     }
 }
 
-/* Sets type hash table */
-dictType setDictType = {
+/* Generic hash table type where keys are Redis Objects, Values
+ * dummy pointers. */
+dictType objectKeyPointerValueDictType = {
     dictEncObjHash,            /* hash function */
     NULL,                      /* key dup */
     NULL,                      /* val dup */
     dictEncObjKeyCompare,      /* key compare */
     dictObjectDestructor, /* key destructor */
     NULL                       /* val destructor */
 };
 
+/* Set dictionary type. Keys are SDS strings, values are ot used. */
+dictType setDictType = {
+    dictSdsHash,               /* hash function */
+    NULL,                      /* key dup */
+    NULL,                      /* val dup */
+    dictSdsKeyCompare,         /* key compare */
+    dictSdsDestructor,         /* key destructor */
+    NULL                       /* val destructor */
+};
+
 /* Sorted sets hash (note: a skiplist is used in addition to the hash table) */
 dictType zsetDictType = {
-    dictEncObjHash,            /* hash function */
+    dictSdsHash,               /* hash function */
     NULL,                      /* key dup */
     NULL,                      /* val dup */
-    dictEncObjKeyCompare,      /* key compare */
-    dictObjectDestructor, /* key destructor */
+    dictSdsKeyCompare,         /* key compare */
+    NULL,                      /* Note: SDS string shared & freed by skiplist */
     NULL                       /* val destructor */
 };
 
 /* Db->dict, keys are sds strings, vals are Redis objects. */
 dictType dbDictType = {
     dictSdsHash,                /* hash function */
@@ -570,54 +585,54 @@
 dictType shaScriptObjectDictType = {
     dictSdsCaseHash,            /* hash function */
     NULL,                       /* key dup */
     NULL,                       /* val dup */
     dictSdsKeyCaseCompare,      /* key compare */
     dictSdsDestructor,          /* key destructor */
-    dictObjectDestructor   /* val destructor */
+    dictObjectDestructor        /* val destructor */
 };
 
 /* Db->expires */
 dictType keyptrDictType = {
-    dictSdsHash,               /* hash function */
-    NULL,                      /* key dup */
-    NULL,                      /* val dup */
-    dictSdsKeyCompare,         /* key compare */
-    NULL,                      /* key destructor */
-    NULL                       /* val destructor */
+    dictSdsHash,                /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictSdsKeyCompare,          /* key compare */
+    NULL,                       /* key destructor */
+    NULL                        /* val destructor */
 };
 
 /* Command table. sds string -> command struct pointer. */
 dictType commandTableDictType = {
-    dictSdsCaseHash,           /* hash function */
-    NULL,                      /* key dup */
-    NULL,                      /* val dup */
-    dictSdsKeyCaseCompare,     /* key compare */
-    dictSdsDestructor,         /* key destructor */
-    NULL                       /* val destructor */
+    dictSdsCaseHash,            /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictSdsKeyCaseCompare,      /* key compare */
+    dictSdsDestructor,          /* key destructor */
+    NULL                        /* val destructor */
 };
 
 /* Hash type hash table (note that small hashes are represented with ziplists) */
 dictType hashDictType = {
-    dictEncObjHash,             /* hash function */
+    dictSdsHash,                /* hash function */
     NULL,                       /* key dup */
     NULL,                       /* val dup */
-    dictEncObjKeyCompare,       /* key compare */
-    dictObjectDestructor,  /* key destructor */
-    dictObjectDestructor   /* val destructor */
+    dictSdsKeyCompare,          /* key compare */
+    dictSdsDestructor,          /* key destructor */
+    dictSdsDestructor           /* val destructor */
 };
 
 /* Keylist hash table type has unencoded redis objects as keys and
  * lists as values. It's used for blocking operations (BLPOP) and to
  * map swapped keys to a list of clients waiting for this keys to be loaded. */
 dictType keylistDictType = {
     dictObjHash,                /* hash function */
     NULL,                       /* key dup */
     NULL,                       /* val dup */
     dictObjKeyCompare,          /* key compare */
-    dictObjectDestructor,  /* key destructor */
+    dictObjectDestructor,       /* key destructor */
     dictListDestructor          /* val destructor */
 };
 
 /* Cluster nodes hash table, mapping nodes addresses 1.2.3.4:6379 to
  * clusterNode structures. */
 dictType clusterNodesDictType = {
@@ -638,12 +653,24 @@
     NULL,                       /* val dup */
     dictSdsKeyCaseCompare,      /* key compare */
     dictSdsDestructor,          /* key destructor */
     NULL                        /* val destructor */
 };
 
+/* Cluster re-addition blacklist. This maps node IDs to the time
+ * we can re-add this node. The goal is to avoid readding a removed
+ * node for some time. */
+dictType modulesDictType = {
+    dictSdsCaseHash,            /* hash function */
+    NULL,                       /* key dup */
+    NULL,                       /* val dup */
+    dictSdsKeyCaseCompare,      /* key compare */
+    dictSdsDestructor,          /* key destructor */
+    NULL                        /* val destructor */
+};
+
 /* Migrate cache dict type. */
 dictType migrateCacheDictType = {
     dictSdsHash,                /* hash function */
     NULL,                       /* key dup */
     NULL,                       /* val dup */
     dictSdsKeyCompare,          /* key compare */
@@ -714,194 +741,12 @@
     else
         dictDisableResize();
 }
 
 /* ======================= Cron: called every 100 ms ======================== */
 
-/* Helper function for the activeExpireCycle() function.
- * This function will try to expire the key that is stored in the hash table
- * entry 'de' of the 'expires' hash table of a Redis database.
- *
- * If the key is found to be expired, it is removed from the database and
- * 1 is returned. Otherwise no operation is performed and 0 is returned.
- *
- * When a key is expired, server.stat_expiredkeys is incremented.
- *
- * The parameter 'now' is the current time in milliseconds as is passed
- * to the function to avoid too many gettimeofday() syscalls. */
-int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {
-    long long t = dictGetSignedIntegerVal(de);
-    if (now > t) {
-        sds key = dictGetKey(de);
-        robj *keyobj = createStringObject(key,sdslen(key));
-
-        propagateExpire(db,keyobj);
-        dbDelete(db,keyobj);
-        notifyKeyspaceEvent(NOTIFY_EXPIRED,
-            "expired",keyobj,db->id);
-        decrRefCount(keyobj);
-        server.stat_expiredkeys++;
-        return 1;
-    } else {
-        return 0;
-    }
-}
-
-/* Try to expire a few timed out keys. The algorithm used is adaptive and
- * will use few CPU cycles if there are few expiring keys, otherwise
- * it will get more aggressive to avoid that too much memory is used by
- * keys that can be removed from the keyspace.
- *
- * No more than CRON_DBS_PER_CALL databases are tested at every
- * iteration.
- *
- * This kind of call is used when Redis detects that timelimit_exit is
- * true, so there is more work to do, and we do it more incrementally from
- * the beforeSleep() function of the event loop.
- *
- * Expire cycle type:
- *
- * If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a
- * "fast" expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION
- * microseconds, and is not repeated again before the same amount of time.
- *
- * If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is
- * executed, where the time limit is a percentage of the REDIS_HZ period
- * as specified by the REDIS_EXPIRELOOKUPS_TIME_PERC define. */
-
-void activeExpireCycle(int type) {
-    /* This function has some global state in order to continue the work
-     * incrementally across calls. */
-    static unsigned int current_db = 0; /* Last DB tested. */
-    static int timelimit_exit = 0;      /* Time limit hit in previous call? */
-    static long long last_fast_cycle = 0; /* When last fast cycle ran. */
-
-    int j, iteration = 0;
-    int dbs_per_call = CRON_DBS_PER_CALL;
-    long long start = ustime(), timelimit;
-
-    /* When clients are paused the dataset should be static not just from the
-     * POV of clients not being able to write, but also from the POV of
-     * expires and evictions of keys not being performed. */
-     if (clientsArePaused()) return;
-
-    if (type == ACTIVE_EXPIRE_CYCLE_FAST) {
-        /* Don't start a fast cycle if the previous cycle did not exited
-         * for time limt. Also don't repeat a fast cycle for the same period
-         * as the fast cycle total duration itself. */
-        if (!timelimit_exit) return;
-        if (start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;
-        last_fast_cycle = start;
-    }
-
-    /* We usually should test CRON_DBS_PER_CALL per iteration, with
-     * two exceptions:
-     *
-     * 1) Don't test more DBs than we have.
-     * 2) If last time we hit the time limit, we want to scan all DBs
-     * in this iteration, as there is work to do in some DB and we don't want
-     * expired keys to use memory for too much time. */
-    if (dbs_per_call > server.dbnum || timelimit_exit)
-        dbs_per_call = server.dbnum;
-
-    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time
-     * per iteration. Since this function gets called with a frequency of
-     * server.hz times per second, the following is the max amount of
-     * microseconds we can spend in this function. */
-    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;
-    timelimit_exit = 0;
-    if (timelimit <= 0) timelimit = 1;
-
-    if (type == ACTIVE_EXPIRE_CYCLE_FAST)
-        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */
-
-    for (j = 0; j < dbs_per_call; j++) {
-        int expired;
-        redisDb *db = server.db+(current_db % server.dbnum);
-
-        /* Increment the DB now so we are sure if we run out of time
-         * in the current DB we'll restart from the next. This allows to
-         * distribute the time evenly across DBs. */
-        current_db++;
-
-        /* Continue to expire if at the end of the cycle more than 25%
-         * of the keys were expired. */
-        do {
-            unsigned long num, slots;
-            long long now, ttl_sum;
-            int ttl_samples;
-
-            /* If there is nothing to expire try next DB ASAP. */
-            if ((num = dictSize(db->expires)) == 0) {
-                db->avg_ttl = 0;
-                break;
-            }
-            slots = dictSlots(db->expires);
-            now = mstime();
-
-            /* When there are less than 1% filled slots getting random
-             * keys is expensive, so stop here waiting for better times...
-             * The dictionary will be resized asap. */
-            if (num && slots > DICT_HT_INITIAL_SIZE &&
-                (num*100/slots < 1)) break;
-
-            /* The main collection cycle. Sample random keys among keys
-             * with an expire set, checking for expired ones. */
-            expired = 0;
-            ttl_sum = 0;
-            ttl_samples = 0;
-
-            if (num > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)
-                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;
-
-            while (num--) {
-                dictEntry *de;
-                long long ttl;
-
-                if ((de = dictGetRandomKey(db->expires)) == NULL) break;
-                ttl = dictGetSignedIntegerVal(de)-now;
-                if (activeExpireCycleTryExpire(db,de,now)) expired++;
-                if (ttl > 0) {
-                    /* We want the average TTL of keys yet not expired. */
-                    ttl_sum += ttl;
-                    ttl_samples++;
-                }
-            }
-
-            /* Update the average TTL stats for this database. */
-            if (ttl_samples) {
-                long long avg_ttl = ttl_sum/ttl_samples;
-
-                /* Do a simple running average with a few samples.
-                 * We just use the current estimate with a weight of 2%
-                 * and the previous estimate with a weight of 98%. */
-                if (db->avg_ttl == 0) db->avg_ttl = avg_ttl;
-                db->avg_ttl = (db->avg_ttl/50)*49 + (avg_ttl/50);
-            }
-
-            /* We can't block forever here even if there are many keys to
-             * expire. So after a given amount of milliseconds return to the
-             * caller waiting for the other active expire cycle. */
-            iteration++;
-            if ((iteration & 0xf) == 0) { /* check once every 16 iterations. */
-                long long elapsed = ustime()-start;
-
-                latencyAddSampleIfNeeded("expire-cycle",elapsed/1000);
-                if (elapsed > timelimit) timelimit_exit = 1;
-            }
-            if (timelimit_exit) return;
-            /* We don't repeat the cycle if there are less than 25% of keys
-             * found expired in the current DB. */
-        } while (expired > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);
-    }
-}
-
-unsigned int getLRUClock(void) {
-    return (mstime()/LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;
-}
-
 /* Add a sample to the operations per second array of samples. */
 void trackInstantaneousMetric(int metric, long long current_reading) {
     long long t = mstime() - server.inst_metric[metric].last_sample_time;
     long long ops = current_reading -
                     server.inst_metric[metric].last_sample_count;
     long long ops_sec;
@@ -1026,14 +871,21 @@
 /* This function handles 'background' operations we are required to do
  * incrementally in Redis databases, such as active key expiring, resizing,
  * rehashing. */
 void databasesCron(void) {
     /* Expire keys by random sampling. Not required for slaves
      * as master will synthesize DELs for us. */
-    if (server.active_expire_enabled && server.masterhost == NULL)
+    if (server.active_expire_enabled && server.masterhost == NULL) {
         activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);
+    } else if (server.masterhost != NULL) {
+        expireSlaveKeys();
+    }
+
+    /* Defrag keys gradually. */
+    if (server.active_defrag_enabled)
+        activeDefragCycle();
 
     /* Perform hash tables rehashing if needed, but only if there are no
      * other processes saving the DB on disk. Otherwise rehashing is bad
      * as will cause a lot of copy-on-write of memory pages. */
     if (server.rdb_child_pid == -1 && server.aof_child_pid == -1) {
         /* We use global counters so if we stop the computation at a given
@@ -1070,13 +922,14 @@
 
 /* We take a cached value of the unix time in the global state because with
  * virtual memory and aging there is to store the current time in objects at
  * every object access, and accuracy is not needed. To access a global var is
  * a lot faster than calling time(NULL) */
 void updateCachedTime(void) {
-    server.unixtime = time(NULL);
+    time_t unixtime = time(NULL);
+    atomicSet(server.unixtime,unixtime);
     server.mstime = mstime();
 }
 
 /* This is our timer interrupt, called server.hz times per second.
  * Here is where we do a number of things that need to be done asynchronously.
  * For instance:
@@ -1125,13 +978,14 @@
      * to Redis. However for this to happen a given object should never be
      * touched for all the time needed to the counter to wrap, which is
      * not likely.
      *
      * Note that you can change the resolution altering the
      * LRU_CLOCK_RESOLUTION define. */
-    server.lruclock = getLRUClock();
+    unsigned long lruclock = getLRUClock();
+    atomicSet(server.lruclock,lruclock);
 
     /* Record the max memory used since the server was started. */
     if (zmalloc_used_memory() > server.stat_peak_memory)
         server.stat_peak_memory = zmalloc_used_memory();
 
     /* Sample the RSS here since this is a relatively slow call. */
@@ -1203,22 +1057,25 @@
                     "rdb_child_pid = %d, aof_child_pid = %d",
                     strerror(errno),
                     (int) server.rdb_child_pid,
                     (int) server.aof_child_pid);
             } else if (pid == server.rdb_child_pid) {
                 backgroundSaveDoneHandler(exitcode,bysignal);
+                if (!bysignal && exitcode == 0) receiveChildInfo();
             } else if (pid == server.aof_child_pid) {
                 backgroundRewriteDoneHandler(exitcode,bysignal);
+                if (!bysignal && exitcode == 0) receiveChildInfo();
             } else {
                 if (!ldbRemoveChild(pid)) {
                     serverLog(LL_WARNING,
                         "Warning, detected child with unmatched pid: %ld",
                         (long)pid);
                 }
             }
             updateDictResizePolicy();
+            closeChildInfoPipe();
         }
     } else {
         /* If there is not a background saving/rewrite in progress check if
          * we have to save/rewrite now */
          for (j = 0; j < server.saveparamslen; j++) {
             struct saveparam *sp = server.saveparams+j;
@@ -1232,13 +1089,13 @@
                 (server.unixtime-server.lastbgsave_try >
                  CONFIG_BGSAVE_RETRY_DELAY ||
                  server.lastbgsave_status == C_OK))
             {
                 serverLog(LL_NOTICE,"%d changes in %d seconds. Saving...",
                     sp->changes, (int)sp->seconds);
-                rdbSaveBackground(server.rdb_filename);
+                rdbSaveBackground(server.rdb_filename,NULL);
                 break;
             }
          }
 
          /* Trigger an AOF rewrite if needed */
          if (server.rdb_child_pid == -1 &&
@@ -1271,13 +1128,13 @@
     }
 
     /* Close clients that need to be closed asynchronous */
     freeClientsInAsyncFreeQueue();
 
     /* Clear the paused clients flag if needed. */
-    clientsArePaused(); /* Don't check return value, just use the side effect. */
+    clientsArePaused(); /* Don't check return value, just use the side effect.*/
 
     /* Replication cron function -- used to reconnect to master,
      * detect transfer failures, start background RDB transfers and so forth. */
     run_with_period(1000) replicationCron();
 
     /* Run the Redis Cluster cron. */
@@ -1304,13 +1161,13 @@
      * because we want to give priority to RDB savings for replication. */
     if (server.rdb_child_pid == -1 && server.aof_child_pid == -1 &&
         server.rdb_bgsave_scheduled &&
         (server.unixtime-server.lastbgsave_try > CONFIG_BGSAVE_RETRY_DELAY ||
          server.lastbgsave_status == C_OK))
     {
-        if (rdbSaveBackground(server.rdb_filename) == C_OK)
+        if (rdbSaveBackground(server.rdb_filename,NULL) == C_OK)
             server.rdb_bgsave_scheduled = 0;
     }
 
     server.cronloops++;
     return 1000/server.hz;
 }
@@ -1349,21 +1206,38 @@
 
     /* Unblock all the clients blocked for synchronous replication
      * in WAIT. */
     if (listLength(server.clients_waiting_acks))
         processClientsWaitingReplicas();
 
+    /* Check if there are clients unblocked by modules that implement
+     * blocking commands. */
+    moduleHandleBlockedClients();
+
     /* Try to process pending commands for clients that were just unblocked. */
     if (listLength(server.unblocked_clients))
         processUnblockedClients();
 
     /* Write the AOF buffer on disk */
     flushAppendOnlyFile(0);
 
     /* Handle writes with pending output buffers. */
     handleClientsWithPendingWrites();
+
+    /* Before we are going to sleep, let the threads access the dataset by
+     * releasing the GIL. Redis main thread will not touch anything at this
+     * time. */
+    if (moduleCount()) moduleReleaseGIL();
+}
+
+/* This function is called immadiately after the event loop multiplexing
+ * API returned, and the control is going to soon return to Redis by invoking
+ * the different events callbacks. */
+void afterSleep(struct aeEventLoop *eventLoop) {
+    UNUSED(eventLoop);
+    if (moduleCount()) moduleAcquireGIL();
 }
 
 /* =========================== Server initialization ======================== */
 
 void createSharedObjects(void) {
     int j;
@@ -1397,13 +1271,13 @@
         "-LOADING Redis is loading the dataset in memory\r\n"));
     shared.slowscripterr = createObject(OBJ_STRING,sdsnew(
         "-BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.\r\n"));
     shared.masterdownerr = createObject(OBJ_STRING,sdsnew(
         "-MASTERDOWN Link with MASTER is down and slave-serve-stale-data is set to 'no'.\r\n"));
     shared.bgsaveerr = createObject(OBJ_STRING,sdsnew(
-        "-MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data set are disabled. Please check Redis logs for details about the error.\r\n"));
+        "-MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.\r\n"));
     shared.roslaveerr = createObject(OBJ_STRING,sdsnew(
         "-READONLY You can't write against a read only slave.\r\n"));
     shared.noautherr = createObject(OBJ_STRING,sdsnew(
         "-NOAUTH Authentication required.\r\n"));
     shared.oomerr = createObject(OBJ_STRING,sdsnew(
         "-OOM command not allowed when used memory > 'maxmemory'.\r\n"));
@@ -1431,41 +1305,49 @@
     shared.pmessagebulk = createStringObject("$8\r\npmessage\r\n",14);
     shared.subscribebulk = createStringObject("$9\r\nsubscribe\r\n",15);
     shared.unsubscribebulk = createStringObject("$11\r\nunsubscribe\r\n",18);
     shared.psubscribebulk = createStringObject("$10\r\npsubscribe\r\n",17);
     shared.punsubscribebulk = createStringObject("$12\r\npunsubscribe\r\n",19);
     shared.del = createStringObject("DEL",3);
+    shared.unlink = createStringObject("UNLINK",6);
     shared.rpop = createStringObject("RPOP",4);
     shared.lpop = createStringObject("LPOP",4);
     shared.lpush = createStringObject("LPUSH",5);
     for (j = 0; j < OBJ_SHARED_INTEGERS; j++) {
-        shared.integers[j] = createObject(OBJ_STRING,(void*)(long)j);
+        shared.integers[j] =
+            makeObjectShared(createObject(OBJ_STRING,(void*)(long)j));
         shared.integers[j]->encoding = OBJ_ENCODING_INT;
     }
     for (j = 0; j < OBJ_SHARED_BULKHDR_LEN; j++) {
         shared.mbulkhdr[j] = createObject(OBJ_STRING,
             sdscatprintf(sdsempty(),"*%d\r\n",j));
         shared.bulkhdr[j] = createObject(OBJ_STRING,
             sdscatprintf(sdsempty(),"$%d\r\n",j));
     }
     /* The following two shared objects, minstring and maxstrings, are not
      * actually used for their value but as a special object meaning
      * respectively the minimum possible string and the maximum possible
      * string in string comparisons for the ZRANGEBYLEX command. */
-    shared.minstring = createStringObject("minstring",9);
-    shared.maxstring = createStringObject("maxstring",9);
+    shared.minstring = sdsnew("minstring");
+    shared.maxstring = sdsnew("maxstring");
 }
 
 void initServerConfig(void) {
     int j;
 
+    pthread_mutex_init(&server.next_client_id_mutex,NULL);
+    pthread_mutex_init(&server.lruclock_mutex,NULL);
+    pthread_mutex_init(&server.unixtime_mutex,NULL);
+
     getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);
+    server.runid[CONFIG_RUN_ID_SIZE] = '\0';
+    changeReplicationId();
+    clearReplicationId2();
     server.configfile = NULL;
     server.executable = NULL;
     server.hz = CONFIG_DEFAULT_HZ;
-    server.runid[CONFIG_RUN_ID_SIZE] = '\0';
     server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
     server.port = CONFIG_DEFAULT_SERVER_PORT;
     server.tcp_backlog = CONFIG_DEFAULT_TCP_BACKLOG;
     server.bindaddr_count = 0;
     server.unixsocket = NULL;
     server.unixsocketperm = CONFIG_DEFAULT_UNIX_SOCKET_PERM;
@@ -1474,12 +1356,18 @@
     server.protected_mode = CONFIG_DEFAULT_PROTECTED_MODE;
     server.dbnum = CONFIG_DEFAULT_DBNUM;
     server.verbosity = CONFIG_DEFAULT_VERBOSITY;
     server.maxidletime = CONFIG_DEFAULT_CLIENT_TIMEOUT;
     server.tcpkeepalive = CONFIG_DEFAULT_TCP_KEEPALIVE;
     server.active_expire_enabled = 1;
+    server.active_defrag_enabled = CONFIG_DEFAULT_ACTIVE_DEFRAG;
+    server.active_defrag_ignore_bytes = CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES;
+    server.active_defrag_threshold_lower = CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER;
+    server.active_defrag_threshold_upper = CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER;
+    server.active_defrag_cycle_min = CONFIG_DEFAULT_DEFRAG_CYCLE_MIN;
+    server.active_defrag_cycle_max = CONFIG_DEFAULT_DEFRAG_CYCLE_MAX;
     server.client_max_querybuf_len = PROTO_MAX_QUERYBUF_LEN;
     server.saveparams = NULL;
     server.loading = 0;
     server.logfile = zstrdup(CONFIG_DEFAULT_LOGFILE);
     server.syslog_enabled = CONFIG_DEFAULT_SYSLOG_ENABLED;
     server.syslog_ident = zstrdup(CONFIG_DEFAULT_SYSLOG_IDENT);
@@ -1501,56 +1389,65 @@
     server.aof_delayed_fsync = 0;
     server.aof_fd = -1;
     server.aof_selected_db = -1; /* Make sure the first time will not match */
     server.aof_flush_postponed_start = 0;
     server.aof_rewrite_incremental_fsync = CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC;
     server.aof_load_truncated = CONFIG_DEFAULT_AOF_LOAD_TRUNCATED;
+    server.aof_use_rdb_preamble = CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE;
     server.pidfile = NULL;
     server.rdb_filename = zstrdup(CONFIG_DEFAULT_RDB_FILENAME);
     server.aof_filename = zstrdup(CONFIG_DEFAULT_AOF_FILENAME);
     server.requirepass = NULL;
     server.rdb_compression = CONFIG_DEFAULT_RDB_COMPRESSION;
     server.rdb_checksum = CONFIG_DEFAULT_RDB_CHECKSUM;
     server.stop_writes_on_bgsave_err = CONFIG_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR;
     server.activerehashing = CONFIG_DEFAULT_ACTIVE_REHASHING;
+    server.active_defrag_running = 0;
     server.notify_keyspace_events = 0;
     server.maxclients = CONFIG_DEFAULT_MAX_CLIENTS;
     server.bpop_blocked_clients = 0;
     server.maxmemory = CONFIG_DEFAULT_MAXMEMORY;
     server.maxmemory_policy = CONFIG_DEFAULT_MAXMEMORY_POLICY;
     server.maxmemory_samples = CONFIG_DEFAULT_MAXMEMORY_SAMPLES;
+    server.lfu_log_factor = CONFIG_DEFAULT_LFU_LOG_FACTOR;
+    server.lfu_decay_time = CONFIG_DEFAULT_LFU_DECAY_TIME;
     server.hash_max_ziplist_entries = OBJ_HASH_MAX_ZIPLIST_ENTRIES;
     server.hash_max_ziplist_value = OBJ_HASH_MAX_ZIPLIST_VALUE;
     server.list_max_ziplist_size = OBJ_LIST_MAX_ZIPLIST_SIZE;
     server.list_compress_depth = OBJ_LIST_COMPRESS_DEPTH;
     server.set_max_intset_entries = OBJ_SET_MAX_INTSET_ENTRIES;
     server.zset_max_ziplist_entries = OBJ_ZSET_MAX_ZIPLIST_ENTRIES;
     server.zset_max_ziplist_value = OBJ_ZSET_MAX_ZIPLIST_VALUE;
     server.hll_sparse_max_bytes = CONFIG_DEFAULT_HLL_SPARSE_MAX_BYTES;
     server.shutdown_asap = 0;
-    server.repl_ping_slave_period = CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD;
-    server.repl_timeout = CONFIG_DEFAULT_REPL_TIMEOUT;
-    server.repl_min_slaves_to_write = CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE;
-    server.repl_min_slaves_max_lag = CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG;
     server.cluster_enabled = 0;
     server.cluster_node_timeout = CLUSTER_DEFAULT_NODE_TIMEOUT;
     server.cluster_migration_barrier = CLUSTER_DEFAULT_MIGRATION_BARRIER;
     server.cluster_slave_validity_factor = CLUSTER_DEFAULT_SLAVE_VALIDITY;
     server.cluster_require_full_coverage = CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE;
     server.cluster_configfile = zstrdup(CONFIG_DEFAULT_CLUSTER_CONFIG_FILE);
+    server.cluster_announce_ip = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP;
+    server.cluster_announce_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT;
+    server.cluster_announce_bus_port = CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT;
     server.migrate_cached_sockets = dictCreate(&migrateCacheDictType,NULL);
     server.next_client_id = 1; /* Client IDs, start from 1 .*/
     server.loading_process_events_interval_bytes = (1024*1024*2);
+    server.lazyfree_lazy_eviction = CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION;
+    server.lazyfree_lazy_expire = CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE;
+    server.lazyfree_lazy_server_del = CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL;
+    server.always_show_logo = CONFIG_DEFAULT_ALWAYS_SHOW_LOGO;
     server.lua_time_limit = LUA_SCRIPT_TIME_LIMIT;
 
-    server.lruclock = getLRUClock();
+    unsigned int lruclock = getLRUClock();
+    atomicSet(server.lruclock,lruclock);
     resetServerSaveParams();
 
     appendServerSaveParams(60*60,1);  /* save after 1 hour and 1 change */
     appendServerSaveParams(300,100);  /* save after 5 minutes and 100 changes */
     appendServerSaveParams(60,10000); /* save after 1 minute and 10000 changes */
+
     /* Replication related */
     server.masterauth = NULL;
     server.masterhost = NULL;
     server.masterport = 6379;
     server.master = NULL;
     server.cached_master = NULL;
@@ -1551,21 +1448,26 @@
     /* Replication related */
     server.masterauth = NULL;
     server.masterhost = NULL;
     server.masterport = 6379;
     server.master = NULL;
     server.cached_master = NULL;
-    server.repl_master_initial_offset = -1;
+    server.master_initial_offset = -1;
     server.repl_state = REPL_STATE_NONE;
     server.repl_syncio_timeout = CONFIG_REPL_SYNCIO_TIMEOUT;
     server.repl_serve_stale_data = CONFIG_DEFAULT_SLAVE_SERVE_STALE_DATA;
     server.repl_slave_ro = CONFIG_DEFAULT_SLAVE_READ_ONLY;
+    server.repl_slave_lazy_flush = CONFIG_DEFAULT_SLAVE_LAZY_FLUSH;
     server.repl_down_since = 0; /* Never connected, repl is down since EVER. */
     server.repl_disable_tcp_nodelay = CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY;
     server.repl_diskless_sync = CONFIG_DEFAULT_REPL_DISKLESS_SYNC;
     server.repl_diskless_sync_delay = CONFIG_DEFAULT_REPL_DISKLESS_SYNC_DELAY;
+    server.repl_ping_slave_period = CONFIG_DEFAULT_REPL_PING_SLAVE_PERIOD;
+    server.repl_timeout = CONFIG_DEFAULT_REPL_TIMEOUT;
+    server.repl_min_slaves_to_write = CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE;
+    server.repl_min_slaves_max_lag = CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG;
     server.slave_priority = CONFIG_DEFAULT_SLAVE_PRIORITY;
     server.slave_announce_ip = CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP;
     server.slave_announce_port = CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT;
     server.master_repl_offset = 0;
 
     /* Replication partial resync backlog */
@@ -1650,13 +1552,17 @@
     /* Perform a proper shutdown. */
     if (flags & RESTART_SERVER_GRACEFULLY &&
         prepareForShutdown(SHUTDOWN_NOFLAGS) != C_OK) return C_ERR;
 
     /* Close all file descriptors, with the exception of stdin, stdout, strerr
      * which are useful if we restart a Redis server which is not daemonized. */
-    for (j = 3; j < (int)server.maxclients + 1024; j++) close(j);
+    for (j = 3; j < (int)server.maxclients + 1024; j++) {
+        /* Test the descriptor validity before closing it, otherwise
+         * Valgrind issues a warning on close(). */
+        if (fcntl(j,F_GETFD) != -1) close(j);
+    }
 
     /* Execute the server with the original command line. */
     if (delay) usleep(delay*1000);
     execve(server.executable,server.exec_argv,environ);
 
     /* If an error occurred here, there is nothing we can do, but exit. */
@@ -1709,15 +1615,18 @@
 
             /* Assume that the limit we get initially is still valid if
              * our last try was even lower. */
             if (bestlimit < oldlimit) bestlimit = oldlimit;
 
             if (bestlimit < maxfiles) {
-                int old_maxclients = server.maxclients;
+                unsigned int old_maxclients = server.maxclients;
                 server.maxclients = bestlimit-CONFIG_MIN_RESERVED_FDS;
-                if (server.maxclients < 1) {
+                /* maxclients is unsigned so may overflow: in order
+                 * to check if maxclients is now logically less than 1
+                 * we test indirectly via bestlimit. */
+                if (bestlimit <= CONFIG_MIN_RESERVED_FDS) {
                     serverLog(LL_WARNING,"Your current 'ulimit -n' "
                         "of %llu is not enough for the server to start. "
                         "Please increase your open file limit to at least "
                         "%llu. Exiting.",
                         (unsigned long long) oldlimit,
                         (unsigned long long) maxfiles);
@@ -1848,12 +1757,16 @@
     server.stat_numcommands = 0;
     server.stat_numconnections = 0;
     server.stat_expiredkeys = 0;
     server.stat_evictedkeys = 0;
     server.stat_keyspace_misses = 0;
     server.stat_keyspace_hits = 0;
+    server.stat_active_defrag_hits = 0;
+    server.stat_active_defrag_misses = 0;
+    server.stat_active_defrag_key_hits = 0;
+    server.stat_active_defrag_key_misses = 0;
     server.stat_fork_time = 0;
     server.stat_fork_rate = 0;
     server.stat_rejected_conn = 0;
     server.stat_sync_full = 0;
     server.stat_sync_partial_ok = 0;
     server.stat_sync_partial_err = 0;
@@ -1896,12 +1809,18 @@
     server.clients_paused = 0;
     server.system_memory_size = zmalloc_get_memory_size();
 
     createSharedObjects();
     adjustOpenFilesLimit();
     server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);
+    if (server.el == NULL) {
+        serverLog(LL_WARNING,
+            "Failed creating the event loop. Error message: '%s'",
+            strerror(errno));
+        exit(1);
+    }
     server.db = zmalloc(sizeof(redisDb)*server.dbnum);
 
     /* Open the TCP listening socket for the user commands. */
     if (server.port != 0 &&
         listenToPort(server.port,server.ipfd,&server.ipfd_count) == C_ERR)
         exit(1);
@@ -1926,49 +1845,55 @@
 
     /* Create the Redis databases, and initialize other internal state. */
     for (j = 0; j < server.dbnum; j++) {
         server.db[j].dict = dictCreate(&dbDictType,NULL);
         server.db[j].expires = dictCreate(&keyptrDictType,NULL);
         server.db[j].blocking_keys = dictCreate(&keylistDictType,NULL);
-        server.db[j].ready_keys = dictCreate(&setDictType,NULL);
+        server.db[j].ready_keys = dictCreate(&objectKeyPointerValueDictType,NULL);
         server.db[j].watched_keys = dictCreate(&keylistDictType,NULL);
-        server.db[j].eviction_pool = evictionPoolAlloc();
         server.db[j].id = j;
         server.db[j].avg_ttl = 0;
     }
+    evictionPoolAlloc(); /* Initialize the LRU keys pool. */
     server.pubsub_channels = dictCreate(&keylistDictType,NULL);
     server.pubsub_patterns = listCreate();
     listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);
     listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);
     server.cronloops = 0;
     server.rdb_child_pid = -1;
     server.aof_child_pid = -1;
     server.rdb_child_type = RDB_CHILD_TYPE_NONE;
     server.rdb_bgsave_scheduled = 0;
+    server.child_info_pipe[0] = -1;
+    server.child_info_pipe[1] = -1;
+    server.child_info_data.magic = 0;
     aofRewriteBufferReset();
     server.aof_buf = sdsempty();
     server.lastsave = time(NULL); /* At startup we consider the DB saved. */
     server.lastbgsave_try = 0;    /* At startup we never tried to BGSAVE. */
     server.rdb_save_time_last = -1;
     server.rdb_save_time_start = -1;
     server.dirty = 0;
     resetServerStats();
     /* A few stats we don't want to reset: server startup time, and peak mem. */
     server.stat_starttime = time(NULL);
     server.stat_peak_memory = 0;
+    server.stat_rdb_cow_bytes = 0;
+    server.stat_aof_cow_bytes = 0;
     server.resident_set_size = 0;
     server.lastbgsave_status = C_OK;
     server.aof_last_write_status = C_OK;
     server.aof_last_write_errno = 0;
     server.repl_good_slaves_count = 0;
     updateCachedTime();
 
-    /* Create the serverCron() time event, that's our main way to process
-     * background operations. */
-    if(aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
-        serverPanic("Can't create the serverCron time event.");
+    /* Create the timer callback, this is our way to process many background
+     * operations incrementally, like clients timeout, eviction of unaccessed
+     * expired keys and so forth. */
+    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
+        serverPanic("Can't create event loop timers.");
         exit(1);
     }
 
     /* Create an event handler for accepting new connections in TCP and Unix
      * domain sockets. */
     for (j = 0; j < server.ipfd_count; j++) {
@@ -1979,12 +1904,22 @@
                     "Unrecoverable error creating server.ipfd file event.");
             }
     }
     if (server.sofd > 0 && aeCreateFileEvent(server.el,server.sofd,AE_READABLE,
         acceptUnixHandler,NULL) == AE_ERR) serverPanic("Unrecoverable error creating server.sofd file event.");
 
+
+    /* Register a readable event for the pipe used to awake the event loop
+     * when a blocked client in a module needs attention. */
+    if (aeCreateFileEvent(server.el, server.module_blocked_pipe[0], AE_READABLE,
+        moduleBlockedClientPipeReadable,NULL) == AE_ERR) {
+            serverPanic(
+                "Error registering the readable event for the module "
+                "blocked clients subsystem.");
+    }
+
     /* Open the AOF file if needed. */
     if (server.aof_state == AOF_ON) {
         server.aof_fd = open(server.aof_filename,
                                O_WRONLY|O_APPEND|O_CREAT,0644);
         if (server.aof_fd == -1) {
             serverLog(LL_WARNING, "Can't open the append-only file: %s",
@@ -2006,12 +1941,13 @@
     if (server.cluster_enabled) clusterInit();
     replicationScriptCacheInit();
     scriptingInit(1);
     slowlogInit();
     latencyMonitorInit();
     bioInit();
+    server.initial_memory_usage = zmalloc_used_memory();
 }
 
 /* Populates the Redis Command Table starting from the hard coded list
  * we have on top of redis.c file. */
 void populateCommandTable(void) {
     int j;
@@ -2251,12 +2187,13 @@
         replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
     }
 
     /* Initialization: clear the flags that must be set by the command on
      * demand, and initialize the array for additional commands propagation. */
     c->flags &= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);
+    redisOpArray prev_also_propagate = server.also_propagate;
     redisOpArrayInit(&server.also_propagate);
 
     /* Call the command. */
     dirty = server.dirty;
     start = ustime();
     c->cmd->proc(c);
@@ -2282,13 +2219,13 @@
     /* Log the command into the Slow log if needed, and populate the
      * per-command statistics that we show in INFO commandstats. */
     if (flags & CMD_CALL_SLOWLOG && c->cmd->proc != execCommand) {
         char *latency_event = (c->cmd->flags & CMD_FAST) ?
                               "fast-command" : "command";
         latencyAddSampleIfNeeded(latency_event,duration/1000);
-        slowlogPushEntryIfNeeded(c->argv,c->argc,duration);
+        slowlogPushEntryIfNeeded(c,c->argv,c->argc,duration);
     }
     if (flags & CMD_CALL_STATS) {
         c->lastcmd->microseconds += duration;
         c->lastcmd->calls++;
     }
 
@@ -2346,12 +2283,13 @@
                 if (target)
                     propagate(rop->cmd,rop->dbid,rop->argv,rop->argc,target);
             }
         }
         redisOpArrayFree(&server.also_propagate);
     }
+    server.also_propagate = prev_also_propagate;
     server.stat_numcommands++;
 }
 
 /* If this function gets called we already read a whole
  * command, arguments are in the client argv/argc fields.
  * processCommand() execute the command or prepare the
@@ -2592,23 +2530,22 @@
                 return C_ERR;
             }
             serverLog(LL_WARNING,
                 "There is a child rewriting the AOF. Killing it!");
             kill(server.aof_child_pid,SIGUSR1);
         }
-        /* Append only file: flush buffers and fsync() the AOF at exit */
+        /* Append only file: fsync() the AOF and exit */
         serverLog(LL_NOTICE,"Calling fsync() on the AOF file.");
-        flushAppendOnlyFile(1);
         aof_fsync(server.aof_fd);
     }
 
     /* Create a new RDB file before exiting. */
     if ((server.saveparamslen > 0 && !nosave) || save) {
         serverLog(LL_NOTICE,"Saving the final RDB snapshot before exiting.");
         /* Snapshotting. Perform a SYNC SAVE and exit */
-        if (rdbSave(server.rdb_filename) != C_OK) {
+        if (rdbSave(server.rdb_filename,NULL) != C_OK) {
             /* Ooops.. error saving! The best we can do is to continue
              * operating. Note that if there was a background saving process,
              * in the next cron() Redis will be notified that the background
              * saving aborted, handling special stuff like slaves pending for
              * synchronization... */
             serverLog(LL_WARNING,"Error trying to save the DB, can't exit.");
@@ -2760,13 +2697,15 @@
         flagcount += addReplyCommandFlag(c,cmd,CMD_SORT_FOR_SCRIPT,"sort_for_script");
         flagcount += addReplyCommandFlag(c,cmd,CMD_LOADING, "loading");
         flagcount += addReplyCommandFlag(c,cmd,CMD_STALE, "stale");
         flagcount += addReplyCommandFlag(c,cmd,CMD_SKIP_MONITOR, "skip_monitor");
         flagcount += addReplyCommandFlag(c,cmd,CMD_ASKING, "asking");
         flagcount += addReplyCommandFlag(c,cmd,CMD_FAST, "fast");
-        if (cmd->getkeys_proc) {
+        if ((cmd->getkeys_proc && !(cmd->flags & CMD_MODULE)) ||
+            cmd->flags & CMD_MODULE_GETKEYS)
+        {
             addReplyStatus(c, "movablekeys");
             flagcount += 1;
         }
         setDeferredMultiBulkLength(c, flaglen, flagcount);
 
         addReplyLongLong(c, cmd->firstkey);
@@ -2884,22 +2823,25 @@
         if (call_uname) {
             /* Uname can be slow and is always the same output. Cache it. */
             uname(&name);
             call_uname = 0;
         }
 
+        unsigned int lruclock;
+        atomicGet(server.lruclock,lruclock);
         info = sdscatprintf(info,
             "# Server\r\n"
             "redis_version:%s\r\n"
             "redis_git_sha1:%s\r\n"
             "redis_git_dirty:%d\r\n"
             "redis_build_id:%llx\r\n"
             "redis_mode:%s\r\n"
             "os:%s %s %s\r\n"
             "arch_bits:%d\r\n"
             "multiplexing_api:%s\r\n"
+            "atomicvar_api:%s\r\n"
             "gcc_version:%d.%d.%d\r\n"
             "process_id:%ld\r\n"
             "run_id:%s\r\n"
             "tcp_port:%d\r\n"
             "uptime_in_seconds:%jd\r\n"
             "uptime_in_days:%jd\r\n"
@@ -2912,24 +2854,25 @@
             strtol(redisGitDirty(),NULL,10) > 0,
             (unsigned long long) redisBuildId(),
             mode,
             name.sysname, name.release, name.machine,
             server.arch_bits,
             aeGetApiName(),
+            REDIS_ATOMIC_API,
 #ifdef __GNUC__
             __GNUC__,__GNUC_MINOR__,__GNUC_PATCHLEVEL__,
 #else
             0,0,0,
 #endif
             (long) getpid(),
             server.runid,
             server.port,
             (intmax_t)uptime,
             (intmax_t)(uptime/(3600*24)),
             server.hz,
-            (unsigned long) server.lruclock,
+            (unsigned long) lruclock,
             server.executable ? server.executable : "",
             server.configfile ? server.configfile : "");
     }
 
     /* Clients */
     if (allsections || defsections || !strcasecmp(section,"clients")) {
@@ -2954,12 +2897,13 @@
         char used_memory_rss_hmem[64];
         char maxmemory_hmem[64];
         size_t zmalloc_used = zmalloc_used_memory();
         size_t total_system_mem = server.system_memory_size;
         const char *evict_policy = evictPolicyToString();
         long long memory_lua = (long long)lua_gc(server.lua,LUA_GCCOUNT,0)*1024;
+        struct redisMemOverhead *mh = getMemoryOverheadData();
 
         /* Peak memory is updated from time to time by serverCron() so it
          * may happen that the instantaneous value is slightly bigger than
          * the peak value. This may confuse users, so we update the peak
          * if found smaller than the current memory usage. */
         if (zmalloc_used > server.stat_peak_memory)
@@ -2978,37 +2922,52 @@
             "used_memory:%zu\r\n"
             "used_memory_human:%s\r\n"
             "used_memory_rss:%zu\r\n"
             "used_memory_rss_human:%s\r\n"
             "used_memory_peak:%zu\r\n"
             "used_memory_peak_human:%s\r\n"
+            "used_memory_peak_perc:%.2f%%\r\n"
+            "used_memory_overhead:%zu\r\n"
+            "used_memory_startup:%zu\r\n"
+            "used_memory_dataset:%zu\r\n"
+            "used_memory_dataset_perc:%.2f%%\r\n"
             "total_system_memory:%lu\r\n"
             "total_system_memory_human:%s\r\n"
             "used_memory_lua:%lld\r\n"
             "used_memory_lua_human:%s\r\n"
             "maxmemory:%lld\r\n"
             "maxmemory_human:%s\r\n"
             "maxmemory_policy:%s\r\n"
             "mem_fragmentation_ratio:%.2f\r\n"
-            "mem_allocator:%s\r\n",
+            "mem_allocator:%s\r\n"
+            "active_defrag_running:%d\r\n"
+            "lazyfree_pending_objects:%zu\r\n",
             zmalloc_used,
             hmem,
             server.resident_set_size,
             used_memory_rss_hmem,
             server.stat_peak_memory,
             peak_hmem,
+            mh->peak_perc,
+            mh->overhead_total,
+            mh->startup_allocated,
+            mh->dataset,
+            mh->dataset_perc,
             (unsigned long)total_system_mem,
             total_system_hmem,
             memory_lua,
             used_memory_lua_hmem,
             server.maxmemory,
             maxmemory_hmem,
             evict_policy,
-            zmalloc_get_fragmentation_ratio(server.resident_set_size),
-            ZMALLOC_LIB
-            );
+            mh->fragmentation,
+            ZMALLOC_LIB,
+            server.active_defrag_running,
+            lazyfreeGetPendingObjectsCount()
+        );
+        freeMemoryOverheadData(mh);
     }
 
     /* Persistence */
     if (allsections || defsections || !strcasecmp(section,"persistence")) {
         if (sections++) info = sdscat(info,"\r\n");
         info = sdscatprintf(info,
@@ -3017,35 +2976,39 @@
             "rdb_changes_since_last_save:%lld\r\n"
             "rdb_bgsave_in_progress:%d\r\n"
             "rdb_last_save_time:%jd\r\n"
             "rdb_last_bgsave_status:%s\r\n"
             "rdb_last_bgsave_time_sec:%jd\r\n"
             "rdb_current_bgsave_time_sec:%jd\r\n"
+            "rdb_last_cow_size:%zu\r\n"
             "aof_enabled:%d\r\n"
             "aof_rewrite_in_progress:%d\r\n"
             "aof_rewrite_scheduled:%d\r\n"
             "aof_last_rewrite_time_sec:%jd\r\n"
             "aof_current_rewrite_time_sec:%jd\r\n"
             "aof_last_bgrewrite_status:%s\r\n"
-            "aof_last_write_status:%s\r\n",
+            "aof_last_write_status:%s\r\n"
+            "aof_last_cow_size:%zu\r\n",
             server.loading,
             server.dirty,
             server.rdb_child_pid != -1,
             (intmax_t)server.lastsave,
             (server.lastbgsave_status == C_OK) ? "ok" : "err",
             (intmax_t)server.rdb_save_time_last,
             (intmax_t)((server.rdb_child_pid == -1) ?
                 -1 : time(NULL)-server.rdb_save_time_start),
+            server.stat_rdb_cow_bytes,
             server.aof_state != AOF_OFF,
             server.aof_child_pid != -1,
             server.aof_rewrite_scheduled,
             (intmax_t)server.aof_rewrite_time_last,
             (intmax_t)((server.aof_child_pid == -1) ?
                 -1 : time(NULL)-server.aof_rewrite_time_start),
             (server.aof_lastbgrewrite_status == C_OK) ? "ok" : "err",
-            (server.aof_last_write_status == C_OK) ? "ok" : "err");
+            (server.aof_last_write_status == C_OK) ? "ok" : "err",
+            server.stat_aof_cow_bytes);
 
         if (server.aof_state != AOF_OFF) {
             info = sdscatprintf(info,
                 "aof_current_size:%lld\r\n"
                 "aof_base_size:%lld\r\n"
                 "aof_pending_rewrite:%d\r\n"
@@ -3114,13 +3077,18 @@
             "evicted_keys:%lld\r\n"
             "keyspace_hits:%lld\r\n"
             "keyspace_misses:%lld\r\n"
             "pubsub_channels:%ld\r\n"
             "pubsub_patterns:%lu\r\n"
             "latest_fork_usec:%lld\r\n"
-            "migrate_cached_sockets:%ld\r\n",
+            "migrate_cached_sockets:%ld\r\n"
+            "slave_expires_tracked_keys:%zu\r\n"
+            "active_defrag_hits:%lld\r\n"
+            "active_defrag_misses:%lld\r\n"
+            "active_defrag_key_hits:%lld\r\n"
+            "active_defrag_key_misses:%lld\r\n",
             server.stat_numconnections,
             server.stat_numcommands,
             getInstantaneousMetric(STATS_METRIC_COMMAND),
             server.stat_net_input_bytes,
             server.stat_net_output_bytes,
             (float)getInstantaneousMetric(STATS_METRIC_NET_INPUT)/1024,
@@ -3133,13 +3101,18 @@
             server.stat_evictedkeys,
             server.stat_keyspace_hits,
             server.stat_keyspace_misses,
             dictSize(server.pubsub_channels),
             listLength(server.pubsub_patterns),
             server.stat_fork_time,
-            dictSize(server.migrate_cached_sockets));
+            dictSize(server.migrate_cached_sockets),
+            getSlaveKeyWithExpireCount(),
+            server.stat_active_defrag_hits,
+            server.stat_active_defrag_misses,
+            server.stat_active_defrag_key_hits,
+            server.stat_active_defrag_key_misses);
     }
 
     /* Replication */
     if (allsections || defsections || !strcasecmp(section,"replication")) {
         if (sections++) info = sdscat(info,"\r\n");
         info = sdscatprintf(info,
@@ -3246,18 +3219,24 @@
                     slaveid,slaveip,slave->slave_listening_port,state,
                     slave->repl_ack_off, lag);
                 slaveid++;
             }
         }
         info = sdscatprintf(info,
+            "master_replid:%s\r\n"
+            "master_replid2:%s\r\n"
             "master_repl_offset:%lld\r\n"
+            "second_repl_offset:%lld\r\n"
             "repl_backlog_active:%d\r\n"
             "repl_backlog_size:%lld\r\n"
             "repl_backlog_first_byte_offset:%lld\r\n"
             "repl_backlog_histlen:%lld\r\n",
+            server.replid,
+            server.replid2,
             server.master_repl_offset,
+            server.second_replid_offset,
             server.repl_backlog != NULL,
             server.repl_backlog_size,
             server.repl_backlog_off,
             server.repl_backlog_histlen);
     }
 
@@ -3336,310 +3315,12 @@
 
     c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);
     listAddNodeTail(server.monitors,c);
     addReply(c,shared.ok);
 }
 
-/* ============================ Maxmemory directive  ======================== */
-
-/* freeMemoryIfNeeded() gets called when 'maxmemory' is set on the config
- * file to limit the max memory used by the server, before processing a
- * command.
- *
- * The goal of the function is to free enough memory to keep Redis under the
- * configured memory limit.
- *
- * The function starts calculating how many bytes should be freed to keep
- * Redis under the limit, and enters a loop selecting the best keys to
- * evict accordingly to the configured policy.
- *
- * If all the bytes needed to return back under the limit were freed the
- * function returns C_OK, otherwise C_ERR is returned, and the caller
- * should block the execution of commands that will result in more memory
- * used by the server.
- *
- * ------------------------------------------------------------------------
- *
- * LRU approximation algorithm
- *
- * Redis uses an approximation of the LRU algorithm that runs in constant
- * memory. Every time there is a key to expire, we sample N keys (with
- * N very small, usually in around 5) to populate a pool of best keys to
- * evict of M keys (the pool size is defined by MAXMEMORY_EVICTION_POOL_SIZE).
- *
- * The N keys sampled are added in the pool of good keys to expire (the one
- * with an old access time) if they are better than one of the current keys
- * in the pool.
- *
- * After the pool is populated, the best key we have in the pool is expired.
- * However note that we don't remove keys from the pool when they are deleted
- * so the pool may contain keys that no longer exist.
- *
- * When we try to evict a key, and all the entries in the pool don't exist
- * we populate it again. This time we'll be sure that the pool has at least
- * one key that can be evicted, if there is at least one key that can be
- * evicted in the whole database. */
-
-/* Create a new eviction pool. */
-struct evictionPoolEntry *evictionPoolAlloc(void) {
-    struct evictionPoolEntry *ep;
-    int j;
-
-    ep = zmalloc(sizeof(*ep)*MAXMEMORY_EVICTION_POOL_SIZE);
-    for (j = 0; j < MAXMEMORY_EVICTION_POOL_SIZE; j++) {
-        ep[j].idle = 0;
-        ep[j].key = NULL;
-    }
-    return ep;
-}
-
-/* This is an helper function for freeMemoryIfNeeded(), it is used in order
- * to populate the evictionPool with a few entries every time we want to
- * expire a key. Keys with idle time smaller than one of the current
- * keys are added. Keys are always added if there are free entries.
- *
- * We insert keys on place in ascending order, so keys with the smaller
- * idle time are on the left, and keys with the higher idle time on the
- * right. */
-
-#define EVICTION_SAMPLES_ARRAY_SIZE 16
-void evictionPoolPopulate(dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {
-    int j, k, count;
-    dictEntry *_samples[EVICTION_SAMPLES_ARRAY_SIZE];
-    dictEntry **samples;
-
-    /* Try to use a static buffer: this function is a big hit...
-     * Note: it was actually measured that this helps. */
-    if (server.maxmemory_samples <= EVICTION_SAMPLES_ARRAY_SIZE) {
-        samples = _samples;
-    } else {
-        samples = zmalloc(sizeof(samples[0])*server.maxmemory_samples);
-    }
-
-    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);
-    for (j = 0; j < count; j++) {
-        unsigned long long idle;
-        sds key;
-        robj *o;
-        dictEntry *de;
-
-        de = samples[j];
-        key = dictGetKey(de);
-        /* If the dictionary we are sampling from is not the main
-         * dictionary (but the expires one) we need to lookup the key
-         * again in the key dictionary to obtain the value object. */
-        if (sampledict != keydict) de = dictFind(keydict, key);
-        o = dictGetVal(de);
-        idle = estimateObjectIdleTime(o);
-
-        /* Insert the element inside the pool.
-         * First, find the first empty bucket or the first populated
-         * bucket that has an idle time smaller than our idle time. */
-        k = 0;
-        while (k < MAXMEMORY_EVICTION_POOL_SIZE &&
-               pool[k].key &&
-               pool[k].idle < idle) k++;
-        if (k == 0 && pool[MAXMEMORY_EVICTION_POOL_SIZE-1].key != NULL) {
-            /* Can't insert if the element is < the worst element we have
-             * and there are no empty buckets. */
-            continue;
-        } else if (k < MAXMEMORY_EVICTION_POOL_SIZE && pool[k].key == NULL) {
-            /* Inserting into empty position. No setup needed before insert. */
-        } else {
-            /* Inserting in the middle. Now k points to the first element
-             * greater than the element to insert.  */
-            if (pool[MAXMEMORY_EVICTION_POOL_SIZE-1].key == NULL) {
-                /* Free space on the right? Insert at k shifting
-                 * all the elements from k to end to the right. */
-                memmove(pool+k+1,pool+k,
-                    sizeof(pool[0])*(MAXMEMORY_EVICTION_POOL_SIZE-k-1));
-            } else {
-                /* No free space on right? Insert at k-1 */
-                k--;
-                /* Shift all elements on the left of k (included) to the
-                 * left, so we discard the element with smaller idle time. */
-                sdsfree(pool[0].key);
-                memmove(pool,pool+1,sizeof(pool[0])*k);
-            }
-        }
-        pool[k].key = sdsdup(key);
-        pool[k].idle = idle;
-    }
-    if (samples != _samples) zfree(samples);
-}
-
-int freeMemoryIfNeeded(void) {
-    size_t mem_used, mem_tofree, mem_freed;
-    int slaves = listLength(server.slaves);
-    mstime_t latency, eviction_latency;
-
-    /* When clients are paused the dataset should be static not just from the
-     * POV of clients not being able to write, but also from the POV of
-     * expires and evictions of keys not being performed. */
-    if (clientsArePaused()) return C_OK;
-
-    /* Remove the size of slaves output buffers and AOF buffer from the
-     * count of used memory. */
-    mem_used = zmalloc_used_memory();
-    if (slaves) {
-        listIter li;
-        listNode *ln;
-
-        listRewind(server.slaves,&li);
-        while((ln = listNext(&li))) {
-            client *slave = listNodeValue(ln);
-            unsigned long obuf_bytes = getClientOutputBufferMemoryUsage(slave);
-            if (obuf_bytes > mem_used)
-                mem_used = 0;
-            else
-                mem_used -= obuf_bytes;
-        }
-    }
-    if (server.aof_state != AOF_OFF) {
-        mem_used -= sdslen(server.aof_buf);
-        mem_used -= aofRewriteBufferSize();
-    }
-
-    /* Check if we are over the memory limit. */
-    if (mem_used <= server.maxmemory) return C_OK;
-
-    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)
-        return C_ERR; /* We need to free memory, but policy forbids. */
-
-    /* Compute how much memory we need to free. */
-    mem_tofree = mem_used - server.maxmemory;
-    mem_freed = 0;
-    latencyStartMonitor(latency);
-    while (mem_freed < mem_tofree) {
-        int j, k, keys_freed = 0;
-
-        for (j = 0; j < server.dbnum; j++) {
-            long bestval = 0; /* just to prevent warning */
-            sds bestkey = NULL;
-            dictEntry *de;
-            redisDb *db = server.db+j;
-            dict *dict;
-
-            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||
-                server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM)
-            {
-                dict = server.db[j].dict;
-            } else {
-                dict = server.db[j].expires;
-            }
-            if (dictSize(dict) == 0) continue;
-
-            /* volatile-random and allkeys-random policy */
-            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||
-                server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)
-            {
-                de = dictGetRandomKey(dict);
-                bestkey = dictGetKey(de);
-            }
-
-            /* volatile-lru and allkeys-lru policy */
-            else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||
-                server.maxmemory_policy == MAXMEMORY_VOLATILE_LRU)
-            {
-                struct evictionPoolEntry *pool = db->eviction_pool;
-
-                while(bestkey == NULL) {
-                    evictionPoolPopulate(dict, db->dict, db->eviction_pool);
-                    /* Go backward from best to worst element to evict. */
-                    for (k = MAXMEMORY_EVICTION_POOL_SIZE-1; k >= 0; k--) {
-                        if (pool[k].key == NULL) continue;
-                        de = dictFind(dict,pool[k].key);
-
-                        /* Remove the entry from the pool. */
-                        sdsfree(pool[k].key);
-                        /* Shift all elements on its right to left. */
-                        memmove(pool+k,pool+k+1,
-                            sizeof(pool[0])*(MAXMEMORY_EVICTION_POOL_SIZE-k-1));
-                        /* Clear the element on the right which is empty
-                         * since we shifted one position to the left.  */
-                        pool[MAXMEMORY_EVICTION_POOL_SIZE-1].key = NULL;
-                        pool[MAXMEMORY_EVICTION_POOL_SIZE-1].idle = 0;
-
-                        /* If the key exists, is our pick. Otherwise it is
-                         * a ghost and we need to try the next element. */
-                        if (de) {
-                            bestkey = dictGetKey(de);
-                            break;
-                        } else {
-                            /* Ghost... */
-                            continue;
-                        }
-                    }
-                }
-            }
-
-            /* volatile-ttl */
-            else if (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) {
-                for (k = 0; k < server.maxmemory_samples; k++) {
-                    sds thiskey;
-                    long thisval;
-
-                    de = dictGetRandomKey(dict);
-                    thiskey = dictGetKey(de);
-                    thisval = (long) dictGetVal(de);
-
-                    /* Expire sooner (minor expire unix timestamp) is better
-                     * candidate for deletion */
-                    if (bestkey == NULL || thisval < bestval) {
-                        bestkey = thiskey;
-                        bestval = thisval;
-                    }
-                }
-            }
-
-            /* Finally remove the selected key. */
-            if (bestkey) {
-                long long delta;
-
-                robj *keyobj = createStringObject(bestkey,sdslen(bestkey));
-                propagateExpire(db,keyobj);
-                /* We compute the amount of memory freed by dbDelete() alone.
-                 * It is possible that actually the memory needed to propagate
-                 * the DEL in AOF and replication link is greater than the one
-                 * we are freeing removing the key, but we can't account for
-                 * that otherwise we would never exit the loop.
-                 *
-                 * AOF and Output buffer memory will be freed eventually so
-                 * we only care about memory used by the key space. */
-                delta = (long long) zmalloc_used_memory();
-                latencyStartMonitor(eviction_latency);
-                dbDelete(db,keyobj);
-                latencyEndMonitor(eviction_latency);
-                latencyAddSampleIfNeeded("eviction-del",eviction_latency);
-                latencyRemoveNestedEvent(latency,eviction_latency);
-                delta -= (long long) zmalloc_used_memory();
-                mem_freed += delta;
-                server.stat_evictedkeys++;
-                notifyKeyspaceEvent(NOTIFY_EVICTED, "evicted",
-                    keyobj, db->id);
-                decrRefCount(keyobj);
-                keys_freed++;
-
-                /* When the memory to free starts to be big enough, we may
-                 * start spending so much time here that is impossible to
-                 * deliver data to the slaves fast enough, so we force the
-                 * transmission here inside the loop. */
-                if (slaves) flushSlavesOutputBuffers();
-            }
-        }
-        if (!keys_freed) {
-            latencyEndMonitor(latency);
-            latencyAddSampleIfNeeded("eviction-cycle",latency);
-            return C_ERR; /* nothing to free... */
-        }
-    }
-    latencyEndMonitor(latency);
-    latencyAddSampleIfNeeded("eviction-cycle",latency);
-    return C_OK;
-}
-
 /* =================================== Main! ================================ */
 
 #ifdef __linux__
 int linuxOvercommitMemoryValue(void) {
     FILE *fp = fopen("/proc/sys/vm/overcommit_memory","r");
     char buf[64];
@@ -3728,21 +3409,24 @@
     char *mode;
 
     if (server.cluster_enabled) mode = "cluster";
     else if (server.sentinel_mode) mode = "sentinel";
     else mode = "standalone";
 
-    if (server.syslog_enabled) {
+    /* Show the ASCII logo if: log file is stdout AND stdout is a
+     * tty AND syslog logging is disabled. Also show logo if the user
+     * forced us to do so via redis.conf. */
+    int show_logo = ((!server.syslog_enabled &&
+                      server.logfile[0] == '\0' &&
+                      isatty(fileno(stdout))) ||
+                     server.always_show_logo);
+
+    if (!show_logo) {
         serverLog(LL_NOTICE,
-            "Redis %s (%s/%d) %s bit, %s mode, port %d, pid %ld ready to start.",
-            REDIS_VERSION,
-            redisGitSHA1(),
-            strtol(redisGitDirty(),NULL,10) > 0,
-            (sizeof(long) == 8) ? "64" : "32",
-            mode, server.port,
-            (long) getpid()
+            "Running mode=%s, port=%d.",
+            mode, server.port
         );
     } else {
         snprintf(buf,1024*16,ascii_logo,
             REDIS_VERSION,
             redisGitSHA1(),
             strtol(redisGitDirty(),NULL,10) > 0,
@@ -3808,13 +3492,13 @@
     return;
 }
 
 void memtest(size_t megabytes, int passes);
 
 /* Returns 1 if there is --sentinel among the arguments or if
- * argv[0] is exactly "redis-sentinel". */
+ * argv[0] contains "redis-sentinel". */
 int checkForSentinelMode(int argc, char **argv) {
     int j;
 
     if (strstr(argv[0],"redis-sentinel") != NULL) return 1;
     for (j = 1; j < argc; j++)
         if (!strcmp(argv[j],"--sentinel")) return 1;
@@ -3825,15 +3509,26 @@
 void loadDataFromDisk(void) {
     long long start = ustime();
     if (server.aof_state == AOF_ON) {
         if (loadAppendOnlyFile(server.aof_filename) == C_OK)
             serverLog(LL_NOTICE,"DB loaded from append only file: %.3f seconds",(float)(ustime()-start)/1000000);
     } else {
-        if (rdbLoad(server.rdb_filename) == C_OK) {
+        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
+        if (rdbLoad(server.rdb_filename,&rsi) == C_OK) {
             serverLog(LL_NOTICE,"DB loaded from disk: %.3f seconds",
                 (float)(ustime()-start)/1000000);
+
+            /* Restore the replication ID / offset from the RDB file. */
+            if (rsi.repl_id_is_set && rsi.repl_offset != -1) {
+                memcpy(server.replid,rsi.repl_id,sizeof(server.replid));
+                server.master_repl_offset = rsi.repl_offset;
+                /* If we are a slave, create a cached master from this
+                 * information, in order to allow partial resynchronizations
+                 * with masters. */
+                if (server.masterhost) replicationCacheMasterUsingMyself();
+            }
         } else if (errno != ENOENT) {
             serverLog(LL_WARNING,"Fatal error loading the DB: %s. Exiting.",strerror(errno));
             exit(1);
         }
     }
 }
@@ -3988,19 +3683,21 @@
 
     /* We need to initialize our libraries, and the server configuration. */
 #ifdef INIT_SETPROCTITLE_REPLACEMENT
     spt_init(argc, argv);
 #endif
     setlocale(LC_COLLATE,"");
-    zmalloc_enable_thread_safeness();
     zmalloc_set_oom_handler(redisOutOfMemoryHandler);
     srand(time(NULL)^getpid());
     gettimeofday(&tv,NULL);
-    dictSetHashFunctionSeed(tv.tv_sec^tv.tv_usec^getpid());
+    char hashseed[16];
+    getRandomHexChars(hashseed,sizeof(hashseed));
+    dictSetHashFunctionSeed((uint8_t*)hashseed);
     server.sentinel_mode = checkForSentinelMode(argc,argv);
     initServerConfig();
+    moduleInitModulesSystem();
 
     /* Store the executable path and arguments in a safe place in order
      * to be able to restart the server later. */
     server.executable = getAbsolutePath(argv[0]);
     server.exec_argv = zmalloc(sizeof(char*)*(argc+1));
     server.exec_argv[argc] = NULL;
@@ -4011,17 +3708,19 @@
      * data structures with master nodes to monitor. */
     if (server.sentinel_mode) {
         initSentinelConfig();
         initSentinel();
     }
 
-    /* Check if we need to start in redis-check-rdb mode. We just execute
+    /* Check if we need to start in redis-check-rdb/aof mode. We just execute
      * the program main. However the program is part of the Redis executable
      * so that we can easily execute an RDB check on loading errors. */
     if (strstr(argv[0],"redis-check-rdb") != NULL)
-        redis_check_rdb_main(argc,argv);
+        redis_check_rdb_main(argc,argv,NULL);
+    else if (strstr(argv[0],"redis-check-aof") != NULL)
+        redis_check_aof_main(argc,argv);
 
     if (argc >= 2) {
         j = 1; /* First option to parse in argv[] */
         sds options = sdsempty();
         char *configfile = NULL;
 
@@ -4081,14 +3780,27 @@
                 "Sentinel needs config file on disk to save state.  Exiting...");
             exit(1);
         }
         resetServerSaveParams();
         loadServerConfig(configfile,options);
         sdsfree(options);
-    } else {
+    }
+
+    serverLog(LL_WARNING, "oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo");
+    serverLog(LL_WARNING,
+        "Redis version=%s, bits=%d, commit=%s, modified=%d, pid=%d, just started",
+            REDIS_VERSION,
+            (sizeof(long) == 8) ? 64 : 32,
+            redisGitSHA1(),
+            strtol(redisGitDirty(),NULL,10) > 0,
+            (int)getpid());
+
+    if (argc == 1) {
         serverLog(LL_WARNING, "Warning: no config file specified, using the default config. In order to specify a config file use %s /path/to/%s.conf", argv[0], server.sentinel_mode ? "sentinel" : "redis");
+    } else {
+        serverLog(LL_WARNING, "Configuration loaded");
     }
 
     server.supervised = redisIsSupervised(server.supervised_mode);
     int background = server.daemonize && !server.supervised;
     if (background) daemonize();
 
@@ -4097,39 +3809,41 @@
     redisSetProcTitle(argv[0]);
     redisAsciiArt();
     checkTcpBacklogSettings();
 
     if (!server.sentinel_mode) {
         /* Things not needed when running in Sentinel mode. */
-        serverLog(LL_WARNING,"Server started, Redis version " REDIS_VERSION);
+        serverLog(LL_WARNING,"Server initialized");
     #ifdef __linux__
         linuxMemoryWarnings();
     #endif
+        moduleLoadFromQueue();
         loadDataFromDisk();
         if (server.cluster_enabled) {
             if (verifyClusterConfigWithData() == C_ERR) {
                 serverLog(LL_WARNING,
                     "You can't have keys in a DB different than DB 0 when in "
                     "Cluster mode. Exiting.");
                 exit(1);
             }
         }
         if (server.ipfd_count > 0)
-            serverLog(LL_NOTICE,"The server is now ready to accept connections on port %d", server.port);
+            serverLog(LL_NOTICE,"Ready to accept connections");
         if (server.sofd > 0)
             serverLog(LL_NOTICE,"The server is now ready to accept connections at %s", server.unixsocket);
     } else {
         sentinelIsRunning();
     }
 
     /* Warning the user about suspicious maxmemory setting. */
     if (server.maxmemory > 0 && server.maxmemory < 1024*1024) {
         serverLog(LL_WARNING,"WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?", server.maxmemory);
     }
 
     aeSetBeforeSleepProc(server.el,beforeSleep);
+    aeSetAfterSleepProc(server.el,afterSleep);
     aeMain(server.el);
     aeDeleteEventLoop(server.el);
     return 0;
 }
 
 /* The End */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.h	2017-07-14 19:28:42.000000000 +0800
@@ -30,12 +30,13 @@
 #ifndef __REDIS_H
 #define __REDIS_H
 
 #include "fmacros.h"
 #include "config.h"
 #include "solarisfixes.h"
+#include "rio.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <limits.h>
@@ -59,13 +60,15 @@
 #include "ziplist.h" /* Compact list data structure */
 #include "intset.h"  /* Compact integer set structure */
 #include "version.h" /* Version macro */
 #include "util.h"    /* Misc functions useful in many places */
 #include "latency.h" /* Latency monitor API */
 #include "sparkline.h" /* ASCII graphs API */
-#include "quicklist.h"
+#include "quicklist.h"  /* Lists are encoded as linked lists of
+                           N-elements flat arrays */
+#include "rax.h"     /* Radix tree */
 
 /* Following includes allow test functions to be called from Redis main() */
 #include "zipmap.h"
 #include "sha1.h"
 #include "endianconv.h"
 #include "crc64.h"
@@ -89,12 +92,13 @@
 #define OBJ_SHARED_INTEGERS 10000
 #define OBJ_SHARED_BULKHDR_LEN 32
 #define LOG_MAX_LEN    1024 /* Default maximum length of syslog messages */
 #define AOF_REWRITE_PERC  100
 #define AOF_REWRITE_MIN_SIZE (64*1024*1024)
 #define AOF_REWRITE_ITEMS_PER_CMD 64
+#define AOF_READ_DIFF_INTERVAL_BYTES (1024*10)
 #define CONFIG_DEFAULT_SLOWLOG_LOG_SLOWER_THAN 10000
 #define CONFIG_DEFAULT_SLOWLOG_MAX_LEN 128
 #define CONFIG_DEFAULT_MAX_CLIENTS 10000
 #define CONFIG_AUTHPASS_MAX_LEN 512
 #define CONFIG_DEFAULT_SLAVE_PRIORITY 100
 #define CONFIG_DEFAULT_REPL_TIMEOUT 60
@@ -105,12 +109,15 @@
 #define CONFIG_DEFAULT_REPL_BACKLOG_TIME_LIMIT (60*60)  /* 1 hour */
 #define CONFIG_REPL_BACKLOG_MIN_SIZE (1024*16)          /* 16k */
 #define CONFIG_BGSAVE_RETRY_DELAY 5 /* Wait a few secs before trying again. */
 #define CONFIG_DEFAULT_PID_FILE "/var/run/redis.pid"
 #define CONFIG_DEFAULT_SYSLOG_IDENT "redis"
 #define CONFIG_DEFAULT_CLUSTER_CONFIG_FILE "nodes.conf"
+#define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_IP NULL         /* Auto detect. */
+#define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_PORT 0          /* Use server.port */
+#define CONFIG_DEFAULT_CLUSTER_ANNOUNCE_BUS_PORT 0      /* Use +10000 offset. */
 #define CONFIG_DEFAULT_DAEMONIZE 0
 #define CONFIG_DEFAULT_UNIX_SOCKET_PERM 0
 #define CONFIG_DEFAULT_TCP_KEEPALIVE 300
 #define CONFIG_DEFAULT_PROTECTED_MODE 1
 #define CONFIG_DEFAULT_LOGFILE ""
 #define CONFIG_DEFAULT_SYSLOG_ENABLED 0
@@ -124,24 +131,38 @@
 #define CONFIG_DEFAULT_SLAVE_READ_ONLY 1
 #define CONFIG_DEFAULT_SLAVE_ANNOUNCE_IP NULL
 #define CONFIG_DEFAULT_SLAVE_ANNOUNCE_PORT 0
 #define CONFIG_DEFAULT_REPL_DISABLE_TCP_NODELAY 0
 #define CONFIG_DEFAULT_MAXMEMORY 0
 #define CONFIG_DEFAULT_MAXMEMORY_SAMPLES 5
+#define CONFIG_DEFAULT_LFU_LOG_FACTOR 10
+#define CONFIG_DEFAULT_LFU_DECAY_TIME 1
 #define CONFIG_DEFAULT_AOF_FILENAME "appendonly.aof"
 #define CONFIG_DEFAULT_AOF_NO_FSYNC_ON_REWRITE 0
 #define CONFIG_DEFAULT_AOF_LOAD_TRUNCATED 1
+#define CONFIG_DEFAULT_AOF_USE_RDB_PREAMBLE 0
 #define CONFIG_DEFAULT_ACTIVE_REHASHING 1
 #define CONFIG_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC 1
 #define CONFIG_DEFAULT_MIN_SLAVES_TO_WRITE 0
 #define CONFIG_DEFAULT_MIN_SLAVES_MAX_LAG 10
 #define NET_IP_STR_LEN 46 /* INET6_ADDRSTRLEN is 46, but we need to be sure */
 #define NET_PEER_ID_LEN (NET_IP_STR_LEN+32) /* Must be enough for ip:port */
 #define CONFIG_BINDADDR_MAX 16
 #define CONFIG_MIN_RESERVED_FDS 32
 #define CONFIG_DEFAULT_LATENCY_MONITOR_THRESHOLD 0
+#define CONFIG_DEFAULT_SLAVE_LAZY_FLUSH 0
+#define CONFIG_DEFAULT_LAZYFREE_LAZY_EVICTION 0
+#define CONFIG_DEFAULT_LAZYFREE_LAZY_EXPIRE 0
+#define CONFIG_DEFAULT_LAZYFREE_LAZY_SERVER_DEL 0
+#define CONFIG_DEFAULT_ALWAYS_SHOW_LOGO 0
+#define CONFIG_DEFAULT_ACTIVE_DEFRAG 0
+#define CONFIG_DEFAULT_DEFRAG_THRESHOLD_LOWER 10 /* don't defrag when fragmentation is below 10% */
+#define CONFIG_DEFAULT_DEFRAG_THRESHOLD_UPPER 100 /* maximum defrag force at 100% fragmentation */
+#define CONFIG_DEFAULT_DEFRAG_IGNORE_BYTES (100<<20) /* don't defrag if frag overhead is below 100mb */
+#define CONFIG_DEFAULT_DEFRAG_CYCLE_MIN 25 /* 25% CPU min (at lower threshold) */
+#define CONFIG_DEFAULT_DEFRAG_CYCLE_MAX 75 /* 75% CPU max (at upper threshold) */
 
 #define ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 20 /* Loopkups per loop. */
 #define ACTIVE_EXPIRE_CYCLE_FAST_DURATION 1000 /* Microseconds */
 #define ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC 25 /* CPU max % for keys collection */
 #define ACTIVE_EXPIRE_CYCLE_SLOW 0
 #define ACTIVE_EXPIRE_CYCLE_FAST 1
@@ -170,74 +191,28 @@
 
 /* Hash table parameters */
 #define HASHTABLE_MIN_FILL        10      /* Minimal hash table fill 10% */
 
 /* Command flags. Please check the command table defined in the redis.c file
  * for more information about the meaning of every flag. */
-#define CMD_WRITE 1                   /* "w" flag */
-#define CMD_READONLY 2                /* "r" flag */
-#define CMD_DENYOOM 4                 /* "m" flag */
-#define CMD_NOT_USED_1 8              /* no longer used flag */
-#define CMD_ADMIN 16                  /* "a" flag */
-#define CMD_PUBSUB 32                 /* "p" flag */
-#define CMD_NOSCRIPT  64              /* "s" flag */
-#define CMD_RANDOM 128                /* "R" flag */
-#define CMD_SORT_FOR_SCRIPT 256       /* "S" flag */
-#define CMD_LOADING 512               /* "l" flag */
-#define CMD_STALE 1024                /* "t" flag */
-#define CMD_SKIP_MONITOR 2048         /* "M" flag */
-#define CMD_ASKING 4096               /* "k" flag */
-#define CMD_FAST 8192                 /* "F" flag */
-
-/* Object types */
-#define OBJ_STRING 0
-#define OBJ_LIST 1
-#define OBJ_SET 2
-#define OBJ_ZSET 3
-#define OBJ_HASH 4
-
-/* Objects encoding. Some kind of objects like Strings and Hashes can be
- * internally represented in multiple ways. The 'encoding' field of the object
- * is set to one of this fields for this object. */
-#define OBJ_ENCODING_RAW 0     /* Raw representation */
-#define OBJ_ENCODING_INT 1     /* Encoded as integer */
-#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
-#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
-#define OBJ_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */
-#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
-#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
-#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
-#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
-#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
-
-/* Defines related to the dump file format. To store 32 bits lengths for short
- * keys requires a lot of space, so we check the most significant 2 bits of
- * the first byte to interpreter the length:
- *
- * 00|000000 => if the two MSB are 00 the len is the 6 bits of this byte
- * 01|000000 00000000 =>  01, the len is 14 byes, 6 bits + 8 bits of next byte
- * 10|000000 [32 bit integer] => if it's 10, a full 32 bit len will follow
- * 11|000000 this means: specially encoded object will follow. The six bits
- *           number specify the kind of object that follows.
- *           See the RDB_ENC_* defines.
- *
- * Lengths up to 63 are stored using a single byte, most DB keys, and may
- * values, will fit inside. */
-#define RDB_6BITLEN 0
-#define RDB_14BITLEN 1
-#define RDB_32BITLEN 2
-#define RDB_ENCVAL 3
-#define RDB_LENERR UINT_MAX
-
-/* When a length of a string object stored on disk has the first two bits
- * set, the remaining two bits specify a special encoding for the object
- * accordingly to the following defines: */
-#define RDB_ENC_INT8 0        /* 8 bit signed integer */
-#define RDB_ENC_INT16 1       /* 16 bit signed integer */
-#define RDB_ENC_INT32 2       /* 32 bit signed integer */
-#define RDB_ENC_LZF 3         /* string compressed with FASTLZ */
+#define CMD_WRITE (1<<0)            /* "w" flag */
+#define CMD_READONLY (1<<1)         /* "r" flag */
+#define CMD_DENYOOM (1<<2)          /* "m" flag */
+#define CMD_MODULE (1<<3)           /* Command exported by module. */
+#define CMD_ADMIN (1<<4)            /* "a" flag */
+#define CMD_PUBSUB (1<<5)           /* "p" flag */
+#define CMD_NOSCRIPT (1<<6)         /* "s" flag */
+#define CMD_RANDOM (1<<7)           /* "R" flag */
+#define CMD_SORT_FOR_SCRIPT (1<<8)  /* "S" flag */
+#define CMD_LOADING (1<<9)          /* "l" flag */
+#define CMD_STALE (1<<10)           /* "t" flag */
+#define CMD_SKIP_MONITOR (1<<11)    /* "M" flag */
+#define CMD_ASKING (1<<12)          /* "k" flag */
+#define CMD_FAST (1<<13)            /* "F" flag */
+#define CMD_MODULE_GETKEYS (1<<14)  /* Use the modules getkeys interface. */
+#define CMD_MODULE_NO_CLUSTER (1<<15) /* Deny on Redis Cluster. */
 
 /* AOF states */
 #define AOF_OFF 0             /* AOF is off */
 #define AOF_ON 1              /* AOF is on */
 #define AOF_WAIT_REWRITE 2    /* AOF waits rewrite to start appending */
 
@@ -269,18 +244,20 @@
                                         handler is yet not installed. */
 #define CLIENT_REPLY_OFF (1<<22)   /* Don't send replies to client. */
 #define CLIENT_REPLY_SKIP_NEXT (1<<23)  /* Set CLIENT_REPLY_SKIP for next cmd */
 #define CLIENT_REPLY_SKIP (1<<24)  /* Don't send just this reply. */
 #define CLIENT_LUA_DEBUG (1<<25)  /* Run EVAL in debug mode. */
 #define CLIENT_LUA_DEBUG_SYNC (1<<26)  /* EVAL debugging without fork() */
+#define CLIENT_MODULE (1<<27) /* Non connected client used by some module. */
 
 /* Client block type (btype field in client structure)
  * if CLIENT_BLOCKED flag is set. */
 #define BLOCKED_NONE 0    /* Not blocked, no CLIENT_BLOCKED flag set. */
 #define BLOCKED_LIST 1    /* BLPOP & co. */
 #define BLOCKED_WAIT 2    /* WAIT for synchronous replication. */
+#define BLOCKED_MODULE 3  /* Blocked by a loadable module. */
 
 /* Client request types */
 #define PROTO_REQ_INLINE 1
 #define PROTO_REQ_MULTIBULK 2
 
 /* Client classes for client limits, currently used only for
@@ -322,13 +299,14 @@
 #define SLAVE_STATE_WAIT_BGSAVE_END 7 /* Waiting RDB file creation to finish. */
 #define SLAVE_STATE_SEND_BULK 8 /* Sending RDB file to slave. */
 #define SLAVE_STATE_ONLINE 9 /* RDB file transmitted, sending just updates. */
 
 /* Slave capabilities. */
 #define SLAVE_CAPA_NONE 0
-#define SLAVE_CAPA_EOF (1<<0)   /* Can parse the RDB EOF streaming format. */
+#define SLAVE_CAPA_EOF (1<<0)    /* Can parse the RDB EOF streaming format. */
+#define SLAVE_CAPA_PSYNC2 (1<<1) /* Supports PSYNC2 protocol. */
 
 /* Synchronous read timeout - slave side */
 #define CONFIG_REPL_SYNCIO_TIMEOUT 5
 
 /* List related stuff */
 #define LIST_HEAD 0
@@ -379,19 +357,30 @@
 
 /* Sets operations codes */
 #define SET_OP_UNION 0
 #define SET_OP_DIFF 1
 #define SET_OP_INTER 2
 
-/* Redis maxmemory strategies */
-#define MAXMEMORY_VOLATILE_LRU 0
-#define MAXMEMORY_VOLATILE_TTL 1
-#define MAXMEMORY_VOLATILE_RANDOM 2
-#define MAXMEMORY_ALLKEYS_LRU 3
-#define MAXMEMORY_ALLKEYS_RANDOM 4
-#define MAXMEMORY_NO_EVICTION 5
+/* Redis maxmemory strategies. Instead of using just incremental number
+ * for this defines, we use a set of flags so that testing for certain
+ * properties common to multiple policies is faster. */
+#define MAXMEMORY_FLAG_LRU (1<<0)
+#define MAXMEMORY_FLAG_LFU (1<<1)
+#define MAXMEMORY_FLAG_ALLKEYS (1<<2)
+#define MAXMEMORY_FLAG_NO_SHARED_INTEGERS \
+    (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU)
+
+#define MAXMEMORY_VOLATILE_LRU ((0<<8)|MAXMEMORY_FLAG_LRU)
+#define MAXMEMORY_VOLATILE_LFU ((1<<8)|MAXMEMORY_FLAG_LFU)
+#define MAXMEMORY_VOLATILE_TTL (2<<8)
+#define MAXMEMORY_VOLATILE_RANDOM (3<<8)
+#define MAXMEMORY_ALLKEYS_LRU ((4<<8)|MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_ALLKEYS)
+#define MAXMEMORY_ALLKEYS_LFU ((5<<8)|MAXMEMORY_FLAG_LFU|MAXMEMORY_FLAG_ALLKEYS)
+#define MAXMEMORY_ALLKEYS_RANDOM ((6<<8)|MAXMEMORY_FLAG_ALLKEYS)
+#define MAXMEMORY_NO_EVICTION (7<<8)
+
 #define CONFIG_DEFAULT_MAXMEMORY_POLICY MAXMEMORY_NO_EVICTION
 
 /* Scripting */
 #define LUA_SCRIPT_TIME_LIMIT 5000 /* milliseconds */
 
 /* Units */
@@ -445,72 +434,188 @@
  * The actual resolution depends on server.hz. */
 #define run_with_period(_ms_) if ((_ms_ <= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))
 
 /* We can print the stacktrace, so our assert is defined this way: */
 #define serverAssertWithInfo(_c,_o,_e) ((_e)?(void)0 : (_serverAssertWithInfo(_c,_o,#_e,__FILE__,__LINE__),_exit(1)))
 #define serverAssert(_e) ((_e)?(void)0 : (_serverAssert(#_e,__FILE__,__LINE__),_exit(1)))
-#define serverPanic(_e) _serverPanic(#_e,__FILE__,__LINE__),_exit(1)
+#define serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)
 
 /*-----------------------------------------------------------------------------
  * Data types
  *----------------------------------------------------------------------------*/
 
 /* A redis object, that is a type able to hold a string / list / set */
 
 /* The actual Redis Object */
+#define OBJ_STRING 0
+#define OBJ_LIST 1
+#define OBJ_SET 2
+#define OBJ_ZSET 3
+#define OBJ_HASH 4
+
+/* The "module" object type is a special one that signals that the object
+ * is one directly managed by a Redis module. In this case the value points
+ * to a moduleValue struct, which contains the object value (which is only
+ * handled by the module itself) and the RedisModuleType struct which lists
+ * function pointers in order to serialize, deserialize, AOF-rewrite and
+ * free the object.
+ *
+ * Inside the RDB file, module types are encoded as OBJ_MODULE followed
+ * by a 64 bit module type ID, which has a 54 bits module-specific signature
+ * in order to dispatch the loading to the right module, plus a 10 bits
+ * encoding version. */
+#define OBJ_MODULE 5
+
+/* Extract encver / signature from a module type ID. */
+#define REDISMODULE_TYPE_ENCVER_BITS 10
+#define REDISMODULE_TYPE_ENCVER_MASK ((1<<REDISMODULE_TYPE_ENCVER_BITS)-1)
+#define REDISMODULE_TYPE_ENCVER(id) (id & REDISMODULE_TYPE_ENCVER_MASK)
+#define REDISMODULE_TYPE_SIGN(id) ((id & ~((uint64_t)REDISMODULE_TYPE_ENCVER_MASK)) >>REDISMODULE_TYPE_ENCVER_BITS)
+
+struct RedisModule;
+struct RedisModuleIO;
+struct RedisModuleDigest;
+struct RedisModuleCtx;
+struct redisObject;
+
+/* Each module type implementation should export a set of methods in order
+ * to serialize and deserialize the value in the RDB file, rewrite the AOF
+ * log, create the digest for "DEBUG DIGEST", and free the value when a key
+ * is deleted. */
+typedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);
+typedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);
+typedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);
+typedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);
+typedef size_t (*moduleTypeMemUsageFunc)(const void *value);
+typedef void (*moduleTypeFreeFunc)(void *value);
+
+/* The module type, which is referenced in each value of a given type, defines
+ * the methods and links to the module exporting the type. */
+typedef struct RedisModuleType {
+    uint64_t id; /* Higher 54 bits of type ID + 10 lower bits of encoding ver. */
+    struct RedisModule *module;
+    moduleTypeLoadFunc rdb_load;
+    moduleTypeSaveFunc rdb_save;
+    moduleTypeRewriteFunc aof_rewrite;
+    moduleTypeMemUsageFunc mem_usage;
+    moduleTypeDigestFunc digest;
+    moduleTypeFreeFunc free;
+    char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */
+} moduleType;
+
+/* In Redis objects 'robj' structures of type OBJ_MODULE, the value pointer
+ * is set to the following structure, referencing the moduleType structure
+ * in order to work with the value, and at the same time providing a raw
+ * pointer to the value, as created by the module commands operating with
+ * the module type.
+ *
+ * So for example in order to free such a value, it is possible to use
+ * the following code:
+ *
+ *  if (robj->type == OBJ_MODULE) {
+ *      moduleValue *mt = robj->ptr;
+ *      mt->type->free(mt->value);
+ *      zfree(mt); // We need to release this in-the-middle struct as well.
+ *  }
+ */
+typedef struct moduleValue {
+    moduleType *type;
+    void *value;
+} moduleValue;
+
+/* This is a wrapper for the 'rio' streams used inside rdb.c in Redis, so that
+ * the user does not have to take the total count of the written bytes nor
+ * to care about error conditions. */
+typedef struct RedisModuleIO {
+    size_t bytes;       /* Bytes read / written so far. */
+    rio *rio;           /* Rio stream. */
+    moduleType *type;   /* Module type doing the operation. */
+    int error;          /* True if error condition happened. */
+    int ver;            /* Module serialization version: 1 (old),
+                         * 2 (current version with opcodes annotation). */
+    struct RedisModuleCtx *ctx; /* Optional context, see RM_GetContextFromIO()*/
+} RedisModuleIO;
+
+/* Macro to initialize an IO context. Note that the 'ver' field is populated
+ * inside rdb.c according to the version of the value to load. */
+#define moduleInitIOContext(iovar,mtype,rioptr) do { \
+    iovar.rio = rioptr; \
+    iovar.type = mtype; \
+    iovar.bytes = 0; \
+    iovar.error = 0; \
+    iovar.ver = 0; \
+    iovar.ctx = NULL; \
+} while(0);
+
+/* This is a structure used to export DEBUG DIGEST capabilities to Redis
+ * modules. We want to capture both the ordered and unordered elements of
+ * a data structure, so that a digest can be created in a way that correctly
+ * reflects the values. See the DEBUG DIGEST command implementation for more
+ * background. */
+typedef struct RedisModuleDigest {
+    unsigned char o[20];    /* Ordered elements. */
+    unsigned char x[20];    /* Xored elements. */
+} RedisModuleDigest;
+
+/* Just start with a digest composed of all zero bytes. */
+#define moduleInitDigestContext(mdvar) do { \
+    memset(mdvar.o,0,sizeof(mdvar.o)); \
+    memset(mdvar.x,0,sizeof(mdvar.x)); \
+} while(0);
+
+/* Objects encoding. Some kind of objects like Strings and Hashes can be
+ * internally represented in multiple ways. The 'encoding' field of the object
+ * is set to one of this fields for this object. */
+#define OBJ_ENCODING_RAW 0     /* Raw representation */
+#define OBJ_ENCODING_INT 1     /* Encoded as integer */
+#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
+#define OBJ_ENCODING_ZIPMAP 3  /* Encoded as zipmap */
+#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */
+#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
+#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
+#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
+#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
+#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
+
 #define LRU_BITS 24
 #define LRU_CLOCK_MAX ((1<<LRU_BITS)-1) /* Max value of obj->lru */
 #define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */
+
+#define OBJ_SHARED_REFCOUNT INT_MAX
 typedef struct redisObject {
     unsigned type:4;
     unsigned encoding:4;
-    unsigned lru:LRU_BITS; /* lru time (relative to server.lruclock) */
+    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
+                            * LFU data (least significant 8 bits frequency
+                            * and most significant 16 bits decreas time). */
     int refcount;
     void *ptr;
 } robj;
 
-/* Macro used to obtain the current LRU clock.
- * If the current resolution is lower than the frequency we refresh the
- * LRU clock (as it should be in production servers) we return the
- * precomputed value, otherwise we need to resort to a system call. */
-#define LRU_CLOCK() ((1000/server.hz <= LRU_CLOCK_RESOLUTION) ? server.lruclock : getLRUClock())
-
 /* Macro used to initialize a Redis object allocated on the stack.
  * Note that this macro is taken near the structure definition to make sure
  * we'll update it when the structure is changed, to avoid bugs like
  * bug #85 introduced exactly in this way. */
 #define initStaticStringObject(_var,_ptr) do { \
     _var.refcount = 1; \
     _var.type = OBJ_STRING; \
     _var.encoding = OBJ_ENCODING_RAW; \
     _var.ptr = _ptr; \
 } while(0)
 
-/* To improve the quality of the LRU approximation we take a set of keys
- * that are good candidate for eviction across freeMemoryIfNeeded() calls.
- *
- * Entries inside the eviciton pool are taken ordered by idle time, putting
- * greater idle times to the right (ascending order).
- *
- * Empty entries have the key pointer set to NULL. */
-#define MAXMEMORY_EVICTION_POOL_SIZE 16
-struct evictionPoolEntry {
-    unsigned long long idle;    /* Object idle time. */
-    sds key;                    /* Key name. */
-};
+struct evictionPoolEntry; /* Defined in evict.c */
 
 /* Redis database representation. There are multiple databases identified
  * by integers from 0 (the default database) up to the max configured
  * database. The database number is the 'id' field in the structure. */
 typedef struct redisDb {
     dict *dict;                 /* The keyspace for this DB */
     dict *expires;              /* Timeout of keys with a timeout set */
-    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */
+    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
     dict *ready_keys;           /* Blocked keys that received a PUSH */
     dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
-    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */
     int id;                     /* Database ID */
     long long avg_ttl;          /* Average TTL, just for stats */
 } redisDb;
 
 /* Client MULTI/EXEC state */
 typedef struct multiCmd {
@@ -539,12 +644,17 @@
     robj *target;           /* The key that should receive the element,
                              * for BRPOPLPUSH. */
 
     /* BLOCKED_WAIT */
     int numreplicas;        /* Number of replicas we are waiting for ACK. */
     long long reploffset;   /* Replication offset to reach. */
+
+    /* BLOCKED_MODULE */
+    void *module_blocked_handle; /* RedisModuleBlockedClient structure.
+                                    which is opaque for the Redis core, only
+                                    handled in module.c. */
 } blockingState;
 
 /* The following structure represents a node in the server.ready_keys list,
  * where we accumulate all the keys that had clients blocked with a blocking
  * operation such as B[LR]POP, but received new data in the context of the
  * last executed command.
@@ -563,15 +673,17 @@
 /* With multiplexing we need to take per-client state.
  * Clients are taken in a linked list. */
 typedef struct client {
     uint64_t id;            /* Client incremental unique ID. */
     int fd;                 /* Client socket. */
     redisDb *db;            /* Pointer to currently SELECTed DB. */
-    int dictid;             /* ID of the currently SELECTed DB. */
     robj *name;             /* As set by CLIENT SETNAME. */
     sds querybuf;           /* Buffer we use to accumulate client queries. */
+    sds pending_querybuf;   /* If this is a master, this buffer represents the
+                               yet not applied replication stream that we
+                               are receiving from the master. */
     size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */
     int argc;               /* Num of arguments of current command. */
     robj **argv;            /* Arguments of current command. */
     struct redisCommand *cmd, *lastcmd;  /* Last command executed. */
     int reqtype;            /* Request protocol type: PROTO_REQ_* */
     int multibulklen;       /* Number of multi bulk arguments left to read. */
@@ -588,20 +700,21 @@
     int replstate;          /* Replication state if this is a slave. */
     int repl_put_online_on_ack; /* Install slave write handler on ACK. */
     int repldbfd;           /* Replication DB file descriptor. */
     off_t repldboff;        /* Replication DB file offset. */
     off_t repldbsize;       /* Replication DB file size. */
     sds replpreamble;       /* Replication DB preamble. */
-    long long reploff;      /* Replication offset if this is our master. */
+    long long read_reploff; /* Read replication offset if this is a master. */
+    long long reploff;      /* Applied replication offset if this is a master. */
     long long repl_ack_off; /* Replication ack offset, if this is a slave. */
     long long repl_ack_time;/* Replication ack time, if this is a slave. */
     long long psync_initial_offset; /* FULLRESYNC reply offset other slaves
                                        copying this slave output buffer
                                        should use. */
-    char replrunid[CONFIG_RUN_ID_SIZE+1]; /* Master run id if is a master. */
-    int slave_listening_port; /* As configured with: REPLCONF listening-port */
+    char replid[CONFIG_RUN_ID_SIZE+1]; /* Master replication ID (if master). */
+    int slave_listening_port; /* As configured with: SLAVECONF listening-port */
     char slave_ip[NET_IP_STR_LEN]; /* Optionally given by REPLCONF ip-address */
     int slave_capa;         /* Slave capabilities: SLAVE_CAPA_* bitwise OR. */
     multiState mstate;      /* MULTI/EXEC state */
     int btype;              /* Type of blocking op if CLIENT_BLOCKED. */
     blockingState bpop;     /* blocking state */
     long long woff;         /* Last write global replication offset. */
@@ -617,30 +730,37 @@
 
 struct saveparam {
     time_t seconds;
     int changes;
 };
 
+struct moduleLoadQueueEntry {
+    sds path;
+    int argc;
+    robj **argv;
+};
+
 struct sharedObjectsStruct {
     robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,
     *colon, *nullbulk, *nullmultibulk, *queued,
     *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,
     *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,
     *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,
     *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,
-    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,
-    *lpush, *emptyscan, *minstring, *maxstring,
+    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,
+    *rpop, *lpop, *lpush, *emptyscan,
     *select[PROTO_SHARED_SELECT_CMDS],
     *integers[OBJ_SHARED_INTEGERS],
     *mbulkhdr[OBJ_SHARED_BULKHDR_LEN], /* "*<value>\r\n" */
     *bulkhdr[OBJ_SHARED_BULKHDR_LEN];  /* "$<value>\r\n" */
+    sds minstring, maxstring;
 };
 
 /* ZSETs use a specialized version of Skiplists */
 typedef struct zskiplistNode {
-    robj *obj;
+    sds ele;
     double score;
     struct zskiplistNode *backward;
     struct zskiplistLevel {
         struct zskiplistNode *forward;
         unsigned int span;
     } level[];
@@ -686,44 +806,102 @@
  */
 typedef struct redisOpArray {
     redisOp *ops;
     int numops;
 } redisOpArray;
 
+/* This structure is returned by the getMemoryOverheadData() function in
+ * order to return memory overhead information. */
+struct redisMemOverhead {
+    size_t peak_allocated;
+    size_t total_allocated;
+    size_t startup_allocated;
+    size_t repl_backlog;
+    size_t clients_slaves;
+    size_t clients_normal;
+    size_t aof_buffer;
+    size_t overhead_total;
+    size_t dataset;
+    size_t total_keys;
+    size_t bytes_per_key;
+    float dataset_perc;
+    float peak_perc;
+    float fragmentation;
+    size_t num_dbs;
+    struct {
+        size_t dbid;
+        size_t overhead_ht_main;
+        size_t overhead_ht_expires;
+    } *db;
+};
+
+/* This structure can be optionally passed to RDB save/load functions in
+ * order to implement additional functionalities, by storing and loading
+ * metadata to the RDB file.
+ *
+ * Currently the only use is to select a DB at load time, useful in
+ * replication in order to make sure that chained slaves (slaves of slaves)
+ * select the correct DB and are able to accept the stream coming from the
+ * top-level master. */
+typedef struct rdbSaveInfo {
+    /* Used saving and loading. */
+    int repl_stream_db;  /* DB to select in server.master client. */
+
+    /* Used only loading. */
+    int repl_id_is_set;  /* True if repl_id field is set. */
+    char repl_id[CONFIG_RUN_ID_SIZE+1];     /* Replication ID. */
+    long long repl_offset;                  /* Replication offset. */
+} rdbSaveInfo;
+
+#define RDB_SAVE_INFO_INIT {-1,0,"000000000000000000000000000000",-1}
+
 /*-----------------------------------------------------------------------------
  * Global server state
  *----------------------------------------------------------------------------*/
 
 struct clusterState;
 
 /* AIX defines hz to __hz, we don't use this define and in order to allow
  * Redis build on AIX we need to undef it. */
 #ifdef _AIX
 #undef hz
 #endif
 
+#define CHILD_INFO_MAGIC 0xC17DDA7A12345678LL
+#define CHILD_INFO_TYPE_RDB 0
+#define CHILD_INFO_TYPE_AOF 1
+
 struct redisServer {
     /* General */
     pid_t pid;                  /* Main process pid. */
     char *configfile;           /* Absolute config file path, or NULL */
     char *executable;           /* Absolute executable file path. */
     char **exec_argv;           /* Executable argv vector (copy). */
     int hz;                     /* serverCron() calls frequency in hertz */
     redisDb *db;
     dict *commands;             /* Command table */
     dict *orig_commands;        /* Command table before command renaming. */
     aeEventLoop *el;
-    unsigned lruclock:LRU_BITS; /* Clock for LRU eviction */
+    unsigned int lruclock;      /* Clock for LRU eviction */
     int shutdown_asap;          /* SHUTDOWN needed ASAP */
     int activerehashing;        /* Incremental rehash in serverCron() */
+    int active_defrag_running;  /* Active defragmentation running (holds current scan aggressiveness) */
     char *requirepass;          /* Pass for AUTH command, or NULL */
     char *pidfile;              /* PID file path */
     int arch_bits;              /* 32 or 64 depending on sizeof(long) */
     int cronloops;              /* Number of times the cron function run */
     char runid[CONFIG_RUN_ID_SIZE+1];  /* ID always different at every exec. */
     int sentinel_mode;          /* True if this instance is a Sentinel. */
+    size_t initial_memory_usage; /* Bytes used after initialization. */
+    int always_show_logo;       /* Show logo even for non-stdout logging. */
+    /* Modules */
+    dict *moduleapi;            /* Exported APIs dictionary for modules. */
+    list *loadmodule_queue;     /* List of modules to load at startup. */
+    int module_blocked_pipe[2]; /* Pipe used to awake the event loop if a
+                                   client blocked on a module command needs
+                                   to be processed. */
     /* Networking */
     int port;                   /* TCP listening port */
     int tcp_backlog;            /* TCP listen() backlog */
     char *bindaddr[CONFIG_BINDADDR_MAX]; /* Addresses we should bind to */
     int bindaddr_count;         /* Number of addresses in server.bindaddr[] */
     char *unixsocket;           /* UNIX socket path */
@@ -759,12 +937,16 @@
     long long stat_numcommands;     /* Number of processed commands */
     long long stat_numconnections;  /* Number of connections received */
     long long stat_expiredkeys;     /* Number of expired keys */
     long long stat_evictedkeys;     /* Number of evicted keys (maxmemory) */
     long long stat_keyspace_hits;   /* Number of successful lookups of keys */
     long long stat_keyspace_misses; /* Number of failed lookups of keys */
+    long long stat_active_defrag_hits;      /* number of allocations moved */
+    long long stat_active_defrag_misses;    /* number of allocations scanned but not moved */
+    long long stat_active_defrag_key_hits;  /* number of keys with moved allocations */
+    long long stat_active_defrag_key_misses;/* number of keys scanned and not moved */
     size_t stat_peak_memory;        /* Max used memory record */
     long long stat_fork_time;       /* Time needed to perform latest fork() */
     double stat_fork_rate;          /* Fork rate in GB/sec. */
     long long stat_rejected_conn;   /* Clients rejected because of maxclients */
     long long stat_sync_full;       /* Number of full resyncs with slaves. */
     long long stat_sync_partial_ok; /* Number of accepted PSYNC requests. */
@@ -773,12 +955,14 @@
     long long slowlog_entry_id;     /* SLOWLOG current entry ID */
     long long slowlog_log_slower_than; /* SLOWLOG time limit (to get logged) */
     unsigned long slowlog_max_len;     /* SLOWLOG max number of items logged */
     size_t resident_set_size;       /* RSS sampled in serverCron(). */
     long long stat_net_input_bytes; /* Bytes read from network. */
     long long stat_net_output_bytes; /* Bytes written to network. */
+    size_t stat_rdb_cow_bytes;      /* Copy on write bytes during RDB saving. */
+    size_t stat_aof_cow_bytes;      /* Copy on write bytes during AOF rewrite. */
     /* The following two are used to track instantaneous metrics, like
      * number of operations per second, network traffic. */
     struct {
         long long last_sample_time; /* Timestamp of last sample in ms */
         long long last_sample_count;/* Count in last sample */
         long long samples[STATS_METRIC_SAMPLES];
@@ -786,12 +970,18 @@
     } inst_metric[STATS_METRIC_COUNT];
     /* Configuration */
     int verbosity;                  /* Loglevel in redis.conf */
     int maxidletime;                /* Client timeout in seconds */
     int tcpkeepalive;               /* Set SO_KEEPALIVE if non-zero. */
     int active_expire_enabled;      /* Can be disabled for testing purposes. */
+    int active_defrag_enabled;
+    size_t active_defrag_ignore_bytes; /* minimum amount of fragmentation waste to start active defrag */
+    int active_defrag_threshold_lower; /* minimum percentage of fragmentation to start active defrag */
+    int active_defrag_threshold_upper; /* maximum percentage of fragmentation at which we use maximum effort */
+    int active_defrag_cycle_min;       /* minimal effort for defrag in CPU percentage */
+    int active_defrag_cycle_max;       /* maximal effort for defrag in CPU percentage */
     size_t client_max_querybuf_len; /* Limit for client query buffer length */
     int dbnum;                      /* Total number of configured DBs */
     int supervised;                 /* 1 if supervised, 0 otherwise. */
     int supervised_mode;            /* See SUPERVISED_* */
     int daemonize;                  /* True if running as a daemon */
     clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];
@@ -817,12 +1007,13 @@
     int aof_lastbgrewrite_status;   /* C_OK or C_ERR */
     unsigned long aof_delayed_fsync;  /* delayed AOF fsync() counter */
     int aof_rewrite_incremental_fsync;/* fsync incrementally while rewriting? */
     int aof_last_write_status;      /* C_OK or C_ERR */
     int aof_last_write_errno;       /* Valid if aof_last_write_status is ERR */
     int aof_load_truncated;         /* Don't stop on unexpected AOF EOF. */
+    int aof_use_rdb_preamble;       /* Use RDB preamble on AOF rewrites. */
     /* AOF pipes used to communicate between parent and child during rewrite. */
     int aof_pipe_write_data_to_child;
     int aof_pipe_read_data_from_parent;
     int aof_pipe_write_ack_to_parent;
     int aof_pipe_read_ack_from_child;
     int aof_pipe_write_ack_to_child;
@@ -846,29 +1037,40 @@
     int rdb_bgsave_scheduled;       /* BGSAVE when possible if true. */
     int rdb_child_type;             /* Type of save by active child. */
     int lastbgsave_status;          /* C_OK or C_ERR */
     int stop_writes_on_bgsave_err;  /* Don't allow writes if can't BGSAVE */
     int rdb_pipe_write_result_to_parent; /* RDB pipes used to return the state */
     int rdb_pipe_read_result_from_child; /* of each slave in diskless SYNC. */
+    /* Pipe and data structures for child -> parent info sharing. */
+    int child_info_pipe[2];         /* Pipe used to write the child_info_data. */
+    struct {
+        int process_type;           /* AOF or RDB child? */
+        size_t cow_size;            /* Copy on write size. */
+        unsigned long long magic;   /* Magic value to make sure data is valid. */
+    } child_info_data;
     /* Propagation of commands in AOF / replication */
     redisOpArray also_propagate;    /* Additional command to propagate. */
     /* Logging */
     char *logfile;                  /* Path of log file */
     int syslog_enabled;             /* Is syslog enabled? */
     char *syslog_ident;             /* Syslog ident */
     int syslog_facility;            /* Syslog facility */
     /* Replication (master) */
+    char replid[CONFIG_RUN_ID_SIZE+1];  /* My current replication ID. */
+    char replid2[CONFIG_RUN_ID_SIZE+1]; /* replid inherited from master*/
+    long long master_repl_offset;   /* My current replication offset */
+    long long second_replid_offset; /* Accept offsets up to this for replid2. */
     int slaveseldb;                 /* Last SELECTed DB in replication output */
-    long long master_repl_offset;   /* Global replication offset */
     int repl_ping_slave_period;     /* Master pings the slave every N seconds */
     char *repl_backlog;             /* Replication backlog for partial syncs */
     long long repl_backlog_size;    /* Backlog circular buffer size */
     long long repl_backlog_histlen; /* Backlog actual data length */
-    long long repl_backlog_idx;     /* Backlog circular buffer current offset */
-    long long repl_backlog_off;     /* Replication offset of first byte in the
-                                       backlog buffer. */
+    long long repl_backlog_idx;     /* Backlog circular buffer current offset,
+                                       that is the next byte will'll write to.*/
+    long long repl_backlog_off;     /* Replication "master offset" of first
+                                       byte in the replication backlog buffer.*/
     time_t repl_backlog_time_limit; /* Time without slaves after the backlog
                                        gets released. */
     time_t repl_no_slaves_since;    /* We have no slaves since that time.
                                        Only valid if server.slaves len is 0. */
     int repl_min_slaves_to_write;   /* Min number of slaves to write. */
     int repl_min_slaves_max_lag;    /* Max lag of <count> slaves to write. */
@@ -895,26 +1097,32 @@
     int repl_slave_ro;          /* Slave is read only? */
     time_t repl_down_since; /* Unix time at which link with master went down */
     int repl_disable_tcp_nodelay;   /* Disable TCP_NODELAY after SYNC? */
     int slave_priority;             /* Reported in INFO and used by Sentinel. */
     int slave_announce_port;        /* Give the master this listening port. */
     char *slave_announce_ip;        /* Give the master this ip address. */
-    char repl_master_runid[CONFIG_RUN_ID_SIZE+1];  /* Master run id for PSYNC.*/
-    long long repl_master_initial_offset;         /* Master PSYNC offset. */
+    /* The following two fields is where we store master PSYNC replid/offset
+     * while the PSYNC is in progress. At the end we'll copy the fields into
+     * the server->master client structure. */
+    char master_replid[CONFIG_RUN_ID_SIZE+1];  /* Master PSYNC runid. */
+    long long master_initial_offset;           /* Master PSYNC offset. */
+    int repl_slave_lazy_flush;          /* Lazy FLUSHALL before loading DB? */
     /* Replication script cache. */
     dict *repl_scriptcache_dict;        /* SHA1 all slaves are aware of. */
     list *repl_scriptcache_fifo;        /* First in, first out LRU eviction. */
     unsigned int repl_scriptcache_size; /* Max number of elements. */
     /* Synchronous replication. */
     list *clients_waiting_acks;         /* Clients waiting in WAIT command. */
     int get_ack_from_slaves;            /* If true we send REPLCONF GETACK. */
     /* Limits */
     unsigned int maxclients;            /* Max number of simultaneous clients */
     unsigned long long maxmemory;   /* Max number of memory bytes to use */
     int maxmemory_policy;           /* Policy for key eviction */
     int maxmemory_samples;          /* Pricision of random sampling */
+    unsigned int lfu_log_factor;    /* LFU logarithmic counter factor. */
+    unsigned int lfu_decay_time;    /* LFU counter decay factor. */
     /* Blocked clients */
     unsigned int bpop_blocked_clients; /* Number of clients blocked by lists */
     list *unblocked_clients; /* list of clients to unblock before next loop */
     list *ready_keys;        /* List of readyList structures for BLPOP & co */
     /* Sort parameters - qsort_r() is only available under BSD so we
      * have to take this state global, in order to pass it to sortCompare() */
@@ -930,14 +1138,14 @@
     size_t zset_max_ziplist_value;
     size_t hll_sparse_max_bytes;
     /* List parameters */
     int list_max_ziplist_size;
     int list_compress_depth;
     /* time cache */
-    time_t unixtime;        /* Unix time sampled every cron cycle. */
-    long long mstime;       /* Like 'unixtime' but with milliseconds resolution. */
+    time_t unixtime;    /* Unix time sampled every cron cycle. */
+    long long mstime;   /* Like 'unixtime' but with milliseconds resolution. */
     /* Pubsub */
     dict *pubsub_channels;  /* Map channels to list of subscribed clients */
     list *pubsub_patterns;  /* A list of pubsub_patterns */
     int notify_keyspace_events; /* Events to propagate via Pub/Sub. This is an
                                    xor of NOTIFY_... flags. */
     /* Cluster */
@@ -946,12 +1154,15 @@
     char *cluster_configfile; /* Cluster auto-generated config file name. */
     struct clusterState *cluster;  /* State of the cluster */
     int cluster_migration_barrier; /* Cluster replicas migration barrier. */
     int cluster_slave_validity_factor; /* Slave max data age for failover. */
     int cluster_require_full_coverage; /* If true, put the cluster down if
                                           there is at least an uncovered slot.*/
+    char *cluster_announce_ip;  /* IP address to announce on cluster bus. */
+    int cluster_announce_port;     /* base port to announce on cluster bus. */
+    int cluster_announce_bus_port; /* bus port to announce on cluster bus. */
     /* Scripting */
     lua_State *lua; /* The Lua interpreter. We use just one for all clients */
     client *lua_client;   /* The "fake client" to query Redis from Lua */
     client *lua_caller;   /* The client running EVAL right now, or NULL */
     dict *lua_scripts;         /* A dictionary of SHA1 -> Lua scripts */
     mstime_t lua_time_limit;  /* Script timeout in milliseconds */
@@ -964,23 +1175,33 @@
     int lua_multi_emitted;/* True if we already proagated MULTI. */
     int lua_repl;         /* Script replication flags for redis.set_repl(). */
     int lua_timedout;     /* True if we reached the time limit for script
                              execution. */
     int lua_kill;         /* Kill the script if true. */
     int lua_always_replicate_commands; /* Default replication type. */
+    /* Lazy free */
+    int lazyfree_lazy_eviction;
+    int lazyfree_lazy_expire;
+    int lazyfree_lazy_server_del;
     /* Latency monitor */
     long long latency_monitor_threshold;
     dict *latency_events;
     /* Assert & bug reporting */
-    char *assert_failed;
-    char *assert_file;
+    const char *assert_failed;
+    const char *assert_file;
     int assert_line;
     int bug_report_start; /* True if bug report header was already logged. */
     int watchdog_period;  /* Software watchdog period in ms. 0 = off */
     /* System hardware info */
     size_t system_memory_size;  /* Total memory in system as reported by OS */
+
+    /* Mutexes used to protect atomic variables when atomic builtins are
+     * not available. */
+    pthread_mutex_t lruclock_mutex;
+    pthread_mutex_t next_client_id_mutex;
+    pthread_mutex_t unixtime_mutex;
 };
 
 typedef struct pubsubPattern {
     client *client;
     robj *pattern;
 } pubsubPattern;
@@ -1063,26 +1284,45 @@
 /*-----------------------------------------------------------------------------
  * Extern declarations
  *----------------------------------------------------------------------------*/
 
 extern struct redisServer server;
 extern struct sharedObjectsStruct shared;
+extern dictType objectKeyPointerValueDictType;
 extern dictType setDictType;
 extern dictType zsetDictType;
 extern dictType clusterNodesDictType;
 extern dictType clusterNodesBlackListDictType;
 extern dictType dbDictType;
 extern dictType shaScriptObjectDictType;
 extern double R_Zero, R_PosInf, R_NegInf, R_Nan;
 extern dictType hashDictType;
 extern dictType replScriptCacheDictType;
+extern dictType keyptrDictType;
+extern dictType modulesDictType;
 
 /*-----------------------------------------------------------------------------
  * Functions prototypes
  *----------------------------------------------------------------------------*/
 
+/* Modules */
+void moduleInitModulesSystem(void);
+int moduleLoad(const char *path, void **argv, int argc);
+void moduleLoadFromQueue(void);
+int *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
+moduleType *moduleTypeLookupModuleByID(uint64_t id);
+void moduleTypeNameByID(char *name, uint64_t moduleid);
+void moduleFreeContext(struct RedisModuleCtx *ctx);
+void unblockClientFromModule(client *c);
+void moduleHandleBlockedClients(void);
+void moduleBlockedClientTimedOut(client *c);
+void moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask);
+size_t moduleCount(void);
+void moduleAcquireGIL(void);
+void moduleReleaseGIL(void);
+
 /* Utils */
 long long ustime(void);
 long long mstime(void);
 void getRandomHexChars(char *p, unsigned int len);
 uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);
 void exitFromChild(int retcode);
@@ -1100,12 +1340,13 @@
 void setDeferredMultiBulkLength(client *c, void *node, long length);
 void processInputBuffer(client *c);
 void acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);
 void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask);
 void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask);
 void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask);
+void addReplyString(client *c, const char *s, size_t len);
 void addReplyBulk(client *c, robj *obj);
 void addReplyBulkCString(client *c, const char *s);
 void addReplyBulkCBuffer(client *c, const void *p, size_t len);
 void addReplyBulkLongLong(client *c, long long ll);
 void addReply(client *c, robj *obj);
 void addReplySds(client *c, sds s);
@@ -1114,12 +1355,14 @@
 void addReplyStatus(client *c, const char *status);
 void addReplyDouble(client *c, double d);
 void addReplyHumanLongDouble(client *c, long double d);
 void addReplyLongLong(client *c, long long ll);
 void addReplyMultiBulkLen(client *c, long length);
 void copyClientOutputBuffer(client *dst, client *src);
+size_t sdsZmallocSize(sds s);
+size_t getStringObjectSdsUsedMemory(robj *o);
 void *dupClientReplyValue(void *o);
 void getClientsMaxBuffers(unsigned long *longest_output_list,
                           unsigned long *biggest_input_buffer);
 char *getClientPeerId(client *client);
 sds catClientInfoString(sds s, client *client);
 sds getAllClientsInfoString(void);
@@ -1154,13 +1397,13 @@
 #endif
 
 /* List data type */
 void listTypeTryConversion(robj *subject, robj *value);
 void listTypePush(robj *subject, robj *value, int where);
 robj *listTypePop(robj *subject, int where);
-unsigned long listTypeLength(robj *subject);
+unsigned long listTypeLength(const robj *subject);
 listTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction);
 void listTypeReleaseIterator(listTypeIterator *li);
 int listTypeNext(listTypeIterator *li, listTypeEntry *entry);
 robj *listTypeGet(listTypeEntry *entry);
 void listTypeInsert(listTypeEntry *entry, robj *value, int where);
 int listTypeEqual(listTypeEntry *entry, robj *o);
@@ -1183,23 +1426,25 @@
 void execCommandPropagateMulti(client *c);
 
 /* Redis object implementation */
 void decrRefCount(robj *o);
 void decrRefCountVoid(void *o);
 void incrRefCount(robj *o);
+robj *makeObjectShared(robj *o);
 robj *resetRefCount(robj *obj);
 void freeStringObject(robj *o);
 void freeListObject(robj *o);
 void freeSetObject(robj *o);
 void freeZsetObject(robj *o);
 void freeHashObject(robj *o);
 robj *createObject(int type, void *ptr);
 robj *createStringObject(const char *ptr, size_t len);
 robj *createRawStringObject(const char *ptr, size_t len);
 robj *createEmbeddedStringObject(const char *ptr, size_t len);
-robj *dupStringObject(robj *o);
+robj *dupStringObject(const robj *o);
+int isSdsRepresentableAsLongLong(sds s, long long *llval);
 int isObjectRepresentableAsLongLong(robj *o, long long *llongval);
 robj *tryObjectEncoding(robj *o);
 robj *getDecodedObject(robj *o);
 size_t stringObjectLen(robj *o);
 robj *createStringObjectFromLongLong(long long value);
 robj *createStringObjectFromLongDouble(long double value, int humanfriendly);
@@ -1207,16 +1452,18 @@
 robj *createZiplistObject(void);
 robj *createSetObject(void);
 robj *createIntsetObject(void);
 robj *createHashObject(void);
 robj *createZsetObject(void);
 robj *createZsetZiplistObject(void);
+robj *createModuleObject(moduleType *mt, void *value);
 int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg);
 int checkType(client *c, robj *o, int type);
 int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg);
 int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg);
+int getDoubleFromObject(const robj *o, double *target);
 int getLongLongFromObject(robj *o, long long *target);
 int getLongDoubleFromObject(robj *o, long double *target);
 int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg);
 char *strEncoding(int encoding);
 int compareStringObjects(robj *a, robj *b);
 int collateStringObjects(robj *a, robj *b);
@@ -1228,12 +1475,13 @@
 ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout);
 ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout);
 ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout);
 
 /* Replication */
 void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);
+void replicationFeedSlavesFromMasterStream(list *slaves, char *buf, size_t buflen);
 void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc);
 void updateSlavesWaitingBgsave(int bgsaveerr, int type);
 void replicationCron(void);
 void replicationHandleMasterDisconnection(void);
 void replicationCacheMaster(client *c);
 void resizeReplicationBacklog(long long newsize);
@@ -1249,62 +1497,108 @@
 int replicationCountAcksByOffset(long long offset);
 void replicationSendNewlineToMaster(void);
 long long replicationGetSlaveOffset(void);
 char *replicationGetSlaveName(client *c);
 long long getPsyncInitialOffset(void);
 int replicationSetupSlaveForFullResync(client *slave, long long offset);
+void changeReplicationId(void);
+void clearReplicationId2(void);
+void chopReplicationBacklog(void);
+void replicationCacheMasterUsingMyself(void);
+void feedReplicationBacklog(void *ptr, size_t len);
 
 /* Generic persistence functions */
 void startLoading(FILE *fp);
 void loadingProgress(off_t pos);
 void stopLoading(void);
 
 /* RDB persistence */
 #include "rdb.h"
+int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi);
 
 /* AOF persistence */
 void flushAppendOnlyFile(int force);
 void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc);
 void aofRemoveTempFile(pid_t childpid);
 int rewriteAppendOnlyFileBackground(void);
 int loadAppendOnlyFile(char *filename);
 void stopAppendOnly(void);
 int startAppendOnly(void);
 void backgroundRewriteDoneHandler(int exitcode, int bysignal);
 void aofRewriteBufferReset(void);
 unsigned long aofRewriteBufferSize(void);
+ssize_t aofReadDiffFromParent(void);
+
+/* Child info */
+void openChildInfoPipe(void);
+void closeChildInfoPipe(void);
+void sendChildInfo(int process_type);
+void receiveChildInfo(void);
 
 /* Sorted sets data type */
 
+/* Input flags. */
+#define ZADD_NONE 0
+#define ZADD_INCR (1<<0)    /* Increment the score instead of setting it. */
+#define ZADD_NX (1<<1)      /* Don't touch elements not already existing. */
+#define ZADD_XX (1<<2)      /* Only touch elements already exisitng. */
+
+/* Output flags. */
+#define ZADD_NOP (1<<3)     /* Operation not performed because of conditionals.*/
+#define ZADD_NAN (1<<4)     /* Only touch elements already exisitng. */
+#define ZADD_ADDED (1<<5)   /* The element was new and was added. */
+#define ZADD_UPDATED (1<<6) /* The element already existed, score updated. */
+
+/* Flags only used by the ZADD command but not by zsetAdd() API: */
+#define ZADD_CH (1<<16)      /* Return num of elements added or updated. */
+
 /* Struct to hold a inclusive/exclusive range spec by score comparison. */
 typedef struct {
     double min, max;
     int minex, maxex; /* are min or max exclusive? */
 } zrangespec;
 
 /* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */
 typedef struct {
-    robj *min, *max;  /* May be set to shared.(minstring|maxstring) */
+    sds min, max;     /* May be set to shared.(minstring|maxstring) */
     int minex, maxex; /* are min or max exclusive? */
 } zlexrangespec;
 
 zskiplist *zslCreate(void);
 void zslFree(zskiplist *zsl);
-zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);
-unsigned char *zzlInsert(unsigned char *zl, robj *ele, double score);
-int zslDelete(zskiplist *zsl, double score, robj *obj);
+zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);
+unsigned char *zzlInsert(unsigned char *zl, sds ele, double score);
+int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);
 zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);
 zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);
 double zzlGetScore(unsigned char *sptr);
 void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);
 void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);
-unsigned int zsetLength(robj *zobj);
+unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);
+unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);
+unsigned int zsetLength(const robj *zobj);
 void zsetConvert(robj *zobj, int encoding);
 void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);
-int zsetScore(robj *zobj, robj *member, double *score);
-unsigned long zslGetRank(zskiplist *zsl, double score, robj *o);
+int zsetScore(robj *zobj, sds member, double *score);
+unsigned long zslGetRank(zskiplist *zsl, double score, sds o);
+int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);
+long zsetRank(robj *zobj, sds ele, int reverse);
+int zsetDel(robj *zobj, sds ele);
+sds ziplistGetObject(unsigned char *sptr);
+int zslValueGteMin(double value, zrangespec *spec);
+int zslValueLteMax(double value, zrangespec *spec);
+void zslFreeLexRange(zlexrangespec *spec);
+int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec);
+unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range);
+unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range);
+zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range);
+zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);
+int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec);
+int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec);
+int zslLexValueGteMin(sds value, zlexrangespec *spec);
+int zslLexValueLteMax(sds value, zlexrangespec *spec);
 
 /* Core functions */
 int freeMemoryIfNeeded(void);
 int processCommand(client *c);
 void setupSignalHandlers(void);
 struct redisCommand *lookupCommand(sds name);
@@ -1332,53 +1626,62 @@
 void populateCommandTable(void);
 void resetCommandTableStats(void);
 void adjustOpenFilesLimit(void);
 void closeListeningSockets(int unlink_unix_socket);
 void updateCachedTime(void);
 void resetServerStats(void);
+void activeDefragCycle(void);
 unsigned int getLRUClock(void);
+unsigned int LRU_CLOCK(void);
 const char *evictPolicyToString(void);
+struct redisMemOverhead *getMemoryOverheadData(void);
+void freeMemoryOverheadData(struct redisMemOverhead *mh);
 
 #define RESTART_SERVER_NONE 0
 #define RESTART_SERVER_GRACEFULLY (1<<0)     /* Do proper shutdown. */
 #define RESTART_SERVER_CONFIG_REWRITE (1<<1) /* CONFIG REWRITE before restart.*/
 int restartServer(int flags, mstime_t delay);
 
 /* Set data type */
-robj *setTypeCreate(robj *value);
-int setTypeAdd(robj *subject, robj *value);
-int setTypeRemove(robj *subject, robj *value);
-int setTypeIsMember(robj *subject, robj *value);
+robj *setTypeCreate(sds value);
+int setTypeAdd(robj *subject, sds value);
+int setTypeRemove(robj *subject, sds value);
+int setTypeIsMember(robj *subject, sds value);
 setTypeIterator *setTypeInitIterator(robj *subject);
 void setTypeReleaseIterator(setTypeIterator *si);
-int setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele);
-robj *setTypeNextObject(setTypeIterator *si);
-int setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele);
+int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele);
+sds setTypeNextObject(setTypeIterator *si);
+int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele);
 unsigned long setTypeRandomElements(robj *set, unsigned long count, robj *aux_set);
-unsigned long setTypeSize(robj *subject);
+unsigned long setTypeSize(const robj *subject);
 void setTypeConvert(robj *subject, int enc);
 
 /* Hash data type */
+#define HASH_SET_TAKE_FIELD (1<<0)
+#define HASH_SET_TAKE_VALUE (1<<1)
+#define HASH_SET_COPY 0
+
 void hashTypeConvert(robj *o, int enc);
 void hashTypeTryConversion(robj *subject, robj **argv, int start, int end);
 void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2);
-robj *hashTypeGetObject(robj *o, robj *key);
-int hashTypeExists(robj *o, robj *key);
-int hashTypeSet(robj *o, robj *key, robj *value);
-int hashTypeDelete(robj *o, robj *key);
-unsigned long hashTypeLength(robj *o);
+int hashTypeExists(robj *o, sds key);
+int hashTypeDelete(robj *o, sds key);
+unsigned long hashTypeLength(const robj *o);
 hashTypeIterator *hashTypeInitIterator(robj *subject);
 void hashTypeReleaseIterator(hashTypeIterator *hi);
 int hashTypeNext(hashTypeIterator *hi);
 void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,
                                 unsigned char **vstr,
                                 unsigned int *vlen,
                                 long long *vll);
-void hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what, robj **dst);
-robj *hashTypeCurrentObject(hashTypeIterator *hi, int what);
+sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what);
+void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll);
+sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what);
 robj *hashTypeLookupWriteOrCreate(client *c, robj *key);
+robj *hashTypeGetValueObject(robj *o, sds field);
+int hashTypeSet(robj *o, sds field, sds value, int flags);
 
 /* Pub / Sub */
 int pubsubUnsubscribeAllChannels(client *c, int notify);
 int pubsubUnsubscribeAllPatterns(client *c, int notify);
 void freePubsubPattern(void *p);
 int listMatchPubsubPattern(void *a, void *b);
@@ -1396,41 +1699,55 @@
 struct rewriteConfigState; /* Forward declaration to export API. */
 void rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force);
 int rewriteConfig(char *path);
 
 /* db.c -- Keyspace access API */
 int removeExpire(redisDb *db, robj *key);
-void propagateExpire(redisDb *db, robj *key);
+void propagateExpire(redisDb *db, robj *key, int lazy);
 int expireIfNeeded(redisDb *db, robj *key);
 long long getExpire(redisDb *db, robj *key);
-void setExpire(redisDb *db, robj *key, long long when);
+void setExpire(client *c, redisDb *db, robj *key, long long when);
 robj *lookupKey(redisDb *db, robj *key, int flags);
 robj *lookupKeyRead(redisDb *db, robj *key);
 robj *lookupKeyWrite(redisDb *db, robj *key);
 robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply);
 robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply);
 robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags);
+robj *objectCommandLookup(client *c, robj *key);
+robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply);
 #define LOOKUP_NONE 0
 #define LOOKUP_NOTOUCH (1<<0)
 void dbAdd(redisDb *db, robj *key, robj *val);
 void dbOverwrite(redisDb *db, robj *key, robj *val);
 void setKey(redisDb *db, robj *key, robj *val);
 int dbExists(redisDb *db, robj *key);
 robj *dbRandomKey(redisDb *db);
+int dbSyncDelete(redisDb *db, robj *key);
 int dbDelete(redisDb *db, robj *key);
 robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);
-long long emptyDb(void(callback)(void*));
+
+#define EMPTYDB_NO_FLAGS 0      /* No flags. */
+#define EMPTYDB_ASYNC (1<<0)    /* Reclaim memory in another thread. */
+long long emptyDb(int dbnum, int flags, void(callback)(void*));
+
 int selectDb(client *c, int id);
 void signalModifiedKey(redisDb *db, robj *key);
 void signalFlushedDb(int dbid);
 unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);
 unsigned int countKeysInSlot(unsigned int hashslot);
 unsigned int delKeysInSlot(unsigned int hashslot);
 int verifyClusterConfigWithData(void);
 void scanGenericCommand(client *c, robj *o, unsigned long cursor);
 int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor);
+void slotToKeyAdd(robj *key);
+void slotToKeyDel(robj *key);
+void slotToKeyFlush(void);
+int dbAsyncDelete(redisDb *db, robj *key);
+void emptyDbAsync(redisDb *db);
+void slotToKeyFlushAsync(void);
+size_t lazyfreeGetPendingObjectsCount(void);
 
 /* API to get key arguments from commands */
 int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
 void getKeysFreeResult(int *result);
 int *zunionInterGetKeys(struct redisCommand *cmd,robj **argv, int argc, int *numkeys);
 int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);
@@ -1451,15 +1768,16 @@
 void initSentinelConfig(void);
 void initSentinel(void);
 void sentinelTimer(void);
 char *sentinelHandleConfiguration(char **argv, int argc);
 void sentinelIsRunning(void);
 
-/* redis-check-rdb */
-int redis_check_rdb(char *rdbfilename);
-int redis_check_rdb_main(int argc, char **argv);
+/* redis-check-rdb & aof */
+int redis_check_rdb(char *rdbfilename, FILE *fp);
+int redis_check_rdb_main(int argc, char **argv, FILE *fp);
+int redis_check_aof_main(int argc, char **argv);
 
 /* Scripting */
 void scriptingInit(int setup);
 int ldbRemoveChild(pid_t pid);
 void ldbKillForkedSessions(void);
 int ldbPendingChildren(void);
@@ -1469,12 +1787,30 @@
 void blockClient(client *c, int btype);
 void unblockClient(client *c);
 void replyToBlockedClientTimedOut(client *c);
 int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit);
 void disconnectAllBlockedClients(void);
 
+/* expire.c -- Handling of expired keys */
+void activeExpireCycle(int type);
+void expireSlaveKeys(void);
+void rememberSlaveKeyWithExpire(redisDb *db, robj *key);
+void flushSlaveKeysWithExpireList(void);
+size_t getSlaveKeyWithExpireCount(void);
+
+/* evict.c -- maxmemory handling and LRU eviction. */
+void evictionPoolAlloc(void);
+#define LFU_INIT_VAL 5
+unsigned long LFUGetTimeInMinutes(void);
+uint8_t LFULogIncr(uint8_t value);
+
+/* Keys hashing / comparison functions for dict.c hash tables. */
+uint64_t dictSdsHash(const void *key);
+int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
+void dictSdsDestructor(void *privdata, void *val);
+
 /* Git SHA1 */
 char *redisGitSHA1(void);
 char *redisGitDirty(void);
 uint64_t redisBuildId(void);
 
 /* Commands prototypes */
@@ -1485,24 +1821,26 @@
 void setCommand(client *c);
 void setnxCommand(client *c);
 void setexCommand(client *c);
 void psetexCommand(client *c);
 void getCommand(client *c);
 void delCommand(client *c);
+void unlinkCommand(client *c);
 void existsCommand(client *c);
 void setbitCommand(client *c);
 void getbitCommand(client *c);
 void bitfieldCommand(client *c);
 void setrangeCommand(client *c);
 void getrangeCommand(client *c);
 void incrCommand(client *c);
 void decrCommand(client *c);
 void incrbyCommand(client *c);
 void decrbyCommand(client *c);
 void incrbyfloatCommand(client *c);
 void selectCommand(client *c);
+void swapdbCommand(client *c);
 void randomkeyCommand(client *c);
 void keysCommand(client *c);
 void scanCommand(client *c);
 void dbsizeCommand(client *c);
 void lastsaveCommand(client *c);
 void saveCommand(client *c);
@@ -1620,12 +1958,13 @@
 void migrateCommand(client *c);
 void askingCommand(client *c);
 void readonlyCommand(client *c);
 void readwriteCommand(client *c);
 void dumpCommand(client *c);
 void objectCommand(client *c);
+void memoryCommand(client *c);
 void clientCommand(client *c);
 void evalCommand(client *c);
 void evalShaCommand(client *c);
 void scriptCommand(client *c);
 void timeCommand(client *c);
 void bitopCommand(client *c);
@@ -1646,34 +1985,37 @@
 void pfselftestCommand(client *c);
 void pfaddCommand(client *c);
 void pfcountCommand(client *c);
 void pfmergeCommand(client *c);
 void pfdebugCommand(client *c);
 void latencyCommand(client *c);
+void moduleCommand(client *c);
 void securityWarningCommand(client *c);
 
 #if defined(__GNUC__)
 void *calloc(size_t count, size_t size) __attribute__ ((deprecated));
 void free(void *ptr) __attribute__ ((deprecated));
 void *malloc(size_t size) __attribute__ ((deprecated));
 void *realloc(void *ptr, size_t size) __attribute__ ((deprecated));
 #endif
 
 /* Debugging stuff */
-void _serverAssertWithInfo(client *c, robj *o, char *estr, char *file, int line);
-void _serverAssert(char *estr, char *file, int line);
-void _serverPanic(char *msg, char *file, int line);
+void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line);
+void _serverAssert(const char *estr, const char *file, int line);
+void _serverPanic(const char *file, int line, const char *msg, ...);
 void bugReportStart(void);
-void serverLogObjectDebugInfo(robj *o);
+void serverLogObjectDebugInfo(const robj *o);
 void sigsegvHandler(int sig, siginfo_t *info, void *secret);
 sds genRedisInfoString(char *section);
 void enableWatchdog(int period);
 void disableWatchdog(void);
 void watchdogScheduleSignal(int period);
 void serverLogHexDump(int level, char *descr, void *value, size_t len);
 int memtest_preserving_test(unsigned long *m, size_t bytes, int passes);
+void mixDigest(unsigned char *digest, void *ptr, size_t len);
+void xorDigest(unsigned char *digest, void *ptr, size_t len);
 
 #define redisDebug(fmt, ...) \
     printf("DEBUG %s:%d > " fmt "\n", __FILE__, __LINE__, __VA_ARGS__)
 #define redisDebugMark() \
     printf("-- MARK %s:%d --\n", __FILE__, __LINE__)
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/server.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/server.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/setproctitle.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/setproctitle.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/setproctitle.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/setproctitle.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sha1.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sha1.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sha1.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sha1.o differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: siphash.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: siphash.c.bc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src: siphash.o
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.c	2017-07-14 19:28:42.000000000 +0800
@@ -42,13 +42,13 @@
 #include "server.h"
 #include "slowlog.h"
 
 /* Create a new slowlog entry.
  * Incrementing the ref count of all the objects retained is up to
  * this function. */
-slowlogEntry *slowlogCreateEntry(robj **argv, int argc, long long duration) {
+slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long duration) {
     slowlogEntry *se = zmalloc(sizeof(*se));
     int j, slargc = argc;
 
     if (slargc > SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;
     se->argc = slargc;
     se->argv = zmalloc(sizeof(robj*)*slargc);
@@ -78,12 +78,14 @@
             }
         }
     }
     se->time = time(NULL);
     se->duration = duration;
     se->id = server.slowlog_entry_id++;
+    se->peerid = sdsnew(getClientPeerId(c));
+    se->cname = c->name ? sdsnew(c->name->ptr) : sdsempty();
     return se;
 }
 
 /* Free a slow log entry. The argument is void so that the prototype of this
  * function matches the one of the 'free' method of adlist.c.
  *
@@ -92,12 +94,14 @@
     slowlogEntry *se = septr;
     int j;
 
     for (j = 0; j < se->argc; j++)
         decrRefCount(se->argv[j]);
     zfree(se->argv);
+    sdsfree(se->peerid);
+    sdsfree(se->cname);
     zfree(se);
 }
 
 /* Initialize the slow log. This function should be called a single time
  * at server startup. */
 void slowlogInit(void) {
@@ -106,16 +110,17 @@
     listSetFreeMethod(server.slowlog,slowlogFreeEntry);
 }
 
 /* Push a new entry into the slow log.
  * This function will make sure to trim the slow log accordingly to the
  * configured max length. */
-void slowlogPushEntryIfNeeded(robj **argv, int argc, long long duration) {
+void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {
     if (server.slowlog_log_slower_than < 0) return; /* Slowlog disabled */
     if (duration >= server.slowlog_log_slower_than)
-        listAddNodeHead(server.slowlog,slowlogCreateEntry(argv,argc,duration));
+        listAddNodeHead(server.slowlog,
+                        slowlogCreateEntry(c,argv,argc,duration));
 
     /* Remove old entries if needed. */
     while (listLength(server.slowlog) > server.slowlog_max_len)
         listDelNode(server.slowlog,listLast(server.slowlog));
 }
 
@@ -149,19 +154,21 @@
         listRewind(server.slowlog,&li);
         totentries = addDeferredMultiBulkLength(c);
         while(count-- && (ln = listNext(&li))) {
             int j;
 
             se = ln->value;
-            addReplyMultiBulkLen(c,4);
+            addReplyMultiBulkLen(c,6);
             addReplyLongLong(c,se->id);
             addReplyLongLong(c,se->time);
             addReplyLongLong(c,se->duration);
             addReplyMultiBulkLen(c,se->argc);
             for (j = 0; j < se->argc; j++)
                 addReplyBulk(c,se->argv[j]);
+            addReplyBulkCBuffer(c,se->peerid,sdslen(se->peerid));
+            addReplyBulkCBuffer(c,se->cname,sdslen(se->cname));
             sent++;
         }
         setDeferredMultiBulkLength(c,totentries,sent);
     } else {
         addReplyError(c,
             "Unknown SLOWLOG subcommand or wrong # of args. Try GET, RESET, LEN.");
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.h	2017-07-14 19:28:42.000000000 +0800
@@ -34,14 +34,16 @@
 typedef struct slowlogEntry {
     robj **argv;
     int argc;
     long long id;       /* Unique entry identifier. */
     long long duration; /* Time spent by the query, in microseconds. */
     time_t time;        /* Unix time at which the query was executed. */
+    sds cname;          /* Client name. */
+    sds peerid;         /* Client network address. */
 } slowlogEntry;
 
 /* Exported API */
 void slowlogInit(void);
-void slowlogPushEntryIfNeeded(robj **argv, int argc, long long duration);
+void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration);
 
 /* Exported commands */
 void slowlogCommand(client *c);
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/slowlog.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/slowlog.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.c	2017-07-14 19:28:42.000000000 +0800
@@ -109,15 +109,15 @@
     o = lookupKeyRead(db,keyobj);
     if (o == NULL) goto noobj;
 
     if (fieldobj) {
         if (o->type != OBJ_HASH) goto noobj;
 
-        /* Retrieve value from hash by the field name. This operation
-         * already increases the refcount of the returned object. */
-        o = hashTypeGetObject(o, fieldobj);
+        /* Retrieve value from hash by the field name. The returend object
+         * is a new object with refcount already incremented. */
+        o = hashTypeGetValueObject(o, fieldobj->ptr);
     } else {
         if (o->type != OBJ_STRING) goto noobj;
 
         /* Every object that this function returns needs to have its refcount
          * increased. sortCommand decreases it again. */
         incrRefCount(o);
@@ -377,15 +377,15 @@
             vector[j].u.cmpobj = NULL;
             j++;
         }
         listTypeReleaseIterator(li);
     } else if (sortval->type == OBJ_SET) {
         setTypeIterator *si = setTypeInitIterator(sortval);
-        robj *ele;
-        while((ele = setTypeNextObject(si)) != NULL) {
-            vector[j].obj = ele;
+        sds sdsele;
+        while((sdsele = setTypeNextObject(si)) != NULL) {
+            vector[j].obj = createObject(OBJ_STRING,sdsele);
             vector[j].u.score = 0;
             vector[j].u.cmpobj = NULL;
             j++;
         }
         setTypeReleaseIterator(si);
     } else if (sortval->type == OBJ_ZSET && dontsort) {
@@ -396,13 +396,13 @@
          * Note that in this case we also handle LIMIT here in a direct
          * way, just getting the required range, as an optimization. */
 
         zset *zs = sortval->ptr;
         zskiplist *zsl = zs->zsl;
         zskiplistNode *ln;
-        robj *ele;
+        sds sdsele;
         int rangelen = vectorlen;
 
         /* Check if starting point is trivial, before doing log(N) lookup. */
         if (desc) {
             long zsetlen = dictSize(((zset*)sortval->ptr)->dict);
 
@@ -414,29 +414,31 @@
             if (start > 0)
                 ln = zslGetElementByRank(zsl,start+1);
         }
 
         while(rangelen--) {
             serverAssertWithInfo(c,sortval,ln != NULL);
-            ele = ln->obj;
-            vector[j].obj = ele;
+            sdsele = ln->ele;
+            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));
             vector[j].u.score = 0;
             vector[j].u.cmpobj = NULL;
             j++;
             ln = desc ? ln->backward : ln->level[0].forward;
         }
         /* Fix start/end: output code is not aware of this optimization. */
         end -= start;
         start = 0;
     } else if (sortval->type == OBJ_ZSET) {
         dict *set = ((zset*)sortval->ptr)->dict;
         dictIterator *di;
         dictEntry *setele;
+        sds sdsele;
         di = dictGetIterator(set);
         while((setele = dictNext(di)) != NULL) {
-            vector[j].obj = dictGetKey(setele);
+            sdsele =  dictGetKey(setele);
+            vector[j].obj = createStringObject(sdsele,sdslen(sdsele));
             vector[j].u.score = 0;
             vector[j].u.cmpobj = NULL;
             j++;
         }
         dictReleaseIterator(di);
     } else {
@@ -574,15 +576,15 @@
         }
         decrRefCount(sobj);
         addReplyLongLong(c,outputlen);
     }
 
     /* Cleanup */
-    if (sortval->type == OBJ_LIST || sortval->type == OBJ_SET)
-        for (j = 0; j < vectorlen; j++)
-            decrRefCount(vector[j].obj);
+    for (j = 0; j < vectorlen; j++)
+        decrRefCount(vector[j].obj);
+
     decrRefCount(sortval);
     listRelease(operations);
     for (j = 0; j < vectorlen; j++) {
         if (alpha && vector[j].u.cmpobj)
             decrRefCount(vector[j].u.cmpobj);
     }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sort.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sort.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sparkline.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sparkline.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/sparkline.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/sparkline.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/syncio.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/syncio.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/syncio.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/syncio.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.c	2017-07-14 19:28:42.000000000 +0800
@@ -49,225 +49,253 @@
             hashTypeConvert(o, OBJ_ENCODING_HT);
             break;
         }
     }
 }
 
-/* Encode given objects in-place when the hash uses a dict. */
-void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2) {
-    if (subject->encoding == OBJ_ENCODING_HT) {
-        if (o1) *o1 = tryObjectEncoding(*o1);
-        if (o2) *o2 = tryObjectEncoding(*o2);
-    }
-}
-
 /* Get the value from a ziplist encoded hash, identified by field.
  * Returns -1 when the field cannot be found. */
-int hashTypeGetFromZiplist(robj *o, robj *field,
+int hashTypeGetFromZiplist(robj *o, sds field,
                            unsigned char **vstr,
                            unsigned int *vlen,
                            long long *vll)
 {
     unsigned char *zl, *fptr = NULL, *vptr = NULL;
     int ret;
 
     serverAssert(o->encoding == OBJ_ENCODING_ZIPLIST);
 
-    field = getDecodedObject(field);
-
     zl = o->ptr;
     fptr = ziplistIndex(zl, ZIPLIST_HEAD);
     if (fptr != NULL) {
-        fptr = ziplistFind(fptr, field->ptr, sdslen(field->ptr), 1);
+        fptr = ziplistFind(fptr, (unsigned char*)field, sdslen(field), 1);
         if (fptr != NULL) {
             /* Grab pointer to the value (fptr points to the field) */
             vptr = ziplistNext(zl, fptr);
             serverAssert(vptr != NULL);
         }
     }
 
-    decrRefCount(field);
-
     if (vptr != NULL) {
         ret = ziplistGet(vptr, vstr, vlen, vll);
         serverAssert(ret);
         return 0;
     }
 
     return -1;
 }
 
 /* Get the value from a hash table encoded hash, identified by field.
- * Returns -1 when the field cannot be found. */
-int hashTypeGetFromHashTable(robj *o, robj *field, robj **value) {
+ * Returns NULL when the field cannot be found, otherwise the SDS value
+ * is returned. */
+sds hashTypeGetFromHashTable(robj *o, sds field) {
     dictEntry *de;
 
     serverAssert(o->encoding == OBJ_ENCODING_HT);
 
     de = dictFind(o->ptr, field);
-    if (de == NULL) return -1;
-    *value = dictGetVal(de);
-    return 0;
+    if (de == NULL) return NULL;
+    return dictGetVal(de);
 }
 
-/* Higher level function of hashTypeGet*() that always returns a Redis
- * object (either new or with refcount incremented), so that the caller
- * can retain a reference or call decrRefCount after the usage.
+/* Higher level function of hashTypeGet*() that returns the hash value
+ * associated with the specified field. If the field is found C_OK
+ * is returned, otherwise C_ERR. The returned object is returned by
+ * reference in either *vstr and *vlen if it's returned in string form,
+ * or stored in *vll if it's returned as a number.
  *
- * The lower level function can prevent copy on write so it is
- * the preferred way of doing read operations. */
-robj *hashTypeGetObject(robj *o, robj *field) {
-    robj *value = NULL;
-
+ * If *vll is populated *vstr is set to NULL, so the caller
+ * can always check the function return by checking the return value
+ * for C_OK and checking if vll (or vstr) is NULL. */
+int hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
-        unsigned char *vstr = NULL;
-        unsigned int vlen = UINT_MAX;
-        long long vll = LLONG_MAX;
-
-        if (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0) {
-            if (vstr) {
-                value = createStringObject((char*)vstr, vlen);
-            } else {
-                value = createStringObjectFromLongLong(vll);
-            }
-        }
+        *vstr = NULL;
+        if (hashTypeGetFromZiplist(o, field, vstr, vlen, vll) == 0)
+            return C_OK;
     } else if (o->encoding == OBJ_ENCODING_HT) {
-        robj *aux;
-
-        if (hashTypeGetFromHashTable(o, field, &aux) == 0) {
-            incrRefCount(aux);
-            value = aux;
+        sds value;
+        if ((value = hashTypeGetFromHashTable(o, field)) != NULL) {
+            *vstr = (unsigned char*) value;
+            *vlen = sdslen(value);
+            return C_OK;
         }
     } else {
         serverPanic("Unknown hash encoding");
     }
-    return value;
+    return C_ERR;
+}
+
+/* Like hashTypeGetValue() but returns a Redis object, which is useful for
+ * interaction with the hash type outside t_hash.c.
+ * The function returns NULL if the field is not found in the hash. Otherwise
+ * a newly allocated string object with the value is returned. */
+robj *hashTypeGetValueObject(robj *o, sds field) {
+    unsigned char *vstr;
+    unsigned int vlen;
+    long long vll;
+
+    if (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == C_ERR) return NULL;
+    if (vstr) return createStringObject((char*)vstr,vlen);
+    else return createStringObjectFromLongLong(vll);
 }
 
 /* Higher level function using hashTypeGet*() to return the length of the
  * object associated with the requested field, or 0 if the field does not
  * exist. */
-size_t hashTypeGetValueLength(robj *o, robj *field) {
+size_t hashTypeGetValueLength(robj *o, sds field) {
     size_t len = 0;
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         if (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0)
             len = vstr ? vlen : sdigits10(vll);
     } else if (o->encoding == OBJ_ENCODING_HT) {
-        robj *aux;
+        sds aux;
 
-        if (hashTypeGetFromHashTable(o, field, &aux) == 0)
-            len = stringObjectLen(aux);
+        if ((aux = hashTypeGetFromHashTable(o, field)) != NULL)
+            len = sdslen(aux);
     } else {
         serverPanic("Unknown hash encoding");
     }
     return len;
 }
 
 /* Test if the specified field exists in the given hash. Returns 1 if the field
  * exists, and 0 when it doesn't. */
-int hashTypeExists(robj *o, robj *field) {
+int hashTypeExists(robj *o, sds field) {
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         if (hashTypeGetFromZiplist(o, field, &vstr, &vlen, &vll) == 0) return 1;
     } else if (o->encoding == OBJ_ENCODING_HT) {
-        robj *aux;
-
-        if (hashTypeGetFromHashTable(o, field, &aux) == 0) return 1;
+        if (hashTypeGetFromHashTable(o, field) != NULL) return 1;
     } else {
         serverPanic("Unknown hash encoding");
     }
     return 0;
 }
 
-/* Add an element, discard the old if the key already exists.
+/* Add a new field, overwrite the old with the new value if it already exists.
  * Return 0 on insert and 1 on update.
- * This function will take care of incrementing the reference count of the
- * retained fields and value objects. */
-int hashTypeSet(robj *o, robj *field, robj *value) {
+ *
+ * By default, the key and value SDS strings are copied if needed, so the
+ * caller retains ownership of the strings passed. However this behavior
+ * can be effected by passing appropriate flags (possibly bitwise OR-ed):
+ *
+ * HASH_SET_TAKE_FIELD -- The SDS field ownership passes to the function.
+ * HASH_SET_TAKE_VALUE -- The SDS value ownership passes to the function.
+ *
+ * When the flags are used the caller does not need to release the passed
+ * SDS string(s). It's up to the function to use the string to create a new
+ * entry or to free the SDS string before returning to the caller.
+ *
+ * HASH_SET_COPY corresponds to no flags passed, and means the default
+ * semantics of copying the values if needed.
+ *
+ */
+#define HASH_SET_TAKE_FIELD (1<<0)
+#define HASH_SET_TAKE_VALUE (1<<1)
+#define HASH_SET_COPY 0
+int hashTypeSet(robj *o, sds field, sds value, int flags) {
     int update = 0;
 
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl, *fptr, *vptr;
 
-        field = getDecodedObject(field);
-        value = getDecodedObject(value);
-
         zl = o->ptr;
         fptr = ziplistIndex(zl, ZIPLIST_HEAD);
         if (fptr != NULL) {
-            fptr = ziplistFind(fptr, field->ptr, sdslen(field->ptr), 1);
+            fptr = ziplistFind(fptr, (unsigned char*)field, sdslen(field), 1);
             if (fptr != NULL) {
                 /* Grab pointer to the value (fptr points to the field) */
                 vptr = ziplistNext(zl, fptr);
                 serverAssert(vptr != NULL);
                 update = 1;
 
                 /* Delete value */
                 zl = ziplistDelete(zl, &vptr);
 
                 /* Insert new value */
-                zl = ziplistInsert(zl, vptr, value->ptr, sdslen(value->ptr));
+                zl = ziplistInsert(zl, vptr, (unsigned char*)value,
+                        sdslen(value));
             }
         }
 
         if (!update) {
             /* Push new field/value pair onto the tail of the ziplist */
-            zl = ziplistPush(zl, field->ptr, sdslen(field->ptr), ZIPLIST_TAIL);
-            zl = ziplistPush(zl, value->ptr, sdslen(value->ptr), ZIPLIST_TAIL);
+            zl = ziplistPush(zl, (unsigned char*)field, sdslen(field),
+                    ZIPLIST_TAIL);
+            zl = ziplistPush(zl, (unsigned char*)value, sdslen(value),
+                    ZIPLIST_TAIL);
         }
         o->ptr = zl;
-        decrRefCount(field);
-        decrRefCount(value);
 
         /* Check if the ziplist needs to be converted to a hash table */
         if (hashTypeLength(o) > server.hash_max_ziplist_entries)
             hashTypeConvert(o, OBJ_ENCODING_HT);
     } else if (o->encoding == OBJ_ENCODING_HT) {
-        if (dictReplace(o->ptr, field, value)) { /* Insert */
-            incrRefCount(field);
-        } else { /* Update */
+        dictEntry *de = dictFind(o->ptr,field);
+        if (de) {
+            sdsfree(dictGetVal(de));
+            if (flags & HASH_SET_TAKE_VALUE) {
+                dictGetVal(de) = value;
+                value = NULL;
+            } else {
+                dictGetVal(de) = sdsdup(value);
+            }
             update = 1;
+        } else {
+            sds f,v;
+            if (flags & HASH_SET_TAKE_FIELD) {
+                f = field;
+                field = NULL;
+            } else {
+                f = sdsdup(field);
+            }
+            if (flags & HASH_SET_TAKE_VALUE) {
+                v = value;
+                value = NULL;
+            } else {
+                v = sdsdup(value);
+            }
+            dictAdd(o->ptr,f,v);
         }
-        incrRefCount(value);
     } else {
         serverPanic("Unknown hash encoding");
     }
+
+    /* Free SDS strings we did not referenced elsewhere if the flags
+     * want this function to be responsible. */
+    if (flags & HASH_SET_TAKE_FIELD && field) sdsfree(field);
+    if (flags & HASH_SET_TAKE_VALUE && value) sdsfree(value);
     return update;
 }
 
 /* Delete an element from a hash.
  * Return 1 on deleted and 0 on not found. */
-int hashTypeDelete(robj *o, robj *field) {
+int hashTypeDelete(robj *o, sds field) {
     int deleted = 0;
 
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl, *fptr;
 
-        field = getDecodedObject(field);
-
         zl = o->ptr;
         fptr = ziplistIndex(zl, ZIPLIST_HEAD);
         if (fptr != NULL) {
-            fptr = ziplistFind(fptr, field->ptr, sdslen(field->ptr), 1);
+            fptr = ziplistFind(fptr, (unsigned char*)field, sdslen(field), 1);
             if (fptr != NULL) {
                 zl = ziplistDelete(zl,&fptr);
                 zl = ziplistDelete(zl,&fptr);
                 o->ptr = zl;
                 deleted = 1;
             }
         }
-
-        decrRefCount(field);
-
     } else if (o->encoding == OBJ_ENCODING_HT) {
         if (dictDelete((dict*)o->ptr, field) == C_OK) {
             deleted = 1;
 
             /* Always check if the dictionary needs a resize after a delete. */
             if (htNeedsResize(o->ptr)) dictResize(o->ptr);
@@ -273,28 +301,26 @@
             if (htNeedsResize(o->ptr)) dictResize(o->ptr);
         }
 
     } else {
         serverPanic("Unknown hash encoding");
     }
-
     return deleted;
 }
 
 /* Return the number of elements in a hash. */
-unsigned long hashTypeLength(robj *o) {
+unsigned long hashTypeLength(const robj *o) {
     unsigned long length = ULONG_MAX;
 
     if (o->encoding == OBJ_ENCODING_ZIPLIST) {
         length = ziplistLen(o->ptr) / 2;
     } else if (o->encoding == OBJ_ENCODING_HT) {
-        length = dictSize((dict*)o->ptr);
+        length = dictSize((const dict*)o->ptr);
     } else {
         serverPanic("Unknown hash encoding");
     }
-
     return length;
 }
 
 hashTypeIterator *hashTypeInitIterator(robj *subject) {
     hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));
     hi->subject = subject;
@@ -305,21 +331,18 @@
         hi->vptr = NULL;
     } else if (hi->encoding == OBJ_ENCODING_HT) {
         hi->di = dictGetIterator(subject->ptr);
     } else {
         serverPanic("Unknown hash encoding");
     }
-
     return hi;
 }
 
 void hashTypeReleaseIterator(hashTypeIterator *hi) {
-    if (hi->encoding == OBJ_ENCODING_HT) {
+    if (hi->encoding == OBJ_ENCODING_HT)
         dictReleaseIterator(hi->di);
-    }
-
     zfree(hi);
 }
 
 /* Move to the next entry in the hash. Return C_OK when the next entry
  * could be found and C_ERR when the iterator reaches the end. */
 int hashTypeNext(hashTypeIterator *hi) {
@@ -375,47 +398,57 @@
         ret = ziplistGet(hi->vptr, vstr, vlen, vll);
         serverAssert(ret);
     }
 }
 
 /* Get the field or value at iterator cursor, for an iterator on a hash value
- * encoded as a ziplist. Prototype is similar to `hashTypeGetFromHashTable`. */
-void hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what, robj **dst) {
+ * encoded as a hash table. Prototype is similar to
+ * `hashTypeGetFromHashTable`. */
+sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {
     serverAssert(hi->encoding == OBJ_ENCODING_HT);
 
     if (what & OBJ_HASH_KEY) {
-        *dst = dictGetKey(hi->de);
+        return dictGetKey(hi->de);
     } else {
-        *dst = dictGetVal(hi->de);
+        return dictGetVal(hi->de);
     }
 }
 
-/* A non copy-on-write friendly but higher level version of hashTypeCurrent*()
- * that returns an object with incremented refcount (or a new object). It is up
- * to the caller to decrRefCount() the object if no reference is retained. */
-robj *hashTypeCurrentObject(hashTypeIterator *hi, int what) {
-    robj *dst;
-
+/* Higher level function of hashTypeCurrent*() that returns the hash value
+ * at current iterator position.
+ *
+ * The returned element is returned by reference in either *vstr and *vlen if
+ * it's returned in string form, or stored in *vll if it's returned as
+ * a number.
+ *
+ * If *vll is populated *vstr is set to NULL, so the caller
+ * can always check the function return by checking the return value
+ * type checking if vstr == NULL. */
+void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {
     if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
-        unsigned char *vstr = NULL;
-        unsigned int vlen = UINT_MAX;
-        long long vll = LLONG_MAX;
-
-        hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
-        if (vstr) {
-            dst = createStringObject((char*)vstr, vlen);
-        } else {
-            dst = createStringObjectFromLongLong(vll);
-        }
+        *vstr = NULL;
+        hashTypeCurrentFromZiplist(hi, what, vstr, vlen, vll);
     } else if (hi->encoding == OBJ_ENCODING_HT) {
-        hashTypeCurrentFromHashTable(hi, what, &dst);
-        incrRefCount(dst);
+        sds ele = hashTypeCurrentFromHashTable(hi, what);
+        *vstr = (unsigned char*) ele;
+        *vlen = sdslen(ele);
     } else {
         serverPanic("Unknown hash encoding");
     }
-    return dst;
+}
+
+/* Return the key or value at the current iterator position as a new
+ * SDS string. */
+sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {
+    unsigned char *vstr;
+    unsigned int vlen;
+    long long vll;
+
+    hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);
+    if (vstr) return sdsnewlen(vstr,vlen);
+    return sdsfromlonglong(vll);
 }
 
 robj *hashTypeLookupWriteOrCreate(client *c, robj *key) {
     robj *o = lookupKeyWrite(c->db,key);
     if (o == NULL) {
         o = createHashObject();
@@ -441,32 +474,27 @@
         int ret;
 
         hi = hashTypeInitIterator(o);
         dict = dictCreate(&hashDictType, NULL);
 
         while (hashTypeNext(hi) != C_ERR) {
-            robj *field, *value;
+            sds key, value;
 
-            field = hashTypeCurrentObject(hi, OBJ_HASH_KEY);
-            field = tryObjectEncoding(field);
-            value = hashTypeCurrentObject(hi, OBJ_HASH_VALUE);
-            value = tryObjectEncoding(value);
-            ret = dictAdd(dict, field, value);
+            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
+            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
+            ret = dictAdd(dict, key, value);
             if (ret != DICT_OK) {
                 serverLogHexDump(LL_WARNING,"ziplist with dup elements dump",
                     o->ptr,ziplistBlobLen(o->ptr));
-                serverAssert(ret == DICT_OK);
+                serverPanic("Ziplist corruption detected");
             }
         }
-
         hashTypeReleaseIterator(hi);
         zfree(o->ptr);
-
         o->encoding = OBJ_ENCODING_HT;
         o->ptr = dict;
-
     } else {
         serverPanic("Unknown hash encoding");
     }
 }
 
 void hashTypeConvert(robj *o, int enc) {
@@ -480,135 +508,139 @@
 }
 
 /*-----------------------------------------------------------------------------
  * Hash type commands
  *----------------------------------------------------------------------------*/
 
-void hsetCommand(client *c) {
-    int update;
-    robj *o;
-
-    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
-    hashTypeTryConversion(o,c->argv,2,3);
-    hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);
-    update = hashTypeSet(o,c->argv[2],c->argv[3]);
-    addReply(c, update ? shared.czero : shared.cone);
-    signalModifiedKey(c->db,c->argv[1]);
-    notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
-    server.dirty++;
-}
-
 void hsetnxCommand(client *c) {
     robj *o;
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
     hashTypeTryConversion(o,c->argv,2,3);
 
-    if (hashTypeExists(o, c->argv[2])) {
+    if (hashTypeExists(o, c->argv[2]->ptr)) {
         addReply(c, shared.czero);
     } else {
-        hashTypeTryObjectEncoding(o,&c->argv[2], &c->argv[3]);
-        hashTypeSet(o,c->argv[2],c->argv[3]);
+        hashTypeSet(o,c->argv[2]->ptr,c->argv[3]->ptr,HASH_SET_COPY);
         addReply(c, shared.cone);
         signalModifiedKey(c->db,c->argv[1]);
         notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
         server.dirty++;
     }
 }
 
-void hmsetCommand(client *c) {
-    int i;
+void hsetCommand(client *c) {
+    int i, created = 0;
     robj *o;
 
     if ((c->argc % 2) == 1) {
         addReplyError(c,"wrong number of arguments for HMSET");
         return;
     }
 
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
     hashTypeTryConversion(o,c->argv,2,c->argc-1);
-    for (i = 2; i < c->argc; i += 2) {
-        hashTypeTryObjectEncoding(o,&c->argv[i], &c->argv[i+1]);
-        hashTypeSet(o,c->argv[i],c->argv[i+1]);
+
+    for (i = 2; i < c->argc; i += 2)
+        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);
+
+    /* HMSET (deprecated) and HSET return value is different. */
+    char *cmdname = c->argv[0]->ptr;
+    if (cmdname[1] == 's' || cmdname[1] == 'S') {
+        /* HSET */
+        addReplyLongLong(c, created);
+    } else {
+        /* HMSET */
+        addReply(c, shared.ok);
     }
-    addReply(c, shared.ok);
     signalModifiedKey(c->db,c->argv[1]);
     notifyKeyspaceEvent(NOTIFY_HASH,"hset",c->argv[1],c->db->id);
     server.dirty++;
 }
 
 void hincrbyCommand(client *c) {
     long long value, incr, oldvalue;
-    robj *o, *current, *new;
+    robj *o;
+    sds new;
+    unsigned char *vstr;
+    unsigned int vlen;
 
     if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
-    if ((current = hashTypeGetObject(o,c->argv[2])) != NULL) {
-        if (getLongLongFromObjectOrReply(c,current,&value,
-            "hash value is not an integer") != C_OK) {
-            decrRefCount(current);
-            return;
-        }
-        decrRefCount(current);
+    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&value) == C_OK) {
+        if (vstr) {
+            if (string2ll((char*)vstr,vlen,&value) == 0) {
+                addReplyError(c,"hash value is not an integer");
+                return;
+            }
+        } /* Else hashTypeGetValue() already stored it into &value */
     } else {
         value = 0;
     }
 
     oldvalue = value;
     if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
         (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
         addReplyError(c,"increment or decrement would overflow");
         return;
     }
     value += incr;
-    new = createStringObjectFromLongLong(value);
-    hashTypeTryObjectEncoding(o,&c->argv[2],NULL);
-    hashTypeSet(o,c->argv[2],new);
-    decrRefCount(new);
+    new = sdsfromlonglong(value);
+    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);
     addReplyLongLong(c,value);
     signalModifiedKey(c->db,c->argv[1]);
     notifyKeyspaceEvent(NOTIFY_HASH,"hincrby",c->argv[1],c->db->id);
     server.dirty++;
 }
 
 void hincrbyfloatCommand(client *c) {
-    double long value, incr;
-    robj *o, *current, *new, *aux;
+    long double value, incr;
+    long long ll;
+    robj *o;
+    sds new;
+    unsigned char *vstr;
+    unsigned int vlen;
 
     if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;
     if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
-    if ((current = hashTypeGetObject(o,c->argv[2])) != NULL) {
-        if (getLongDoubleFromObjectOrReply(c,current,&value,
-            "hash value is not a valid float") != C_OK) {
-            decrRefCount(current);
-            return;
+    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {
+        if (vstr) {
+            if (string2ld((char*)vstr,vlen,&value) == 0) {
+                addReplyError(c,"hash value is not a float");
+                return;
+            }
+        } else {
+            value = (long double)ll;
         }
-        decrRefCount(current);
     } else {
         value = 0;
     }
 
     value += incr;
-    new = createStringObjectFromLongDouble(value,1);
-    hashTypeTryObjectEncoding(o,&c->argv[2],NULL);
-    hashTypeSet(o,c->argv[2],new);
-    addReplyBulk(c,new);
+
+    char buf[256];
+    int len = ld2string(buf,sizeof(buf),value,1);
+    new = sdsnewlen(buf,len);
+    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);
+    addReplyBulkCBuffer(c,buf,len);
     signalModifiedKey(c->db,c->argv[1]);
     notifyKeyspaceEvent(NOTIFY_HASH,"hincrbyfloat",c->argv[1],c->db->id);
     server.dirty++;
 
     /* Always replicate HINCRBYFLOAT as an HSET command with the final value
      * in order to make sure that differences in float pricision or formatting
      * will not create differences in replicas or after an AOF restart. */
+    robj *aux, *newobj;
     aux = createStringObject("HSET",4);
+    newobj = createRawStringObject(buf,len);
     rewriteClientCommandArgument(c,0,aux);
     decrRefCount(aux);
-    rewriteClientCommandArgument(c,3,new);
-    decrRefCount(new);
+    rewriteClientCommandArgument(c,3,newobj);
+    decrRefCount(newobj);
 }
 
-static void addHashFieldToReply(client *c, robj *o, robj *field) {
+static void addHashFieldToReply(client *c, robj *o, sds field) {
     int ret;
 
     if (o == NULL) {
         addReply(c, shared.nullbulk);
         return;
     }
@@ -627,33 +659,29 @@
             } else {
                 addReplyBulkLongLong(c, vll);
             }
         }
 
     } else if (o->encoding == OBJ_ENCODING_HT) {
-        robj *value;
-
-        ret = hashTypeGetFromHashTable(o, field, &value);
-        if (ret < 0) {
+        sds value = hashTypeGetFromHashTable(o, field);
+        if (value == NULL)
             addReply(c, shared.nullbulk);
-        } else {
-            addReplyBulk(c, value);
-        }
-
+        else
+            addReplyBulkCBuffer(c, value, sdslen(value));
     } else {
         serverPanic("Unknown hash encoding");
     }
 }
 
 void hgetCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
         checkType(c,o,OBJ_HASH)) return;
 
-    addHashFieldToReply(c, o, c->argv[2]);
+    addHashFieldToReply(c, o, c->argv[2]->ptr);
 }
 
 void hmgetCommand(client *c) {
     robj *o;
     int i;
 
@@ -664,25 +692,25 @@
         addReply(c, shared.wrongtypeerr);
         return;
     }
 
     addReplyMultiBulkLen(c, c->argc-2);
     for (i = 2; i < c->argc; i++) {
-        addHashFieldToReply(c, o, c->argv[i]);
+        addHashFieldToReply(c, o, c->argv[i]->ptr);
     }
 }
 
 void hdelCommand(client *c) {
     robj *o;
     int j, deleted = 0, keyremoved = 0;
 
     if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,o,OBJ_HASH)) return;
 
     for (j = 2; j < c->argc; j++) {
-        if (hashTypeDelete(o,c->argv[j])) {
+        if (hashTypeDelete(o,c->argv[j]->ptr)) {
             deleted++;
             if (hashTypeLength(o) == 0) {
                 dbDelete(c->db,c->argv[1]);
                 keyremoved = 1;
                 break;
             }
@@ -710,34 +738,29 @@
 
 void hstrlenCommand(client *c) {
     robj *o;
 
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,o,OBJ_HASH)) return;
-    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]));
+    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));
 }
 
 static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {
     if (hi->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *vstr = NULL;
         unsigned int vlen = UINT_MAX;
         long long vll = LLONG_MAX;
 
         hashTypeCurrentFromZiplist(hi, what, &vstr, &vlen, &vll);
-        if (vstr) {
+        if (vstr)
             addReplyBulkCBuffer(c, vstr, vlen);
-        } else {
+        else
             addReplyBulkLongLong(c, vll);
-        }
-
     } else if (hi->encoding == OBJ_ENCODING_HT) {
-        robj *value;
-
-        hashTypeCurrentFromHashTable(hi, what, &value);
-        addReplyBulk(c, value);
-
+        sds value = hashTypeCurrentFromHashTable(hi, what);
+        addReplyBulkCBuffer(c, value, sdslen(value));
     } else {
         serverPanic("Unknown hash encoding");
     }
 }
 
 void genericHgetallCommand(client *c, int flags) {
@@ -785,13 +808,13 @@
 
 void hexistsCommand(client *c) {
     robj *o;
     if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,o,OBJ_HASH)) return;
 
-    addReply(c, hashTypeExists(o,c->argv[2]) ? shared.cone : shared.czero);
+    addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);
 }
 
 void hscanCommand(client *c) {
     robj *o;
     unsigned long cursor;
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_hash.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_hash.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.c	2017-07-14 19:28:42.000000000 +0800
@@ -68,13 +68,13 @@
     } else {
         serverPanic("Unknown list encoding");
     }
     return value;
 }
 
-unsigned long listTypeLength(robj *subject) {
+unsigned long listTypeLength(const robj *subject) {
     if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
         return quicklistCount(subject->ptr);
     } else {
         serverPanic("Unknown list encoding");
     }
 }
@@ -192,32 +192,31 @@
 
 /*-----------------------------------------------------------------------------
  * List Commands
  *----------------------------------------------------------------------------*/
 
 void pushGenericCommand(client *c, int where) {
-    int j, waiting = 0, pushed = 0;
+    int j, pushed = 0;
     robj *lobj = lookupKeyWrite(c->db,c->argv[1]);
 
     if (lobj && lobj->type != OBJ_LIST) {
         addReply(c,shared.wrongtypeerr);
         return;
     }
 
     for (j = 2; j < c->argc; j++) {
-        c->argv[j] = tryObjectEncoding(c->argv[j]);
         if (!lobj) {
             lobj = createQuicklistObject();
             quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,
                                 server.list_compress_depth);
             dbAdd(c->db,c->argv[1],lobj);
         }
         listTypePush(lobj,c->argv[j],where);
         pushed++;
     }
-    addReplyLongLong(c, waiting + (lobj ? listTypeLength(lobj) : 0));
+    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));
     if (pushed) {
         char *event = (where == LIST_HEAD) ? "lpush" : "rpush";
 
         signalModifiedKey(c->db,c->argv[1]);
         notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
     }
@@ -229,74 +228,84 @@
 }
 
 void rpushCommand(client *c) {
     pushGenericCommand(c,LIST_TAIL);
 }
 
-void pushxGenericCommand(client *c, robj *refval, robj *val, int where) {
+void pushxGenericCommand(client *c, int where) {
+    int j, pushed = 0;
     robj *subject;
-    listTypeIterator *iter;
-    listTypeEntry entry;
-    int inserted = 0;
 
     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,subject,OBJ_LIST)) return;
 
-    if (refval != NULL) {
-        /* Seek refval from head to tail */
-        iter = listTypeInitIterator(subject,0,LIST_TAIL);
-        while (listTypeNext(iter,&entry)) {
-            if (listTypeEqual(&entry,refval)) {
-                listTypeInsert(&entry,val,where);
-                inserted = 1;
-                break;
-            }
-        }
-        listTypeReleaseIterator(iter);
+    for (j = 2; j < c->argc; j++) {
+        listTypePush(subject,c->argv[j],where);
+        pushed++;
+    }
 
-        if (inserted) {
-            signalModifiedKey(c->db,c->argv[1]);
-            notifyKeyspaceEvent(NOTIFY_LIST,"linsert",
-                                c->argv[1],c->db->id);
-            server.dirty++;
-        } else {
-            /* Notify client of a failed insert */
-            addReply(c,shared.cnegone);
-            return;
-        }
-    } else {
-        char *event = (where == LIST_HEAD) ? "lpush" : "rpush";
+    addReplyLongLong(c,listTypeLength(subject));
 
-        listTypePush(subject,val,where);
+    if (pushed) {
+        char *event = (where == LIST_HEAD) ? "lpush" : "rpush";
         signalModifiedKey(c->db,c->argv[1]);
         notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
-        server.dirty++;
     }
-
-    addReplyLongLong(c,listTypeLength(subject));
+    server.dirty += pushed;
 }
 
 void lpushxCommand(client *c) {
-    c->argv[2] = tryObjectEncoding(c->argv[2]);
-    pushxGenericCommand(c,NULL,c->argv[2],LIST_HEAD);
+    pushxGenericCommand(c,LIST_HEAD);
 }
 
 void rpushxCommand(client *c) {
-    c->argv[2] = tryObjectEncoding(c->argv[2]);
-    pushxGenericCommand(c,NULL,c->argv[2],LIST_TAIL);
+    pushxGenericCommand(c,LIST_TAIL);
 }
 
 void linsertCommand(client *c) {
-    c->argv[4] = tryObjectEncoding(c->argv[4]);
+    int where;
+    robj *subject;
+    listTypeIterator *iter;
+    listTypeEntry entry;
+    int inserted = 0;
+
     if (strcasecmp(c->argv[2]->ptr,"after") == 0) {
-        pushxGenericCommand(c,c->argv[3],c->argv[4],LIST_TAIL);
+        where = LIST_TAIL;
     } else if (strcasecmp(c->argv[2]->ptr,"before") == 0) {
-        pushxGenericCommand(c,c->argv[3],c->argv[4],LIST_HEAD);
+        where = LIST_HEAD;
     } else {
         addReply(c,shared.syntaxerr);
+        return;
     }
+
+    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
+        checkType(c,subject,OBJ_LIST)) return;
+
+    /* Seek pivot from head to tail */
+    iter = listTypeInitIterator(subject,0,LIST_TAIL);
+    while (listTypeNext(iter,&entry)) {
+        if (listTypeEqual(&entry,c->argv[3])) {
+            listTypeInsert(&entry,c->argv[4],where);
+            inserted = 1;
+            break;
+        }
+    }
+    listTypeReleaseIterator(iter);
+
+    if (inserted) {
+        signalModifiedKey(c->db,c->argv[1]);
+        notifyKeyspaceEvent(NOTIFY_LIST,"linsert",
+                            c->argv[1],c->db->id);
+        server.dirty++;
+    } else {
+        /* Notify client of a failed insert */
+        addReply(c,shared.cnegone);
+        return;
+    }
+
+    addReplyLongLong(c,listTypeLength(subject));
 }
 
 void llenCommand(client *c) {
     robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);
     if (o == NULL || checkType(c,o,OBJ_LIST)) return;
     addReplyLongLong(c,listTypeLength(o));
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_list.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_list.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.c	2017-07-14 19:28:42.000000000 +0800
@@ -36,32 +36,34 @@
 void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
                               robj *dstkey, int op);
 
 /* Factory method to return a set that *can* hold "value". When the object has
  * an integer-encodable value, an intset will be returned. Otherwise a regular
  * hash table. */
-robj *setTypeCreate(robj *value) {
-    if (isObjectRepresentableAsLongLong(value,NULL) == C_OK)
+robj *setTypeCreate(sds value) {
+    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK)
         return createIntsetObject();
     return createSetObject();
 }
 
-/* Add the specified value into a set. The function takes care of incrementing
- * the reference count of the object if needed in order to retain a copy.
+/* Add the specified value into a set.
  *
  * If the value was already member of the set, nothing is done and 0 is
  * returned, otherwise the new element is added and 1 is returned. */
-int setTypeAdd(robj *subject, robj *value) {
+int setTypeAdd(robj *subject, sds value) {
     long long llval;
     if (subject->encoding == OBJ_ENCODING_HT) {
-        if (dictAdd(subject->ptr,value,NULL) == DICT_OK) {
-            incrRefCount(value);
+        dict *ht = subject->ptr;
+        dictEntry *de = dictAddRaw(ht,value,NULL);
+        if (de) {
+            dictSetKey(ht,de,sdsdup(value));
+            dictSetVal(ht,de,NULL);
             return 1;
         }
     } else if (subject->encoding == OBJ_ENCODING_INTSET) {
-        if (isObjectRepresentableAsLongLong(value,&llval) == C_OK) {
+        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
             uint8_t success = 0;
             subject->ptr = intsetAdd(subject->ptr,llval,&success);
             if (success) {
                 /* Convert to regular set when the intset contains
                  * too many entries. */
                 if (intsetLen(subject->ptr) > server.set_max_intset_entries)
@@ -71,48 +73,46 @@
         } else {
             /* Failed to get integer from object, convert to regular set. */
             setTypeConvert(subject,OBJ_ENCODING_HT);
 
             /* The set *was* an intset and this value is not integer
              * encodable, so dictAdd should always work. */
-            serverAssertWithInfo(NULL,value,
-                                dictAdd(subject->ptr,value,NULL) == DICT_OK);
-            incrRefCount(value);
+            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);
             return 1;
         }
     } else {
         serverPanic("Unknown set encoding");
     }
     return 0;
 }
 
-int setTypeRemove(robj *setobj, robj *value) {
+int setTypeRemove(robj *setobj, sds value) {
     long long llval;
     if (setobj->encoding == OBJ_ENCODING_HT) {
         if (dictDelete(setobj->ptr,value) == DICT_OK) {
             if (htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);
             return 1;
         }
     } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
-        if (isObjectRepresentableAsLongLong(value,&llval) == C_OK) {
+        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
             int success;
             setobj->ptr = intsetRemove(setobj->ptr,llval,&success);
             if (success) return 1;
         }
     } else {
         serverPanic("Unknown set encoding");
     }
     return 0;
 }
 
-int setTypeIsMember(robj *subject, robj *value) {
+int setTypeIsMember(robj *subject, sds value) {
     long long llval;
     if (subject->encoding == OBJ_ENCODING_HT) {
         return dictFind((dict*)subject->ptr,value) != NULL;
     } else if (subject->encoding == OBJ_ENCODING_INTSET) {
-        if (isObjectRepresentableAsLongLong(value,&llval) == C_OK) {
+        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
             return intsetFind((intset*)subject->ptr,llval);
         }
     } else {
         serverPanic("Unknown set encoding");
     }
     return 0;
@@ -138,102 +138,95 @@
     zfree(si);
 }
 
 /* Move to the next entry in the set. Returns the object at the current
  * position.
  *
- * Since set elements can be internally be stored as redis objects or
+ * Since set elements can be internally be stored as SDS strings or
  * simple arrays of integers, setTypeNext returns the encoding of the
  * set object you are iterating, and will populate the appropriate pointer
- * (objele) or (llele) accordingly.
+ * (sdsele) or (llele) accordingly.
  *
- * Note that both the objele and llele pointers should be passed and cannot
+ * Note that both the sdsele and llele pointers should be passed and cannot
  * be NULL since the function will try to defensively populate the non
  * used field with values which are easy to trap if misused.
  *
- * When there are no longer elements -1 is returned.
- * Returned objects ref count is not incremented, so this function is
- * copy on write friendly. */
-int setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele) {
+ * When there are no longer elements -1 is returned. */
+int setTypeNext(setTypeIterator *si, sds *sdsele, int64_t *llele) {
     if (si->encoding == OBJ_ENCODING_HT) {
         dictEntry *de = dictNext(si->di);
         if (de == NULL) return -1;
-        *objele = dictGetKey(de);
+        *sdsele = dictGetKey(de);
         *llele = -123456789; /* Not needed. Defensive. */
     } else if (si->encoding == OBJ_ENCODING_INTSET) {
         if (!intsetGet(si->subject->ptr,si->ii++,llele))
             return -1;
-        *objele = NULL; /* Not needed. Defensive. */
+        *sdsele = NULL; /* Not needed. Defensive. */
     } else {
         serverPanic("Wrong set encoding in setTypeNext");
     }
     return si->encoding;
 }
 
 /* The not copy on write friendly version but easy to use version
- * of setTypeNext() is setTypeNextObject(), returning new objects
- * or incrementing the ref count of returned objects. So if you don't
- * retain a pointer to this object you should call decrRefCount() against it.
+ * of setTypeNext() is setTypeNextObject(), returning new SDS
+ * strings. So if you don't retain a pointer to this object you should call
+ * sdsfree() against it.
  *
  * This function is the way to go for write operations where COW is not
- * an issue as the result will be anyway of incrementing the ref count. */
-robj *setTypeNextObject(setTypeIterator *si) {
+ * an issue. */
+sds setTypeNextObject(setTypeIterator *si) {
     int64_t intele;
-    robj *objele;
+    sds sdsele;
     int encoding;
 
-    encoding = setTypeNext(si,&objele,&intele);
+    encoding = setTypeNext(si,&sdsele,&intele);
     switch(encoding) {
         case -1:    return NULL;
         case OBJ_ENCODING_INTSET:
-            return createStringObjectFromLongLong(intele);
+            return sdsfromlonglong(intele);
         case OBJ_ENCODING_HT:
-            incrRefCount(objele);
-            return objele;
+            return sdsdup(sdsele);
         default:
             serverPanic("Unsupported encoding");
     }
     return NULL; /* just to suppress warnings */
 }
 
 /* Return random element from a non empty set.
  * The returned element can be a int64_t value if the set is encoded
- * as an "intset" blob of integers, or a redis object if the set
+ * as an "intset" blob of integers, or an SDS string if the set
  * is a regular set.
  *
  * The caller provides both pointers to be populated with the right
  * object. The return value of the function is the object->encoding
  * field of the object and is used by the caller to check if the
  * int64_t pointer or the redis object pointer was populated.
  *
- * Note that both the objele and llele pointers should be passed and cannot
+ * Note that both the sdsele and llele pointers should be passed and cannot
  * be NULL since the function will try to defensively populate the non
- * used field with values which are easy to trap if misused.
- *
- * When an object is returned (the set was a real set) the ref count
- * of the object is not incremented so this function can be considered
- * copy on write friendly. */
-int setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele) {
+ * used field with values which are easy to trap if misused. */
+int setTypeRandomElement(robj *setobj, sds *sdsele, int64_t *llele) {
     if (setobj->encoding == OBJ_ENCODING_HT) {
         dictEntry *de = dictGetRandomKey(setobj->ptr);
-        *objele = dictGetKey(de);
+        *sdsele = dictGetKey(de);
         *llele = -123456789; /* Not needed. Defensive. */
     } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
         *llele = intsetRandom(setobj->ptr);
-        *objele = NULL; /* Not needed. Defensive. */
+        *sdsele = NULL; /* Not needed. Defensive. */
     } else {
         serverPanic("Unknown set encoding");
     }
     return setobj->encoding;
 }
 
-unsigned long setTypeSize(robj *subject) {
+unsigned long setTypeSize(const robj *subject) {
     if (subject->encoding == OBJ_ENCODING_HT) {
-        return dictSize((dict*)subject->ptr);
+        return dictSize((const dict*)subject->ptr);
     } else if (subject->encoding == OBJ_ENCODING_INTSET) {
-        return intsetLen((intset*)subject->ptr);
+        return intsetLen((const intset*)subject->ptr);
     } else {
         serverPanic("Unknown set encoding");
     }
 }
 
 /* Convert the set to specified encoding. The resulting dict (when converting
@@ -244,23 +237,22 @@
     serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&
                              setobj->encoding == OBJ_ENCODING_INTSET);
 
     if (enc == OBJ_ENCODING_HT) {
         int64_t intele;
         dict *d = dictCreate(&setDictType,NULL);
-        robj *element;
+        sds element;
 
         /* Presize the dict to avoid rehashing */
         dictExpand(d,intsetLen(setobj->ptr));
 
         /* To add the elements we extract integers and create redis objects */
         si = setTypeInitIterator(setobj);
         while (setTypeNext(si,&element,&intele) != -1) {
-            element = createStringObjectFromLongLong(intele);
-            serverAssertWithInfo(NULL,element,
-                                dictAdd(d,element,NULL) == DICT_OK);
+            element = sdsfromlonglong(intele);
+            serverAssert(dictAdd(d,element,NULL) == DICT_OK);
         }
         setTypeReleaseIterator(si);
 
         setobj->encoding = OBJ_ENCODING_HT;
         zfree(setobj->ptr);
         setobj->ptr = d;
@@ -272,24 +264,23 @@
 void saddCommand(client *c) {
     robj *set;
     int j, added = 0;
 
     set = lookupKeyWrite(c->db,c->argv[1]);
     if (set == NULL) {
-        set = setTypeCreate(c->argv[2]);
+        set = setTypeCreate(c->argv[2]->ptr);
         dbAdd(c->db,c->argv[1],set);
     } else {
         if (set->type != OBJ_SET) {
             addReply(c,shared.wrongtypeerr);
             return;
         }
     }
 
     for (j = 2; j < c->argc; j++) {
-        c->argv[j] = tryObjectEncoding(c->argv[j]);
-        if (setTypeAdd(set,c->argv[j])) added++;
+        if (setTypeAdd(set,c->argv[j]->ptr)) added++;
     }
     if (added) {
         signalModifiedKey(c->db,c->argv[1]);
         notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[1],c->db->id);
     }
     server.dirty += added;
@@ -301,13 +292,13 @@
     int j, deleted = 0, keyremoved = 0;
 
     if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,set,OBJ_SET)) return;
 
     for (j = 2; j < c->argc; j++) {
-        if (setTypeRemove(set,c->argv[j])) {
+        if (setTypeRemove(set,c->argv[j]->ptr)) {
             deleted++;
             if (setTypeSize(set) == 0) {
                 dbDelete(c->db,c->argv[1]);
                 keyremoved = 1;
                 break;
             }
@@ -325,13 +316,13 @@
 }
 
 void smoveCommand(client *c) {
     robj *srcset, *dstset, *ele;
     srcset = lookupKeyWrite(c->db,c->argv[1]);
     dstset = lookupKeyWrite(c->db,c->argv[2]);
-    ele = c->argv[3] = tryObjectEncoding(c->argv[3]);
+    ele = c->argv[3];
 
     /* If the source key does not exist return 0 */
     if (srcset == NULL) {
         addReply(c,shared.czero);
         return;
     }
@@ -340,18 +331,19 @@
      * is set and has the wrong type, return with an error. */
     if (checkType(c,srcset,OBJ_SET) ||
         (dstset && checkType(c,dstset,OBJ_SET))) return;
 
     /* If srcset and dstset are equal, SMOVE is a no-op */
     if (srcset == dstset) {
-        addReply(c,setTypeIsMember(srcset,ele) ? shared.cone : shared.czero);
+        addReply(c,setTypeIsMember(srcset,ele->ptr) ?
+            shared.cone : shared.czero);
         return;
     }
 
     /* If the element cannot be removed from the src set, return 0. */
-    if (!setTypeRemove(srcset,ele)) {
+    if (!setTypeRemove(srcset,ele->ptr)) {
         addReply(c,shared.czero);
         return;
     }
     notifyKeyspaceEvent(NOTIFY_SET,"srem",c->argv[1],c->db->id);
 
     /* Remove the src set from the database when empty */
@@ -359,36 +351,35 @@
         dbDelete(c->db,c->argv[1]);
         notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
     }
 
     /* Create the destination set when it doesn't exist */
     if (!dstset) {
-        dstset = setTypeCreate(ele);
+        dstset = setTypeCreate(ele->ptr);
         dbAdd(c->db,c->argv[2],dstset);
     }
 
     signalModifiedKey(c->db,c->argv[1]);
     signalModifiedKey(c->db,c->argv[2]);
     server.dirty++;
 
     /* An extra key has changed when ele was successfully added to dstset */
-    if (setTypeAdd(dstset,ele)) {
+    if (setTypeAdd(dstset,ele->ptr)) {
         server.dirty++;
         notifyKeyspaceEvent(NOTIFY_SET,"sadd",c->argv[2],c->db->id);
     }
     addReply(c,shared.cone);
 }
 
 void sismemberCommand(client *c) {
     robj *set;
 
     if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
         checkType(c,set,OBJ_SET)) return;
 
-    c->argv[2] = tryObjectEncoding(c->argv[2]);
-    if (setTypeIsMember(set,c->argv[2]))
+    if (setTypeIsMember(set,c->argv[2]->ptr))
         addReply(c,shared.cone);
     else
         addReply(c,shared.czero);
 }
 
 void scardCommand(client *c) {
@@ -455,21 +446,22 @@
         rewriteClientCommandVector(c,2,shared.del,c->argv[1]);
         signalModifiedKey(c->db,c->argv[1]);
         server.dirty++;
         return;
     }
 
-    /* Case 2 and 3 require to replicate SPOP as a set of SERM commands.
+    /* Case 2 and 3 require to replicate SPOP as a set of SREM commands.
      * Prepare our replication argument vector. Also send the array length
      * which is common to both the code paths. */
     robj *propargv[3];
     propargv[0] = createStringObject("SREM",4);
     propargv[1] = c->argv[1];
     addReplyMultiBulkLen(c,count);
 
     /* Common iteration vars. */
+    sds sdsele;
     robj *objele;
     int encoding;
     int64_t llele;
     unsigned long remaining = size-count; /* Elements left after SPOP. */
 
     /* If we are here, the number of requested elements is less than the
@@ -478,23 +470,24 @@
      *
      * CASE 2: The number of elements to return is small compared to the
      * set size. We can just extract random elements and return them to
      * the set. */
     if (remaining*SPOP_MOVE_STRATEGY_MUL > count) {
         while(count--) {
-            encoding = setTypeRandomElement(set,&objele,&llele);
+            /* Emit and remove. */
+            encoding = setTypeRandomElement(set,&sdsele,&llele);
             if (encoding == OBJ_ENCODING_INTSET) {
+                addReplyBulkLongLong(c,llele);
                 objele = createStringObjectFromLongLong(llele);
+                set->ptr = intsetRemove(set->ptr,llele,NULL);
             } else {
-                incrRefCount(objele);
+                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));
+                objele = createStringObject(sdsele,sdslen(sdsele));
+                setTypeRemove(set,sdsele);
             }
 
-            /* Return the element to the client and remove from the set. */
-            addReplyBulk(c,objele);
-            setTypeRemove(set,objele);
-
             /* Replicate/AOF this command as an SREM operation */
             propargv[2] = objele;
             alsoPropagate(server.sremCommand,c->db->id,propargv,3,
                 PROPAGATE_AOF|PROPAGATE_REPL);
             decrRefCount(objele);
         }
@@ -508,44 +501,44 @@
      * set). Then we return the elements left in the original set and
      * release it. */
         robj *newset = NULL;
 
         /* Create a new set with just the remaining elements. */
         while(remaining--) {
-            encoding = setTypeRandomElement(set,&objele,&llele);
+            encoding = setTypeRandomElement(set,&sdsele,&llele);
             if (encoding == OBJ_ENCODING_INTSET) {
-                objele = createStringObjectFromLongLong(llele);
+                sdsele = sdsfromlonglong(llele);
             } else {
-                incrRefCount(objele);
+                sdsele = sdsdup(sdsele);
             }
-            if (!newset) newset = setTypeCreate(objele);
-            setTypeAdd(newset,objele);
-            setTypeRemove(set,objele);
-            decrRefCount(objele);
+            if (!newset) newset = setTypeCreate(sdsele);
+            setTypeAdd(newset,sdsele);
+            setTypeRemove(set,sdsele);
+            sdsfree(sdsele);
         }
 
         /* Assign the new set as the key value. */
         incrRefCount(set); /* Protect the old set value. */
         dbOverwrite(c->db,c->argv[1],newset);
 
         /* Tranfer the old set to the client and release it. */
         setTypeIterator *si;
         si = setTypeInitIterator(set);
-        while((encoding = setTypeNext(si,&objele,&llele)) != -1) {
+        while((encoding = setTypeNext(si,&sdsele,&llele)) != -1) {
             if (encoding == OBJ_ENCODING_INTSET) {
+                addReplyBulkLongLong(c,llele);
                 objele = createStringObjectFromLongLong(llele);
             } else {
-                incrRefCount(objele);
+                addReplyBulkCBuffer(c,sdsele,sdslen(sdsele));
+                objele = createStringObject(sdsele,sdslen(sdsele));
             }
-            addReplyBulk(c,objele);
 
             /* Replicate/AOF this command as an SREM operation */
             propargv[2] = objele;
             alsoPropagate(server.sremCommand,c->db->id,propargv,3,
                 PROPAGATE_AOF|PROPAGATE_REPL);
-
             decrRefCount(objele);
         }
         setTypeReleaseIterator(si);
         decrRefCount(set);
     }
 
@@ -558,12 +551,13 @@
     signalModifiedKey(c->db,c->argv[1]);
     server.dirty++;
 }
 
 void spopCommand(client *c) {
     robj *set, *ele, *aux;
+    sds sdsele;
     int64_t llele;
     int encoding;
 
     if (c->argc == 3) {
         spopWithCountCommand(c);
         return;
@@ -575,33 +569,33 @@
     /* Make sure a key with the name inputted exists, and that it's type is
      * indeed a set */
     if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.nullbulk)) == NULL ||
         checkType(c,set,OBJ_SET)) return;
 
     /* Get a random element from the set */
-    encoding = setTypeRandomElement(set,&ele,&llele);
+    encoding = setTypeRandomElement(set,&sdsele,&llele);
 
     /* Remove the element from the set */
     if (encoding == OBJ_ENCODING_INTSET) {
         ele = createStringObjectFromLongLong(llele);
         set->ptr = intsetRemove(set->ptr,llele,NULL);
     } else {
-        incrRefCount(ele);
-        setTypeRemove(set,ele);
+        ele = createStringObject(sdsele,sdslen(sdsele));
+        setTypeRemove(set,ele->ptr);
     }
 
     notifyKeyspaceEvent(NOTIFY_SET,"spop",c->argv[1],c->db->id);
 
     /* Replicate/AOF this command as an SREM operation */
     aux = createStringObject("SREM",4);
     rewriteClientCommandVector(c,3,aux,c->argv[1],ele);
-    decrRefCount(ele);
     decrRefCount(aux);
 
     /* Add the element to the reply */
     addReplyBulk(c,ele);
+    decrRefCount(ele);
 
     /* Delete the set if it's empty */
     if (setTypeSize(set) == 0) {
         dbDelete(c->db,c->argv[1]);
         notifyKeyspaceEvent(NOTIFY_GENERIC,"del",c->argv[1],c->db->id);
     }
@@ -620,13 +614,14 @@
 #define SRANDMEMBER_SUB_STRATEGY_MUL 3
 
 void srandmemberWithCountCommand(client *c) {
     long l;
     unsigned long count, size;
     int uniq = 1;
-    robj *set, *ele;
+    robj *set;
+    sds ele;
     int64_t llele;
     int encoding;
 
     dict *d;
 
     if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
@@ -657,13 +652,13 @@
         addReplyMultiBulkLen(c,count);
         while(count--) {
             encoding = setTypeRandomElement(set,&ele,&llele);
             if (encoding == OBJ_ENCODING_INTSET) {
                 addReplyBulkLongLong(c,llele);
             } else {
-                addReplyBulk(c,ele);
+                addReplyBulkCBuffer(c,ele,sdslen(ele));
             }
         }
         return;
     }
 
     /* CASE 2:
@@ -672,13 +667,13 @@
     if (count >= size) {
         sunionDiffGenericCommand(c,c->argv+1,1,NULL,SET_OP_UNION);
         return;
     }
 
     /* For CASE 3 and CASE 4 we need an auxiliary dictionary. */
-    d = dictCreate(&setDictType,NULL);
+    d = dictCreate(&objectKeyPointerValueDictType,NULL);
 
     /* CASE 3:
      * The number of elements inside the set is not greater than
      * SRANDMEMBER_SUB_STRATEGY_MUL times the number of requested elements.
      * In this case we create a set from scratch with all the elements, and
      * subtract random elements to reach the requested number of elements.
@@ -694,13 +689,13 @@
         while((encoding = setTypeNext(si,&ele,&llele)) != -1) {
             int retval = DICT_ERR;
 
             if (encoding == OBJ_ENCODING_INTSET) {
                 retval = dictAdd(d,createStringObjectFromLongLong(llele),NULL);
             } else {
-                retval = dictAdd(d,dupStringObject(ele),NULL);
+                retval = dictAdd(d,createStringObject(ele,sdslen(ele)),NULL);
             }
             serverAssert(retval == DICT_OK);
         }
         setTypeReleaseIterator(si);
         serverAssert(dictSize(d) == size);
 
@@ -717,27 +712,28 @@
     /* CASE 4: We have a big set compared to the requested number of elements.
      * In this case we can simply get random elements from the set and add
      * to the temporary set, trying to eventually get enough unique elements
      * to reach the specified count. */
     else {
         unsigned long added = 0;
+        robj *objele;
 
         while(added < count) {
             encoding = setTypeRandomElement(set,&ele,&llele);
             if (encoding == OBJ_ENCODING_INTSET) {
-                ele = createStringObjectFromLongLong(llele);
+                objele = createStringObjectFromLongLong(llele);
             } else {
-                ele = dupStringObject(ele);
+                objele = createStringObject(ele,sdslen(ele));
             }
             /* Try to add the object to the dictionary. If it already exists
              * free it, otherwise increment the number of objects we have
              * in the result dictionary. */
-            if (dictAdd(d,ele,NULL) == DICT_OK)
+            if (dictAdd(d,objele,NULL) == DICT_OK)
                 added++;
             else
-                decrRefCount(ele);
+                decrRefCount(objele);
         }
     }
 
     /* CASE 3 & 4: send the result to the user. */
     {
         dictIterator *di;
@@ -750,13 +746,14 @@
         dictReleaseIterator(di);
         dictRelease(d);
     }
 }
 
 void srandmemberCommand(client *c) {
-    robj *set, *ele;
+    robj *set;
+    sds ele;
     int64_t llele;
     int encoding;
 
     if (c->argc == 3) {
         srandmemberWithCountCommand(c);
         return;
@@ -769,13 +766,13 @@
         checkType(c,set,OBJ_SET)) return;
 
     encoding = setTypeRandomElement(set,&ele,&llele);
     if (encoding == OBJ_ENCODING_INTSET) {
         addReplyBulkLongLong(c,llele);
     } else {
-        addReplyBulk(c,ele);
+        addReplyBulkCBuffer(c,ele,sdslen(ele));
     }
 }
 
 int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
     return setTypeSize(*(robj**)s1)-setTypeSize(*(robj**)s2);
 }
@@ -789,13 +786,14 @@
 }
 
 void sinterGenericCommand(client *c, robj **setkeys,
                           unsigned long setnum, robj *dstkey) {
     robj **sets = zmalloc(sizeof(robj*)*setnum);
     setTypeIterator *si;
-    robj *eleobj, *dstset = NULL;
+    robj *dstset = NULL;
+    sds elesds;
     int64_t intobj;
     void *replylen = NULL;
     unsigned long j, cardinality = 0;
     int encoding;
 
     for (j = 0; j < setnum; j++) {
@@ -839,64 +837,54 @@
     }
 
     /* Iterate all the elements of the first (smallest) set, and test
      * the element against all the other sets, if at least one set does
      * not include the element it is discarded */
     si = setTypeInitIterator(sets[0]);
-    while((encoding = setTypeNext(si,&eleobj,&intobj)) != -1) {
+    while((encoding = setTypeNext(si,&elesds,&intobj)) != -1) {
         for (j = 1; j < setnum; j++) {
             if (sets[j] == sets[0]) continue;
             if (encoding == OBJ_ENCODING_INTSET) {
                 /* intset with intset is simple... and fast */
                 if (sets[j]->encoding == OBJ_ENCODING_INTSET &&
                     !intsetFind((intset*)sets[j]->ptr,intobj))
                 {
                     break;
                 /* in order to compare an integer with an object we
                  * have to use the generic function, creating an object
                  * for this */
                 } else if (sets[j]->encoding == OBJ_ENCODING_HT) {
-                    eleobj = createStringObjectFromLongLong(intobj);
-                    if (!setTypeIsMember(sets[j],eleobj)) {
-                        decrRefCount(eleobj);
+                    elesds = sdsfromlonglong(intobj);
+                    if (!setTypeIsMember(sets[j],elesds)) {
+                        sdsfree(elesds);
                         break;
                     }
-                    decrRefCount(eleobj);
+                    sdsfree(elesds);
                 }
             } else if (encoding == OBJ_ENCODING_HT) {
-                /* Optimization... if the source object is integer
-                 * encoded AND the target set is an intset, we can get
-                 * a much faster path. */
-                if (eleobj->encoding == OBJ_ENCODING_INT &&
-                    sets[j]->encoding == OBJ_ENCODING_INTSET &&
-                    !intsetFind((intset*)sets[j]->ptr,(long)eleobj->ptr))
-                {
-                    break;
-                /* else... object to object check is easy as we use the
-                 * type agnostic API here. */
-                } else if (!setTypeIsMember(sets[j],eleobj)) {
+                if (!setTypeIsMember(sets[j],elesds)) {
                     break;
                 }
             }
         }
 
         /* Only take action when all sets contain the member */
         if (j == setnum) {
             if (!dstkey) {
                 if (encoding == OBJ_ENCODING_HT)
-                    addReplyBulk(c,eleobj);
+                    addReplyBulkCBuffer(c,elesds,sdslen(elesds));
                 else
                     addReplyBulkLongLong(c,intobj);
                 cardinality++;
             } else {
                 if (encoding == OBJ_ENCODING_INTSET) {
-                    eleobj = createStringObjectFromLongLong(intobj);
-                    setTypeAdd(dstset,eleobj);
-                    decrRefCount(eleobj);
+                    elesds = sdsfromlonglong(intobj);
+                    setTypeAdd(dstset,elesds);
+                    sdsfree(elesds);
                 } else {
-                    setTypeAdd(dstset,eleobj);
+                    setTypeAdd(dstset,elesds);
                 }
             }
         }
     }
     setTypeReleaseIterator(si);
 
@@ -937,13 +925,14 @@
 #define SET_OP_INTER 2
 
 void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
                               robj *dstkey, int op) {
     robj **sets = zmalloc(sizeof(robj*)*setnum);
     setTypeIterator *si;
-    robj *ele, *dstset = NULL;
+    robj *dstset = NULL;
+    sds ele;
     int j, cardinality = 0;
     int diff_algo = 1;
 
     for (j = 0; j < setnum; j++) {
         robj *setobj = dstkey ?
             lookupKeyWrite(c->db,setkeys[j]) :
@@ -1003,13 +992,13 @@
         for (j = 0; j < setnum; j++) {
             if (!sets[j]) continue; /* non existing keys are like empty sets */
 
             si = setTypeInitIterator(sets[j]);
             while((ele = setTypeNextObject(si)) != NULL) {
                 if (setTypeAdd(dstset,ele)) cardinality++;
-                decrRefCount(ele);
+                sdsfree(ele);
             }
             setTypeReleaseIterator(si);
         }
     } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 1) {
         /* DIFF Algorithm 1:
          *
@@ -1028,13 +1017,13 @@
             }
             if (j == setnum) {
                 /* There is no other set with this element. Add it. */
                 setTypeAdd(dstset,ele);
                 cardinality++;
             }
-            decrRefCount(ele);
+            sdsfree(ele);
         }
         setTypeReleaseIterator(si);
     } else if (op == SET_OP_DIFF && sets[0] && diff_algo == 2) {
         /* DIFF Algorithm 2:
          *
          * Add all the elements of the first set to the auxiliary set.
@@ -1049,13 +1038,13 @@
             while((ele = setTypeNextObject(si)) != NULL) {
                 if (j == 0) {
                     if (setTypeAdd(dstset,ele)) cardinality++;
                 } else {
                     if (setTypeRemove(dstset,ele)) cardinality--;
                 }
-                decrRefCount(ele);
+                sdsfree(ele);
             }
             setTypeReleaseIterator(si);
 
             /* Exit if result set is empty as any additional removal
              * of elements will have no effect. */
             if (cardinality == 0) break;
@@ -1064,14 +1053,14 @@
 
     /* Output the content of the resulting set, if not in STORE mode */
     if (!dstkey) {
         addReplyMultiBulkLen(c,cardinality);
         si = setTypeInitIterator(dstset);
         while((ele = setTypeNextObject(si)) != NULL) {
-            addReplyBulk(c,ele);
-            decrRefCount(ele);
+            addReplyBulkCBuffer(c,ele,sdslen(ele));
+            sdsfree(ele);
         }
         setTypeReleaseIterator(si);
         decrRefCount(dstset);
     } else {
         /* If we have a target key where to store the resulting set
          * create this key with the result set inside */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_set.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_set.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.c	2017-07-14 19:28:42.000000000 +0800
@@ -82,13 +82,13 @@
     {
         addReply(c, abort_reply ? abort_reply : shared.nullbulk);
         return;
     }
     setKey(c->db,key,val);
     server.dirty++;
-    if (expire) setExpire(c->db,key,mstime()+milliseconds);
+    if (expire) setExpire(c,c->db,key,mstime()+milliseconds);
     notifyKeyspaceEvent(NOTIFY_STRING,"set",key,c->db->id);
     if (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,
         "expire",key,c->db->id);
     addReply(c, ok_reply ? ok_reply : shared.ok);
 }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_string.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_string.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.c	2017-07-14 19:28:42.000000000 +0800
@@ -35,36 +35,51 @@
 /* ZSETs are ordered sets using two data structures to hold the same elements
  * in order to get O(log(N)) INSERT and REMOVE operations into a sorted
  * data structure.
  *
  * The elements are added to a hash table mapping Redis objects to scores.
  * At the same time the elements are added to a skip list mapping scores
- * to Redis objects (so objects are sorted by scores in this "view"). */
-
-/* This skiplist implementation is almost a C translation of the original
+ * to Redis objects (so objects are sorted by scores in this "view").
+ *
+ * Note that the SDS string representing the element is the same in both
+ * the hash table and skiplist in order to save memory. What we do in order
+ * to manage the shared SDS string more easily is to free the SDS string
+ * only in zslFreeNode(). The dictionary has no value free method set.
+ * So we should always remove an element from the dictionary, and later from
+ * the skiplist.
+ *
+ * This skiplist implementation is almost a C translation of the original
  * algorithm described by William Pugh in "Skip Lists: A Probabilistic
  * Alternative to Balanced Trees", modified in three ways:
  * a) this implementation allows for repeated scores.
  * b) the comparison is not just by key (our 'score') but by satellite data.
  * c) there is a back pointer, so it's a doubly linked list with the back
  * pointers being only at "level 1". This allows to traverse the list
  * from tail to head, useful for ZREVRANGE. */
 
 #include "server.h"
 #include <math.h>
 
-static int zslLexValueGteMin(robj *value, zlexrangespec *spec);
-static int zslLexValueLteMax(robj *value, zlexrangespec *spec);
+/*-----------------------------------------------------------------------------
+ * Skiplist implementation of the low level API
+ *----------------------------------------------------------------------------*/
+
+int zslLexValueGteMin(sds value, zlexrangespec *spec);
+int zslLexValueLteMax(sds value, zlexrangespec *spec);
 
-zskiplistNode *zslCreateNode(int level, double score, robj *obj) {
-    zskiplistNode *zn = zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
+/* Create a skiplist node with the specified number of levels.
+ * The SDS string 'ele' is referenced by the node after the call. */
+zskiplistNode *zslCreateNode(int level, double score, sds ele) {
+    zskiplistNode *zn =
+        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
     zn->score = score;
-    zn->obj = obj;
+    zn->ele = ele;
     return zn;
 }
 
+/* Create a new skiplist. */
 zskiplist *zslCreate(void) {
     int j;
     zskiplist *zsl;
 
     zsl = zmalloc(sizeof(*zsl));
     zsl->level = 1;
@@ -76,17 +91,21 @@
     }
     zsl->header->backward = NULL;
     zsl->tail = NULL;
     return zsl;
 }
 
+/* Free the specified skiplist node. The referenced SDS string representation
+ * of the element is freed too, unless node->ele is set to NULL before calling
+ * this function. */
 void zslFreeNode(zskiplistNode *node) {
-    decrRefCount(node->obj);
+    sdsfree(node->ele);
     zfree(node);
 }
 
+/* Free a whole skiplist. */
 void zslFree(zskiplist *zsl) {
     zskiplistNode *node = zsl->header->level[0].forward, *next;
 
     zfree(zsl->header);
     while(node) {
         next = node->level[0].forward;
@@ -104,45 +123,49 @@
     int level = 1;
     while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
         level += 1;
     return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
 }
 
-zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) {
+/* Insert a new node in the skiplist. Assumes the element does not already
+ * exist (up to the caller to enforce that). The skiplist takes ownership
+ * of the passed SDS string 'ele'. */
+zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     unsigned int rank[ZSKIPLIST_MAXLEVEL];
     int i, level;
 
     serverAssert(!isnan(score));
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
         /* store rank that is crossed to reach the insert position */
         rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
         while (x->level[i].forward &&
-            (x->level[i].forward->score < score ||
-                (x->level[i].forward->score == score &&
-                compareStringObjects(x->level[i].forward->obj,obj) < 0))) {
+                (x->level[i].forward->score < score ||
+                    (x->level[i].forward->score == score &&
+                    sdscmp(x->level[i].forward->ele,ele) < 0)))
+        {
             rank[i] += x->level[i].span;
             x = x->level[i].forward;
         }
         update[i] = x;
     }
-    /* we assume the key is not already inside, since we allow duplicated
-     * scores, and the re-insertion of score and redis object should never
-     * happen since the caller of zslInsert() should test in the hash table
-     * if the element is already inside or not. */
+    /* we assume the element is not already inside, since we allow duplicated
+     * scores, reinserting the same element should never happen since the
+     * caller of zslInsert() should test in the hash table if the element is
+     * already inside or not. */
     level = zslRandomLevel();
     if (level > zsl->level) {
         for (i = zsl->level; i < level; i++) {
             rank[i] = 0;
             update[i] = zsl->header;
             update[i]->level[i].span = zsl->length;
         }
         zsl->level = level;
     }
-    x = zslCreateNode(level,score,obj);
+    x = zslCreateNode(level,score,ele);
     for (i = 0; i < level; i++) {
         x->level[i].forward = update[i]->level[i].forward;
         update[i]->level[i].forward = x;
 
         /* update span covered by update[i] as x is inserted here */
         x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
@@ -181,38 +204,50 @@
     }
     while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
         zsl->level--;
     zsl->length--;
 }
 
-/* Delete an element with matching score/object from the skiplist. */
-int zslDelete(zskiplist *zsl, double score, robj *obj) {
+/* Delete an element with matching score/element from the skiplist.
+ * The function returns 1 if the node was found and deleted, otherwise
+ * 0 is returned.
+ *
+ * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise
+ * it is not freed (but just unlinked) and *node is set to the node pointer,
+ * so that it is possible for the caller to reuse the node (including the
+ * referenced SDS string at node->ele). */
+int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
     zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
     int i;
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
         while (x->level[i].forward &&
-            (x->level[i].forward->score < score ||
-                (x->level[i].forward->score == score &&
-                compareStringObjects(x->level[i].forward->obj,obj) < 0)))
+                (x->level[i].forward->score < score ||
+                    (x->level[i].forward->score == score &&
+                     sdscmp(x->level[i].forward->ele,ele) < 0)))
+        {
             x = x->level[i].forward;
+        }
         update[i] = x;
     }
     /* We may have multiple elements with the same score, what we need
      * is to find the element with both the right score and object. */
     x = x->level[0].forward;
-    if (x && score == x->score && equalStringObjects(x->obj,obj)) {
+    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {
         zslDeleteNode(zsl, x, update);
-        zslFreeNode(x);
+        if (!node)
+            zslFreeNode(x);
+        else
+            *node = x;
         return 1;
     }
     return 0; /* not found */
 }
 
-static int zslValueGteMin(double value, zrangespec *spec) {
+int zslValueGteMin(double value, zrangespec *spec) {
     return spec->minex ? (value > spec->min) : (value >= spec->min);
 }
 
 int zslValueLteMax(double value, zrangespec *spec) {
     return spec->maxex ? (value < spec->max) : (value <= spec->max);
 }
@@ -309,14 +344,14 @@
     /* Delete nodes while in range. */
     while (x &&
            (range->maxex ? x->score < range->max : x->score <= range->max))
     {
         zskiplistNode *next = x->level[0].forward;
         zslDeleteNode(zsl,x,update);
-        dictDelete(dict,x->obj);
-        zslFreeNode(x);
+        dictDelete(dict,x->ele);
+        zslFreeNode(x); /* Here is where x->ele is actually released. */
         removed++;
         x = next;
     }
     return removed;
 }
 
@@ -326,26 +361,26 @@
     int i;
 
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
         while (x->level[i].forward &&
-            !zslLexValueGteMin(x->level[i].forward->obj,range))
+            !zslLexValueGteMin(x->level[i].forward->ele,range))
                 x = x->level[i].forward;
         update[i] = x;
     }
 
     /* Current node is the last with score < or <= min. */
     x = x->level[0].forward;
 
     /* Delete nodes while in range. */
-    while (x && zslLexValueLteMax(x->obj,range)) {
+    while (x && zslLexValueLteMax(x->ele,range)) {
         zskiplistNode *next = x->level[0].forward;
         zslDeleteNode(zsl,x,update);
-        dictDelete(dict,x->obj);
-        zslFreeNode(x);
+        dictDelete(dict,x->ele);
+        zslFreeNode(x); /* Here is where x->ele is actually released. */
         removed++;
         x = next;
     }
     return removed;
 }
 
@@ -367,42 +402,42 @@
 
     traversed++;
     x = x->level[0].forward;
     while (x && traversed <= end) {
         zskiplistNode *next = x->level[0].forward;
         zslDeleteNode(zsl,x,update);
-        dictDelete(dict,x->obj);
+        dictDelete(dict,x->ele);
         zslFreeNode(x);
         removed++;
         traversed++;
         x = next;
     }
     return removed;
 }
 
 /* Find the rank for an element by both score and key.
  * Returns 0 when the element cannot be found, rank otherwise.
  * Note that the rank is 1-based due to the span of zsl->header to the
  * first element. */
-unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) {
+unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
     zskiplistNode *x;
     unsigned long rank = 0;
     int i;
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
         while (x->level[i].forward &&
             (x->level[i].forward->score < score ||
                 (x->level[i].forward->score == score &&
-                compareStringObjects(x->level[i].forward->obj,o) <= 0))) {
+                sdscmp(x->level[i].forward->ele,ele) <= 0))) {
             rank += x->level[i].span;
             x = x->level[i].forward;
         }
 
         /* x might be equal to zsl->header, so test if obj is non-NULL */
-        if (x->obj && equalStringObjects(x->obj,o)) {
+        if (x->ele && sdscmp(x->ele,ele) == 0) {
             return rank;
         }
     }
     return 0;
 }
 
@@ -475,107 +510,105 @@
   * that will be used for the comparision, and ex will be set to 0 or 1
   * respectively if the item is exclusive or inclusive. C_OK will be
   * returned.
   *
   * If the string is not a valid range C_ERR is returned, and the value
   * of *dest and *ex is undefined. */
-int zslParseLexRangeItem(robj *item, robj **dest, int *ex) {
+int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
     char *c = item->ptr;
 
     switch(c[0]) {
     case '+':
         if (c[1] != '\0') return C_ERR;
         *ex = 0;
         *dest = shared.maxstring;
-        incrRefCount(shared.maxstring);
         return C_OK;
     case '-':
         if (c[1] != '\0') return C_ERR;
         *ex = 0;
         *dest = shared.minstring;
-        incrRefCount(shared.minstring);
         return C_OK;
     case '(':
         *ex = 1;
-        *dest = createStringObject(c+1,sdslen(c)-1);
+        *dest = sdsnewlen(c+1,sdslen(c)-1);
         return C_OK;
     case '[':
         *ex = 0;
-        *dest = createStringObject(c+1,sdslen(c)-1);
+        *dest = sdsnewlen(c+1,sdslen(c)-1);
         return C_OK;
     default:
         return C_ERR;
     }
 }
 
-/* Populate the rangespec according to the objects min and max.
+/* Free a lex range structure, must be called only after zelParseLexRange()
+ * populated the structure with success (C_OK returned). */
+void zslFreeLexRange(zlexrangespec *spec) {
+    if (spec->min != shared.minstring &&
+        spec->min != shared.maxstring) sdsfree(spec->min);
+    if (spec->max != shared.minstring &&
+        spec->max != shared.maxstring) sdsfree(spec->max);
+}
+
+/* Populate the lex rangespec according to the objects min and max.
  *
  * Return C_OK on success. On error C_ERR is returned.
  * When OK is returned the structure must be freed with zslFreeLexRange(),
  * otherwise no release is needed. */
-static int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
+int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
     /* The range can't be valid if objects are integer encoded.
      * Every item must start with ( or [. */
     if (min->encoding == OBJ_ENCODING_INT ||
         max->encoding == OBJ_ENCODING_INT) return C_ERR;
 
     spec->min = spec->max = NULL;
     if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||
         zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {
-        if (spec->min) decrRefCount(spec->min);
-        if (spec->max) decrRefCount(spec->max);
+        zslFreeLexRange(spec);
         return C_ERR;
     } else {
         return C_OK;
     }
 }
 
-/* Free a lex range structure, must be called only after zelParseLexRange()
- * populated the structure with success (C_OK returned). */
-void zslFreeLexRange(zlexrangespec *spec) {
-    decrRefCount(spec->min);
-    decrRefCount(spec->max);
-}
-
-/* This is just a wrapper to compareStringObjects() that is able to
+/* This is just a wrapper to sdscmp() that is able to
  * handle shared.minstring and shared.maxstring as the equivalent of
  * -inf and +inf for strings */
-int compareStringObjectsForLexRange(robj *a, robj *b) {
-    if (a == b) return 0; /* This makes sure that we handle inf,inf and
-                             -inf,-inf ASAP. One special case less. */
+int sdscmplex(sds a, sds b) {
+    if (a == b) return 0;
     if (a == shared.minstring || b == shared.maxstring) return -1;
     if (a == shared.maxstring || b == shared.minstring) return 1;
-    return compareStringObjects(a,b);
+    return sdscmp(a,b);
 }
 
-static int zslLexValueGteMin(robj *value, zlexrangespec *spec) {
+int zslLexValueGteMin(sds value, zlexrangespec *spec) {
     return spec->minex ?
-        (compareStringObjectsForLexRange(value,spec->min) > 0) :
-        (compareStringObjectsForLexRange(value,spec->min) >= 0);
+        (sdscmplex(value,spec->min) > 0) :
+        (sdscmplex(value,spec->min) >= 0);
 }
 
-static int zslLexValueLteMax(robj *value, zlexrangespec *spec) {
+int zslLexValueLteMax(sds value, zlexrangespec *spec) {
     return spec->maxex ?
-        (compareStringObjectsForLexRange(value,spec->max) < 0) :
-        (compareStringObjectsForLexRange(value,spec->max) <= 0);
+        (sdscmplex(value,spec->max) < 0) :
+        (sdscmplex(value,spec->max) <= 0);
 }
 
 /* Returns if there is a part of the zset is in the lex range. */
 int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
     zskiplistNode *x;
 
     /* Test for ranges that will always be empty. */
-    if (compareStringObjectsForLexRange(range->min,range->max) > 1 ||
-            (compareStringObjects(range->min,range->max) == 0 &&
+    if (sdscmplex(range->min,range->max) > 1 ||
+            (sdscmp(range->min,range->max) == 0 &&
             (range->minex || range->maxex)))
         return 0;
     x = zsl->tail;
-    if (x == NULL || !zslLexValueGteMin(x->obj,range))
+    if (x == NULL || !zslLexValueGteMin(x->ele,range))
         return 0;
     x = zsl->header->level[0].forward;
-    if (x == NULL || !zslLexValueLteMax(x->obj,range))
+    if (x == NULL || !zslLexValueLteMax(x->ele,range))
         return 0;
     return 1;
 }
 
 /* Find the first node that is contained in the specified lex range.
  * Returns NULL when no element is contained in the range. */
@@ -587,22 +620,22 @@
     if (!zslIsInLexRange(zsl,range)) return NULL;
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
         /* Go forward while *OUT* of range. */
         while (x->level[i].forward &&
-            !zslLexValueGteMin(x->level[i].forward->obj,range))
+            !zslLexValueGteMin(x->level[i].forward->ele,range))
                 x = x->level[i].forward;
     }
 
     /* This is an inner range, so the next node cannot be NULL. */
     x = x->level[0].forward;
     serverAssert(x != NULL);
 
     /* Check if score <= max. */
-    if (!zslLexValueLteMax(x->obj,range)) return NULL;
+    if (!zslLexValueLteMax(x->ele,range)) return NULL;
     return x;
 }
 
 /* Find the last node that is contained in the specified range.
  * Returns NULL when no element is contained in the range. */
 zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
@@ -613,21 +646,21 @@
     if (!zslIsInLexRange(zsl,range)) return NULL;
 
     x = zsl->header;
     for (i = zsl->level-1; i >= 0; i--) {
         /* Go forward while *IN* range. */
         while (x->level[i].forward &&
-            zslLexValueLteMax(x->level[i].forward->obj,range))
+            zslLexValueLteMax(x->level[i].forward->ele,range))
                 x = x->level[i].forward;
     }
 
     /* This is an inner range, so this node cannot be NULL. */
     serverAssert(x != NULL);
 
     /* Check if score >= min. */
-    if (!zslLexValueGteMin(x->obj,range)) return NULL;
+    if (!zslLexValueGteMin(x->ele,range)) return NULL;
     return x;
 }
 
 /*-----------------------------------------------------------------------------
  * Ziplist-backed sorted set API
  *----------------------------------------------------------------------------*/
@@ -650,27 +683,25 @@
         score = vlong;
     }
 
     return score;
 }
 
-/* Return a ziplist element as a Redis string object.
- * This simple abstraction can be used to simplifies some code at the
- * cost of some performance. */
-robj *ziplistGetObject(unsigned char *sptr) {
+/* Return a ziplist element as an SDS string. */
+sds ziplistGetObject(unsigned char *sptr) {
     unsigned char *vstr;
     unsigned int vlen;
     long long vlong;
 
     serverAssert(sptr != NULL);
     serverAssert(ziplistGet(sptr,&vstr,&vlen,&vlong));
 
     if (vstr) {
-        return createStringObject((char*)vstr,vlen);
+        return sdsnewlen((char*)vstr,vlen);
     } else {
-        return createStringObjectFromLongLong(vlong);
+        return sdsfromlonglong(vlong);
     }
 }
 
 /* Compare element in sorted set with given element. */
 int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
     unsigned char *vstr;
@@ -818,34 +849,34 @@
             eptr = NULL;
     }
 
     return NULL;
 }
 
-static int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
-    robj *value = ziplistGetObject(p);
+int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
+    sds value = ziplistGetObject(p);
     int res = zslLexValueGteMin(value,spec);
-    decrRefCount(value);
+    sdsfree(value);
     return res;
 }
 
-static int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
-    robj *value = ziplistGetObject(p);
+int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
+    sds value = ziplistGetObject(p);
     int res = zslLexValueLteMax(value,spec);
-    decrRefCount(value);
+    sdsfree(value);
     return res;
 }
 
 /* Returns if there is a part of the zset is in range. Should only be used
  * internally by zzlFirstInRange and zzlLastInRange. */
 int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
     unsigned char *p;
 
     /* Test for ranges that will always be empty. */
-    if (compareStringObjectsForLexRange(range->min,range->max) > 1 ||
-            (compareStringObjects(range->min,range->max) == 0 &&
+    if (sdscmplex(range->min,range->max) > 1 ||
+            (sdscmp(range->min,range->max) == 0 &&
             (range->minex || range->maxex)))
         return 0;
 
     p = ziplistIndex(zl,-2); /* Last element. */
     if (p == NULL) return 0;
     if (!zzlLexValueGteMin(p,range))
@@ -909,32 +940,28 @@
             eptr = NULL;
     }
 
     return NULL;
 }
 
-unsigned char *zzlFind(unsigned char *zl, robj *ele, double *score) {
+unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
 
-    ele = getDecodedObject(ele);
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
-        serverAssertWithInfo(NULL,ele,sptr != NULL);
+        serverAssert(sptr != NULL);
 
-        if (ziplistCompare(eptr,ele->ptr,sdslen(ele->ptr))) {
+        if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele))) {
             /* Matching element, pull out score. */
             if (score != NULL) *score = zzlGetScore(sptr);
-            decrRefCount(ele);
             return eptr;
         }
 
         /* Move to next element. */
         eptr = ziplistNext(zl,sptr);
     }
-
-    decrRefCount(ele);
     return NULL;
 }
 
 /* Delete (element,score) pair from ziplist. Use local copy of eptr because we
  * don't want to modify the one given as argument. */
 unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
@@ -943,72 +970,67 @@
     /* TODO: add function to ziplist API to delete N elements from offset. */
     zl = ziplistDelete(zl,&p);
     zl = ziplistDelete(zl,&p);
     return zl;
 }
 
-unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, robj *ele, double score) {
+unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
     unsigned char *sptr;
     char scorebuf[128];
     int scorelen;
     size_t offset;
 
-    serverAssertWithInfo(NULL,ele,sdsEncodedObject(ele));
     scorelen = d2string(scorebuf,sizeof(scorebuf),score);
     if (eptr == NULL) {
-        zl = ziplistPush(zl,ele->ptr,sdslen(ele->ptr),ZIPLIST_TAIL);
+        zl = ziplistPush(zl,(unsigned char*)ele,sdslen(ele),ZIPLIST_TAIL);
         zl = ziplistPush(zl,(unsigned char*)scorebuf,scorelen,ZIPLIST_TAIL);
     } else {
         /* Keep offset relative to zl, as it might be re-allocated. */
         offset = eptr-zl;
-        zl = ziplistInsert(zl,eptr,ele->ptr,sdslen(ele->ptr));
+        zl = ziplistInsert(zl,eptr,(unsigned char*)ele,sdslen(ele));
         eptr = zl+offset;
 
         /* Insert score after the element. */
-        serverAssertWithInfo(NULL,ele,(sptr = ziplistNext(zl,eptr)) != NULL);
+        serverAssert((sptr = ziplistNext(zl,eptr)) != NULL);
         zl = ziplistInsert(zl,sptr,(unsigned char*)scorebuf,scorelen);
     }
-
     return zl;
 }
 
 /* Insert (element,score) pair in ziplist. This function assumes the element is
  * not yet present in the list. */
-unsigned char *zzlInsert(unsigned char *zl, robj *ele, double score) {
+unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
     unsigned char *eptr = ziplistIndex(zl,0), *sptr;
     double s;
 
-    ele = getDecodedObject(ele);
     while (eptr != NULL) {
         sptr = ziplistNext(zl,eptr);
-        serverAssertWithInfo(NULL,ele,sptr != NULL);
+        serverAssert(sptr != NULL);
         s = zzlGetScore(sptr);
 
         if (s > score) {
             /* First element with score larger than score for element to be
              * inserted. This means we should take its spot in the list to
              * maintain ordering. */
             zl = zzlInsertAt(zl,eptr,ele,score);
             break;
         } else if (s == score) {
             /* Ensure lexicographical ordering for elements. */
-            if (zzlCompareElements(eptr,ele->ptr,sdslen(ele->ptr)) > 0) {
+            if (zzlCompareElements(eptr,(unsigned char*)ele,sdslen(ele)) > 0) {
                 zl = zzlInsertAt(zl,eptr,ele,score);
                 break;
             }
         }
 
         /* Move to next element. */
         eptr = ziplistNext(zl,sptr);
     }
 
     /* Push on tail of list when it was not yet inserted. */
     if (eptr == NULL)
         zl = zzlInsertAt(zl,NULL,ele,score);
-
-    decrRefCount(ele);
     return zl;
 }
 
 unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {
     unsigned char *eptr, *sptr;
     double score;
@@ -1075,28 +1097,28 @@
 }
 
 /*-----------------------------------------------------------------------------
  * Common sorted set API
  *----------------------------------------------------------------------------*/
 
-unsigned int zsetLength(robj *zobj) {
+unsigned int zsetLength(const robj *zobj) {
     int length = -1;
     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         length = zzlLength(zobj->ptr);
     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
-        length = ((zset*)zobj->ptr)->zsl->length;
+        length = ((const zset*)zobj->ptr)->zsl->length;
     } else {
         serverPanic("Unknown sorted set encoding");
     }
     return length;
 }
 
 void zsetConvert(robj *zobj, int encoding) {
     zset *zs;
     zskiplistNode *node, *next;
-    robj *ele;
+    sds ele;
     double score;
 
     if (zobj->encoding == encoding) return;
     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         unsigned char *zl = zobj->ptr;
         unsigned char *eptr, *sptr;
@@ -1117,20 +1139,18 @@
         serverAssertWithInfo(NULL,zobj,sptr != NULL);
 
         while (eptr != NULL) {
             score = zzlGetScore(sptr);
             serverAssertWithInfo(NULL,zobj,ziplistGet(eptr,&vstr,&vlen,&vlong));
             if (vstr == NULL)
-                ele = createStringObjectFromLongLong(vlong);
+                ele = sdsfromlonglong(vlong);
             else
-                ele = createStringObject((char*)vstr,vlen);
+                ele = sdsnewlen((char*)vstr,vlen);
 
-            /* Has incremented refcount since it was just created. */
             node = zslInsert(zs->zsl,score,ele);
-            serverAssertWithInfo(NULL,zobj,dictAdd(zs->dict,ele,&node->score) == DICT_OK);
-            incrRefCount(ele); /* Added to dictionary. */
+            serverAssert(dictAdd(zs->dict,ele,&node->score) == DICT_OK);
             zzlNext(zl,&eptr,&sptr);
         }
 
         zfree(zobj->ptr);
         zobj->ptr = zs;
         zobj->encoding = OBJ_ENCODING_SKIPLIST;
@@ -1146,16 +1166,13 @@
         dictRelease(zs->dict);
         node = zs->zsl->header->level[0].forward;
         zfree(zs->zsl->header);
         zfree(zs->zsl);
 
         while (node) {
-            ele = getDecodedObject(node->obj);
-            zl = zzlInsertAt(zl,NULL,ele,node->score);
-            decrRefCount(ele);
-
+            zl = zzlInsertAt(zl,NULL,node->ele,node->score);
             next = node->level[0].forward;
             zslFreeNode(node);
             node = next;
         }
 
         zfree(zs);
@@ -1179,13 +1196,13 @@
 }
 
 /* Return (by reference) the score of the specified member of the sorted set
  * storing it into *score. If the element does not exist C_ERR is returned
  * otherwise C_OK is returned and *score is correctly populated.
  * If 'zobj' or 'member' is NULL, C_ERR is returned. */
-int zsetScore(robj *zobj, robj *member, double *score) {
+int zsetScore(robj *zobj, sds member, double *score) {
     if (!zobj || !member) return C_ERR;
 
     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
         if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;
     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
@@ -1195,29 +1212,286 @@
     } else {
         serverPanic("Unknown sorted set encoding");
     }
     return C_OK;
 }
 
+/* Add a new element or update the score of an existing element in a sorted
+ * set, regardless of its encoding.
+ *
+ * The set of flags change the command behavior. They are passed with an integer
+ * pointer since the function will clear the flags and populate them with
+ * other flags to indicate different conditions.
+ *
+ * The input flags are the following:
+ *
+ * ZADD_INCR: Increment the current element score by 'score' instead of updating
+ *            the current element score. If the element does not exist, we
+ *            assume 0 as previous score.
+ * ZADD_NX:   Perform the operation only if the element does not exist.
+ * ZADD_XX:   Perform the operation only if the element already exist.
+ *
+ * When ZADD_INCR is used, the new score of the element is stored in
+ * '*newscore' if 'newscore' is not NULL.
+ *
+ * The returned flags are the following:
+ *
+ * ZADD_NAN:     The resulting score is not a number.
+ * ZADD_ADDED:   The element was added (not present before the call).
+ * ZADD_UPDATED: The element score was updated.
+ * ZADD_NOP:     No operation was performed because of NX or XX.
+ *
+ * Return value:
+ *
+ * The function returns 1 on success, and sets the appropriate flags
+ * ADDED or UPDATED to signal what happened during the operation (note that
+ * none could be set if we re-added an element using the same score it used
+ * to have, or in the case a zero increment is used).
+ *
+ * The function returns 0 on erorr, currently only when the increment
+ * produces a NAN condition, or when the 'score' value is NAN since the
+ * start.
+ *
+ * The commad as a side effect of adding a new element may convert the sorted
+ * set internal encoding from ziplist to hashtable+skiplist.
+ *
+ * Memory managemnet of 'ele':
+ *
+ * The function does not take ownership of the 'ele' SDS string, but copies
+ * it if needed. */
+int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore) {
+    /* Turn options into simple to check vars. */
+    int incr = (*flags & ZADD_INCR) != 0;
+    int nx = (*flags & ZADD_NX) != 0;
+    int xx = (*flags & ZADD_XX) != 0;
+    *flags = 0; /* We'll return our response flags. */
+    double curscore;
+
+    /* NaN as input is an error regardless of all the other parameters. */
+    if (isnan(score)) {
+        *flags = ZADD_NAN;
+        return 0;
+    }
+
+    /* Update the sorted set according to its encoding. */
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
+        unsigned char *eptr;
+
+        if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
+            /* NX? Return, same element already exists. */
+            if (nx) {
+                *flags |= ZADD_NOP;
+                return 1;
+            }
+
+            /* Prepare the score for the increment if needed. */
+            if (incr) {
+                score += curscore;
+                if (isnan(score)) {
+                    *flags |= ZADD_NAN;
+                    return 0;
+                }
+                if (newscore) *newscore = score;
+            }
+
+            /* Remove and re-insert when score changed. */
+            if (score != curscore) {
+                zobj->ptr = zzlDelete(zobj->ptr,eptr);
+                zobj->ptr = zzlInsert(zobj->ptr,ele,score);
+                *flags |= ZADD_UPDATED;
+            }
+            return 1;
+        } else if (!xx) {
+            /* Optimize: check if the element is too large or the list
+             * becomes too long *before* executing zzlInsert. */
+            zobj->ptr = zzlInsert(zobj->ptr,ele,score);
+            if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries)
+                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
+            if (sdslen(ele) > server.zset_max_ziplist_value)
+                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
+            if (newscore) *newscore = score;
+            *flags |= ZADD_ADDED;
+            return 1;
+        } else {
+            *flags |= ZADD_NOP;
+            return 1;
+        }
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
+        zset *zs = zobj->ptr;
+        zskiplistNode *znode;
+        dictEntry *de;
+
+        de = dictFind(zs->dict,ele);
+        if (de != NULL) {
+            /* NX? Return, same element already exists. */
+            if (nx) {
+                *flags |= ZADD_NOP;
+                return 1;
+            }
+            curscore = *(double*)dictGetVal(de);
+
+            /* Prepare the score for the increment if needed. */
+            if (incr) {
+                score += curscore;
+                if (isnan(score)) {
+                    *flags |= ZADD_NAN;
+                    return 0;
+                }
+                if (newscore) *newscore = score;
+            }
+
+            /* Remove and re-insert when score changes. */
+            if (score != curscore) {
+                zskiplistNode *node;
+                serverAssert(zslDelete(zs->zsl,curscore,ele,&node));
+                znode = zslInsert(zs->zsl,score,node->ele);
+                /* We reused the node->ele SDS string, free the node now
+                 * since zslInsert created a new one. */
+                node->ele = NULL;
+                zslFreeNode(node);
+                /* Note that we did not removed the original element from
+                 * the hash table representing the sorted set, so we just
+                 * update the score. */
+                dictGetVal(de) = &znode->score; /* Update score ptr. */
+                *flags |= ZADD_UPDATED;
+            }
+            return 1;
+        } else if (!xx) {
+            ele = sdsdup(ele);
+            znode = zslInsert(zs->zsl,score,ele);
+            serverAssert(dictAdd(zs->dict,ele,&znode->score) == DICT_OK);
+            *flags |= ZADD_ADDED;
+            if (newscore) *newscore = score;
+            return 1;
+        } else {
+            *flags |= ZADD_NOP;
+            return 1;
+        }
+    } else {
+        serverPanic("Unknown sorted set encoding");
+    }
+    return 0; /* Never reached. */
+}
+
+/* Delete the element 'ele' from the sorted set, returning 1 if the element
+ * existed and was deleted, 0 otherwise (the element was not there). */
+int zsetDel(robj *zobj, sds ele) {
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
+        unsigned char *eptr;
+
+        if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {
+            zobj->ptr = zzlDelete(zobj->ptr,eptr);
+            return 1;
+        }
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
+        zset *zs = zobj->ptr;
+        dictEntry *de;
+        double score;
+
+        de = dictUnlink(zs->dict,ele);
+        if (de != NULL) {
+            /* Get the score in order to delete from the skiplist later. */
+            score = *(double*)dictGetVal(de);
+
+            /* Delete from the hash table and later from the skiplist.
+             * Note that the order is important: deleting from the skiplist
+             * actually releases the SDS string representing the element,
+             * which is shared between the skiplist and the hash table, so
+             * we need to delete from the skiplist as the final step. */
+            dictFreeUnlinkedEntry(zs->dict,de);
+
+            /* Delete from skiplist. */
+            int retval = zslDelete(zs->zsl,score,ele,NULL);
+            serverAssert(retval);
+
+            if (htNeedsResize(zs->dict)) dictResize(zs->dict);
+            return 1;
+        }
+    } else {
+        serverPanic("Unknown sorted set encoding");
+    }
+    return 0; /* No such element found. */
+}
+
+/* Given a sorted set object returns the 0-based rank of the object or
+ * -1 if the object does not exist.
+ *
+ * For rank we mean the position of the element in the sorted collection
+ * of elements. So the first element has rank 0, the second rank 1, and so
+ * forth up to length-1 elements.
+ *
+ * If 'reverse' is false, the rank is returned considering as first element
+ * the one with the lowest score. Otherwise if 'reverse' is non-zero
+ * the rank is computed considering as element with rank 0 the one with
+ * the highest score. */
+long zsetRank(robj *zobj, sds ele, int reverse) {
+    unsigned long llen;
+    unsigned long rank;
+
+    llen = zsetLength(zobj);
+
+    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
+        unsigned char *zl = zobj->ptr;
+        unsigned char *eptr, *sptr;
+
+        eptr = ziplistIndex(zl,0);
+        serverAssert(eptr != NULL);
+        sptr = ziplistNext(zl,eptr);
+        serverAssert(sptr != NULL);
+
+        rank = 1;
+        while(eptr != NULL) {
+            if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele)))
+                break;
+            rank++;
+            zzlNext(zl,&eptr,&sptr);
+        }
+
+        if (eptr != NULL) {
+            if (reverse)
+                return llen-rank;
+            else
+                return rank-1;
+        } else {
+            return -1;
+        }
+    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
+        zset *zs = zobj->ptr;
+        zskiplist *zsl = zs->zsl;
+        dictEntry *de;
+        double score;
+
+        de = dictFind(zs->dict,ele);
+        if (de != NULL) {
+            score = *(double*)dictGetVal(de);
+            rank = zslGetRank(zsl,score,ele);
+            /* Existing elements always have a rank. */
+            serverAssert(rank != 0);
+            if (reverse)
+                return llen-rank;
+            else
+                return rank-1;
+        } else {
+            return -1;
+        }
+    } else {
+        serverPanic("Unknown sorted set encoding");
+    }
+}
+
 /*-----------------------------------------------------------------------------
  * Sorted set commands
  *----------------------------------------------------------------------------*/
 
 /* This generic command implements both ZADD and ZINCRBY. */
-#define ZADD_NONE 0
-#define ZADD_INCR (1<<0)    /* Increment the score instead of setting it. */
-#define ZADD_NX (1<<1)      /* Don't touch elements not already existing. */
-#define ZADD_XX (1<<2)      /* Only touch elements already exisitng. */
-#define ZADD_CH (1<<3)      /* Return num of elements added or updated. */
 void zaddGenericCommand(client *c, int flags) {
     static char *nanerr = "resulting score is not a number (NaN)";
     robj *key = c->argv[1];
-    robj *ele;
     robj *zobj;
-    robj *curobj;
-    double score = 0, *scores = NULL, curscore = 0.0;
+    sds ele;
+    double score = 0, *scores = NULL;
     int j, elements;
     int scoreidx = 0;
     /* The following vars are used in order to track what the command actually
      * did during the execution, to reply to the client and to trigger the
      * notification of keyspace change. */
     int added = 0;      /* Number of new elements added. */
@@ -1292,97 +1566,28 @@
             addReply(c,shared.wrongtypeerr);
             goto cleanup;
         }
     }
 
     for (j = 0; j < elements; j++) {
+        double newscore;
         score = scores[j];
+        int retflags = flags;
 
-        if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
-            unsigned char *eptr;
-
-            /* Prefer non-encoded element when dealing with ziplists. */
-            ele = c->argv[scoreidx+1+j*2];
-            if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
-                if (nx) continue;
-                if (incr) {
-                    score += curscore;
-                    if (isnan(score)) {
-                        addReplyError(c,nanerr);
-                        goto cleanup;
-                    }
-                }
-
-                /* Remove and re-insert when score changed. */
-                if (score != curscore) {
-                    zobj->ptr = zzlDelete(zobj->ptr,eptr);
-                    zobj->ptr = zzlInsert(zobj->ptr,ele,score);
-                    server.dirty++;
-                    updated++;
-                }
-                processed++;
-            } else if (!xx) {
-                /* Optimize: check if the element is too large or the list
-                 * becomes too long *before* executing zzlInsert. */
-                zobj->ptr = zzlInsert(zobj->ptr,ele,score);
-                if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries)
-                    zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
-                if (sdslen(ele->ptr) > server.zset_max_ziplist_value)
-                    zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
-                server.dirty++;
-                added++;
-                processed++;
-            }
-        } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
-            zset *zs = zobj->ptr;
-            zskiplistNode *znode;
-            dictEntry *de;
-
-            ele = c->argv[scoreidx+1+j*2] =
-                tryObjectEncoding(c->argv[scoreidx+1+j*2]);
-            de = dictFind(zs->dict,ele);
-            if (de != NULL) {
-                if (nx) continue;
-                curobj = dictGetKey(de);
-                curscore = *(double*)dictGetVal(de);
-
-                if (incr) {
-                    score += curscore;
-                    if (isnan(score)) {
-                        addReplyError(c,nanerr);
-                        /* Don't need to check if the sorted set is empty
-                         * because we know it has at least one element. */
-                        goto cleanup;
-                    }
-                }
-
-                /* Remove and re-insert when score changed. We can safely
-                 * delete the key object from the skiplist, since the
-                 * dictionary still has a reference to it. */
-                if (score != curscore) {
-                    serverAssertWithInfo(c,curobj,zslDelete(zs->zsl,curscore,curobj));
-                    znode = zslInsert(zs->zsl,score,curobj);
-                    incrRefCount(curobj); /* Re-inserted in skiplist. */
-                    dictGetVal(de) = &znode->score; /* Update score ptr. */
-                    server.dirty++;
-                    updated++;
-                }
-                processed++;
-            } else if (!xx) {
-                znode = zslInsert(zs->zsl,score,ele);
-                incrRefCount(ele); /* Inserted in skiplist. */
-                serverAssertWithInfo(c,NULL,dictAdd(zs->dict,ele,&znode->score) == DICT_OK);
-                incrRefCount(ele); /* Added to dictionary. */
-                server.dirty++;
-                added++;
-                processed++;
-            }
-        } else {
-            serverPanic("Unknown sorted set encoding");
+        ele = c->argv[scoreidx+1+j*2]->ptr;
+        int retval = zsetAdd(zobj, score, ele, &retflags, &newscore);
+        if (retval == 0) {
+            addReplyError(c,nanerr);
+            goto cleanup;
         }
+        if (retflags & ZADD_ADDED) added++;
+        if (retflags & ZADD_UPDATED) updated++;
+        if (!(retflags & ZADD_NOP)) processed++;
+        score = newscore;
     }
+    server.dirty += (added+updated);
 
 reply_to_client:
     if (incr) { /* ZINCRBY or INCR option. */
         if (processed)
             addReplyDouble(c,score);
         else
@@ -1413,52 +1618,19 @@
     robj *zobj;
     int deleted = 0, keyremoved = 0, j;
 
     if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
         checkType(c,zobj,OBJ_ZSET)) return;
 
-    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
-        unsigned char *eptr;
-
-        for (j = 2; j < c->argc; j++) {
-            if ((eptr = zzlFind(zobj->ptr,c->argv[j],NULL)) != NULL) {
-                deleted++;
-                zobj->ptr = zzlDelete(zobj->ptr,eptr);
-                if (zzlLength(zobj->ptr) == 0) {
-                    dbDelete(c->db,key);
-                    keyremoved = 1;
-                    break;
-                }
-            }
-        }
-    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
-        zset *zs = zobj->ptr;
-        dictEntry *de;
-        double score;
-
-        for (j = 2; j < c->argc; j++) {
-            de = dictFind(zs->dict,c->argv[j]);
-            if (de != NULL) {
-                deleted++;
-
-                /* Delete from the skiplist */
-                score = *(double*)dictGetVal(de);
-                serverAssertWithInfo(c,c->argv[j],zslDelete(zs->zsl,score,c->argv[j]));
-
-                /* Delete from the hash table */
-                dictDelete(zs->dict,c->argv[j]);
-                if (htNeedsResize(zs->dict)) dictResize(zs->dict);
-                if (dictSize(zs->dict) == 0) {
-                    dbDelete(c->db,key);
-                    keyremoved = 1;
-                    break;
-                }
-            }
+    for (j = 2; j < c->argc; j++) {
+        if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;
+        if (zsetLength(zobj) == 0) {
+            dbDelete(c->db,key);
+            keyremoved = 1;
+            break;
         }
-    } else {
-        serverPanic("Unknown sorted set encoding");
     }
 
     if (deleted) {
         notifyKeyspaceEvent(NOTIFY_ZSET,"zrem",key,c->db->id);
         if (keyremoved)
             notifyKeyspaceEvent(NOTIFY_GENERIC,"del",key,c->db->id);
@@ -1622,21 +1794,21 @@
 /* Use dirty flags for pointers that need to be cleaned up in the next
  * iteration over the zsetopval. The dirty flag for the long long value is
  * special, since long long values don't need cleanup. Instead, it means that
  * we already checked that "ell" holds a long long, or tried to convert another
  * representation into a long long value. When this was successful,
  * OPVAL_VALID_LL is set as well. */
-#define OPVAL_DIRTY_ROBJ 1
+#define OPVAL_DIRTY_SDS 1
 #define OPVAL_DIRTY_LL 2
 #define OPVAL_VALID_LL 4
 
 /* Store value retrieved from the iterator. */
 typedef struct {
     int flags;
     unsigned char _buf[32]; /* Private buffer. */
-    robj *ele;
+    sds ele;
     unsigned char *estr;
     unsigned int elen;
     long long ell;
     double score;
 } zsetopval;
 
@@ -1737,14 +1909,14 @@
  * and move to the next element. If not valid, this means we have reached the
  * end of the structure and can abort. */
 int zuiNext(zsetopsrc *op, zsetopval *val) {
     if (op->subject == NULL)
         return 0;
 
-    if (val->flags & OPVAL_DIRTY_ROBJ)
-        decrRefCount(val->ele);
+    if (val->flags & OPVAL_DIRTY_SDS)
+        sdsfree(val->ele);
 
     memset(val,0,sizeof(zsetopval));
 
     if (op->type == OBJ_SET) {
         iterset *it = &op->iter.set;
         if (op->encoding == OBJ_ENCODING_INTSET) {
@@ -1779,13 +1951,13 @@
 
             /* Move to next element. */
             zzlNext(it->zl.zl,&it->zl.eptr,&it->zl.sptr);
         } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
             if (it->sl.node == NULL)
                 return 0;
-            val->ele = it->sl.node->obj;
+            val->ele = it->sl.node->ele;
             val->score = it->sl.node->score;
 
             /* Move to next element. */
             it->sl.node = it->sl.node->level[0].forward;
         } else {
             serverPanic("Unknown sorted set encoding");
@@ -1798,56 +1970,60 @@
 
 int zuiLongLongFromValue(zsetopval *val) {
     if (!(val->flags & OPVAL_DIRTY_LL)) {
         val->flags |= OPVAL_DIRTY_LL;
 
         if (val->ele != NULL) {
-            if (val->ele->encoding == OBJ_ENCODING_INT) {
-                val->ell = (long)val->ele->ptr;
+            if (string2ll(val->ele,sdslen(val->ele),&val->ell))
                 val->flags |= OPVAL_VALID_LL;
-            } else if (sdsEncodedObject(val->ele)) {
-                if (string2ll(val->ele->ptr,sdslen(val->ele->ptr),&val->ell))
-                    val->flags |= OPVAL_VALID_LL;
-            } else {
-                serverPanic("Unsupported element encoding");
-            }
         } else if (val->estr != NULL) {
             if (string2ll((char*)val->estr,val->elen,&val->ell))
                 val->flags |= OPVAL_VALID_LL;
         } else {
             /* The long long was already set, flag as valid. */
             val->flags |= OPVAL_VALID_LL;
         }
     }
     return val->flags & OPVAL_VALID_LL;
 }
 
-robj *zuiObjectFromValue(zsetopval *val) {
+sds zuiSdsFromValue(zsetopval *val) {
     if (val->ele == NULL) {
         if (val->estr != NULL) {
-            val->ele = createStringObject((char*)val->estr,val->elen);
+            val->ele = sdsnewlen((char*)val->estr,val->elen);
         } else {
-            val->ele = createStringObjectFromLongLong(val->ell);
+            val->ele = sdsfromlonglong(val->ell);
         }
-        val->flags |= OPVAL_DIRTY_ROBJ;
+        val->flags |= OPVAL_DIRTY_SDS;
     }
     return val->ele;
 }
 
+/* This is different from zuiSdsFromValue since returns a new SDS string
+ * which is up to the caller to free. */
+sds zuiNewSdsFromValue(zsetopval *val) {
+    if (val->flags & OPVAL_DIRTY_SDS) {
+        /* We have already one to return! */
+        sds ele = val->ele;
+        val->flags &= ~OPVAL_DIRTY_SDS;
+        val->ele = NULL;
+        return ele;
+    } else if (val->ele) {
+        return sdsdup(val->ele);
+    } else if (val->estr) {
+        return sdsnewlen((char*)val->estr,val->elen);
+    } else {
+        return sdsfromlonglong(val->ell);
+    }
+}
+
 int zuiBufferFromValue(zsetopval *val) {
     if (val->estr == NULL) {
         if (val->ele != NULL) {
-            if (val->ele->encoding == OBJ_ENCODING_INT) {
-                val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),(long)val->ele->ptr);
-                val->estr = val->_buf;
-            } else if (sdsEncodedObject(val->ele)) {
-                val->elen = sdslen(val->ele->ptr);
-                val->estr = val->ele->ptr;
-            } else {
-                serverPanic("Unsupported element encoding");
-            }
+            val->elen = sdslen(val->ele);
+            val->estr = (unsigned char*)val->ele;
         } else {
             val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);
             val->estr = val->_buf;
         }
     }
     return 1;
@@ -1868,24 +2044,24 @@
                 return 1;
             } else {
                 return 0;
             }
         } else if (op->encoding == OBJ_ENCODING_HT) {
             dict *ht = op->subject->ptr;
-            zuiObjectFromValue(val);
+            zuiSdsFromValue(val);
             if (dictFind(ht,val->ele) != NULL) {
                 *score = 1.0;
                 return 1;
             } else {
                 return 0;
             }
         } else {
             serverPanic("Unknown set encoding");
         }
     } else if (op->type == OBJ_ZSET) {
-        zuiObjectFromValue(val);
+        zuiSdsFromValue(val);
 
         if (op->encoding == OBJ_ENCODING_ZIPLIST) {
             if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {
                 /* Score is already set by zzlFind. */
                 return 1;
             } else {
@@ -1931,19 +2107,31 @@
     } else {
         /* safety net */
         serverPanic("Unknown ZUNION/INTER aggregate type");
     }
 }
 
+uint64_t dictSdsHash(const void *key);
+int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);
+
+dictType setAccumulatorDictType = {
+    dictSdsHash,               /* hash function */
+    NULL,                      /* key dup */
+    NULL,                      /* val dup */
+    dictSdsKeyCompare,         /* key compare */
+    NULL,                      /* key destructor */
+    NULL                       /* val destructor */
+};
+
 void zunionInterGenericCommand(client *c, robj *dstkey, int op) {
     int i, j;
     long setnum;
     int aggregate = REDIS_AGGR_SUM;
     zsetopsrc *src;
     zsetopval zval;
-    robj *tmp;
+    sds tmp;
     unsigned int maxelelen = 0;
     robj *dstobj;
     zset *dstzset;
     zskiplistNode *znode;
     int touched = 0;
 
@@ -1987,23 +2175,27 @@
 
     /* parse optional extra arguments */
     if (j < c->argc) {
         int remaining = c->argc - j;
 
         while (remaining) {
-            if (remaining >= (setnum + 1) && !strcasecmp(c->argv[j]->ptr,"weights")) {
+            if (remaining >= (setnum + 1) &&
+                !strcasecmp(c->argv[j]->ptr,"weights"))
+            {
                 j++; remaining--;
                 for (i = 0; i < setnum; i++, j++, remaining--) {
                     if (getDoubleFromObjectOrReply(c,c->argv[j],&src[i].weight,
                             "weight value is not a float") != C_OK)
                     {
                         zfree(src);
                         return;
                     }
                 }
-            } else if (remaining >= 2 && !strcasecmp(c->argv[j]->ptr,"aggregate")) {
+            } else if (remaining >= 2 &&
+                       !strcasecmp(c->argv[j]->ptr,"aggregate"))
+            {
                 j++; remaining--;
                 if (!strcasecmp(c->argv[j]->ptr,"sum")) {
                     aggregate = REDIS_AGGR_SUM;
                 } else if (!strcasecmp(c->argv[j]->ptr,"min")) {
                     aggregate = REDIS_AGGR_MIN;
                 } else if (!strcasecmp(c->argv[j]->ptr,"max")) {
@@ -2055,30 +2247,24 @@
                         break;
                     }
                 }
 
                 /* Only continue when present in every input. */
                 if (j == setnum) {
-                    tmp = zuiObjectFromValue(&zval);
+                    tmp = zuiNewSdsFromValue(&zval);
                     znode = zslInsert(dstzset->zsl,score,tmp);
-                    incrRefCount(tmp); /* added to skiplist */
                     dictAdd(dstzset->dict,tmp,&znode->score);
-                    incrRefCount(tmp); /* added to dictionary */
-
-                    if (sdsEncodedObject(tmp)) {
-                        if (sdslen(tmp->ptr) > maxelelen)
-                            maxelelen = sdslen(tmp->ptr);
-                    }
+                    if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);
                 }
             }
             zuiClearIterator(&src[0]);
         }
     } else if (op == SET_OP_UNION) {
-        dict *accumulator = dictCreate(&setDictType,NULL);
+        dict *accumulator = dictCreate(&setAccumulatorDictType,NULL);
         dictIterator *di;
-        dictEntry *de;
+        dictEntry *de, *existing;
         double score;
 
         if (setnum) {
             /* Our union is at least as large as the largest set.
              * Resize the dictionary ASAP to avoid useless rehashing. */
             dictExpand(accumulator,zuiLength(&src[setnum-1]));
@@ -2093,35 +2279,31 @@
             while (zuiNext(&src[i],&zval)) {
                 /* Initialize value */
                 score = src[i].weight * zval.score;
                 if (isnan(score)) score = 0;
 
                 /* Search for this element in the accumulating dictionary. */
-                de = dictFind(accumulator,zuiObjectFromValue(&zval));
+                de = dictAddRaw(accumulator,zuiSdsFromValue(&zval),&existing);
                 /* If we don't have it, we need to create a new entry. */
-                if (de == NULL) {
-                    tmp = zuiObjectFromValue(&zval);
+                if (!existing) {
+                    tmp = zuiNewSdsFromValue(&zval);
                     /* Remember the longest single element encountered,
                      * to understand if it's possible to convert to ziplist
                      * at the end. */
-                    if (sdsEncodedObject(tmp)) {
-                        if (sdslen(tmp->ptr) > maxelelen)
-                            maxelelen = sdslen(tmp->ptr);
-                    }
-                    /* Add the element with its initial score. */
-                    de = dictAddRaw(accumulator,tmp);
-                    incrRefCount(tmp);
+                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);
+                    /* Update the element with its initial score. */
+                    dictSetKey(accumulator, de, tmp);
                     dictSetDoubleVal(de,score);
                 } else {
                     /* Update the score with the score of the new instance
                      * of the element found in the current sorted set.
                      *
                      * Here we access directly the dictEntry double
                      * value inside the union as it is a big speedup
                      * compared to using the getDouble/setDouble API. */
-                    zunionInterAggregate(&de->v.d,score,aggregate);
+                    zunionInterAggregate(&existing->v.d,score,aggregate);
                 }
             }
             zuiClearIterator(&src[i]);
         }
 
         /* Step 2: convert the dictionary into the final sorted set. */
@@ -2130,22 +2312,18 @@
         /* We now are aware of the final size of the resulting sorted set,
          * let's resize the dictionary embedded inside the sorted set to the
          * right size, in order to save rehashing time. */
         dictExpand(dstzset->dict,dictSize(accumulator));
 
         while((de = dictNext(di)) != NULL) {
-            robj *ele = dictGetKey(de);
+            sds ele = dictGetKey(de);
             score = dictGetDoubleVal(de);
             znode = zslInsert(dstzset->zsl,score,ele);
-            incrRefCount(ele); /* added to skiplist */
             dictAdd(dstzset->dict,ele,&znode->score);
-            incrRefCount(ele); /* added to dictionary */
         }
         dictReleaseIterator(di);
-
-        /* We can free the accumulator dictionary now. */
         dictRelease(accumulator);
     } else {
         serverPanic("Unknown operator");
     }
 
     if (dbDelete(c->db,dstkey))
@@ -2252,13 +2430,13 @@
         }
 
     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
         zset *zs = zobj->ptr;
         zskiplist *zsl = zs->zsl;
         zskiplistNode *ln;
-        robj *ele;
+        sds ele;
 
         /* Check if starting point is trivial, before doing log(N) lookup. */
         if (reverse) {
             ln = zsl->tail;
             if (start > 0)
                 ln = zslGetElementByRank(zsl,llen-start);
@@ -2267,14 +2445,14 @@
             if (start > 0)
                 ln = zslGetElementByRank(zsl,start+1);
         }
 
         while(rangelen--) {
             serverAssertWithInfo(c,zobj,ln != NULL);
-            ele = ln->obj;
-            addReplyBulk(c,ele);
+            ele = ln->ele;
+            addReplyBulkCBuffer(c,ele,sdslen(ele));
             if (withscores)
                 addReplyDouble(c,ln->score);
             ln = reverse ? ln->backward : ln->level[0].forward;
         }
     } else {
         serverPanic("Unknown sorted set encoding");
@@ -2322,14 +2500,19 @@
 
         while (remaining) {
             if (remaining >= 1 && !strcasecmp(c->argv[pos]->ptr,"withscores")) {
                 pos++; remaining--;
                 withscores = 1;
             } else if (remaining >= 3 && !strcasecmp(c->argv[pos]->ptr,"limit")) {
-                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL) != C_OK) ||
-                    (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL) != C_OK)) return;
+                if ((getLongFromObjectOrReply(c, c->argv[pos+1], &offset, NULL)
+                        != C_OK) ||
+                    (getLongFromObjectOrReply(c, c->argv[pos+2], &limit, NULL)
+                        != C_OK))
+                {
+                    return;
+                }
                 pos += 3; remaining -= 3;
             } else {
                 addReply(c,shared.syntaxerr);
                 return;
             }
         }
@@ -2449,13 +2632,13 @@
                 if (!zslValueGteMin(ln->score,&range)) break;
             } else {
                 if (!zslValueLteMax(ln->score,&range)) break;
             }
 
             rangelen++;
-            addReplyBulk(c,ln->obj);
+            addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));
 
             if (withscores) {
                 addReplyDouble(c,ln->score);
             }
 
             /* Move to next node */
@@ -2539,21 +2722,21 @@
 
         /* Find first element in range */
         zn = zslFirstInRange(zsl, &range);
 
         /* Use rank of first element, if any, to determine preliminary count */
         if (zn != NULL) {
-            rank = zslGetRank(zsl, zn->score, zn->obj);
+            rank = zslGetRank(zsl, zn->score, zn->ele);
             count = (zsl->length - (rank - 1));
 
             /* Find last element in range */
             zn = zslLastInRange(zsl, &range);
 
             /* Use rank of last element, if any, to determine the actual count */
             if (zn != NULL) {
-                rank = zslGetRank(zsl, zn->score, zn->obj);
+                rank = zslGetRank(zsl, zn->score, zn->ele);
                 count -= (zsl->length - rank);
             }
         }
     } else {
         serverPanic("Unknown sorted set encoding");
     }
@@ -2617,21 +2800,21 @@
 
         /* Find first element in range */
         zn = zslFirstInLexRange(zsl, &range);
 
         /* Use rank of first element, if any, to determine preliminary count */
         if (zn != NULL) {
-            rank = zslGetRank(zsl, zn->score, zn->obj);
+            rank = zslGetRank(zsl, zn->score, zn->ele);
             count = (zsl->length - (rank - 1));
 
             /* Find last element in range */
             zn = zslLastInLexRange(zsl, &range);
 
             /* Use rank of last element, if any, to determine the actual count */
             if (zn != NULL) {
-                rank = zslGetRank(zsl, zn->score, zn->obj);
+                rank = zslGetRank(zsl, zn->score, zn->ele);
                 count -= (zsl->length - rank);
             }
         }
     } else {
         serverPanic("Unknown sorted set encoding");
     }
@@ -2791,19 +2974,19 @@
             }
         }
 
         while (ln && limit--) {
             /* Abort when the node is no longer in range. */
             if (reverse) {
-                if (!zslLexValueGteMin(ln->obj,&range)) break;
+                if (!zslLexValueGteMin(ln->ele,&range)) break;
             } else {
-                if (!zslLexValueLteMax(ln->obj,&range)) break;
+                if (!zslLexValueLteMax(ln->ele,&range)) break;
             }
 
             rangelen++;
-            addReplyBulk(c,ln->obj);
+            addReplyBulkCBuffer(c,ln->ele,sdslen(ln->ele));
 
             /* Move to next node */
             if (reverse) {
                 ln = ln->backward;
             } else {
                 ln = ln->level[0].forward;
@@ -2840,78 +3023,34 @@
     robj *zobj;
     double score;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
         checkType(c,zobj,OBJ_ZSET)) return;
 
-    if (zsetScore(zobj,c->argv[2],&score) == C_ERR) {
+    if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {
         addReply(c,shared.nullbulk);
     } else {
         addReplyDouble(c,score);
     }
 }
 
 void zrankGenericCommand(client *c, int reverse) {
     robj *key = c->argv[1];
     robj *ele = c->argv[2];
     robj *zobj;
-    unsigned long llen;
-    unsigned long rank;
+    long rank;
 
     if ((zobj = lookupKeyReadOrReply(c,key,shared.nullbulk)) == NULL ||
         checkType(c,zobj,OBJ_ZSET)) return;
-    llen = zsetLength(zobj);
 
     serverAssertWithInfo(c,ele,sdsEncodedObject(ele));
-
-    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {
-        unsigned char *zl = zobj->ptr;
-        unsigned char *eptr, *sptr;
-
-        eptr = ziplistIndex(zl,0);
-        serverAssertWithInfo(c,zobj,eptr != NULL);
-        sptr = ziplistNext(zl,eptr);
-        serverAssertWithInfo(c,zobj,sptr != NULL);
-
-        rank = 1;
-        while(eptr != NULL) {
-            if (ziplistCompare(eptr,ele->ptr,sdslen(ele->ptr)))
-                break;
-            rank++;
-            zzlNext(zl,&eptr,&sptr);
-        }
-
-        if (eptr != NULL) {
-            if (reverse)
-                addReplyLongLong(c,llen-rank);
-            else
-                addReplyLongLong(c,rank-1);
-        } else {
-            addReply(c,shared.nullbulk);
-        }
-    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
-        zset *zs = zobj->ptr;
-        zskiplist *zsl = zs->zsl;
-        dictEntry *de;
-        double score;
-
-        ele = c->argv[2];
-        de = dictFind(zs->dict,ele);
-        if (de != NULL) {
-            score = *(double*)dictGetVal(de);
-            rank = zslGetRank(zsl,score,ele);
-            serverAssertWithInfo(c,ele,rank); /* Existing elements always have a rank. */
-            if (reverse)
-                addReplyLongLong(c,llen-rank);
-            else
-                addReplyLongLong(c,rank-1);
-        } else {
-            addReply(c,shared.nullbulk);
-        }
+    rank = zsetRank(zobj,ele->ptr,reverse);
+    if (rank >= 0) {
+        addReplyLongLong(c,rank);
     } else {
-        serverPanic("Unknown sorted set encoding");
+        addReply(c,shared.nullbulk);
     }
 }
 
 void zrankCommand(client *c) {
     zrankGenericCommand(c, 0);
 }
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/t_zset.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/t_zset.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.c	2017-07-14 19:28:42.000000000 +0800
@@ -271,13 +271,13 @@
  * novel approach but only publicizes an already used technique):
  *
  * https://www.facebook.com/notes/facebook-engineering/three-optimization-tips-for-c/10151361643253920
  *
  * Modified in order to handle signed integers since the original code was
  * designed for unsigned integers. */
-int ll2string(char* dst, size_t dstlen, long long svalue) {
+int ll2string(char *dst, size_t dstlen, long long svalue) {
     static const char digits[201] =
         "0001020304050607080910111213141516171819"
         "2021222324252627282930313233343536373839"
         "4041424344454647484950515253545556575859"
         "6061626364656667686970717273747576777879"
         "8081828384858687888990919293949596979899";
@@ -327,13 +327,22 @@
     if (negative) dst[0] = '-';
     return length;
 }
 
 /* Convert a string into a long long. Returns 1 if the string could be parsed
  * into a (non-overflowing) long long, 0 otherwise. The value will be set to
- * the parsed value when appropriate. */
+ * the parsed value when appropriate.
+ *
+ * Note that this function demands that the string strictly represents
+ * a long long: no spaces or other characters before or after the string
+ * representing the number are accepted, nor zeroes at the start if not
+ * for the string "0" representing the zero number.
+ *
+ * Because of its strictness, it is safe to use this function to check if
+ * you can convert a string into a long long, and obtain back the string
+ * from the number without any loss in the string representation. */
 int string2ll(const char *s, size_t slen, long long *value) {
     const char *p = s;
     size_t plen = 0;
     int negative = 0;
     unsigned long long v;
 
@@ -407,14 +416,46 @@
         return 0;
 
     *lval = (long)llval;
     return 1;
 }
 
+/* Convert a string into a double. Returns 1 if the string could be parsed
+ * into a (non-overflowing) double, 0 otherwise. The value will be set to
+ * the parsed value when appropriate.
+ *
+ * Note that this function demands that the string strictly represents
+ * a double: no spaces or other characters before or after the string
+ * representing the number are accepted. */
+int string2ld(const char *s, size_t slen, long double *dp) {
+    char buf[256];
+    long double value;
+    char *eptr;
+
+    if (slen >= sizeof(buf)) return 0;
+    memcpy(buf,s,slen);
+    buf[slen] = '\0';
+
+    errno = 0;
+    value = strtold(buf, &eptr);
+    if (isspace(buf[0]) || eptr[0] != '\0' ||
+        (errno == ERANGE &&
+            (value == HUGE_VAL || value == -HUGE_VAL || value == 0)) ||
+        errno == EINVAL ||
+        isnan(value))
+        return 0;
+
+    if (dp) *dp = value;
+    return 1;
+}
+
 /* Convert a double to a string representation. Returns the number of bytes
- * required. The representation should always be parsable by strtod(3). */
+ * required. The representation should always be parsable by strtod(3).
+ * This function does not support human-friendly formatting like ld2string
+ * does. It is intented mainly to be used inside t_zset.c when writing scores
+ * into a ziplist representing a sorted set. */
 int d2string(char *buf, size_t len, double value) {
     if (isnan(value)) {
         len = snprintf(buf,len,"nan");
     } else if (isinf(value)) {
         if (value < 0)
             len = snprintf(buf,len,"-inf");
@@ -446,12 +487,58 @@
             len = snprintf(buf,len,"%.17g",value);
     }
 
     return len;
 }
 
+/* Convert a long double into a string. If humanfriendly is non-zero
+ * it does not use exponential format and trims trailing zeroes at the end,
+ * however this results in loss of precision. Otherwise exp format is used
+ * and the output of snprintf() is not modified.
+ *
+ * The function returns the length of the string or zero if there was not
+ * enough buffer room to store it. */
+int ld2string(char *buf, size_t len, long double value, int humanfriendly) {
+    size_t l;
+
+    if (isinf(value)) {
+        /* Libc in odd systems (Hi Solaris!) will format infinite in a
+         * different way, so better to handle it in an explicit way. */
+        if (len < 5) return 0; /* No room. 5 is "-inf\0" */
+        if (value > 0) {
+            memcpy(buf,"inf",3);
+            l = 3;
+        } else {
+            memcpy(buf,"-inf",4);
+            l = 4;
+        }
+    } else if (humanfriendly) {
+        /* We use 17 digits precision since with 128 bit floats that precision
+         * after rounding is able to represent most small decimal numbers in a
+         * way that is "non surprising" for the user (that is, most small
+         * decimal numbers will be represented in a way that when converted
+         * back into a string are exactly the same as what the user typed.) */
+        l = snprintf(buf,len,"%.17Lf", value);
+        if (l+1 > len) return 0; /* No room. */
+        /* Now remove trailing zeroes after the '.' */
+        if (strchr(buf,'.') != NULL) {
+            char *p = buf+l-1;
+            while(*p == '0') {
+                p--;
+                l--;
+            }
+            if (*p == '.') l--;
+        }
+    } else {
+        l = snprintf(buf,len,"%.17Lg", value);
+        if (l+1 > len) return 0; /* No room. */
+    }
+    buf[l] = '\0';
+    return l;
+}
+
 /* Generate the Redis "Run ID", a SHA1-sized random number that identifies a
  * given execution of Redis, so that if you are talking with an instance
  * having run_id == A, and you reconnect and it has run_id == B, you can be
  * sure that it is either a different instance or it was restarted. */
 void getRandomHexChars(char *p, unsigned int len) {
     char *charset = "0123456789abcdef";
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.h	2017-07-14 19:28:42.000000000 +0800
@@ -38,13 +38,15 @@
 long long memtoll(const char *p, int *err);
 uint32_t digits10(uint64_t v);
 uint32_t sdigits10(int64_t v);
 int ll2string(char *s, size_t len, long long value);
 int string2ll(const char *s, size_t slen, long long *value);
 int string2l(const char *s, size_t slen, long *value);
+int string2ld(const char *s, size_t slen, long double *dp);
 int d2string(char *buf, size_t len, double value);
+int ld2string(char *buf, size_t len, long double value, int humanfriendly);
 sds getAbsolutePath(char *filename);
 int pathIsBaseName(char *path);
 
 #ifdef REDIS_TEST
 int utilTest(int argc, char **argv);
 #endif
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/util.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/util.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/version.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/version.h	2017-07-14 19:28:42.000000000 +0800
@@ -1 +1 @@
-#define REDIS_VERSION "3.2.11"
+#define REDIS_VERSION "4.0.0"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.c	2017-07-14 19:28:42.000000000 +0800
@@ -5,78 +5,156 @@
  * in O(1) time. However, because every operation requires a reallocation of
  * the memory used by the ziplist, the actual complexity is related to the
  * amount of memory used by the ziplist.
  *
  * ----------------------------------------------------------------------------
  *
- * ZIPLIST OVERALL LAYOUT:
+ * ZIPLIST OVERALL LAYOUT
+ * ======================
+ *
  * The general layout of the ziplist is as follows:
- * <zlbytes><zltail><zllen><entry><entry><zlend>
  *
- * <zlbytes> is an unsigned integer to hold the number of bytes that the
- * ziplist occupies. This value needs to be stored to be able to resize the
- * entire structure without the need to traverse it first.
+ * <zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
  *
- * <zltail> is the offset to the last entry in the list. This allows a pop
- * operation on the far side of the list without the need for full traversal.
+ * NOTE: all fields are stored in little endian, if not specified otherwise.
  *
- * <zllen> is the number of entries.When this value is larger than 2**16-2,
- * we need to traverse the entire list to know how many items it holds.
+ * <uint32_t zlbytes> is an unsigned integer to hold the number of bytes that
+ * the ziplist occupies, including the four bytes of the zlbytes field itself.
+ * This value needs to be stored to be able to resize the entire structure
+ * without the need to traverse it first.
  *
- * <zlend> is a single byte special value, equal to 255, which indicates the
- * end of the list.
+ * <uint32_t zltail> is the offset to the last entry in the list. This allows
+ * a pop operation on the far side of the list without the need for full
+ * traversal.
  *
- * ZIPLIST ENTRIES:
- * Every entry in the ziplist is prefixed by a header that contains two pieces
- * of information. First, the length of the previous entry is stored to be
- * able to traverse the list from back to front. Second, the encoding with an
- * optional string length of the entry itself is stored.
+ * <uint16_t zllen> is the number of entries. When there are more than
+ * 2^16-2 entires, this value is set to 2^16-1 and we need to traverse the
+ * entire list to know how many items it holds.
+ *
+ * <uint8_t zlend> is a special entry representing the end of the ziplist.
+ * Is encoded as a single byte equal to 255. No other normal entry starts
+ * with a byte set to the value of 255.
  *
- * The length of the previous entry is encoded in the following way:
- * If this length is smaller than 254 bytes, it will only consume a single
- * byte that takes the length as value. When the length is greater than or
- * equal to 254, it will consume 5 bytes. The first byte is set to 254 to
- * indicate a larger value is following. The remaining 4 bytes take the
- * length of the previous entry as value.
- *
- * The other header field of the entry itself depends on the contents of the
- * entry. When the entry is a string, the first 2 bits of this header will hold
- * the type of encoding used to store the length of the string, followed by the
- * actual length of the string. When the entry is an integer the first 2 bits
- * are both set to 1. The following 2 bits are used to specify what kind of
- * integer will be stored after this header. An overview of the different
- * types and encodings is as follows:
+ * ZIPLIST ENTRIES
+ * ===============
+ *
+ * Every entry in the ziplist is prefixed by metadata that contains two pieces
+ * of information. First, the length of the previous entry is stored to be
+ * able to traverse the list from back to front. Second, the entry encoding is
+ * provided. It represents the entry type, integer or string, and in the case
+ * of strings it also represents the length of the string payload.
+ * So a complete entry is stored like this:
+ *
+ * <prevlen> <encoding> <entry-data>
+ *
+ * Sometimes the encoding represents the entry itself, like for small integers
+ * as we'll see later. In such a case the <entry-data> part is missing, and we
+ * could have just:
+ *
+ * <prevlen> <encoding>
+ *
+ * The length of the previous entry, <prevlen>, is encoded in the following way:
+ * If this length is smaller than 255 bytes, it will only consume a single
+ * byte representing the length as an unsinged 8 bit integer. When the length
+ * is greater than or equal to 255, it will consume 5 bytes. The first byte is
+ * set to 255 (FF) to indicate a larger value is following. The remaining 4
+ * bytes take the length of the previous entry as value.
+ *
+ * So practically an entry is encoded in the following way:
+ *
+ * <prevlen from 0 to 254> <encoding> <entry>
+ *
+ * Or alternatively if the previous entry length is greater than 254 bytes
+ * the following encoding is used:
+ *
+ * 0xFF <4 bytes unsigned little endian prevlen> <encoding> <entry>
+ *
+ * The encoding field of the entry depends on the content of the
+ * entry. When the entry is a string, the first 2 bits of the encoding first
+ * byte will hold the type of encoding used to store the length of the string,
+ * followed by the actual length of the string. When the entry is an integer
+ * the first 2 bits are both set to 1. The following 2 bits are used to specify
+ * what kind of integer will be stored after this header. An overview of the
+ * different types and encodings is as follows. The first byte is always enough
+ * to determine the kind of entry.
  *
  * |00pppppp| - 1 byte
  *      String value with length less than or equal to 63 bytes (6 bits).
+ *      "pppppp" represents the unsigned 6 bit length.
  * |01pppppp|qqqqqqqq| - 2 bytes
  *      String value with length less than or equal to 16383 bytes (14 bits).
- * |10______|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
+ *      IMPORTANT: The 14 bit number is stored in big endian.
+ * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
  *      String value with length greater than or equal to 16384 bytes.
- * |11000000| - 1 byte
+ *      Only the 4 bytes following the first byte represents the length
+ *      up to 32^2-1. The 6 lower bits of the first byte are not used and
+ *      are set to zero.
+ *      IMPORTANT: The 32 bit number is stored in big endian.
+ * |11000000| - 3 bytes
  *      Integer encoded as int16_t (2 bytes).
- * |11010000| - 1 byte
+ * |11010000| - 5 bytes
  *      Integer encoded as int32_t (4 bytes).
- * |11100000| - 1 byte
+ * |11100000| - 9 bytes
  *      Integer encoded as int64_t (8 bytes).
- * |11110000| - 1 byte
+ * |11110000| - 4 bytes
  *      Integer encoded as 24 bit signed (3 bytes).
- * |11111110| - 1 byte
+ * |11111110| - 2 bytes
  *      Integer encoded as 8 bit signed (1 byte).
  * |1111xxxx| - (with xxxx between 0000 and 1101) immediate 4 bit integer.
  *      Unsigned integer from 0 to 12. The encoded value is actually from
  *      1 to 13 because 0000 and 1111 can not be used, so 1 should be
  *      subtracted from the encoded 4 bit value to obtain the right value.
- * |11111111| - End of ziplist.
+ * |11111111| - End of ziplist special entry.
  *
- * All the integers are represented in little endian byte order.
+ * Like for the ziplist header, all the integers are represented in little
+ * endian byte order, even when this code is compiled in big endian systems.
+ *
+ * EXAMPLES OF ACTUAL ZIPLISTS
+ * ===========================
+ *
+ * The following is a ziplist containing the two elements representing
+ * the strings "2" and "5". It is composed of 15 bytes, that we visually
+ * split into sections:
+ *
+ *  [0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]
+ *        |             |          |       |       |     |
+ *     zlbytes        zltail    entries   "2"     "5"   end
+ *
+ * The first 4 bytes represent the number 15, that is the number of bytes
+ * the whole ziplist is composed of. The second 4 bytes are the offset
+ * at which the last ziplist entry is found, that is 12, in fact the
+ * last entry, that is "5", is at offset 12 inside the ziplist.
+ * The next 16 bit integer represents the number of elements inside the
+ * ziplist, its value is 2 since there are just two elements inside.
+ * Finally "00 f3" is the first entry representing the number 2. It is
+ * composed of the previous entry length, which is zero because this is
+ * our first entry, and the byte F3 which corresponds to the encoding
+ * |1111xxxx| with xxxx between 0001 and 1101. We need to remove the "F"
+ * higher order bits 1111, and subtract 1 from the "3", so the entry value
+ * is "2". The next entry has a prevlen of 02, since the first entry is
+ * composed of exactly two bytes. The entry itself, F6, is encoded exactly
+ * like the first entry, and 6-1 = 5, so the value of the entry is 5.
+ * Finally the special entry FF signals the end of the ziplist.
+ *
+ * Adding another element to the above string with the value "Hello World"
+ * allows us to show how the ziplist encodes small strings. We'll just show
+ * the hex dump of the entry itself. Imagine the bytes as following the
+ * entry that stores "5" in the ziplist above:
+ *
+ * [02] [0b] [48 65 6c 6c 6f 20 57 6f 72 6c 64]
+ *
+ * The first byte, 02, is the length of the previous entry. The next
+ * byte represents the encoding in the pattern |00pppppp| that means
+ * that the entry is a string of length <pppppp>, so 0B means that
+ * an 11 bytes string follows. From the third byte (48) to the last (64)
+ * there are just the ASCII characters for "Hello World".
  *
  * ----------------------------------------------------------------------------
  *
  * Copyright (c) 2009-2012, Pieter Noordhuis <pcnoordhuis at gmail dot com>
- * Copyright (c) 2009-2012, Salvatore Sanfilippo <antirez at gmail dot com>
+ * Copyright (c) 2009-2017, Salvatore Sanfilippo <antirez at gmail dot com>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  *   * Redistributions of source code must retain the above copyright notice,
@@ -109,96 +187,152 @@
 #include "zmalloc.h"
 #include "util.h"
 #include "ziplist.h"
 #include "endianconv.h"
 #include "redisassert.h"
 
-#define ZIP_END 255
-#define ZIP_BIGLEN 254
+#define ZIP_END 255         /* Special "end of ziplist" entry. */
+#define ZIP_BIG_PREVLEN 254 /* Max number of bytes of the previous entry, for
+                               the "prevlen" field prefixing each entry, to be
+                               represented with just a single byte. Otherwise
+                               it is represented as FF AA BB CC DD, where
+                               AA BB CC DD are a 4 bytes unsigned integer
+                               representing the previous entry len. */
 
 /* Different encoding/length possibilities */
 #define ZIP_STR_MASK 0xc0
 #define ZIP_INT_MASK 0x30
 #define ZIP_STR_06B (0 << 6)
 #define ZIP_STR_14B (1 << 6)
 #define ZIP_STR_32B (2 << 6)
 #define ZIP_INT_16B (0xc0 | 0<<4)
 #define ZIP_INT_32B (0xc0 | 1<<4)
 #define ZIP_INT_64B (0xc0 | 2<<4)
 #define ZIP_INT_24B (0xc0 | 3<<4)
 #define ZIP_INT_8B 0xfe
-/* 4 bit integer immediate encoding */
-#define ZIP_INT_IMM_MASK 0x0f
+
+/* 4 bit integer immediate encoding |1111xxxx| with xxxx between
+ * 0001 and 1101. */
+#define ZIP_INT_IMM_MASK 0x0f   /* Mask to extract the 4 bits value. To add
+                                   one is needed to reconstruct the value. */
 #define ZIP_INT_IMM_MIN 0xf1    /* 11110001 */
 #define ZIP_INT_IMM_MAX 0xfd    /* 11111101 */
-#define ZIP_INT_IMM_VAL(v) (v & ZIP_INT_IMM_MASK)
 
 #define INT24_MAX 0x7fffff
 #define INT24_MIN (-INT24_MAX - 1)
 
-/* Macro to determine type */
+/* Macro to determine if the entry is a string. String entries never start
+ * with "11" as most significant bits of the first byte. */
 #define ZIP_IS_STR(enc) (((enc) & ZIP_STR_MASK) < ZIP_STR_MASK)
 
-/* Utility macros */
+/* Utility macros.*/
+
+/* Return total bytes a ziplist is composed of. */
 #define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))
+
+/* Return the offset of the last item inside the ziplist. */
 #define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))
+
+/* Return the length of a ziplist, or UINT16_MAX if the length cannot be
+ * determined without scanning the whole ziplist. */
 #define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))
+
+/* The size of a ziplist header: two 32 bit integers for the total
+ * bytes count and last item offset. One 16 bit integer for the number
+ * of items field. */
 #define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))
+
+/* Size of the "end of ziplist" entry. Just one byte. */
 #define ZIPLIST_END_SIZE        (sizeof(uint8_t))
+
+/* Return the pointer to the first entry of a ziplist. */
 #define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)
+
+/* Return the pointer to the last entry of a ziplist, using the
+ * last entry offset inside the ziplist header. */
 #define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))
+
+/* Return the pointer to the last byte of a ziplist, which is, the
+ * end of ziplist FF entry. */
 #define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)
 
-/* We know a positive increment can only be 1 because entries can only be
- * pushed one at a time. */
+/* Increment the number of items field in the ziplist header. Note that this
+ * macro should never overflow the unsigned 16 bit integer, since entires are
+ * always pushed one at a time. When UINT16_MAX is reached we want the count
+ * to stay there to signal that a full scan is needed to get the number of
+ * items inside the ziplist. */
 #define ZIPLIST_INCR_LENGTH(zl,incr) { \
     if (ZIPLIST_LENGTH(zl) < UINT16_MAX) \
         ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \
 }
 
+/* We use this function to receive information about a ziplist entry.
+ * Note that this is not how the data is actually encoded, is just what we
+ * get filled by a function in order to operate more easily. */
 typedef struct zlentry {
-    unsigned int prevrawlensize, prevrawlen;
-    unsigned int lensize, len;
-    unsigned int headersize;
-    unsigned char encoding;
-    unsigned char *p;
+    unsigned int prevrawlensize; /* Bytes used to encode the previos entry len*/
+    unsigned int prevrawlen;     /* Previous entry len. */
+    unsigned int lensize;        /* Bytes used to encode this entry type/len.
+                                    For example strings have a 1, 2 or 5 bytes
+                                    header. Integers always use a single byte.*/
+    unsigned int len;            /* Bytes used to represent the actual entry.
+                                    For strings this is just the string length
+                                    while for integers it is 1, 2, 3, 4, 8 or
+                                    0 (for 4 bit immediate) depending on the
+                                    number range. */
+    unsigned int headersize;     /* prevrawlensize + lensize. */
+    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
+                                    the entry encoding. However for 4 bits
+                                    immediate integers this can assume a range
+                                    of values and must be range-checked. */
+    unsigned char *p;            /* Pointer to the very start of the entry, that
+                                    is, this points to prev-entry-len field. */
 } zlentry;
 
 #define ZIPLIST_ENTRY_ZERO(zle) { \
     (zle)->prevrawlensize = (zle)->prevrawlen = 0; \
     (zle)->lensize = (zle)->len = (zle)->headersize = 0; \
     (zle)->encoding = 0; \
     (zle)->p = NULL; \
 }
 
 /* Extract the encoding from the byte pointed by 'ptr' and set it into
- * 'encoding'. */
+ * 'encoding' field of the zlentry structure. */
 #define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \
     (encoding) = (ptr[0]); \
     if ((encoding) < ZIP_STR_MASK) (encoding) &= ZIP_STR_MASK; \
 } while(0)
 
-void ziplistRepr(unsigned char *zl);
-
-/* Return bytes needed to store integer encoded by 'encoding' */
+/* Return bytes needed to store integer encoded by 'encoding'. */
 unsigned int zipIntSize(unsigned char encoding) {
     switch(encoding) {
     case ZIP_INT_8B:  return 1;
     case ZIP_INT_16B: return 2;
     case ZIP_INT_24B: return 3;
     case ZIP_INT_32B: return 4;
     case ZIP_INT_64B: return 8;
-    default: return 0; /* 4 bit immediate */
     }
-    assert(NULL);
+    if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
+        return 0; /* 4 bit immediate */
+    panic("Invalid integer encoding 0x%02X", encoding);
     return 0;
 }
 
-/* Encode the length 'rawlen' writing it in 'p'. If p is NULL it just returns
- * the amount of bytes required to encode such a length. */
-unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
+/* Write the encoidng header of the entry in 'p'. If p is NULL it just returns
+ * the amount of bytes required to encode such a length. Arguments:
+ *
+ * 'encoding' is the encoding we are using for the entry. It could be
+ * ZIP_INT_* or ZIP_STR_* or between ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX
+ * for single-byte small immediate integers.
+ *
+ * 'rawlen' is only used for ZIP_STR_* encodings and is the length of the
+ * srting that this entry represents.
+ *
+ * The function returns the number of bytes used by the encoding/length
+ * header stored in 'p'. */
+unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
     unsigned char len = 1, buf[5];
 
     if (ZIP_IS_STR(encoding)) {
         /* Although encoding is given it may not be set for strings,
          * so we determine it here using the raw length. */
         if (rawlen <= 0x3f) {
@@ -221,101 +355,119 @@
     } else {
         /* Implies integer encoding, so length is always 1. */
         if (!p) return len;
         buf[0] = encoding;
     }
 
-    /* Store this length at p */
+    /* Store this length at p. */
     memcpy(p,buf,len);
     return len;
 }
 
-/* Decode the length encoded in 'ptr'. The 'encoding' variable will hold the
- * entries encoding, the 'lensize' variable will hold the number of bytes
- * required to encode the entries length, and the 'len' variable will hold the
- * entries length. */
+/* Decode the entry encoding type and data length (string length for strings,
+ * number of bytes used for the integer for integer entries) encoded in 'ptr'.
+ * The 'encoding' variable will hold the entry encoding, the 'lensize'
+ * variable will hold the number of bytes required to encode the entry
+ * length, and the 'len' variable will hold the entry length. */
 #define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \
     ZIP_ENTRY_ENCODING((ptr), (encoding));                                     \
     if ((encoding) < ZIP_STR_MASK) {                                           \
         if ((encoding) == ZIP_STR_06B) {                                       \
             (lensize) = 1;                                                     \
             (len) = (ptr)[0] & 0x3f;                                           \
         } else if ((encoding) == ZIP_STR_14B) {                                \
             (lensize) = 2;                                                     \
             (len) = (((ptr)[0] & 0x3f) << 8) | (ptr)[1];                       \
-        } else if (encoding == ZIP_STR_32B) {                                  \
+        } else if ((encoding) == ZIP_STR_32B) {                                \
             (lensize) = 5;                                                     \
             (len) = ((ptr)[1] << 24) |                                         \
                     ((ptr)[2] << 16) |                                         \
                     ((ptr)[3] <<  8) |                                         \
                     ((ptr)[4]);                                                \
         } else {                                                               \
-            assert(NULL);                                                      \
+            panic("Invalid string encoding 0x%02X", (encoding));               \
         }                                                                      \
     } else {                                                                   \
         (lensize) = 1;                                                         \
         (len) = zipIntSize(encoding);                                          \
     }                                                                          \
 } while(0);
 
+/* Encode the length of the previous entry and write it to "p". This only
+ * uses the larger encoding (required in __ziplistCascadeUpdate). */
+int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
+    if (p != NULL) {
+        p[0] = ZIP_BIG_PREVLEN;
+        memcpy(p+1,&len,sizeof(len));
+        memrev32ifbe(p+1);
+    }
+    return 1+sizeof(len);
+}
+
 /* Encode the length of the previous entry and write it to "p". Return the
  * number of bytes needed to encode this length if "p" is NULL. */
-unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) {
+unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
     if (p == NULL) {
-        return (len < ZIP_BIGLEN) ? 1 : sizeof(len)+1;
+        return (len < ZIP_BIG_PREVLEN) ? 1 : sizeof(len)+1;
     } else {
-        if (len < ZIP_BIGLEN) {
+        if (len < ZIP_BIG_PREVLEN) {
             p[0] = len;
             return 1;
         } else {
-            p[0] = ZIP_BIGLEN;
-            memcpy(p+1,&len,sizeof(len));
-            memrev32ifbe(p+1);
-            return 1+sizeof(len);
+            return zipStorePrevEntryLengthLarge(p,len);
         }
     }
 }
 
-/* Encode the length of the previous entry and write it to "p". This only
- * uses the larger encoding (required in __ziplistCascadeUpdate). */
-void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len) {
-    if (p == NULL) return;
-    p[0] = ZIP_BIGLEN;
-    memcpy(p+1,&len,sizeof(len));
-    memrev32ifbe(p+1);
-}
-
-/* Decode the number of bytes required to store the length of the previous
- * element, from the perspective of the entry pointed to by 'ptr'. */
+/* Return the number of bytes used to encode the length of the previous
+ * entry. The length is returned by setting the var 'prevlensize'. */
 #define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
-    if ((ptr)[0] < ZIP_BIGLEN) {                                               \
+    if ((ptr)[0] < ZIP_BIG_PREVLEN) {                                          \
         (prevlensize) = 1;                                                     \
     } else {                                                                   \
         (prevlensize) = 5;                                                     \
     }                                                                          \
 } while(0);
 
-/* Decode the length of the previous element, from the perspective of the entry
- * pointed to by 'ptr'. */
+/* Return the length of the previous element, and the number of bytes that
+ * are used in order to encode the previous element length.
+ * 'ptr' must point to the prevlen prefix of an entry (that encodes the
+ * length of the previos entry in order to navigate the elements backward).
+ * The length of the previous entry is stored in 'prevlen', the number of
+ * bytes needed to encode the previous entry length are stored in
+ * 'prevlensize'. */
 #define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
     ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
     if ((prevlensize) == 1) {                                                  \
         (prevlen) = (ptr)[0];                                                  \
     } else if ((prevlensize) == 5) {                                           \
         assert(sizeof((prevlensize)) == 4);                                    \
         memcpy(&(prevlen), ((char*)(ptr)) + 1, 4);                             \
         memrev32ifbe(&prevlen);                                                \
     }                                                                          \
 } while(0);
 
-/* Return the difference in number of bytes needed to store the length of the
- * previous element 'len', in the entry pointed to by 'p'. */
+/* Given a pointer 'p' to the prevlen info that prefixes an entry, this
+ * function returns the difference in number of bytes needed to encode
+ * the prevlen if the previous entry changes of size.
+ *
+ * So if A is the number of bytes used right now to encode the 'prevlen'
+ * field.
+ *
+ * And B is the number of bytes that are needed in order to encode the
+ * 'prevlen' if the previous element will be updated to one of size 'len'.
+ *
+ * Then the function returns B - A
+ *
+ * So the function returns a positive number if more space is needed,
+ * a negative number if less space is needed, or zero if the same space
+ * is needed. */
 int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
     unsigned int prevlensize;
     ZIP_DECODE_PREVLENSIZE(p, prevlensize);
-    return zipPrevEncodeLength(NULL, len) - prevlensize;
+    return zipStorePrevEntryLength(NULL, len) - prevlensize;
 }
 
 /* Return the total number of bytes used by the entry pointed to by 'p'. */
 unsigned int zipRawEntryLength(unsigned char *p) {
     unsigned int prevlensize, encoding, lensize, len;
     ZIP_DECODE_PREVLENSIZE(p, prevlensize);
@@ -446,14 +598,14 @@
  * length cannot be encoded in 1 byte and the next entry needs to be grow
  * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,
  * because this only happens when an entry is already being inserted (which
  * causes a realloc and memmove). However, encoding the prevlen may require
  * that this entry is grown as well. This effect may cascade throughout
  * the ziplist when there are consecutive entries with a size close to
- * ZIP_BIGLEN, so we need to check that the prevlen can be encoded in every
- * consecutive entry.
+ * ZIP_BIG_PREVLEN, so we need to check that the prevlen can be encoded in
+ * every consecutive entry.
  *
  * Note that this effect can also happen in reverse, where the bytes required
  * to encode the prevlen field can shrink. This effect is deliberately ignored,
  * because it can cause a "flapping" effect where a chain prevlen fields is
  * first grown and then shrunk again after consecutive inserts. Rather, the
  * field is allowed to stay larger than necessary, because a large prevlen
@@ -467,13 +619,13 @@
     unsigned char *np;
     zlentry cur, next;
 
     while (p[0] != ZIP_END) {
         zipEntry(p, &cur);
         rawlen = cur.headersize + cur.len;
-        rawlensize = zipPrevEncodeLength(NULL,rawlen);
+        rawlensize = zipStorePrevEntryLength(NULL,rawlen);
 
         /* Abort if there is no next entry. */
         if (p[rawlen] == ZIP_END) break;
         zipEntry(p+rawlen, &next);
 
         /* Abort when "prevlen" has not changed. */
@@ -498,24 +650,24 @@
             }
 
             /* Move the tail to the back. */
             memmove(np+rawlensize,
                 np+next.prevrawlensize,
                 curlen-noffset-next.prevrawlensize-1);
-            zipPrevEncodeLength(np,rawlen);
+            zipStorePrevEntryLength(np,rawlen);
 
             /* Advance the cursor */
             p += rawlen;
             curlen += extra;
         } else {
             if (next.prevrawlensize > rawlensize) {
                 /* This would result in shrinking, which we want to avoid.
                  * So, set "rawlen" in the available bytes. */
-                zipPrevEncodeLengthForceLarge(p+rawlen,rawlen);
+                zipStorePrevEntryLengthLarge(p+rawlen,rawlen);
             } else {
-                zipPrevEncodeLength(p+rawlen,rawlen);
+                zipStorePrevEntryLength(p+rawlen,rawlen);
             }
 
             /* Stop here, as the raw length of "next" has not changed. */
             break;
         }
     }
@@ -532,22 +684,27 @@
     zipEntry(p, &first);
     for (i = 0; p[0] != ZIP_END && i < num; i++) {
         p += zipRawEntryLength(p);
         deleted++;
     }
 
-    totlen = p-first.p;
+    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */
     if (totlen > 0) {
         if (p[0] != ZIP_END) {
             /* Storing `prevrawlen` in this entry may increase or decrease the
              * number of bytes required compare to the current `prevrawlen`.
              * There always is room to store this, because it was previously
              * stored by an entry that is now being deleted. */
             nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);
+
+            /* Note that there is always space when p jumps backward: if
+             * the new previous entry is large, one of the deleted elements
+             * had a 5 bytes prevlen header, so there is for sure at least
+             * 5 bytes free and we need just 4. */
             p -= nextdiff;
-            zipPrevEncodeLength(p,first.prevrawlen);
+            zipStorePrevEntryLength(p,first.prevrawlen);
 
             /* Update offset for tail */
             ZIPLIST_TAIL_OFFSET(zl) =
                 intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);
 
             /* When the tail contains more than one entry, we need to take
@@ -606,20 +763,20 @@
 
     /* See if the entry can be encoded */
     if (zipTryEncoding(s,slen,&value,&encoding)) {
         /* 'encoding' is set to the appropriate integer encoding */
         reqlen = zipIntSize(encoding);
     } else {
-        /* 'encoding' is untouched, however zipEncodeLength will use the
+        /* 'encoding' is untouched, however zipStoreEntryEncoding will use the
          * string length to figure out how to encode it. */
         reqlen = slen;
     }
     /* We need space for both the length of the previous entry and
      * the length of the payload. */
-    reqlen += zipPrevEncodeLength(NULL,prevlen);
-    reqlen += zipEncodeLength(NULL,encoding,slen);
+    reqlen += zipStorePrevEntryLength(NULL,prevlen);
+    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);
 
     /* When the insert position is not equal to the tail, we need to
      * make sure that the next entry can hold this entry's length in
      * its prevlen field. */
     int forcelarge = 0;
     nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
@@ -637,15 +794,15 @@
     if (p[0] != ZIP_END) {
         /* Subtract one because of the ZIP_END bytes */
         memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
 
         /* Encode this entry's raw length in the next entry. */
         if (forcelarge)
-            zipPrevEncodeLengthForceLarge(p+reqlen,reqlen);
+            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);
         else
-            zipPrevEncodeLength(p+reqlen,reqlen);
+            zipStorePrevEntryLength(p+reqlen,reqlen);
 
         /* Update offset for tail */
         ZIPLIST_TAIL_OFFSET(zl) =
             intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);
 
         /* When the tail contains more than one entry, we need to take
@@ -667,14 +824,14 @@
         offset = p-zl;
         zl = __ziplistCascadeUpdate(zl,p+reqlen);
         p = zl+offset;
     }
 
     /* Write the entry */
-    p += zipPrevEncodeLength(p,prevlen);
-    p += zipEncodeLength(p,encoding,slen);
+    p += zipStorePrevEntryLength(p,prevlen);
+    p += zipStoreEntryEncoding(p,encoding,slen);
     if (ZIP_IS_STR(encoding)) {
         memcpy(p,s,slen);
     } else {
         zipSaveInteger(p,value,encoding);
     }
     ZIPLIST_INCR_LENGTH(zl,1);
@@ -1034,52 +1191,57 @@
     unsigned char *p;
     int index = 0;
     zlentry entry;
 
     printf(
         "{total bytes %d} "
-        "{length %u}\n"
+        "{num entries %u}\n"
         "{tail offset %u}\n",
         intrev32ifbe(ZIPLIST_BYTES(zl)),
         intrev16ifbe(ZIPLIST_LENGTH(zl)),
         intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
     p = ZIPLIST_ENTRY_HEAD(zl);
     while(*p != ZIP_END) {
         zipEntry(p, &entry);
         printf(
-            "{"
-                "addr 0x%08lx, "
-                "index %2d, "
-                "offset %5ld, "
-                "rl: %5u, "
-                "hs %2u, "
-                "pl: %5u, "
-                "pls: %2u, "
-                "payload %5u"
-            "} ",
+            "{\n"
+                "\taddr 0x%08lx,\n"
+                "\tindex %2d,\n"
+                "\toffset %5ld,\n"
+                "\thdr+entry len: %5u,\n"
+                "\thdr len%2u,\n"
+                "\tprevrawlen: %5u,\n"
+                "\tprevrawlensize: %2u,\n"
+                "\tpayload %5u\n",
             (long unsigned)p,
             index,
             (unsigned long) (p-zl),
             entry.headersize+entry.len,
             entry.headersize,
             entry.prevrawlen,
             entry.prevrawlensize,
             entry.len);
+        printf("\tbytes: ");
+        for (unsigned int i = 0; i < entry.headersize+entry.len; i++) {
+            printf("%02x|",p[i]);
+        }
+        printf("\n");
         p += entry.headersize;
         if (ZIP_IS_STR(entry.encoding)) {
+            printf("\t[str]");
             if (entry.len > 40) {
                 if (fwrite(p,40,1,stdout) == 0) perror("fwrite");
                 printf("...");
             } else {
                 if (entry.len &&
                     fwrite(p,entry.len,1,stdout) == 0) perror("fwrite");
             }
         } else {
-            printf("%lld", (long long) zipLoadInteger(p,entry.encoding));
+            printf("\t[int]%lld", (long long) zipLoadInteger(p,entry.encoding));
         }
-        printf("\n");
+        printf("\n}\n");
         p += entry.len;
         index++;
     }
     printf("{end}\n\n");
 }
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.h	2017-07-14 19:28:42.000000000 +0800
@@ -45,12 +45,13 @@
 unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);
 unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num);
 unsigned int ziplistCompare(unsigned char *p, unsigned char *s, unsigned int slen);
 unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);
 unsigned int ziplistLen(unsigned char *zl);
 size_t ziplistBlobLen(unsigned char *zl);
+void ziplistRepr(unsigned char *zl);
 
 #ifdef REDIS_TEST
 int ziplistTest(int argc, char *argv[]);
 #endif
 
 #endif /* _ZIPLIST_H */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/ziplist.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/ziplist.o differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zipmap.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zipmap.c.bc differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zipmap.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zipmap.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.c	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.c	2017-07-14 19:28:42.000000000 +0800
@@ -40,12 +40,13 @@
 }
 
 #include <string.h>
 #include <pthread.h>
 #include "config.h"
 #include "zmalloc.h"
+#include "atomicvar.h"
 
 #ifdef HAVE_MALLOC_SIZE
 #define PREFIX_SIZE (0)
 #else
 #if defined(__sun) || defined(__sparc) || defined(__sparc__)
 #define PREFIX_SIZE (sizeof(long long))
@@ -62,57 +63,29 @@
 #define free(ptr) tc_free(ptr)
 #elif defined(USE_JEMALLOC)
 #define malloc(size) je_malloc(size)
 #define calloc(count,size) je_calloc(count,size)
 #define realloc(ptr,size) je_realloc(ptr,size)
 #define free(ptr) je_free(ptr)
-#endif
-
-#if defined(__ATOMIC_RELAXED)
-#define update_zmalloc_stat_add(__n) __atomic_add_fetch(&used_memory, (__n), __ATOMIC_RELAXED)
-#define update_zmalloc_stat_sub(__n) __atomic_sub_fetch(&used_memory, (__n), __ATOMIC_RELAXED)
-#elif defined(HAVE_ATOMIC)
-#define update_zmalloc_stat_add(__n) __sync_add_and_fetch(&used_memory, (__n))
-#define update_zmalloc_stat_sub(__n) __sync_sub_and_fetch(&used_memory, (__n))
-#else
-#define update_zmalloc_stat_add(__n) do { \
-    pthread_mutex_lock(&used_memory_mutex); \
-    used_memory += (__n); \
-    pthread_mutex_unlock(&used_memory_mutex); \
-} while(0)
-
-#define update_zmalloc_stat_sub(__n) do { \
-    pthread_mutex_lock(&used_memory_mutex); \
-    used_memory -= (__n); \
-    pthread_mutex_unlock(&used_memory_mutex); \
-} while(0)
-
+#define mallocx(size,flags) je_mallocx(size,flags)
+#define dallocx(ptr,flags) je_dallocx(ptr,flags)
 #endif
 
 #define update_zmalloc_stat_alloc(__n) do { \
     size_t _n = (__n); \
     if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
-    if (zmalloc_thread_safe) { \
-        update_zmalloc_stat_add(_n); \
-    } else { \
-        used_memory += _n; \
-    } \
+    atomicIncr(used_memory,__n); \
 } while(0)
 
 #define update_zmalloc_stat_free(__n) do { \
     size_t _n = (__n); \
     if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
-    if (zmalloc_thread_safe) { \
-        update_zmalloc_stat_sub(_n); \
-    } else { \
-        used_memory -= _n; \
-    } \
+    atomicDecr(used_memory,__n); \
 } while(0)
 
 static size_t used_memory = 0;
-static int zmalloc_thread_safe = 0;
 pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static void zmalloc_default_oom(size_t size) {
     fprintf(stderr, "zmalloc: Out of memory trying to allocate %zu bytes\n",
         size);
     fflush(stderr);
@@ -132,12 +105,30 @@
     *((size_t*)ptr) = size;
     update_zmalloc_stat_alloc(size+PREFIX_SIZE);
     return (char*)ptr+PREFIX_SIZE;
 #endif
 }
 
+/* Allocation and free functions that bypass the thread cache
+ * and go straight to the allocator arena bins.
+ * Currently implemented only for jemalloc. Used for online defragmentation. */
+#ifdef HAVE_DEFRAG
+void *zmalloc_no_tcache(size_t size) {
+    void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE);
+    if (!ptr) zmalloc_oom_handler(size);
+    update_zmalloc_stat_alloc(zmalloc_size(ptr));
+    return ptr;
+}
+
+void zfree_no_tcache(void *ptr) {
+    if (ptr == NULL) return;
+    update_zmalloc_stat_free(zmalloc_size(ptr));
+    dallocx(ptr, MALLOCX_TCACHE_NONE);
+}
+#endif
+
 void *zcalloc(size_t size) {
     void *ptr = calloc(1, size+PREFIX_SIZE);
 
     if (!ptr) zmalloc_oom_handler(size);
 #ifdef HAVE_MALLOC_SIZE
     update_zmalloc_stat_alloc(zmalloc_size(ptr));
@@ -217,33 +208,16 @@
     memcpy(p,s,l);
     return p;
 }
 
 size_t zmalloc_used_memory(void) {
     size_t um;
-
-    if (zmalloc_thread_safe) {
-#if defined(__ATOMIC_RELAXED) || defined(HAVE_ATOMIC)
-        um = update_zmalloc_stat_add(0);
-#else
-        pthread_mutex_lock(&used_memory_mutex);
-        um = used_memory;
-        pthread_mutex_unlock(&used_memory_mutex);
-#endif
-    }
-    else {
-        um = used_memory;
-    }
-
+    atomicGet(used_memory,um);
     return um;
 }
 
-void zmalloc_enable_thread_safeness(void) {
-    zmalloc_thread_safe = 1;
-}
-
 void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {
     zmalloc_oom_handler = oom_handler;
 }
 
 /* Get the RSS information in an OS-specific way.
  *
@@ -329,20 +303,32 @@
 }
 
 /* Get the sum of the specified field (converted form kb to bytes) in
  * /proc/self/smaps. The field must be specified with trailing ":" as it
  * apperas in the smaps output.
  *
- * Example: zmalloc_get_smap_bytes_by_field("Rss:");
+ * If a pid is specified, the information is extracted for such a pid,
+ * otherwise if pid is -1 the information is reported is about the
+ * current process.
+ *
+ * Example: zmalloc_get_smap_bytes_by_field("Rss:",-1);
  */
 #if defined(HAVE_PROC_SMAPS)
-size_t zmalloc_get_smap_bytes_by_field(char *field) {
+size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
     char line[1024];
     size_t bytes = 0;
-    FILE *fp = fopen("/proc/self/smaps","r");
     int flen = strlen(field);
+    FILE *fp;
+
+    if (pid == -1) {
+        fp = fopen("/proc/self/smaps","r");
+    } else {
+        char filename[128];
+        snprintf(filename,sizeof(filename),"/proc/%ld/smaps",pid);
+        fp = fopen(filename,"r");
+    }
 
     if (!fp) return 0;
     while(fgets(line,sizeof(line),fp) != NULL) {
         if (strncmp(line,field,flen) == 0) {
             char *p = strchr(line,'k');
             if (p) {
@@ -352,20 +338,21 @@
         }
     }
     fclose(fp);
     return bytes;
 }
 #else
-size_t zmalloc_get_smap_bytes_by_field(char *field) {
+size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
     ((void) field);
+    ((void) pid);
     return 0;
 }
 #endif
 
-size_t zmalloc_get_private_dirty(void) {
-    return zmalloc_get_smap_bytes_by_field("Private_Dirty:");
+size_t zmalloc_get_private_dirty(long pid) {
+    return zmalloc_get_smap_bytes_by_field("Private_Dirty:",pid);
 }
 
 /* Returns the size of physical memory (RAM) in bytes.
  * It looks ugly, but this is the cleanest way to achive cross platform results.
  * Cleaned up from:
  *
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.c.bc and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.c.bc differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.h	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.h	2017-07-14 19:28:42.000000000 +0800
@@ -62,26 +62,37 @@
 #endif
 
 #ifndef ZMALLOC_LIB
 #define ZMALLOC_LIB "libc"
 #endif
 
+/* We can enable the Redis defrag capabilities only if we are using Jemalloc
+ * and the version used is our special version modified for Redis having
+ * the ability to return per-allocation fragmentation hints. */
+#if defined(USE_JEMALLOC) && defined(JEMALLOC_FRAG_HINT)
+#define HAVE_DEFRAG
+#endif
+
 void *zmalloc(size_t size);
 void *zcalloc(size_t size);
 void *zrealloc(void *ptr, size_t size);
 void zfree(void *ptr);
 char *zstrdup(const char *s);
 size_t zmalloc_used_memory(void);
-void zmalloc_enable_thread_safeness(void);
 void zmalloc_set_oom_handler(void (*oom_handler)(size_t));
 float zmalloc_get_fragmentation_ratio(size_t rss);
 size_t zmalloc_get_rss(void);
-size_t zmalloc_get_private_dirty(void);
-size_t zmalloc_get_smap_bytes_by_field(char *field);
+size_t zmalloc_get_private_dirty(long pid);
+size_t zmalloc_get_smap_bytes_by_field(char *field, long pid);
 size_t zmalloc_get_memory_size(void);
 void zlibc_free(void *ptr);
 
+#ifdef HAVE_DEFRAG
+void zfree_no_tcache(void *ptr);
+void *zmalloc_no_tcache(size_t size);
+#endif
+
 #ifndef HAVE_MALLOC_SIZE
 size_t zmalloc_size(void *ptr);
 #endif
 
 #endif /* __ZMALLOC_H */
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/src/zmalloc.o and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/src/zmalloc.o differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/assets/default.conf /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/assets/default.conf
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/assets/default.conf	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/assets/default.conf	2017-07-14 19:28:42.000000000 +0800
@@ -1,8 +1,9 @@
 # Redis configuration for testing.
 
+always-show-logo yes
 notify-keyspace-events KEA
 daemonize no
 pidfile /var/run/redis.pid
 port 6379
 timeout 0
 bind 127.0.0.1
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/cluster/tests/04-resharding.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/cluster/tests/04-resharding.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/cluster/tests/04-resharding.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/cluster/tests/04-resharding.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -56,12 +56,13 @@
 set cluster [redis_cluster 127.0.0.1:[get_instance_attrib redis 0 port]]
 catch {unset content}
 array set content {}
 set tribpid {}
 
 test "Cluster consistency during live resharding" {
+    set ele 0
     for {set j 0} {$j < $numops} {incr j} {
         # Trigger the resharding once we execute half the ops.
         if {$tribpid ne {} &&
             ($j % 10000) == 0 &&
             ![process_is_running $tribpid]} {
             set tribpid {}
@@ -83,13 +84,13 @@
                 &] 0]
         }
 
         # Write random data to random list.
         set listid [randomInt $numkeys]
         set key "key:$listid"
-        set ele [randomValue]
+        incr ele
         # We write both with Lua scripts and with plain commands.
         # This way we are able to stress Lua -> Redis command invocation
         # as well, that has tests to prevent Lua to write into wrong
         # hash slots.
         if {$listid % 2} {
             $cluster rpush $key $ele
@@ -112,13 +113,15 @@
 
 }
 
 test "Verify $numkeys keys for consistency with logical content" {
     # Check that the Redis Cluster content matches our logical content.
     foreach {key value} [array get content] {
-        assert {[$cluster lrange $key 0 -1] eq $value}
+        if {[$cluster lrange $key 0 -1] ne $value} {
+            fail "Key $key expected to hold '$value' but actual content is [$cluster lrange $key 0 -1]"
+        }
     }
 }
 
 test "Crash and restart all the instances" {
     foreach_redis_id id {
         kill_instance redis $id
@@ -130,13 +133,15 @@
     assert_cluster_state ok
 }
 
 test "Verify $numkeys keys after the crash & restart" {
     # Check that the Redis Cluster content matches our logical content.
     foreach {key value} [array get content] {
-        assert {[$cluster lrange $key 0 -1] eq $value}
+        if {[$cluster lrange $key 0 -1] ne $value} {
+            fail "Key $key expected to hold '$value' but actual content is [$cluster lrange $key 0 -1]"
+        }
     }
 }
 
 test "Disable AOF in all the instances" {
     foreach_redis_id id {
         R $id config set appendonly no
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/integration/aof.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration/aof.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/integration/aof.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration/aof.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -85,13 +85,13 @@
 
     start_server_aof [list dir $server_path aof-load-truncated yes] {
         test "Bad format: Server should have logged an error" {
             set pattern "*Bad file format reading the append only file*"
             set retry 10
             while {$retry} {
-                set result [exec tail -n1 < [dict get $srv stdout]]
+                set result [exec tail -1 < [dict get $srv stdout]]
                 if {[string match $pattern $result]} {
                     break
                 }
                 incr retry -1
                 after 1000
             }
@@ -110,13 +110,13 @@
 
     start_server_aof [list dir $server_path aof-load-truncated no] {
         test "Unfinished MULTI: Server should have logged an error" {
             set pattern "*Unexpected end of file reading the append only file*"
             set retry 10
             while {$retry} {
-                set result [exec tail -n1 < [dict get $srv stdout]]
+                set result [exec tail -1 < [dict get $srv stdout]]
                 if {[string match $pattern $result]} {
                     break
                 }
                 incr retry -1
                 after 1000
             }
@@ -134,13 +134,13 @@
 
     start_server_aof [list dir $server_path aof-load-truncated no] {
         test "Short read: Server should have logged an error" {
             set pattern "*Unexpected end of file reading the append only file*"
             set retry 10
             while {$retry} {
-                set result [exec tail -n1 < [dict get $srv stdout]]
+                set result [exec tail -1 < [dict get $srv stdout]]
                 if {[string match $pattern $result]} {
                     break
                 }
                 incr retry -1
                 after 1000
             }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration: psync2-reg.tcl
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration: psync2.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/integration/rdb.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration/rdb.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/integration/rdb.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration/rdb.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -63,13 +63,13 @@
 # Now make sure the server aborted with an error
 if {!$isroot} {
     start_server_and_kill_it [list "dir" $server_path] {
         test {Server should not start if RDB file can't be open} {
             wait_for_condition 50 100 {
                 [string match {*Fatal error loading*} \
-                    [exec tail -n1 < [dict get $srv stdout]]]
+                    [exec tail -1 < [dict get $srv stdout]]]
             } else {
                 fail "Server started even if RDB was unreadable!"
             }
         }
     }
 }
@@ -87,12 +87,12 @@
 
 # Now make sure the server aborted with an error
 start_server_and_kill_it [list "dir" $server_path] {
     test {Server should not start if RDB is corrupted} {
         wait_for_condition 50 100 {
             [string match {*CRC error*} \
-                [exec tail -n10 < [dict get $srv stdout]]]
+                [exec tail -10 < [dict get $srv stdout]]]
         } else {
             fail "Server started even if RDB was corrupted!"
         }
     }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/integration/replication-3.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration/replication-3.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/integration/replication-3.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration/replication-3.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -27,12 +27,24 @@
                 close $fd
                 puts "Master - Slave inconsistency"
                 puts "Run diff -u against /tmp/repldump*.txt for more info"
             }
             assert_equal [r debug digest] [r -1 debug digest]
         }
+
+        test {Slave is able to evict keys created in writable slaves} {
+            r -1 select 5
+            assert {[r -1 dbsize] == 0}
+            r -1 config set slave-read-only no
+            r -1 set key1 1 ex 5
+            r -1 set key2 2 ex 5
+            r -1 set key3 3 ex 5
+            assert {[r -1 dbsize] == 3}
+            after 6000
+            r -1 dbsize
+        } {0}
     }
 }
 
 start_server {tags {"repl"}} {
     start_server {} {
         test {First server should have role slave after SLAVEOF} {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/integration/replication-psync.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration/replication-psync.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/integration/replication-psync.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/integration/replication-psync.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -44,13 +44,13 @@
                     fail "Replication not started."
                 }
             }
 
             # Check that the background clients are actually writing.
             test {Detect write load to master} {
-                wait_for_condition 50 100 {
+                wait_for_condition 50 1000 {
                     [$master dbsize] > 100
                 } else {
                     fail "Can't detect write load from background clients."
                 }
             }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/support/cluster.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/support/cluster.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/support/cluster.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/support/cluster.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -55,23 +55,24 @@
 # and every time we get a -MOVED redirection error.
 proc ::redis_cluster::__method__refresh_nodes_map {id} {
     # Contact the first responding startup node.
     set idx 0; # Index of the node that will respond.
     set errmsg {}
     foreach start_node $::redis_cluster::startup_nodes($id) {
-        lassign [split $start_node :] start_host start_port
+        set ip_port [lindex [split $start_node @] 0]
+        lassign [split $ip_port :] start_host start_port
         if {[catch {
             set r {}
             set r [redis $start_host $start_port]
             set nodes_descr [$r cluster nodes]
             $r close
         } e]} {
             if {$r ne {}} {catch {$r close}}
             incr idx
             if {[string length $errmsg] < 200} {
-                append errmsg " $start_node: $e"
+                append errmsg " $ip_port: $e"
             }
             continue ; # Try next.
         } else {
             break; # Good node found.
         }
     }
@@ -95,12 +96,13 @@
     foreach line [split $nodes_descr "\n"] {
         set line [string trim $line]
         if {$line eq {}} continue
         set args [split $line " "]
         lassign $args nodeid addr flags slaveof pingsent pongrecv configepoch linkstate
         set slots [lrange $args 8 end]
+        set addr [lindex [split $addr @] 0]
         if {$addr eq {:0}} {
             set addr $start_host:$start_port
         }
         lassign [split $addr :] host port
 
         # Connect to the node
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/support/server.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/support/server.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/support/server.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/support/server.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -210,12 +210,14 @@
 
     set stdout [format "%s/%s" [dict get $config "dir"] "stdout"]
     set stderr [format "%s/%s" [dict get $config "dir"] "stderr"]
 
     if {$::valgrind} {
         set pid [exec valgrind --track-origins=yes --suppressions=src/valgrind.sup --show-reachable=no --show-possibly-lost=no --leak-check=full src/redis-server $config_file > $stdout 2> $stderr &]
+    } elseif ($::stack_logging) {
+        set pid [exec /usr/bin/env MallocStackLogging=1 MallocLogFile=/tmp/malloc_log.txt src/redis-server $config_file > $stdout 2> $stderr &]
     } else {
         set pid [exec src/redis-server $config_file > $stdout 2> $stderr &]
     }
 
     # Tell the test server about this new instance.
     send_data_packet $::test_server_fd server-spawned $pid
@@ -273,13 +275,13 @@
         if {[string match {*already in use*} $line]} {
             error_and_quit $config_file $line
         }
 
         while 1 {
             # check that the server actually started and is ready for connections
-            if {[exec grep "ready to accept" | wc -l < $stdout] > 0} {
+            if {[exec grep -i "Ready to accept" | wc -l < $stdout] > 0} {
                 break
             }
             after 10
         }
 
         # append the server to the stack
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/test_helper.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/test_helper.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/test_helper.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/test_helper.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -38,12 +38,14 @@
     integration/replication-4
     integration/replication-psync
     integration/aof
     integration/rdb
     integration/convert-zipmap-hash-on-load
     integration/logging
+    integration/psync2
+    integration/psync2-reg
     unit/pubsub
     unit/slowlog
     unit/scripting
     unit/maxmemory
     unit/introspection
     unit/introspection-2
@@ -51,20 +53,23 @@
     unit/obuf-limits
     unit/bitops
     unit/bitfield
     unit/geo
     unit/memefficiency
     unit/hyperloglog
+    unit/lazyfree
+    unit/wait
 }
 # Index to the next test to run in the ::all_tests list.
 set ::next_test 0
 
 set ::host 127.0.0.1
 set ::port 21111
 set ::traceleaks 0
 set ::valgrind 0
+set ::stack_logging 0
 set ::verbose 0
 set ::quiet 0
 set ::denytags {}
 set ::allowtags {}
 set ::external 0; # If "1" this means, we are running against external instance
 set ::file ""; # If set, runs only the tests in this comma separated list
@@ -391,12 +396,13 @@
     flush $fd
 }
 
 proc print_help_screen {} {
     puts [join {
         "--valgrind         Run the test over valgrind."
+        "--stack-logging    Enable OSX leaks/malloc stack logging."
         "--accurate         Run slow randomized tests for more iterations."
         "--quiet            Don't show individual tests."
         "--single <unit>    Just execute the specified unit (see next option)."
         "--list-tests       List all the available test units."
         "--clients <num>    Number of test clients (default 16)."
         "--timeout <sec>    Test timeout in seconds (default 10 min)."
@@ -417,12 +423,16 @@
                 lappend ::allowtags $tag
             }
         }
         incr j
     } elseif {$opt eq {--valgrind}} {
         set ::valgrind 1
+    } elseif {$opt eq {--stack-logging}} {
+        if {[string match {*Darwin*} [exec uname -a]]} {
+            set ::stack_logging 1
+        }
     } elseif {$opt eq {--quiet}} {
         set ::quiet 1
     } elseif {$opt eq {--host}} {
         set ::external 1
         set ::host $arg
         incr j
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/aofrw.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/aofrw.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/aofrw.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/aofrw.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -1,79 +1,82 @@
 start_server {tags {"aofrw"}} {
     # Enable the AOF
     r config set appendonly yes
     r config set auto-aof-rewrite-percentage 0 ; # Disable auto-rewrite.
     waitForBgrewriteaof r
 
-    test {AOF rewrite during write load} {
-        # Start a write load for 10 seconds
-        set master [srv 0 client]
-        set master_host [srv 0 host]
-        set master_port [srv 0 port]
-        set load_handle0 [start_write_load $master_host $master_port 10]
-        set load_handle1 [start_write_load $master_host $master_port 10]
-        set load_handle2 [start_write_load $master_host $master_port 10]
-        set load_handle3 [start_write_load $master_host $master_port 10]
-        set load_handle4 [start_write_load $master_host $master_port 10]
+    foreach rdbpre {yes no} {
+        r config set aof-use-rdb-preamble $rdbpre
+        test "AOF rewrite during write load: RDB preamble=$rdbpre" {
+            # Start a write load for 10 seconds
+            set master [srv 0 client]
+            set master_host [srv 0 host]
+            set master_port [srv 0 port]
+            set load_handle0 [start_write_load $master_host $master_port 10]
+            set load_handle1 [start_write_load $master_host $master_port 10]
+            set load_handle2 [start_write_load $master_host $master_port 10]
+            set load_handle3 [start_write_load $master_host $master_port 10]
+            set load_handle4 [start_write_load $master_host $master_port 10]
+
+            # Make sure the instance is really receiving data
+            wait_for_condition 50 100 {
+                [r dbsize] > 0
+            } else {
+                fail "No write load detected."
+            }
+
+            # After 3 seconds, start a rewrite, while the write load is still
+            # active.
+            after 3000
+            r bgrewriteaof
+            waitForBgrewriteaof r
+
+            # Let it run a bit more so that we'll append some data to the new
+            # AOF.
+            after 1000
+
+            # Stop the processes generating the load if they are still active
+            stop_write_load $load_handle0
+            stop_write_load $load_handle1
+            stop_write_load $load_handle2
+            stop_write_load $load_handle3
+            stop_write_load $load_handle4
+
+            # Make sure that we remain the only connected client.
+            # This step is needed to make sure there are no pending writes
+            # that will be processed between the two "debug digest" calls.
+            wait_for_condition 50 100 {
+                [llength [split [string trim [r client list]] "\n"]] == 1
+            } else {
+                puts [r client list]
+                fail "Clients generating loads are not disconnecting"
+            }
+
+            # Get the data set digest
+            set d1 [r debug digest]
+
+            # Load the AOF
+            r debug loadaof
+            set d2 [r debug digest]
 
-        # Make sure the instance is really receiving data
-        wait_for_condition 50 100 {
-            [r dbsize] > 0
-        } else {
-            fail "No write load detected."
-        }
-
-        # After 3 seconds, start a rewrite, while the write load is still
-        # active.
-        after 3000
-        r bgrewriteaof
-        waitForBgrewriteaof r
-
-        # Let it run a bit more so that we'll append some data to the new
-        # AOF.
-        after 1000
-
-        # Stop the processes generating the load if they are still active
-        stop_write_load $load_handle0
-        stop_write_load $load_handle1
-        stop_write_load $load_handle2
-        stop_write_load $load_handle3
-        stop_write_load $load_handle4
-
-        # Make sure that we remain the only connected client.
-        # This step is needed to make sure there are no pending writes
-        # that will be processed between the two "debug digest" calls.
-        wait_for_condition 50 100 {
-            [llength [split [string trim [r client list]] "\n"]] == 1
-        } else {
-            puts [r client list]
-            fail "Clients generating loads are not disconnecting"
+            # Make sure they are the same
+            assert {$d1 eq $d2}
         }
-
-        # Get the data set digest
-        set d1 [r debug digest]
-
-        # Load the AOF
-        r debug loadaof
-        set d2 [r debug digest]
-
-        # Make sure they are the same
-        assert {$d1 eq $d2}
     }
 }
 
 start_server {tags {"aofrw"}} {
     test {Turning off AOF kills the background writing child if any} {
         r config set appendonly yes
         waitForBgrewriteaof r
         r multi
         r bgrewriteaof
         r config set appendonly no
         r exec
         wait_for_condition 50 100 {
-            [string match {*Killing*AOF*child*} [exec tail -n5 < [srv 0 stdout]]]
+            [string match {*Killing*AOF*child*} [exec tail -5 < [srv 0 stdout]]]
         } else {
             fail "Can't find 'Killing AOF child' into recent logs"
         }
     }
 
     foreach d {string int} {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/geo.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/geo.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/geo.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/geo.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -46,12 +46,15 @@
 # and radius that caused bugs in the past. It is used by the randomized
 # test later as a starting point. When the regression vectors are scanned
 # the code reverts to using random data.
 #
 # The format is: seed km lon lat
 set regression_vectors {
+    {1482225976969 7083 81.634948934258375 30.561509253718668}
+    {1482340074151 5416 -70.863281847379767 -46.347003465679947}
+    {1499014685896 6064 -89.818768962202014 -40.463868561416803}
     {1412 156 149.29737817929004 15.95807862745508}
     {441574 143 59.235461856813856 66.269555127373678}
     {160645 187 -101.88575239939883 49.061997951502917}
     {750269 154 -90.187939661642517 66.615930412251487}
     {342880 145 163.03472387745728 64.012747720821181}
     {729955 143 137.86663517256579 63.986745399416776}
@@ -251,16 +254,17 @@
             lappend debuginfo "Search area: $search_lon,$search_lat $radius_km km"
             set tcl_result {}
             set argv {}
             for {set j 0} {$j < 20000} {incr j} {
                 geo_random_point lon lat
                 lappend argv $lon $lat "place:$j"
-                if {[geo_distance $lon $lat $search_lon $search_lat] < $radius_m} {
+                set distance [geo_distance $lon $lat $search_lon $search_lat]
+                if {$distance < $radius_m} {
                     lappend tcl_result "place:$j"
-                    lappend debuginfo "place:$j $lon $lat [expr {[geo_distance $lon $lat $search_lon $search_lat]/1000}] km"
                 }
+                lappend debuginfo "place:$j $lon $lat [expr {$distance/1000}] km"
             }
             r geoadd mypoints {*}$argv
             set res [lsort [r georadius mypoints $search_lon $search_lat $radius_km km]]
             set res2 [lsort $tcl_result]
             set test_result OK
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/introspection.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/introspection.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/introspection.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/introspection.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -3,22 +3,23 @@
         r client list
     } {*addr=*:* fd=* age=* idle=* flags=N db=9 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=* obl=0 oll=0 omem=0 events=r cmd=client*}
 
     test {MONITOR can log executed commands} {
         set rd [redis_deferring_client]
         $rd monitor
+        assert_match {*OK*} [$rd read]
         r set foo bar
         r get foo
-        list [$rd read] [$rd read] [$rd read]
-    } {*OK*"set" "foo"*"get" "foo"*}
+        list [$rd read] [$rd read]
+    } {*"set" "foo"*"get" "foo"*}
 
     test {MONITOR can log commands issued by the scripting engine} {
         set rd [redis_deferring_client]
         $rd monitor
-        r eval {redis.call('set',KEYS[1],ARGV[1])} 1 foo bar
         $rd read ;# Discard the OK
+        r eval {redis.call('set',KEYS[1],ARGV[1])} 1 foo bar
         assert_match {*eval*} [$rd read]
         assert_match {*lua*"set"*"foo"*"bar"*} [$rd read]
     }
 
     test {CLIENT GETNAME should return NIL if name is not assigned} {
         r client getname
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit: lazyfree.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/maxmemory.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/maxmemory.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/maxmemory.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/maxmemory.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -21,13 +21,13 @@
         assert {[r object refcount a] == 1}
         assert {[r object refcount b] == 1}
         r config set maxmemory 0
     }
 
     foreach policy {
-        allkeys-random allkeys-lru volatile-lru volatile-random volatile-ttl
+        allkeys-random allkeys-lru allkeys-lfu volatile-lru volatile-lfu volatile-random volatile-ttl
     } {
         test "maxmemory - is the memory limit honoured? (policy $policy)" {
             # make sure to start with a blank instance
             r flushall
             # Get the current memory limit and calculate a new limit.
             # We just add 100k to the current memory size so that it is
@@ -95,13 +95,13 @@
                 assert {$err == 1}
             }
         }
     }
 
     foreach policy {
-        volatile-lru volatile-random volatile-ttl
+        volatile-lru volatile-lfu volatile-random volatile-ttl
     } {
         test "maxmemory - policy $policy should only remove volatile keys." {
             # make sure to start with a blank instance
             r flushall
             # Get the current memory limit and calculate a new limit.
             # We just add 100k to the current memory size so that it is
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/memefficiency.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/memefficiency.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/memefficiency.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/memefficiency.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -32,6 +32,54 @@
         test "Memory efficiency with values in range $size_range" {
             set efficiency [test_memory_efficiency $size_range]
             assert {$efficiency >= $expected_min_efficiency}
         }
     }
 }
+
+if 0 {
+    start_server {tags {"defrag"}} {
+        if {[string match {*jemalloc*} [s mem_allocator]]} {
+            test "Active defrag" {
+                r config set activedefrag no
+                r config set active-defrag-threshold-lower 5
+                r config set active-defrag-ignore-bytes 2mb
+                r config set maxmemory 100mb
+                r config set maxmemory-policy allkeys-lru
+                r debug populate 700000 asdf 150
+                r debug populate 170000 asdf 300
+                set frag [s mem_fragmentation_ratio]
+                assert {$frag >= 1.7}
+                r config set activedefrag yes
+                after 1500 ;# active defrag tests the status once a second.
+                set hits [s active_defrag_hits]
+
+                # wait for the active defrag to stop working
+                set tries 0
+                while { True } {
+                    incr tries
+                    after 500
+                    set prev_hits $hits
+                    set hits [s active_defrag_hits]
+                    if {$hits == $prev_hits} {
+                        break
+                    }
+                    assert {$tries < 100}
+                }
+
+                # TODO: we need to expose more accurate fragmentation info
+                # i.e. the allocator used and active pages
+                # instead we currently look at RSS so we need to ask for purge
+                r memory purge
+
+                # Test the the fragmentation is lower and that the defragger
+                # stopped working
+                set frag [s mem_fragmentation_ratio]
+                assert {$frag < 1.55}
+                set misses [s active_defrag_misses]
+                after 500
+                set misses2 [s active_defrag_misses]
+                assert {$misses2 == $misses}
+            }
+        }
+    }
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/other.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/other.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/other.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/other.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -49,13 +49,13 @@
         r get x
     } {10}
 
     test {SELECT an out of range DB} {
         catch {r select 1000000} err
         set _ $err
-    } {*invalid*}
+    } {*index is out of range*}
 
     tags {consistency} {
         if {![catch {package require sha1}]} {
             if {$::accurate} {set numops 10000} else {set numops 1000}
             test {Check consistency of different data types after a reload} {
                 r flushdb
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/scripting.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/scripting.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/scripting.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/scripting.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -327,13 +327,13 @@
              [r eval {return redis.sha1hex('Pizza & Mandolino')} 0]
     } {da39a3ee5e6b4b0d3255bfef95601890afd80709 74822d82031af7493c20eefa13bd07ec4fada82f}
 
     test {Globals protection reading an undeclared global variable} {
         catch {r eval {return a} 0} e
         set e
-    } {*ERR*attempted to access unexisting global*}
+    } {*ERR*attempted to access * global*}
 
     test {Globals protection setting an undeclared global*} {
         catch {r eval {a=10} 0} e
         set e
     } {*ERR*attempted to create global*}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/slowlog.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/slowlog.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/slowlog.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/slowlog.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -28,18 +28,20 @@
         r config set slowlog-log-slower-than 100000
         r slowlog reset
         r slowlog len
     } {0}
 
     test {SLOWLOG - logged entry sanity check} {
+        r client setname foobar
         r debug sleep 0.2
         set e [lindex [r slowlog get] 0]
-        assert_equal [llength $e] 4
+        assert_equal [llength $e] 6
         assert_equal [lindex $e 0] 105
         assert_equal [expr {[lindex $e 2] > 100000}] 1
         assert_equal [lindex $e 3] {debug sleep 0.2}
+        assert_equal {foobar} [lindex $e 5]
     }
 
     test {SLOWLOG - commands with too many arguments are trimmed} {
         r config set slowlog-log-slower-than 0
         r slowlog reset
         r sadd set 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
@@ -64,7 +66,16 @@
         r debug sleep 0.2
         r exec
         assert_equal [r slowlog len] 1
         set e [lindex [r slowlog get] 0]
         assert_equal [lindex $e 3] {debug sleep 0.2}
     }
+
+    test {SLOWLOG - can clean older entires} {
+        r client setname lastentry_client
+        r config set slowlog-max-len 1
+        r debug sleep 0.2
+        assert {[llength [r slowlog get]] == 1}
+        set e [lindex [r slowlog get] 0]
+        assert_equal {lastentry_client} [lindex $e 5]
+    }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/type/hash.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/type/hash.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/type/hash.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/type/hash.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -512,7 +512,25 @@
             for {set i 0} {$i < 64} {incr i} {
                 r hset myhash [randomValue] [randomValue]
             }
             assert {[r object encoding myhash] eq {hashtable}}
         }
     }
+
+    # The following test can only be executed if we don't use Valgrind, and if
+    # we are using x86_64 architecture, because:
+    #
+    # 1) Valgrind has floating point limitations, no support for 80 bits math.
+    # 2) Other archs may have the same limits.
+    #
+    # 1.23 cannot be represented correctly with 64 bit doubles, so we skip
+    # the test, since we are only testing pretty printing here and is not
+    # a bug if the program outputs things like 1.299999...
+    if {!$::valgrind && [string match *x86_64* [exec uname -a]]} {
+        test {Test HINCRBYFLOAT for correct float representation (issue #2846)} {
+            r del myhash
+            assert {[r hincrbyfloat myhash float 1.23] eq {1.23}}
+            assert {[r hincrbyfloat myhash float 0.77] eq {2}}
+            assert {[r hincrbyfloat myhash float -0.1] eq {1.9}}
+        }
+    }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/type/list.tcl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/type/list.tcl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/tests/unit/type/list.tcl	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit/type/list.tcl	2017-07-14 19:28:42.000000000 +0800
@@ -504,13 +504,15 @@
 
     foreach {type large} [array get largevalue] {
         test "LPUSHX, RPUSHX - $type" {
             create_list xlist "$large c"
             assert_equal 3 [r rpushx xlist d]
             assert_equal 4 [r lpushx xlist a]
-            assert_equal "a $large c d" [r lrange xlist 0 -1]
+            assert_equal 6 [r rpushx xlist 42 x]
+            assert_equal 9 [r lpushx xlist y3 y2 y1]
+            assert_equal "y1 y2 y3 a $large c d 42 x" [r lrange xlist 0 -1]
         }
 
         test "LINSERT - $type" {
             create_list xlist "a $large c d"
             assert_equal 5 [r linsert xlist before c zz] "before c"
             assert_equal "a $large zz c d" [r lrange xlist 0 10] "lrangeA"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/tests/unit: wait.tcl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/create-cluster/create-cluster /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/create-cluster/create-cluster
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/create-cluster/create-cluster	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/create-cluster/create-cluster	2017-07-14 19:28:42.000000000 +0800
@@ -83,13 +83,20 @@
     rm -rf appendonly*.aof
     rm -rf dump*.rdb
     rm -rf nodes*.conf
     exit 0
 fi
 
+if [ "$1" == "clean-logs" ]
+then
+    rm -rf *.log
+    exit 0
+fi
+
 echo "Usage: $0 [start|create|stop|watch|tail|clean]"
 echo "start       -- Launch Redis Cluster instances."
 echo "create      -- Create a cluster using redis-trib create."
 echo "stop        -- Stop Redis Cluster instances."
 echo "watch       -- Show CLUSTER NODES output (first 30 lines) of first node."
 echo "tail <id>   -- Run tail -f of instance at base port + ID."
 echo "clean       -- Remove all instances data, logs, configs."
+echo "clean-logs  -- Remove just instances logs."
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils: graphs
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/hyperloglog/hll-gnuplot-graph.rb /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/hyperloglog/hll-gnuplot-graph.rb
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/hyperloglog/hll-gnuplot-graph.rb	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/hyperloglog/hll-gnuplot-graph.rb	2017-07-14 19:28:42.000000000 +0800
@@ -27,13 +27,13 @@
         elements = []
         step.times {
             ele = Digest::SHA1.hexdigest(i.to_s+seed.to_s)
             elements << ele
             i += 1
         }
-        r.pfadd('hll',*elements)
+        r.pfadd('hll',elements)
         approx = r.pfcount('hll')
         err = approx-i
         rel_err = 100.to_f*err/i
         samples << [i,rel_err]
     end
     samples
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/install_server.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/install_server.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/install_server.sh	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/install_server.sh	2017-07-14 19:28:42.000000000 +0800
@@ -22,15 +22,31 @@
 # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 # EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #
 ################################################################################
 #
-# Interactive service installer for redis server
-# this generates a redis config file and an /etc/init.d script, and installs them
-# this scripts should be run as root
+# Service installer for redis server, runs interactively by default.
+#
+# To run this script non-interactively (for automation/provisioning purposes),
+# feed the variables into the script. Any missing variables will be prompted!
+# Tip: Environment variables also support command substitution (see REDIS_EXECUTABLE)
+#
+# Example:
+#
+# sudo REDIS_PORT=1234 \
+# 		 REDIS_CONFIG_FILE=/etc/redis/1234.conf \
+# 		 REDIS_LOG_FILE=/var/log/redis_1234.log \
+# 		 REDIS_DATA_DIR=/var/lib/redis/1234 \
+# 		 REDIS_EXECUTABLE=`command -v redis-server` ./utils/install_server.sh
+#
+# This generates a redis config file and an /etc/init.d script, and installs them.
+#
+# /!\ This script should be run as root
+#
+################################################################################
 
 die () {
 	echo "ERROR: $1. Aborting!"
 	exit 1
 }
 
@@ -39,64 +55,79 @@
 SCRIPT=$(readlink -f $0)
 #Absolute path this script is in
 SCRIPTPATH=$(dirname $SCRIPT)
 
 #Initial defaults
 _REDIS_PORT=6379
+_MANUAL_EXECUTION=false
 
 echo "Welcome to the redis service installer"
 echo "This script will help you easily set up a running redis server"
 echo
 
 #check for root user
 if [ "$(id -u)" -ne 0 ] ; then
 	echo "You must run this script as root. Sorry!"
 	exit 1
 fi
 
-#Read the redis port
-read  -p "Please select the redis port for this instance: [$_REDIS_PORT] " REDIS_PORT
 if ! echo $REDIS_PORT | egrep -q '^[0-9]+$' ; then
-	echo "Selecting default: $_REDIS_PORT"
-	REDIS_PORT=$_REDIS_PORT
+	_MANUAL_EXECUTION=true
+	#Read the redis port
+	read  -p "Please select the redis port for this instance: [$_REDIS_PORT] " REDIS_PORT
+	if ! echo $REDIS_PORT | egrep -q '^[0-9]+$' ; then
+		echo "Selecting default: $_REDIS_PORT"
+		REDIS_PORT=$_REDIS_PORT
+	fi
 fi
 
-#read the redis config file
-_REDIS_CONFIG_FILE="/etc/redis/$REDIS_PORT.conf"
-read -p "Please select the redis config file name [$_REDIS_CONFIG_FILE] " REDIS_CONFIG_FILE
 if [ -z "$REDIS_CONFIG_FILE" ] ; then
-	REDIS_CONFIG_FILE=$_REDIS_CONFIG_FILE
-	echo "Selected default - $REDIS_CONFIG_FILE"
+	_MANUAL_EXECUTION=true
+	#read the redis config file
+	_REDIS_CONFIG_FILE="/etc/redis/$REDIS_PORT.conf"
+	read -p "Please select the redis config file name [$_REDIS_CONFIG_FILE] " REDIS_CONFIG_FILE
+	if [ -z "$REDIS_CONFIG_FILE" ] ; then
+		REDIS_CONFIG_FILE=$_REDIS_CONFIG_FILE
+		echo "Selected default - $REDIS_CONFIG_FILE"
+	fi
 fi
 
-#read the redis log file path
-_REDIS_LOG_FILE="/var/log/redis_$REDIS_PORT.log"
-read -p "Please select the redis log file name [$_REDIS_LOG_FILE] " REDIS_LOG_FILE
 if [ -z "$REDIS_LOG_FILE" ] ; then
-	REDIS_LOG_FILE=$_REDIS_LOG_FILE
-	echo "Selected default - $REDIS_LOG_FILE"
+	_MANUAL_EXECUTION=true
+	#read the redis log file path
+	_REDIS_LOG_FILE="/var/log/redis_$REDIS_PORT.log"
+	read -p "Please select the redis log file name [$_REDIS_LOG_FILE] " REDIS_LOG_FILE
+	if [ -z "$REDIS_LOG_FILE" ] ; then
+		REDIS_LOG_FILE=$_REDIS_LOG_FILE
+		echo "Selected default - $REDIS_LOG_FILE"
+	fi
 fi
 
-
-#get the redis data directory
-_REDIS_DATA_DIR="/var/lib/redis/$REDIS_PORT"
-read -p "Please select the data directory for this instance [$_REDIS_DATA_DIR] " REDIS_DATA_DIR
 if [ -z "$REDIS_DATA_DIR" ] ; then
-	REDIS_DATA_DIR=$_REDIS_DATA_DIR
-	echo "Selected default - $REDIS_DATA_DIR"
+	_MANUAL_EXECUTION=true
+	#get the redis data directory
+	_REDIS_DATA_DIR="/var/lib/redis/$REDIS_PORT"
+	read -p "Please select the data directory for this instance [$_REDIS_DATA_DIR] " REDIS_DATA_DIR
+	if [ -z "$REDIS_DATA_DIR" ] ; then
+		REDIS_DATA_DIR=$_REDIS_DATA_DIR
+		echo "Selected default - $REDIS_DATA_DIR"
+	fi
 fi
 
-#get the redis executable path
-_REDIS_EXECUTABLE=`command -v redis-server`
-read -p "Please select the redis executable path [$_REDIS_EXECUTABLE] " REDIS_EXECUTABLE
 if [ ! -x "$REDIS_EXECUTABLE" ] ; then
-	REDIS_EXECUTABLE=$_REDIS_EXECUTABLE
-
+	_MANUAL_EXECUTION=true
+	#get the redis executable path
+	_REDIS_EXECUTABLE=`command -v redis-server`
+	read -p "Please select the redis executable path [$_REDIS_EXECUTABLE] " REDIS_EXECUTABLE
 	if [ ! -x "$REDIS_EXECUTABLE" ] ; then
-		echo "Mmmmm...  it seems like you don't have a redis executable. Did you run make install yet?"
-		exit 1
+		REDIS_EXECUTABLE=$_REDIS_EXECUTABLE
+
+		if [ ! -x "$REDIS_EXECUTABLE" ] ; then
+			echo "Mmmmm...  it seems like you don't have a redis executable. Did you run make install yet?"
+			exit 1
+		fi
 	fi
 fi
 
 #check the default for redis cli
 CLI_EXEC=`command -v redis-cli`
 if [ -z "$CLI_EXEC" ] ; then
@@ -109,13 +140,15 @@
 echo "Config file    : $REDIS_CONFIG_FILE"
 echo "Log file       : $REDIS_LOG_FILE"
 echo "Data dir       : $REDIS_DATA_DIR"
 echo "Executable     : $REDIS_EXECUTABLE"
 echo "Cli Executable : $CLI_EXEC"
 
-read -p "Is this ok? Then press ENTER to go on or Ctrl-C to abort." _UNUSED_
+if $_MANUAL_EXECUTION == true ; then
+	read -p "Is this ok? Then press ENTER to go on or Ctrl-C to abort." _UNUSED_
+fi
 
 mkdir -p `dirname "$REDIS_CONFIG_FILE"` || die "Could not create redis config directory"
 mkdir -p `dirname "$REDIS_LOG_FILE"` || die "Could not create redis log dir"
 mkdir -p "$REDIS_DATA_DIR" || die "Could not create redis data directory"
 
 #render the templates
@@ -132,19 +165,19 @@
 
 #Generate config file from the default config file as template
 #changing only the stuff we're controlling from this script
 echo "## Generated by install_server.sh ##" > $TMP_FILE
 
 read -r SED_EXPR <<-EOF
-s#^port .\+#port ${REDIS_PORT}#; \
-s#^logfile .\+#logfile ${REDIS_LOG_FILE}#; \
-s#^dir .\+#dir ${REDIS_DATA_DIR}#; \
-s#^pidfile .\+#pidfile ${PIDFILE}#; \
-s#^daemonize no#daemonize yes#;
+s#^port [0-9]{4}\$#port ${REDIS_PORT}#; \
+s#^logfile .+\$#logfile ${REDIS_LOG_FILE}#; \
+s#^dir .+\$#dir ${REDIS_DATA_DIR}#; \
+s#^pidfile .+\$#pidfile ${PIDFILE}#; \
+s#^daemonize no\$#daemonize yes#;
 EOF
-sed "$SED_EXPR" $DEFAULT_CONFIG >> $TMP_FILE
+sed -r "$SED_EXPR" $DEFAULT_CONFIG  >> $TMP_FILE
 
 #cat $TPL_FILE | while read line; do eval "echo \"$line\"" >> $TMP_FILE; done
 cp $TMP_FILE $REDIS_CONFIG_FILE || die "Could not write redis config file $REDIS_CONFIG_FILE"
 
 #Generate sample script from template file
 rm -f $TMP_FILE
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/lru: lfu-simulation.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/lru/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/lru/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/lru/README	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/lru/README	2017-07-14 19:28:42.000000000 +0800
@@ -1,13 +1,19 @@
 The test-lru.rb program can be used in order to check the behavior of the
 Redis approximated LRU algorithm against the theoretical output of true
 LRU algorithm.
 
 In order to use the program you need to recompile Redis setting the define
-REDIS_LRU_CLOCK_RESOLUTION to 1, by editing redis.h.
+REDIS_LRU_CLOCK_RESOLUTION to 1, by editing the file server.h.
 This allows to execute the program in a fast way since the 1 ms resolution
 is enough for all the objects to have a different enough time stamp during
 the test.
 
 The program is executed like this:
 
-    ruby test-lru.rb > /tmp/lru.html
+    ruby test-lru.rb /tmp/lru.html
+
+You can optionally specify a number of times to run, so that the program
+will output averages of different runs, by adding an additional argument.
+For instance in order to run the test 10 times use:
+
+    ruby test-lru.rb /tmp/lru.html 10
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/lru/test-lru.rb /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/lru/test-lru.rb
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/lru/test-lru.rb	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/lru/test-lru.rb	2017-07-14 19:28:42.000000000 +0800
@@ -1,112 +1,223 @@
 require 'rubygems'
 require 'redis'
 
-r = Redis.new
-r.config("SET","maxmemory","2000000")
-r.config("SET","maxmemory-policy","allkeys-lru")
-r.config("SET","maxmemory-samples",5)
-r.config("RESETSTAT")
-r.flushall
-
-puts <<EOF
-<html>
-<body>
-<style>
-.box {
-    width:5px;
-    height:5px;
-    float:left;
-    margin: 1px;
-}
+$runs = []; # Remember the error rate of each run for average purposes.
+$o = {};    # Options set parsing arguments
 
-.old {
-    border: 1px black solid;
-}
+def testit(filename)
+    r = Redis.new
+    r.config("SET","maxmemory","2000000")
+    if $o[:ttl]
+        r.config("SET","maxmemory-policy","volatile-ttl")
+    else
+        r.config("SET","maxmemory-policy","allkeys-lru")
+    end
+    r.config("SET","maxmemory-samples",5)
+    r.config("RESETSTAT")
+    r.flushall
+
+    html = ""
+    html << <<EOF
+    <html>
+    <body>
+    <style>
+    .box {
+        width:5px;
+        height:5px;
+        float:left;
+        margin: 1px;
+    }
+
+    .old {
+        border: 1px black solid;
+    }
+
+    .new {
+        border: 1px green solid;
+    }
+
+    .otherdb {
+        border: 1px red solid;
+    }
+
+    .ex {
+        background-color: #666;
+    }
+    </style>
+    <pre>
+EOF
 
-.new {
-    border: 1px green solid;
-}
+    # Fill the DB up to the first eviction.
+    oldsize = r.dbsize
+    id = 0
+    while true
+        id += 1
+        begin
+            r.set(id,"foo")
+        rescue
+            break
+        end
+        newsize = r.dbsize
+        break if newsize == oldsize # A key was evicted? Stop.
+        oldsize = newsize
+    end
 
-.ex {
-    background-color: #666;
-}
-</style>
-<pre>
-EOF
+    inserted = r.dbsize
+    first_set_max_id = id
+    html << "#{r.dbsize} keys inserted.\n"
+
+    # Access keys sequentially, so that in theory the first part will be expired
+    # and the latter part will not, according to perfect LRU.
+
+    if $o[:ttl]
+        STDERR.puts "Set increasing expire value"
+        (1..first_set_max_id).each{|id|
+            r.expire(id,1000+id)
+            STDERR.print(".") if (id % 150) == 0
+        }
+    else
+        STDERR.puts "Access keys sequentially"
+        (1..first_set_max_id).each{|id|
+            r.get(id)
+            sleep 0.001
+            STDERR.print(".") if (id % 150) == 0
+        }
+    end
+    STDERR.puts
 
-# Fill
-oldsize = r.dbsize
-id = 0
-while true
-    id += 1
-    r.set(id,"foo")
-    newsize = r.dbsize
-    break if newsize == oldsize
-    oldsize = newsize
-end
+    # Insert more 50% keys. We expect that the new keys will rarely be expired
+    # since their last access time is recent compared to the others.
+    #
+    # Note that we insert the first 100 keys of the new set into DB1 instead
+    # of DB0, so that we can try how cross-DB eviction works.
+    half = inserted/2
+    html << "Insert enough keys to evict half the keys we inserted.\n"
+    add = 0
+
+    otherdb_start_idx = id+1
+    otherdb_end_idx = id+100
+    while true
+        add += 1
+        id += 1
+        if id >= otherdb_start_idx && id <= otherdb_end_idx
+            r.select(1)
+            r.set(id,"foo")
+            r.select(0)
+        else
+            r.set(id,"foo")
+        end
+        break if r.info['evicted_keys'].to_i >= half
+    end
 
-inserted = r.dbsize
-first_set_max_id = id
-puts "#{r.dbsize} keys inserted"
-
-# Access keys sequentially
-
-puts "Access keys sequentially"
-(1..first_set_max_id).each{|id|
-    r.get(id)
-#    sleep 0.001
-}
+    html << "#{add} additional keys added.\n"
+    html << "#{r.dbsize} keys in DB.\n"
+
+    # Check if evicted keys respect LRU
+    # We consider errors from 1 to N progressively more serious as they violate
+    # more the access pattern.
+
+    errors = 0
+    e = 1
+    error_per_key = 100000.0/first_set_max_id
+    half_set_size = first_set_max_id/2
+    maxerr = 0
+    (1..(first_set_max_id/2)).each{|id|
+        if id >= otherdb_start_idx && id <= otherdb_end_idx
+            r.select(1)
+            exists = r.exists(id)
+            r.select(0)
+        else
+            exists = r.exists(id)
+        end
+        if id < first_set_max_id/2
+            thiserr = error_per_key * ((half_set_size-id).to_f/half_set_size)
+            maxerr += thiserr
+            errors += thiserr if exists
+        elsif id >= first_set_max_id/2
+            thiserr = error_per_key * ((id-half_set_size).to_f/half_set_size)
+            maxerr += thiserr
+            errors += thiserr if !exists
+        end
+    }
+    errors = errors*100/maxerr
+
+    STDERR.puts "Test finished with #{errors}% error! Generating HTML on stdout."
+
+    html << "#{errors}% error!\n"
+    html << "</pre>"
+    $runs << errors
+
+    # Generate the graphical representation
+    (1..id).each{|id|
+        # Mark first set and added items in a different way.
+        c = "box"
+        if id >= otherdb_start_idx && id <= otherdb_end_idx
+            c << " otherdb"
+        elsif id <= first_set_max_id
+            c << " old"
+        else
+            c << " new"
+        end
+
+        # Add class if exists
+        if id >= otherdb_start_idx && id <= otherdb_end_idx
+            r.select(1)
+            exists = r.exists(id)
+            r.select(0)
+        else
+            exists = r.exists(id)
+        end
+
+        c << " ex" if exists
+        html << "<div title=\"#{id}\" class=\"#{c}\"></div>"
+    }
+
+    # Close HTML page
+
+    html << <<EOF
+    </body>
+    </html>
+EOF
 
-# Insert more 50% keys. We expect that the new keys
-half = inserted/2
-puts "Insert enough keys to evict half the keys we inserted"
-add = 0
-while true
-    add += 1
-    id += 1
-    r.set(id,"foo")
-    break if r.info['evicted_keys'].to_i >= half
+    f = File.open(filename,"w")
+    f.write(html)
+    f.close
 end
 
-puts "#{add} additional keys added."
-puts "#{r.dbsize} keys in DB"
+def print_avg
+    avg = ($runs.reduce {|a,b| a+b}) / $runs.length
+    puts "#{$runs.length} runs, AVG is #{avg}"
+end
 
-# Check if evicted keys respect LRU
-# We consider errors from 1 to N progressively more serious as they violate
-# more the access pattern.
-
-errors = 0
-e = 1
-edecr = 1.0/(first_set_max_id/2)
-(1..(first_set_max_id/2)).each{|id|
-    e -= edecr if e > 0
-    e = 0 if e < 0
-    if r.exists(id)
-        errors += e
-    end
-}
+if ARGV.length < 1
+    STDERR.puts "Usage: ruby test-lru.rb <html-output-filename> [--runs <count>] [--ttl]"
+    STDERR.puts "Options:"
+    STDERR.puts "  --runs <count>    Execute the test <count> times."
+    STDERR.puts "  --ttl             Set keys with increasing TTL values"
+    STDERR.puts "                    (starting from 1000 seconds) in order to"
+    STDERR.puts "                    test the volatile-lru policy."
+    exit 1
+end
 
-puts "#{errors} errors!"
-puts "</pre>"
+filename = ARGV[0]
+$o[:numruns] = 1
 
-# Generate the graphical representation
-(1..id).each{|id|
-    # Mark first set and added items in a different way.
-    c = "box"
-    if id <= first_set_max_id
-        c << " old"
+# Options parsing
+i = 1
+while i < ARGV.length
+    if ARGV[i] == '--runs'
+        $o[:numruns] = ARGV[i+1].to_i
+        i+= 1
+    elsif ARGV[i] == '--ttl'
+        $o[:ttl] = true
     else
-        c << " new"
+        STDERR.puts "Unknown option #{ARGV[i]}"
+        exit 1
     end
+    i+= 1
+end
 
-    # Add class if exists
-    c << " ex" if r.exists(id)
-    puts "<div class=\"#{c}\"></div>"
+$o[:numruns].times {
+    testit(filename)
+    print_avg if $o[:numruns] != 1
 }
-
-# Close HTML page
-
-puts <<EOF
-</body>
-</html>
-EOF
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/releasetools/03_test_release.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/releasetools/03_test_release.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/releasetools/03_test_release.sh	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/releasetools/03_test_release.sh	2017-07-14 19:28:42.000000000 +0800
@@ -10,12 +10,14 @@
 DOWNLOADURL="http://download.redis.io/releases/${TARNAME}"
 
 ssh antirez@metal "export TERM=xterm;
                    cd /tmp;
                    rm -rf test_release_tmp_dir;
                    cd test_release_tmp_dir;
+                   rm -f $TARNAME;
+                   rm -rf redis-${TAG};
                    wget $DOWNLOADURL;
                    tar xvzf $TARNAME;
                    cd redis-${TAG};
                    make;
                    ./runtest;
                    ./runtest-sentinel;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/releasetools/04_release_hash.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/releasetools/04_release_hash.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-3.2.11/utils/releasetools/04_release_hash.sh	2017-09-21 22:20:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/releasetools/04_release_hash.sh	2017-07-14 19:28:42.000000000 +0800
@@ -1,8 +1,8 @@
 #!/bin/bash
-SHA=$(curl -s http://download.redis.io/releases/redis-${1}.tar.gz | shasum | cut -f 1 -d' ')
-ENTRY="hash redis-${1}.tar.gz sha1 $SHA http://download.redis.io/releases/redis-${1}.tar.gz"
+SHA=$(curl -s http://download.redis.io/releases/redis-${1}.tar.gz | shasum -a 256 | cut -f 1 -d' ')
+ENTRY="hash redis-${1}.tar.gz sha256 $SHA http://download.redis.io/releases/redis-${1}.tar.gz"
 echo $ENTRY >> ~/hack/redis-hashes/README
 vi ~/hack/redis-hashes/README
 echo "Press any key to commit, Ctrl-C to abort)."
 read yes
 (cd ~/hack/redis-hashes; git commit -a -m "${1} hash."; git push)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/redis/repos/redis-4.0.0/utils/releasetools: changelog.tcl
